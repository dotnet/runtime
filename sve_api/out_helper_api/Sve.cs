// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using System.Numerics;

namespace System.Runtime.Intrinsics.Arm
{
    /// <summary>
    /// This class provides access to the ARM SVE hardware instructions via intrinsics
    /// </summary>
    [Intrinsic]
    [CLSCompliant(false)]
    public abstract class Sve : AdvSimd
    {
        internal Sve() { }

        public static new bool IsSupported { get => IsSupported; }

        [Intrinsic]
        public new abstract class Arm64 : AdvSimd.Arm64
        {
            internal Arm64() { }

            public static new bool IsSupported { get => IsSupported; }
        }

        ///  Abs : Absolute value

        /// <summary>
        /// svint8_t svabs[_s8]_m(svint8_t inactive, svbool_t pg, svint8_t op)
        ///   ABS Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; ABS Zresult.B, Pg/M, Zop.B
        /// svint8_t svabs[_s8]_x(svbool_t pg, svint8_t op)
        ///   ABS Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; ABS Zresult.B, Pg/M, Zop.B
        /// svint8_t svabs[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; ABS Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  ABS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_abs, EA_SCALABLE, REG_V24, REG_P7, REG_V7, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Abs(Vector<sbyte> value) => Abs(value);

        /// <summary>
        /// svint16_t svabs[_s16]_m(svint16_t inactive, svbool_t pg, svint16_t op)
        ///   ABS Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; ABS Zresult.H, Pg/M, Zop.H
        /// svint16_t svabs[_s16]_x(svbool_t pg, svint16_t op)
        ///   ABS Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; ABS Zresult.H, Pg/M, Zop.H
        /// svint16_t svabs[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; ABS Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  ABS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_abs, EA_SCALABLE, REG_V24, REG_P7, REG_V7, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Abs(Vector<short> value) => Abs(value);

        /// <summary>
        /// svint32_t svabs[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   ABS Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; ABS Zresult.S, Pg/M, Zop.S
        /// svint32_t svabs[_s32]_x(svbool_t pg, svint32_t op)
        ///   ABS Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; ABS Zresult.S, Pg/M, Zop.S
        /// svint32_t svabs[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; ABS Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  ABS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_abs, EA_SCALABLE, REG_V24, REG_P7, REG_V7, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Abs(Vector<int> value) => Abs(value);

        /// <summary>
        /// svint64_t svabs[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   ABS Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; ABS Zresult.D, Pg/M, Zop.D
        /// svint64_t svabs[_s64]_x(svbool_t pg, svint64_t op)
        ///   ABS Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; ABS Zresult.D, Pg/M, Zop.D
        /// svint64_t svabs[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; ABS Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  ABS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_abs, EA_SCALABLE, REG_V24, REG_P7, REG_V7, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Abs(Vector<long> value) => Abs(value);

        /// <summary>
        /// svfloat32_t svabs[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FABS Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FABS Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svabs[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FABS Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FABS Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svabs[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FABS Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  FABS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fabs, EA_SCALABLE, REG_V27, REG_P4, REG_V4, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Abs(Vector<float> value) => Abs(value);

        /// <summary>
        /// svfloat64_t svabs[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FABS Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FABS Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svabs[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FABS Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FABS Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svabs[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FABS Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  FABS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fabs, EA_SCALABLE, REG_V27, REG_P4, REG_V4, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Abs(Vector<double> value) => Abs(value);


        ///  AbsoluteCompareGreaterThan : Absolute compare greater than

        /// <summary>
        /// svbool_t svacgt[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FACGT Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facgt, EA_SCALABLE, REG_P15, REG_P1, REG_V20, REG_V21, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AbsoluteCompareGreaterThan(Vector<float> left, Vector<float> right) => AbsoluteCompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svacgt[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FACGT Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facgt, EA_SCALABLE, REG_P15, REG_P1, REG_V20, REG_V21, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AbsoluteCompareGreaterThan(Vector<double> left, Vector<double> right) => AbsoluteCompareGreaterThan(left, right);


        ///  AbsoluteCompareGreaterThanOrEqual : Absolute compare greater than or equal to

        /// <summary>
        /// svbool_t svacge[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FACGE Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facge, EA_SCALABLE, REG_P0, REG_P0, REG_V10, REG_V31, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AbsoluteCompareGreaterThanOrEqual(Vector<float> left, Vector<float> right) => AbsoluteCompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svacge[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FACGE Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facge, EA_SCALABLE, REG_P0, REG_P0, REG_V10, REG_V31, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AbsoluteCompareGreaterThanOrEqual(Vector<double> left, Vector<double> right) => AbsoluteCompareGreaterThanOrEqual(left, right);


        ///  AbsoluteCompareLessThan : Absolute compare less than

        /// <summary>
        /// svbool_t svaclt[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FACGT Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facgt, EA_SCALABLE, REG_P15, REG_P1, REG_V20, REG_V21, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AbsoluteCompareLessThan(Vector<float> left, Vector<float> right) => AbsoluteCompareLessThan(left, right);

        /// <summary>
        /// svbool_t svaclt[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FACGT Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facgt, EA_SCALABLE, REG_P15, REG_P1, REG_V20, REG_V21, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AbsoluteCompareLessThan(Vector<double> left, Vector<double> right) => AbsoluteCompareLessThan(left, right);


        ///  AbsoluteCompareLessThanOrEqual : Absolute compare less than or equal to

        /// <summary>
        /// svbool_t svacle[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FACGE Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facge, EA_SCALABLE, REG_P0, REG_P0, REG_V10, REG_V31, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AbsoluteCompareLessThanOrEqual(Vector<float> left, Vector<float> right) => AbsoluteCompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svacle[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FACGE Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FACGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_facge, EA_SCALABLE, REG_P0, REG_P0, REG_V10, REG_V31, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AbsoluteCompareLessThanOrEqual(Vector<double> left, Vector<double> right) => AbsoluteCompareLessThanOrEqual(left, right);


        ///  AbsoluteDifference : Absolute difference

        /// <summary>
        /// svint8_t svabd[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SABD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svabd[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SABD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   SABD Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svabd[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; SABD Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; SABD Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sabd, EA_SCALABLE, REG_V5, REG_P2, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> AbsoluteDifference(Vector<sbyte> left, Vector<sbyte> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svint16_t svabd[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SABD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svabd[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SABD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   SABD Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svabd[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; SABD Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; SABD Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sabd, EA_SCALABLE, REG_V5, REG_P2, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> AbsoluteDifference(Vector<short> left, Vector<short> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svint32_t svabd[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SABD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svabd[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SABD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   SABD Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svabd[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; SABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; SABD Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sabd, EA_SCALABLE, REG_V5, REG_P2, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> AbsoluteDifference(Vector<int> left, Vector<int> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svint64_t svabd[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SABD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svabd[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SABD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   SABD Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; SABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svabd[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; SABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; SABD Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sabd, EA_SCALABLE, REG_V5, REG_P2, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> AbsoluteDifference(Vector<long> left, Vector<long> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svuint8_t svabd[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   UABD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svabd[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   UABD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   UABD Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svabd[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; UABD Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; UABD Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uabd, EA_SCALABLE, REG_V23, REG_P3, REG_V9, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> AbsoluteDifference(Vector<byte> left, Vector<byte> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svuint16_t svabd[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   UABD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svabd[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   UABD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   UABD Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svabd[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; UABD Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; UABD Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uabd, EA_SCALABLE, REG_V23, REG_P3, REG_V9, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> AbsoluteDifference(Vector<ushort> left, Vector<ushort> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svuint32_t svabd[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UABD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svabd[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UABD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   UABD Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svabd[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; UABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; UABD Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uabd, EA_SCALABLE, REG_V23, REG_P3, REG_V9, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> AbsoluteDifference(Vector<uint> left, Vector<uint> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svuint64_t svabd[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UABD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svabd[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UABD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   UABD Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; UABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svabd[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; UABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; UABD Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uabd, EA_SCALABLE, REG_V23, REG_P3, REG_V9, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> AbsoluteDifference(Vector<ulong> left, Vector<ulong> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svfloat32_t svabd[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FABD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svabd[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FABD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FABD Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svabd[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FABD Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FABD Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fabd, EA_SCALABLE, REG_V24, REG_P3, REG_V11, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AbsoluteDifference(Vector<float> left, Vector<float> right) => AbsoluteDifference(left, right);

        /// <summary>
        /// svfloat64_t svabd[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FABD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svabd[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FABD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FABD Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svabd[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FABD Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FABD Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FABD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fabd, EA_SCALABLE, REG_V24, REG_P3, REG_V11, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AbsoluteDifference(Vector<double> left, Vector<double> right) => AbsoluteDifference(left, right);


        ///  Add : Add

        /// <summary>
        /// svint8_t svadd[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   ADD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svadd[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   ADD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   ADD Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   ADD Zresult.B, Zop1.B, Zop2.B
        /// svint8_t svadd[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; ADD Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; ADD Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Add(Vector<sbyte> left, Vector<sbyte> right) => Add(left, right);

        /// <summary>
        /// svint16_t svadd[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   ADD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svadd[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   ADD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   ADD Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   ADD Zresult.H, Zop1.H, Zop2.H
        /// svint16_t svadd[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; ADD Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; ADD Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Add(Vector<short> left, Vector<short> right) => Add(left, right);

        /// <summary>
        /// svint32_t svadd[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   ADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svadd[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   ADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   ADD Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   ADD Zresult.S, Zop1.S, Zop2.S
        /// svint32_t svadd[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; ADD Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; ADD Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Add(Vector<int> left, Vector<int> right) => Add(left, right);

        /// <summary>
        /// svint64_t svadd[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   ADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svadd[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   ADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   ADD Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   ADD Zresult.D, Zop1.D, Zop2.D
        /// svint64_t svadd[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; ADD Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; ADD Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Add(Vector<long> left, Vector<long> right) => Add(left, right);

        /// <summary>
        /// svuint8_t svadd[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   ADD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svadd[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   ADD Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   ADD Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   ADD Zresult.B, Zop1.B, Zop2.B
        /// svuint8_t svadd[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; ADD Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; ADD Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Add(Vector<byte> left, Vector<byte> right) => Add(left, right);

        /// <summary>
        /// svuint16_t svadd[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   ADD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svadd[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   ADD Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   ADD Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   ADD Zresult.H, Zop1.H, Zop2.H
        /// svuint16_t svadd[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; ADD Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; ADD Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Add(Vector<ushort> left, Vector<ushort> right) => Add(left, right);

        /// <summary>
        /// svuint32_t svadd[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   ADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svadd[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   ADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   ADD Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   ADD Zresult.S, Zop1.S, Zop2.S
        /// svuint32_t svadd[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; ADD Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; ADD Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Add(Vector<uint> left, Vector<uint> right) => Add(left, right);

        /// <summary>
        /// svuint64_t svadd[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   ADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ADD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svadd[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   ADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   ADD Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   ADD Zresult.D, Zop1.D, Zop2.D
        /// svuint64_t svadd[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; ADD Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; ADD Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  ADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V5, REG_P6, REG_V7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  ADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_add, EA_SCALABLE, REG_V0, REG_V0, REG_V0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  ADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_add, EA_SCALABLE, REG_V0, 0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Add(Vector<ulong> left, Vector<ulong> right) => Add(left, right);

        /// <summary>
        /// svfloat32_t svadd[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FADD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svadd[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FADD Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   FADD Zresult.S, Zop1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FADD Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svadd[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FADD Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FADD Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadd, EA_SCALABLE, REG_V25, REG_P2, REG_V10, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadd, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_HM_2A  FADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fadd, EA_SCALABLE, REG_V0, REG_P0, 0.5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fadd, EA_SCALABLE, REG_V0, REG_P1, 1.0, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Add(Vector<float> left, Vector<float> right) => Add(left, right);

        /// <summary>
        /// svfloat64_t svadd[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FADD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svadd[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FADD Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   FADD Zresult.D, Zop1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FADD Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svadd[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FADD Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FADD Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadd, EA_SCALABLE, REG_V25, REG_P2, REG_V10, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadd, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_HM_2A  FADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fadd, EA_SCALABLE, REG_V0, REG_P0, 0.5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fadd, EA_SCALABLE, REG_V0, REG_P1, 1.0, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Add(Vector<double> left, Vector<double> right) => Add(left, right);


        ///  AddAcross : Add reduction

        /// <summary>
        /// int64_t svaddv[_s8](svbool_t pg, svint8_t op)
        ///   SADDV Dresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  SADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_saddv, EA_1BYTE, REG_V1, REG_P4, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_saddv, EA_2BYTE, REG_V2, REG_P5, REG_V3, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> AddAcross(Vector<sbyte> value) => AddAcross(value);

        /// <summary>
        /// int64_t svaddv[_s16](svbool_t pg, svint16_t op)
        ///   SADDV Dresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  SADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_saddv, EA_1BYTE, REG_V1, REG_P4, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_saddv, EA_2BYTE, REG_V2, REG_P5, REG_V3, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> AddAcross(Vector<short> value) => AddAcross(value);

        /// <summary>
        /// int64_t svaddv[_s32](svbool_t pg, svint32_t op)
        ///   SADDV Dresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  SADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_saddv, EA_1BYTE, REG_V1, REG_P4, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_saddv, EA_2BYTE, REG_V2, REG_P5, REG_V3, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> AddAcross(Vector<int> value) => AddAcross(value);

        /// <summary>
        /// int64_t svaddv[_s64](svbool_t pg, svint64_t op)
        ///   UADDV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  UADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uaddv, EA_4BYTE, REG_V3, REG_P6, REG_V4, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> AddAcross(Vector<long> value) => AddAcross(value);

        /// <summary>
        /// uint64_t svaddv[_u8](svbool_t pg, svuint8_t op)
        ///   UADDV Dresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  UADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uaddv, EA_4BYTE, REG_V3, REG_P6, REG_V4, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> AddAcross(Vector<byte> value) => AddAcross(value);

        /// <summary>
        /// uint64_t svaddv[_u16](svbool_t pg, svuint16_t op)
        ///   UADDV Dresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  UADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uaddv, EA_4BYTE, REG_V3, REG_P6, REG_V4, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> AddAcross(Vector<ushort> value) => AddAcross(value);

        /// <summary>
        /// uint64_t svaddv[_u32](svbool_t pg, svuint32_t op)
        ///   UADDV Dresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  UADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uaddv, EA_4BYTE, REG_V3, REG_P6, REG_V4, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> AddAcross(Vector<uint> value) => AddAcross(value);

        /// <summary>
        /// uint64_t svaddv[_u64](svbool_t pg, svuint64_t op)
        ///   UADDV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AI_3A  UADDV <Dd>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uaddv, EA_4BYTE, REG_V3, REG_P6, REG_V4, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> AddAcross(Vector<ulong> value) => AddAcross(value);

        /// <summary>
        /// float32_t svaddv[_f32](svbool_t pg, svfloat32_t op)
        ///   FADDV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FADDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_faddv, EA_2BYTE, REG_V21, REG_P7, REG_V7, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AddAcross(Vector<float> value) => AddAcross(value);

        /// <summary>
        /// float64_t svaddv[_f64](svbool_t pg, svfloat64_t op)
        ///   FADDV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FADDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_faddv, EA_2BYTE, REG_V21, REG_P7, REG_V7, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AddAcross(Vector<double> value) => AddAcross(value);


        ///  AddRotateComplex : Complex add with rotate

        /// <summary>
        /// svfloat32_t svcadd[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2, uint64_t imm_rotation)
        ///   FCADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCADD Zresult.S, Pg/M, Zresult.S, Zop2.S, #imm_rotation
        /// svfloat32_t svcadd[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2, uint64_t imm_rotation)
        ///   FCADD Ztied1.S, Pg/M, Ztied1.S, Zop2.S, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCADD Zresult.S, Pg/M, Zresult.S, Zop2.S, #imm_rotation
        /// svfloat32_t svcadd[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2, uint64_t imm_rotation)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FCADD Zresult.S, Pg/M, Zresult.S, Zop2.S, #imm_rotation
        ///
        /// codegenarm64test:
        ///    IF_SVE_GP_3A  FCADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>, <const>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 90, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 270, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 270, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 270, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AddRotateComplex(Vector<float> left, Vector<float> right, [ConstantExpected] byte rotation) => AddRotateComplex(left, right, rotation);

        /// <summary>
        /// svfloat64_t svcadd[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2, uint64_t imm_rotation)
        ///   FCADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCADD Zresult.D, Pg/M, Zresult.D, Zop2.D, #imm_rotation
        /// svfloat64_t svcadd[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2, uint64_t imm_rotation)
        ///   FCADD Ztied1.D, Pg/M, Ztied1.D, Zop2.D, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCADD Zresult.D, Pg/M, Zresult.D, Zop2.D, #imm_rotation
        /// svfloat64_t svcadd[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2, uint64_t imm_rotation)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FCADD Zresult.D, Pg/M, Zresult.D, Zop2.D, #imm_rotation
        ///
        /// codegenarm64test:
        ///    IF_SVE_GP_3A  FCADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>, <const>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 90, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 270, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 270, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fcadd, EA_SCALABLE, REG_V0, REG_P1, REG_V2, 270, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AddRotateComplex(Vector<double> left, Vector<double> right, [ConstantExpected] byte rotation) => AddRotateComplex(left, right, rotation);


        ///  AddSaturate : Saturating add

        /// <summary>
        /// svint8_t svqadd[_s8](svint8_t op1, svint8_t op2)
        ///   SQADD Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V28, REG_P1, REG_V23, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  SQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V3, REG_V31, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqadd, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<sbyte> AddSaturate(Vector<sbyte> left, Vector<sbyte> right) => AddSaturate(left, right);

        /// <summary>
        /// svint16_t svqadd[_s16](svint16_t op1, svint16_t op2)
        ///   SQADD Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V28, REG_P1, REG_V23, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  SQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V3, REG_V31, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqadd, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<short> AddSaturate(Vector<short> left, Vector<short> right) => AddSaturate(left, right);

        /// <summary>
        /// svint32_t svqadd[_s32](svint32_t op1, svint32_t op2)
        ///   SQADD Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V28, REG_P1, REG_V23, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  SQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V3, REG_V31, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqadd, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<int> AddSaturate(Vector<int> left, Vector<int> right) => AddSaturate(left, right);

        /// <summary>
        /// svint64_t svqadd[_s64](svint64_t op1, svint64_t op2)
        ///   SQADD Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V28, REG_P1, REG_V23, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AT_3A  SQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqadd, EA_SCALABLE, REG_V3, REG_V31, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqadd, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<long> AddSaturate(Vector<long> left, Vector<long> right) => AddSaturate(left, right);

        /// <summary>
        /// svuint8_t svqadd[_u8](svuint8_t op1, svuint8_t op2)
        ///   UQADD Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V0, REG_P3, REG_V27, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AT_3A  UQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V23, REG_V28, REG_V29, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqadd, EA_SCALABLE, REG_V5, 5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<byte> AddSaturate(Vector<byte> left, Vector<byte> right) => AddSaturate(left, right);

        /// <summary>
        /// svuint16_t svqadd[_u16](svuint16_t op1, svuint16_t op2)
        ///   UQADD Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V0, REG_P3, REG_V27, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AT_3A  UQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V23, REG_V28, REG_V29, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqadd, EA_SCALABLE, REG_V5, 5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<ushort> AddSaturate(Vector<ushort> left, Vector<ushort> right) => AddSaturate(left, right);

        /// <summary>
        /// svuint32_t svqadd[_u32](svuint32_t op1, svuint32_t op2)
        ///   UQADD Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V0, REG_P3, REG_V27, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AT_3A  UQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V23, REG_V28, REG_V29, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqadd, EA_SCALABLE, REG_V5, 5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<uint> AddSaturate(Vector<uint> left, Vector<uint> right) => AddSaturate(left, right);

        /// <summary>
        /// svuint64_t svqadd[_u64](svuint64_t op1, svuint64_t op2)
        ///   UQADD Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQADD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V0, REG_P3, REG_V27, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AT_3A  UQADD <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqadd, EA_SCALABLE, REG_V23, REG_V28, REG_V29, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQADD <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqadd, EA_SCALABLE, REG_V5, 5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<ulong> AddSaturate(Vector<ulong> left, Vector<ulong> right) => AddSaturate(left, right);


        ///  AddSequentialAcross : Add reduction (strictly-ordered)

        /// <summary>
        /// float32_t svadda[_f32](svbool_t pg, float32_t initial, svfloat32_t op)
        ///   FADDA Stied, Pg, Stied, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HJ_3A  FADDA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadda, EA_2BYTE, REG_V21, REG_P6, REG_V14, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadda, EA_4BYTE, REG_V22, REG_P5, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadda, EA_8BYTE, REG_V23, REG_P4, REG_V12, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> AddSequentialAcross(Vector<float> initial, Vector<float> value) => AddSequentialAcross(initial, value);

        /// <summary>
        /// float64_t svadda[_f64](svbool_t pg, float64_t initial, svfloat64_t op)
        ///   FADDA Dtied, Pg, Dtied, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HJ_3A  FADDA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadda, EA_2BYTE, REG_V21, REG_P6, REG_V14, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadda, EA_4BYTE, REG_V22, REG_P5, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_fadda, EA_8BYTE, REG_V23, REG_P4, REG_V12, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> AddSequentialAcross(Vector<double> initial, Vector<double> value) => AddSequentialAcross(initial, value);


        ///  And : Bitwise AND

        /// <summary>
        /// svint8_t svand[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   AND Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; AND Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svand[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   AND Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   AND Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svint8_t svand[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; AND Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; AND Zresult.B, Pg/M, Zresult.B, Zop1.B
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> And(Vector<sbyte> left, Vector<sbyte> right) => And(left, right);

        /// <summary>
        /// svint16_t svand[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   AND Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; AND Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svand[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   AND Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   AND Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svint16_t svand[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; AND Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; AND Zresult.H, Pg/M, Zresult.H, Zop1.H
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> And(Vector<short> left, Vector<short> right) => And(left, right);

        /// <summary>
        /// svint32_t svand[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   AND Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; AND Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svand[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   AND Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   AND Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svint32_t svand[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; AND Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; AND Zresult.S, Pg/M, Zresult.S, Zop1.S
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> And(Vector<int> left, Vector<int> right) => And(left, right);

        /// <summary>
        /// svint64_t svand[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   AND Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; AND Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svand[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   AND Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   AND Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svint64_t svand[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; AND Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; AND Zresult.D, Pg/M, Zresult.D, Zop1.D
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> And(Vector<long> left, Vector<long> right) => And(left, right);

        /// <summary>
        /// svuint8_t svand[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   AND Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; AND Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svand[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   AND Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   AND Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svuint8_t svand[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; AND Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; AND Zresult.B, Pg/M, Zresult.B, Zop1.B
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> And(Vector<byte> left, Vector<byte> right) => And(left, right);

        /// <summary>
        /// svuint16_t svand[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   AND Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; AND Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svand[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   AND Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   AND Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svuint16_t svand[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; AND Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; AND Zresult.H, Pg/M, Zresult.H, Zop1.H
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> And(Vector<ushort> left, Vector<ushort> right) => And(left, right);

        /// <summary>
        /// svuint32_t svand[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   AND Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; AND Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svand[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   AND Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   AND Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svuint32_t svand[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; AND Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; AND Zresult.S, Pg/M, Zresult.S, Zop1.S
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> And(Vector<uint> left, Vector<uint> right) => And(left, right);

        /// <summary>
        /// svuint64_t svand[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   AND Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; AND Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svand[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   AND Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   AND Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   AND Zresult.D, Zop1.D, Zop2.D
        /// svuint64_t svand[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; AND Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; AND Zresult.D, Pg/M, Zresult.D, Zop1.D
        /// svbool_t svand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   AND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  AND <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_P1, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_and, EA_SCALABLE, REG_P0, REG_P3, REG_P14, REG_P15, INS_OPTS_SCALABLE_B); /* AND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  AND <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_and, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> And(Vector<ulong> left, Vector<ulong> right) => And(left, right);


        ///  AndAcross : Bitwise AND reduction to scalar

        /// <summary>
        /// int8_t svandv[_s8](svbool_t pg, svint8_t op)
        ///   ANDV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> AndAcross(Vector<sbyte> value) => AndAcross(value);

        /// <summary>
        /// int16_t svandv[_s16](svbool_t pg, svint16_t op)
        ///   ANDV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> AndAcross(Vector<short> value) => AndAcross(value);

        /// <summary>
        /// int32_t svandv[_s32](svbool_t pg, svint32_t op)
        ///   ANDV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> AndAcross(Vector<int> value) => AndAcross(value);

        /// <summary>
        /// int64_t svandv[_s64](svbool_t pg, svint64_t op)
        ///   ANDV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> AndAcross(Vector<long> value) => AndAcross(value);

        /// <summary>
        /// uint8_t svandv[_u8](svbool_t pg, svuint8_t op)
        ///   ANDV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> AndAcross(Vector<byte> value) => AndAcross(value);

        /// <summary>
        /// uint16_t svandv[_u16](svbool_t pg, svuint16_t op)
        ///   ANDV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> AndAcross(Vector<ushort> value) => AndAcross(value);

        /// <summary>
        /// uint32_t svandv[_u32](svbool_t pg, svuint32_t op)
        ///   ANDV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> AndAcross(Vector<uint> value) => AndAcross(value);

        /// <summary>
        /// uint64_t svandv[_u64](svbool_t pg, svuint64_t op)
        ///   ANDV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ANDV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_andv, EA_1BYTE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> AndAcross(Vector<ulong> value) => AndAcross(value);


        ///  AndNot : Bitwise NAND

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> AndNot(Vector<sbyte> left, Vector<sbyte> right) => AndNot(left, right);

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> AndNot(Vector<short> left, Vector<short> right) => AndNot(left, right);

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> AndNot(Vector<int> left, Vector<int> right) => AndNot(left, right);

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> AndNot(Vector<long> left, Vector<long> right) => AndNot(left, right);

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> AndNot(Vector<byte> left, Vector<byte> right) => AndNot(left, right);

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> AndNot(Vector<ushort> left, Vector<ushort> right) => AndNot(left, right);

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> AndNot(Vector<uint> left, Vector<uint> right) => AndNot(left, right);

        /// <summary>
        /// svbool_t svnand[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NAND Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nand, EA_SCALABLE, REG_P1, REG_P7, REG_P2, REG_P15, INS_OPTS_SCALABLE_B); /* NAND <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> AndNot(Vector<ulong> left, Vector<ulong> right) => AndNot(left, right);


        ///  BitwiseClear : Bitwise clear

        /// <summary>
        /// svint8_t svbic[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   BIC Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svbic[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   BIC Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svint8_t svbic[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; BIC Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> BitwiseClear(Vector<sbyte> left, Vector<sbyte> right) => BitwiseClear(left, right);

        /// <summary>
        /// svint16_t svbic[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   BIC Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svbic[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   BIC Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svint16_t svbic[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; BIC Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> BitwiseClear(Vector<short> left, Vector<short> right) => BitwiseClear(left, right);

        /// <summary>
        /// svint32_t svbic[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   BIC Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svbic[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   BIC Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svint32_t svbic[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; BIC Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> BitwiseClear(Vector<int> left, Vector<int> right) => BitwiseClear(left, right);

        /// <summary>
        /// svint64_t svbic[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   BIC Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svbic[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   BIC Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svint64_t svbic[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; BIC Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> BitwiseClear(Vector<long> left, Vector<long> right) => BitwiseClear(left, right);

        /// <summary>
        /// svuint8_t svbic[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   BIC Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svbic[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   BIC Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svuint8_t svbic[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; BIC Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> BitwiseClear(Vector<byte> left, Vector<byte> right) => BitwiseClear(left, right);

        /// <summary>
        /// svuint16_t svbic[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   BIC Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svbic[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   BIC Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svuint16_t svbic[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; BIC Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> BitwiseClear(Vector<ushort> left, Vector<ushort> right) => BitwiseClear(left, right);

        /// <summary>
        /// svuint32_t svbic[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   BIC Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svbic[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   BIC Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svuint32_t svbic[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; BIC Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> BitwiseClear(Vector<uint> left, Vector<uint> right) => BitwiseClear(left, right);

        /// <summary>
        /// svuint64_t svbic[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   BIC Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; BIC Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svbic[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   BIC Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   BIC Zresult.D, Zop1.D, Zop2.D
        /// svuint64_t svbic[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; BIC Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svbool_t svbic[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BIC Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  BIC <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_P4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_bic, EA_SCALABLE, REG_P4, REG_P9, REG_P12, REG_P11, INS_OPTS_SCALABLE_B); /* BIC <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  BIC <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_bic, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> BitwiseClear(Vector<ulong> left, Vector<ulong> right) => BitwiseClear(left, right);


        ///  BooleanNot : Logically invert boolean condition

        /// <summary>
        /// svint8_t svcnot[_s8]_m(svint8_t inactive, svbool_t pg, svint8_t op)
        ///   CNOT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.B, Pg/M, Zop.B
        /// svint8_t svcnot[_s8]_x(svbool_t pg, svint8_t op)
        ///   CNOT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.B, Pg/M, Zop.B
        /// svint8_t svcnot[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; CNOT Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> BooleanNot(Vector<sbyte> value) => BooleanNot(value);

        /// <summary>
        /// svint16_t svcnot[_s16]_m(svint16_t inactive, svbool_t pg, svint16_t op)
        ///   CNOT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.H, Pg/M, Zop.H
        /// svint16_t svcnot[_s16]_x(svbool_t pg, svint16_t op)
        ///   CNOT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.H, Pg/M, Zop.H
        /// svint16_t svcnot[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; CNOT Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> BooleanNot(Vector<short> value) => BooleanNot(value);

        /// <summary>
        /// svint32_t svcnot[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   CNOT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.S, Pg/M, Zop.S
        /// svint32_t svcnot[_s32]_x(svbool_t pg, svint32_t op)
        ///   CNOT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.S, Pg/M, Zop.S
        /// svint32_t svcnot[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CNOT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> BooleanNot(Vector<int> value) => BooleanNot(value);

        /// <summary>
        /// svint64_t svcnot[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   CNOT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.D, Pg/M, Zop.D
        /// svint64_t svcnot[_s64]_x(svbool_t pg, svint64_t op)
        ///   CNOT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.D, Pg/M, Zop.D
        /// svint64_t svcnot[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CNOT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> BooleanNot(Vector<long> value) => BooleanNot(value);

        /// <summary>
        /// svuint8_t svcnot[_u8]_m(svuint8_t inactive, svbool_t pg, svuint8_t op)
        ///   CNOT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcnot[_u8]_x(svbool_t pg, svuint8_t op)
        ///   CNOT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcnot[_u8]_z(svbool_t pg, svuint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; CNOT Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> BooleanNot(Vector<byte> value) => BooleanNot(value);

        /// <summary>
        /// svuint16_t svcnot[_u16]_m(svuint16_t inactive, svbool_t pg, svuint16_t op)
        ///   CNOT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcnot[_u16]_x(svbool_t pg, svuint16_t op)
        ///   CNOT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcnot[_u16]_z(svbool_t pg, svuint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; CNOT Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> BooleanNot(Vector<ushort> value) => BooleanNot(value);

        /// <summary>
        /// svuint32_t svcnot[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   CNOT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnot[_u32]_x(svbool_t pg, svuint32_t op)
        ///   CNOT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnot[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CNOT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> BooleanNot(Vector<uint> value) => BooleanNot(value);

        /// <summary>
        /// svuint64_t svcnot[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   CNOT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CNOT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnot[_u64]_x(svbool_t pg, svuint64_t op)
        ///   CNOT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CNOT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnot[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CNOT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnot, EA_SCALABLE, REG_V29, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> BooleanNot(Vector<ulong> value) => BooleanNot(value);



        ///  Compact : Shuffle active elements of vector to the right and fill with zero

        /// <summary>
        /// svint32_t svcompact[_s32](svbool_t pg, svint32_t op)
        ///   COMPACT Zresult.S, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CL_3A  COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V16, REG_P7, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V15, REG_P0, REG_V12, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> Compact(Vector<int> mask, Vector<int> value) => Compact(mask, value);

        /// <summary>
        /// svint64_t svcompact[_s64](svbool_t pg, svint64_t op)
        ///   COMPACT Zresult.D, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CL_3A  COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V16, REG_P7, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V15, REG_P0, REG_V12, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> Compact(Vector<long> mask, Vector<long> value) => Compact(mask, value);

        /// <summary>
        /// svuint32_t svcompact[_u32](svbool_t pg, svuint32_t op)
        ///   COMPACT Zresult.S, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CL_3A  COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V16, REG_P7, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V15, REG_P0, REG_V12, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> Compact(Vector<uint> mask, Vector<uint> value) => Compact(mask, value);

        /// <summary>
        /// svuint64_t svcompact[_u64](svbool_t pg, svuint64_t op)
        ///   COMPACT Zresult.D, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CL_3A  COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V16, REG_P7, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V15, REG_P0, REG_V12, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> Compact(Vector<ulong> mask, Vector<ulong> value) => Compact(mask, value);

        /// <summary>
        /// svfloat32_t svcompact[_f32](svbool_t pg, svfloat32_t op)
        ///   COMPACT Zresult.S, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CL_3A  COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V16, REG_P7, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V15, REG_P0, REG_V12, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> Compact(Vector<float> mask, Vector<float> value) => Compact(mask, value);

        /// <summary>
        /// svfloat64_t svcompact[_f64](svbool_t pg, svfloat64_t op)
        ///   COMPACT Zresult.D, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CL_3A  COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V16, REG_P7, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_compact, EA_SCALABLE, REG_V15, REG_P0, REG_V12, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> Compact(Vector<double> mask, Vector<double> value) => Compact(mask, value);


        ///  CompareEqual : Compare equal to

        /// <summary>
        /// svbool_t svcmpeq[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   CMPEQ Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareEqual(Vector<sbyte> left, Vector<sbyte> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq_wide[_s8](svbool_t pg, svint8_t op1, svint64_t op2)
        ///   CMPEQ Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareEqual(Vector<sbyte> left, Vector<long> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   CMPEQ Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareEqual(Vector<short> left, Vector<short> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq_wide[_s16](svbool_t pg, svint16_t op1, svint64_t op2)
        ///   CMPEQ Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareEqual(Vector<short> left, Vector<long> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   CMPEQ Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareEqual(Vector<int> left, Vector<int> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq_wide[_s32](svbool_t pg, svint32_t op1, svint64_t op2)
        ///   CMPEQ Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareEqual(Vector<int> left, Vector<long> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   CMPEQ Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CompareEqual(Vector<long> left, Vector<long> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   CMPEQ Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareEqual(Vector<byte> left, Vector<byte> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   CMPEQ Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareEqual(Vector<ushort> left, Vector<ushort> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   CMPEQ Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareEqual(Vector<uint> left, Vector<uint> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   CMPEQ Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V0, REG_V10, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P7, REG_V31, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpeq, EA_SCALABLE, REG_P15, REG_P0, REG_V31, 8, INS_OPTS_SCALABLE_B); /* CMPEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CompareEqual(Vector<ulong> left, Vector<ulong> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FCMEQ Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmeq, EA_SCALABLE, REG_P2, REG_P4, REG_V28, REG_V8, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HI_3A  FCMEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmeq, EA_SCALABLE, REG_P2, REG_P3, REG_V4, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> CompareEqual(Vector<float> left, Vector<float> right) => CompareEqual(left, right);

        /// <summary>
        /// svbool_t svcmpeq[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FCMEQ Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmeq, EA_SCALABLE, REG_P2, REG_P4, REG_V28, REG_V8, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HI_3A  FCMEQ <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmeq, EA_SCALABLE, REG_P2, REG_P3, REG_V4, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> CompareEqual(Vector<double> left, Vector<double> right) => CompareEqual(left, right);


        ///  CompareGreaterThan : Compare greater than

        /// <summary>
        /// svbool_t svcmpgt[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   CMPGT Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareGreaterThan(Vector<sbyte> left, Vector<sbyte> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt_wide[_s8](svbool_t pg, svint8_t op1, svint64_t op2)
        ///   CMPGT Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareGreaterThan(Vector<sbyte> left, Vector<long> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   CMPGT Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareGreaterThan(Vector<short> left, Vector<short> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt_wide[_s16](svbool_t pg, svint16_t op1, svint64_t op2)
        ///   CMPGT Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareGreaterThan(Vector<short> left, Vector<long> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   CMPGT Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareGreaterThan(Vector<int> left, Vector<int> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt_wide[_s32](svbool_t pg, svint32_t op1, svint64_t op2)
        ///   CMPGT Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareGreaterThan(Vector<int> left, Vector<long> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   CMPGT Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CompareGreaterThan(Vector<long> left, Vector<long> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   CMPHI Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareGreaterThan(Vector<byte> left, Vector<byte> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt_wide[_u8](svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   CMPHI Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareGreaterThan(Vector<byte> left, Vector<ulong> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   CMPHI Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareGreaterThan(Vector<ushort> left, Vector<ushort> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt_wide[_u16](svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   CMPHI Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareGreaterThan(Vector<ushort> left, Vector<ulong> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   CMPHI Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareGreaterThan(Vector<uint> left, Vector<uint> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt_wide[_u32](svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   CMPHI Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareGreaterThan(Vector<uint> left, Vector<ulong> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   CMPHI Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CompareGreaterThan(Vector<ulong> left, Vector<ulong> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FCMGT Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P3, REG_P6, REG_V18, REG_V28, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HI_3A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P11, REG_P5, REG_V2, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> CompareGreaterThan(Vector<float> left, Vector<float> right) => CompareGreaterThan(left, right);

        /// <summary>
        /// svbool_t svcmpgt[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FCMGT Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P3, REG_P6, REG_V18, REG_V28, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HI_3A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P11, REG_P5, REG_V2, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> CompareGreaterThan(Vector<double> left, Vector<double> right) => CompareGreaterThan(left, right);


        ///  CompareGreaterThanOrEqual : Compare greater than or equal to

        /// <summary>
        /// svbool_t svcmpge[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   CMPGE Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareGreaterThanOrEqual(Vector<sbyte> left, Vector<sbyte> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge_wide[_s8](svbool_t pg, svint8_t op1, svint64_t op2)
        ///   CMPGE Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareGreaterThanOrEqual(Vector<sbyte> left, Vector<long> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   CMPGE Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareGreaterThanOrEqual(Vector<short> left, Vector<short> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge_wide[_s16](svbool_t pg, svint16_t op1, svint64_t op2)
        ///   CMPGE Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareGreaterThanOrEqual(Vector<short> left, Vector<long> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   CMPGE Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareGreaterThanOrEqual(Vector<int> left, Vector<int> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge_wide[_s32](svbool_t pg, svint32_t op1, svint64_t op2)
        ///   CMPGE Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareGreaterThanOrEqual(Vector<int> left, Vector<long> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   CMPGE Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CompareGreaterThanOrEqual(Vector<long> left, Vector<long> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   CMPHS Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareGreaterThanOrEqual(Vector<byte> left, Vector<byte> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge_wide[_u8](svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   CMPHS Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareGreaterThanOrEqual(Vector<byte> left, Vector<ulong> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   CMPHS Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareGreaterThanOrEqual(Vector<ushort> left, Vector<ushort> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge_wide[_u16](svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   CMPHS Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareGreaterThanOrEqual(Vector<ushort> left, Vector<ulong> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   CMPHS Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareGreaterThanOrEqual(Vector<uint> left, Vector<uint> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge_wide[_u32](svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   CMPHS Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareGreaterThanOrEqual(Vector<uint> left, Vector<ulong> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   CMPHS Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CompareGreaterThanOrEqual(Vector<ulong> left, Vector<ulong> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FCMGE Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P13, REG_P5, REG_V8, REG_V18, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HI_3A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P1, REG_P2, REG_V3, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> CompareGreaterThanOrEqual(Vector<float> left, Vector<float> right) => CompareGreaterThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmpge[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FCMGE Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P13, REG_P5, REG_V8, REG_V18, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HI_3A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P1, REG_P2, REG_V3, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> CompareGreaterThanOrEqual(Vector<double> left, Vector<double> right) => CompareGreaterThanOrEqual(left, right);


        ///  CompareLessThan : Compare less than

        /// <summary>
        /// svbool_t svcmplt[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   CMPGT Presult.B, Pg/Z, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareLessThan(Vector<sbyte> left, Vector<sbyte> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt_wide[_s8](svbool_t pg, svint8_t op1, svint64_t op2)
        ///   CMPLT Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLT <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplt, EA_SCALABLE, REG_P2, REG_P0, REG_V14, REG_V30, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplt, EA_SCALABLE, REG_P1, REG_P7, REG_V24, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPLT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmplt, EA_SCALABLE, REG_P7, REG_P2, REG_V8, -16, INS_OPTS_SCALABLE_B); /* CMPLT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareLessThan(Vector<sbyte> left, Vector<long> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   CMPGT Presult.H, Pg/Z, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareLessThan(Vector<short> left, Vector<short> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt_wide[_s16](svbool_t pg, svint16_t op1, svint64_t op2)
        ///   CMPLT Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLT <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplt, EA_SCALABLE, REG_P2, REG_P0, REG_V14, REG_V30, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplt, EA_SCALABLE, REG_P1, REG_P7, REG_V24, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPLT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmplt, EA_SCALABLE, REG_P7, REG_P2, REG_V8, -16, INS_OPTS_SCALABLE_B); /* CMPLT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareLessThan(Vector<short> left, Vector<long> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   CMPGT Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareLessThan(Vector<int> left, Vector<int> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt_wide[_s32](svbool_t pg, svint32_t op1, svint64_t op2)
        ///   CMPLT Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLT <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplt, EA_SCALABLE, REG_P2, REG_P0, REG_V14, REG_V30, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplt, EA_SCALABLE, REG_P1, REG_P7, REG_V24, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPLT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmplt, EA_SCALABLE, REG_P7, REG_P2, REG_V8, -16, INS_OPTS_SCALABLE_B); /* CMPLT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareLessThan(Vector<int> left, Vector<long> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   CMPGT Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P2, REG_V20, REG_V24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpgt, EA_SCALABLE, REG_P13, REG_P5, REG_V11, REG_V23, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpgt, EA_SCALABLE, REG_P10, REG_P1, REG_V18, 4, INS_OPTS_SCALABLE_S); /* CMPGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CompareLessThan(Vector<long> left, Vector<long> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   CMPHI Presult.B, Pg/Z, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareLessThan(Vector<byte> left, Vector<byte> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt_wide[_u8](svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   CMPLO Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLO <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplo, EA_SCALABLE, REG_P11, REG_P6, REG_V12, REG_V28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplo, EA_SCALABLE, REG_P3, REG_P1, REG_V20, REG_V1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPLO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmplo, EA_SCALABLE, REG_P8, REG_P5, REG_V21, 64, INS_OPTS_SCALABLE_S); /* CMPLO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareLessThan(Vector<byte> left, Vector<ulong> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   CMPHI Presult.H, Pg/Z, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareLessThan(Vector<ushort> left, Vector<ushort> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt_wide[_u16](svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   CMPLO Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLO <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplo, EA_SCALABLE, REG_P11, REG_P6, REG_V12, REG_V28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplo, EA_SCALABLE, REG_P3, REG_P1, REG_V20, REG_V1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPLO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmplo, EA_SCALABLE, REG_P8, REG_P5, REG_V21, 64, INS_OPTS_SCALABLE_S); /* CMPLO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareLessThan(Vector<ushort> left, Vector<ulong> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   CMPHI Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareLessThan(Vector<uint> left, Vector<uint> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt_wide[_u32](svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   CMPLO Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLO <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplo, EA_SCALABLE, REG_P11, REG_P6, REG_V12, REG_V28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmplo, EA_SCALABLE, REG_P3, REG_P1, REG_V20, REG_V1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPLO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmplo, EA_SCALABLE, REG_P8, REG_P5, REG_V21, 64, INS_OPTS_SCALABLE_S); /* CMPLO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareLessThan(Vector<uint> left, Vector<ulong> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   CMPHI Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P3, REG_V30, REG_V25, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphi, EA_SCALABLE, REG_P12, REG_P4, REG_V1, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphi, EA_SCALABLE, REG_P15, REG_P7, REG_V19, 0, INS_OPTS_SCALABLE_B); /* CMPHI <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CompareLessThan(Vector<ulong> left, Vector<ulong> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FCMGT Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P3, REG_P6, REG_V18, REG_V28, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HI_3A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P11, REG_P5, REG_V2, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> CompareLessThan(Vector<float> left, Vector<float> right) => CompareLessThan(left, right);

        /// <summary>
        /// svbool_t svcmplt[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FCMGT Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P3, REG_P6, REG_V18, REG_V28, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HI_3A  FCMGT <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmgt, EA_SCALABLE, REG_P11, REG_P5, REG_V2, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> CompareLessThan(Vector<double> left, Vector<double> right) => CompareLessThan(left, right);


        ///  CompareLessThanOrEqual : Compare less than or equal to

        /// <summary>
        /// svbool_t svcmple[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   CMPGE Presult.B, Pg/Z, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareLessThanOrEqual(Vector<sbyte> left, Vector<sbyte> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple_wide[_s8](svbool_t pg, svint8_t op1, svint64_t op2)
        ///   CMPLE Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLE <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmple, EA_SCALABLE, REG_P10, REG_P5, REG_V11, REG_V27, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmple, EA_SCALABLE, REG_P4, REG_P2, REG_V10, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPLE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmple, EA_SCALABLE, REG_P8, REG_P6, REG_V11, 15, INS_OPTS_SCALABLE_D); /* CMPLE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareLessThanOrEqual(Vector<sbyte> left, Vector<long> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   CMPGE Presult.H, Pg/Z, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareLessThanOrEqual(Vector<short> left, Vector<short> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple_wide[_s16](svbool_t pg, svint16_t op1, svint64_t op2)
        ///   CMPLE Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLE <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmple, EA_SCALABLE, REG_P10, REG_P5, REG_V11, REG_V27, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmple, EA_SCALABLE, REG_P4, REG_P2, REG_V10, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPLE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmple, EA_SCALABLE, REG_P8, REG_P6, REG_V11, 15, INS_OPTS_SCALABLE_D); /* CMPLE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareLessThanOrEqual(Vector<short> left, Vector<long> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   CMPGE Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareLessThanOrEqual(Vector<int> left, Vector<int> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple_wide[_s32](svbool_t pg, svint32_t op1, svint64_t op2)
        ///   CMPLE Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLE <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmple, EA_SCALABLE, REG_P10, REG_P5, REG_V11, REG_V27, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmple, EA_SCALABLE, REG_P4, REG_P2, REG_V10, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE); /* CMPLE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmple, EA_SCALABLE, REG_P8, REG_P6, REG_V11, 15, INS_OPTS_SCALABLE_D); /* CMPLE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareLessThanOrEqual(Vector<int> left, Vector<long> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   CMPGE Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P1, REG_V10, REG_V23, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpge, EA_SCALABLE, REG_P14, REG_P6, REG_V21, REG_V13, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpge, EA_SCALABLE, REG_P11, REG_P7, REG_V21, 1, INS_OPTS_SCALABLE_H); /* CMPGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CompareLessThanOrEqual(Vector<long> left, Vector<long> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   CMPHS Presult.B, Pg/Z, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareLessThanOrEqual(Vector<byte> left, Vector<byte> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple_wide[_u8](svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   CMPLS Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLS <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpls, EA_SCALABLE, REG_P0, REG_P7, REG_V13, REG_V29, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpls, EA_SCALABLE, REG_P2, REG_P0, REG_V30, REG_V2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPLS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpls, EA_SCALABLE, REG_P0, REG_P3, REG_V9, 127, INS_OPTS_SCALABLE_D); /* CMPLS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareLessThanOrEqual(Vector<byte> left, Vector<ulong> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   CMPHS Presult.H, Pg/Z, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareLessThanOrEqual(Vector<ushort> left, Vector<ushort> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple_wide[_u16](svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   CMPLS Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLS <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpls, EA_SCALABLE, REG_P0, REG_P7, REG_V13, REG_V29, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpls, EA_SCALABLE, REG_P2, REG_P0, REG_V30, REG_V2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPLS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpls, EA_SCALABLE, REG_P0, REG_P3, REG_V9, 127, INS_OPTS_SCALABLE_D); /* CMPLS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareLessThanOrEqual(Vector<ushort> left, Vector<ulong> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   CMPHS Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareLessThanOrEqual(Vector<uint> left, Vector<uint> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple_wide[_u32](svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   CMPLS Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPLS <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpls, EA_SCALABLE, REG_P0, REG_P7, REG_V13, REG_V29, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpls, EA_SCALABLE, REG_P2, REG_P0, REG_V30, REG_V2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPLS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpls, EA_SCALABLE, REG_P0, REG_P3, REG_V9, 127, INS_OPTS_SCALABLE_D); /* CMPLS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareLessThanOrEqual(Vector<uint> left, Vector<ulong> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   CMPHS Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P4, REG_V1, REG_V26, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P3, REG_V0, REG_V30, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3B  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmphs, EA_SCALABLE, REG_P11, REG_P1, REG_V0, 36, INS_OPTS_SCALABLE_H); /* CMPHS <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CompareLessThanOrEqual(Vector<ulong> left, Vector<ulong> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FCMGE Presult.S, Pg/Z, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P13, REG_P5, REG_V8, REG_V18, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HI_3A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P1, REG_P2, REG_V3, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> CompareLessThanOrEqual(Vector<float> left, Vector<float> right) => CompareLessThanOrEqual(left, right);

        /// <summary>
        /// svbool_t svcmple[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FCMGE Presult.D, Pg/Z, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P13, REG_P5, REG_V8, REG_V18, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HI_3A  FCMGE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmge, EA_SCALABLE, REG_P1, REG_P2, REG_V3, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> CompareLessThanOrEqual(Vector<double> left, Vector<double> right) => CompareLessThanOrEqual(left, right);


        ///  CompareNotEqualTo : Compare not equal to

        /// <summary>
        /// svbool_t svcmpne[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   CMPNE Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareNotEqualTo(Vector<sbyte> left, Vector<sbyte> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne_wide[_s8](svbool_t pg, svint8_t op1, svint64_t op2)
        ///   CMPNE Presult.B, Pg/Z, Zop1.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CompareNotEqualTo(Vector<sbyte> left, Vector<long> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   CMPNE Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareNotEqualTo(Vector<short> left, Vector<short> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne_wide[_s16](svbool_t pg, svint16_t op1, svint64_t op2)
        ///   CMPNE Presult.H, Pg/Z, Zop1.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CompareNotEqualTo(Vector<short> left, Vector<long> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   CMPNE Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareNotEqualTo(Vector<int> left, Vector<int> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne_wide[_s32](svbool_t pg, svint32_t op1, svint64_t op2)
        ///   CMPNE Presult.S, Pg/Z, Zop1.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CompareNotEqualTo(Vector<int> left, Vector<long> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   CMPNE Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CompareNotEqualTo(Vector<long> left, Vector<long> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   CMPNE Presult.B, Pg/Z, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CompareNotEqualTo(Vector<byte> left, Vector<byte> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   CMPNE Presult.H, Pg/Z, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CompareNotEqualTo(Vector<ushort> left, Vector<ushort> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   CMPNE Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CompareNotEqualTo(Vector<uint> left, Vector<uint> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   CMPNE Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CX_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P3, REG_P1, REG_V15, REG_V20, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_CX_4A_A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P0, REG_V14, REG_V28, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D */
        ///    IF_SVE_CY_3A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_cmpne, EA_SCALABLE, REG_P0, REG_P5, REG_V0, -14, INS_OPTS_SCALABLE_H); /* CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm> */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CompareNotEqualTo(Vector<ulong> left, Vector<ulong> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FCMNE Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmne, EA_SCALABLE, REG_P11, REG_P1, REG_V21, REG_V10, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HI_3A  FCMNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmne, EA_SCALABLE, REG_P1, REG_P0, REG_V5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> CompareNotEqualTo(Vector<float> left, Vector<float> right) => CompareNotEqualTo(left, right);

        /// <summary>
        /// svbool_t svcmpne[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FCMNE Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmne, EA_SCALABLE, REG_P11, REG_P1, REG_V21, REG_V10, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HI_3A  FCMNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0
        ///        theEmitter->emitIns_R_R_R(INS_sve_fcmne, EA_SCALABLE, REG_P1, REG_P0, REG_V5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> CompareNotEqualTo(Vector<double> left, Vector<double> right) => CompareNotEqualTo(left, right);


        ///  CompareUnordered : Compare unordered with

        /// <summary>
        /// svbool_t svcmpuo[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FCMUO Presult.S, Pg/Z, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMUO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmuo, EA_SCALABLE, REG_P5, REG_P2, REG_V31, REG_V20, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> CompareUnordered(Vector<float> left, Vector<float> right) => CompareUnordered(left, right);

        /// <summary>
        /// svbool_t svcmpuo[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FCMUO Presult.D, Pg/Z, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HT_4A  FCMUO <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fcmuo, EA_SCALABLE, REG_P5, REG_P2, REG_V31, REG_V20, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> CompareUnordered(Vector<double> left, Vector<double> right) => CompareUnordered(left, right);


        ///  Compute16BitAddresses : Compute vector addresses for 16-bit data

        /// <summary>
        /// svuint32_t svadrh[_u32base]_[s32]index(svuint32_t bases, svint32_t indices)
        ///   ADR Zresult.S, [Zbases.S, Zindices.S, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute16BitAddresses(Vector<uint> bases, Vector<int> indices) => Compute16BitAddresses(bases, indices);

        /// <summary>
        /// svuint32_t svadrh[_u32base]_[u32]index(svuint32_t bases, svuint32_t indices)
        ///   ADR Zresult.S, [Zbases.S, Zindices.S, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute16BitAddresses(Vector<uint> bases, Vector<uint> indices) => Compute16BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrh[_u64base]_[s64]index(svuint64_t bases, svint64_t indices)
        ///   ADR Zresult.D, [Zbases.D, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute16BitAddresses(Vector<ulong> bases, Vector<long> indices) => Compute16BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrh[_u64base]_[u64]index(svuint64_t bases, svuint64_t indices)
        ///   ADR Zresult.D, [Zbases.D, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute16BitAddresses(Vector<ulong> bases, Vector<ulong> indices) => Compute16BitAddresses(bases, indices);


        ///  Compute32BitAddresses : Compute vector addresses for 32-bit data

        /// <summary>
        /// svuint32_t svadrw[_u32base]_[s32]index(svuint32_t bases, svint32_t indices)
        ///   ADR Zresult.S, [Zbases.S, Zindices.S, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute32BitAddresses(Vector<uint> bases, Vector<int> indices) => Compute32BitAddresses(bases, indices);

        /// <summary>
        /// svuint32_t svadrw[_u32base]_[u32]index(svuint32_t bases, svuint32_t indices)
        ///   ADR Zresult.S, [Zbases.S, Zindices.S, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute32BitAddresses(Vector<uint> bases, Vector<uint> indices) => Compute32BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrw[_u64base]_[s64]index(svuint64_t bases, svint64_t indices)
        ///   ADR Zresult.D, [Zbases.D, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute32BitAddresses(Vector<ulong> bases, Vector<long> indices) => Compute32BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrw[_u64base]_[u64]index(svuint64_t bases, svuint64_t indices)
        ///   ADR Zresult.D, [Zbases.D, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute32BitAddresses(Vector<ulong> bases, Vector<ulong> indices) => Compute32BitAddresses(bases, indices);


        ///  Compute64BitAddresses : Compute vector addresses for 64-bit data

        /// <summary>
        /// svuint32_t svadrd[_u32base]_[s32]index(svuint32_t bases, svint32_t indices)
        ///   ADR Zresult.S, [Zbases.S, Zindices.S, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute64BitAddresses(Vector<uint> bases, Vector<int> indices) => Compute64BitAddresses(bases, indices);

        /// <summary>
        /// svuint32_t svadrd[_u32base]_[u32]index(svuint32_t bases, svuint32_t indices)
        ///   ADR Zresult.S, [Zbases.S, Zindices.S, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute64BitAddresses(Vector<uint> bases, Vector<uint> indices) => Compute64BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrd[_u64base]_[s64]index(svuint64_t bases, svint64_t indices)
        ///   ADR Zresult.D, [Zbases.D, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute64BitAddresses(Vector<ulong> bases, Vector<long> indices) => Compute64BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrd[_u64base]_[u64]index(svuint64_t bases, svuint64_t indices)
        ///   ADR Zresult.D, [Zbases.D, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute64BitAddresses(Vector<ulong> bases, Vector<ulong> indices) => Compute64BitAddresses(bases, indices);


        ///  Compute8BitAddresses : Compute vector addresses for 8-bit data

        /// <summary>
        /// svuint32_t svadrb[_u32base]_[s32]offset(svuint32_t bases, svint32_t offsets)
        ///   ADR Zresult.S, [Zbases.S, Zoffsets.S]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute8BitAddresses(Vector<uint> bases, Vector<int> indices) => Compute8BitAddresses(bases, indices);

        /// <summary>
        /// svuint32_t svadrb[_u32base]_[u32]offset(svuint32_t bases, svuint32_t offsets)
        ///   ADR Zresult.S, [Zbases.S, Zoffsets.S]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<uint> Compute8BitAddresses(Vector<uint> bases, Vector<uint> indices) => Compute8BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrb[_u64base]_[s64]offset(svuint64_t bases, svint64_t offsets)
        ///   ADR Zresult.D, [Zbases.D, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute8BitAddresses(Vector<ulong> bases, Vector<long> indices) => Compute8BitAddresses(bases, indices);

        /// <summary>
        /// svuint64_t svadrb[_u64base]_[u64]offset(svuint64_t bases, svuint64_t offsets)
        ///   ADR Zresult.D, [Zbases.D, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_BH_3A  ADR <Zd>.<T>, [<Zn>.<T>, <Zm>.<T>{, <mod><amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V4, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V29, REG_V1, REG_V10, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_BH_3B  ADR <Zd>.D, [<Zn>.D, <Zm>.D, SXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V7, REG_V9, 0, INS_OPTS_SCALABLE_D_SXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V12, REG_V3, REG_V5, 2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_BH_3B_A  ADR <Zd>.D, [<Zn>.D, <Zm>.D, UXTW{<amount>}]
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V9, REG_V10, REG_V14, 0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitInsSve_R_R_R_I(INS_sve_adr, EA_SCALABLE, REG_V3, REG_V15, REG_V11, 3, INS_OPTS_SCALABLE_D_UXTW);
        /// </summary>
        public static unsafe Vector<ulong> Compute8BitAddresses(Vector<ulong> bases, Vector<ulong> indices) => Compute8BitAddresses(bases, indices);


        ///  ConditionalExtractAfterLastActiveElement : Conditionally extract element after last

        /// <summary>
        /// svint8_t svclasta[_s8](svbool_t pg, svint8_t fallback, svint8_t data)
        ///   CLASTA Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<sbyte> ConditionalExtractAfterLastActiveElement(Vector<sbyte> mask, Vector<sbyte> defaultValue, Vector<sbyte> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint8_t svclasta[_s8](svbool_t pg, svint8_t fallback, svint8_t data)
        ///   CLASTA Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.B, Pg, Zresult.B, Zdata.B
        /// int8_t svclasta[_n_s8](svbool_t pg, int8_t fallback, svint8_t data)
        ///   CLASTA Wtied, Pg, Wtied, Zdata.B
        ///   CLASTA Btied, Pg, Btied, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe sbyte ConditionalExtractAfterLastActiveElement(Vector<sbyte> mask, sbyte defaultValues, Vector<sbyte> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svint16_t svclasta[_s16](svbool_t pg, svint16_t fallback, svint16_t data)
        ///   CLASTA Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<short> ConditionalExtractAfterLastActiveElement(Vector<short> mask, Vector<short> defaultValue, Vector<short> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint16_t svclasta[_s16](svbool_t pg, svint16_t fallback, svint16_t data)
        ///   CLASTA Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.H, Pg, Zresult.H, Zdata.H
        /// int16_t svclasta[_n_s16](svbool_t pg, int16_t fallback, svint16_t data)
        ///   CLASTA Wtied, Pg, Wtied, Zdata.H
        ///   CLASTA Htied, Pg, Htied, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe short ConditionalExtractAfterLastActiveElement(Vector<short> mask, short defaultValues, Vector<short> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svint32_t svclasta[_s32](svbool_t pg, svint32_t fallback, svint32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<int> ConditionalExtractAfterLastActiveElement(Vector<int> mask, Vector<int> defaultValue, Vector<int> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint32_t svclasta[_s32](svbool_t pg, svint32_t fallback, svint32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        /// int32_t svclasta[_n_s32](svbool_t pg, int32_t fallback, svint32_t data)
        ///   CLASTA Wtied, Pg, Wtied, Zdata.S
        ///   CLASTA Stied, Pg, Stied, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe int ConditionalExtractAfterLastActiveElement(Vector<int> mask, int defaultValues, Vector<int> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svint64_t svclasta[_s64](svbool_t pg, svint64_t fallback, svint64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<long> ConditionalExtractAfterLastActiveElement(Vector<long> mask, Vector<long> defaultValue, Vector<long> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint64_t svclasta[_s64](svbool_t pg, svint64_t fallback, svint64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        /// int64_t svclasta[_n_s64](svbool_t pg, int64_t fallback, svint64_t data)
        ///   CLASTA Xtied, Pg, Xtied, Zdata.D
        ///   CLASTA Dtied, Pg, Dtied, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe long ConditionalExtractAfterLastActiveElement(Vector<long> mask, long defaultValues, Vector<long> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint8_t svclasta[_u8](svbool_t pg, svuint8_t fallback, svuint8_t data)
        ///   CLASTA Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<byte> ConditionalExtractAfterLastActiveElement(Vector<byte> mask, Vector<byte> defaultValue, Vector<byte> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint8_t svclasta[_u8](svbool_t pg, svuint8_t fallback, svuint8_t data)
        ///   CLASTA Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.B, Pg, Zresult.B, Zdata.B
        /// uint8_t svclasta[_n_u8](svbool_t pg, uint8_t fallback, svuint8_t data)
        ///   CLASTA Wtied, Pg, Wtied, Zdata.B
        ///   CLASTA Btied, Pg, Btied, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe byte ConditionalExtractAfterLastActiveElement(Vector<byte> mask, byte defaultValues, Vector<byte> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint16_t svclasta[_u16](svbool_t pg, svuint16_t fallback, svuint16_t data)
        ///   CLASTA Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ushort> ConditionalExtractAfterLastActiveElement(Vector<ushort> mask, Vector<ushort> defaultValue, Vector<ushort> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint16_t svclasta[_u16](svbool_t pg, svuint16_t fallback, svuint16_t data)
        ///   CLASTA Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.H, Pg, Zresult.H, Zdata.H
        /// uint16_t svclasta[_n_u16](svbool_t pg, uint16_t fallback, svuint16_t data)
        ///   CLASTA Wtied, Pg, Wtied, Zdata.H
        ///   CLASTA Htied, Pg, Htied, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe ushort ConditionalExtractAfterLastActiveElement(Vector<ushort> mask, ushort defaultValues, Vector<ushort> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint32_t svclasta[_u32](svbool_t pg, svuint32_t fallback, svuint32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<uint> ConditionalExtractAfterLastActiveElement(Vector<uint> mask, Vector<uint> defaultValue, Vector<uint> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint32_t svclasta[_u32](svbool_t pg, svuint32_t fallback, svuint32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        /// uint32_t svclasta[_n_u32](svbool_t pg, uint32_t fallback, svuint32_t data)
        ///   CLASTA Wtied, Pg, Wtied, Zdata.S
        ///   CLASTA Stied, Pg, Stied, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe uint ConditionalExtractAfterLastActiveElement(Vector<uint> mask, uint defaultValues, Vector<uint> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint64_t svclasta[_u64](svbool_t pg, svuint64_t fallback, svuint64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ulong> ConditionalExtractAfterLastActiveElement(Vector<ulong> mask, Vector<ulong> defaultValue, Vector<ulong> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint64_t svclasta[_u64](svbool_t pg, svuint64_t fallback, svuint64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        /// uint64_t svclasta[_n_u64](svbool_t pg, uint64_t fallback, svuint64_t data)
        ///   CLASTA Xtied, Pg, Xtied, Zdata.D
        ///   CLASTA Dtied, Pg, Dtied, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe ulong ConditionalExtractAfterLastActiveElement(Vector<ulong> mask, ulong defaultValues, Vector<ulong> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svfloat32_t svclasta[_f32](svbool_t pg, svfloat32_t fallback, svfloat32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<float> ConditionalExtractAfterLastActiveElement(Vector<float> mask, Vector<float> defaultValue, Vector<float> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svfloat32_t svclasta[_f32](svbool_t pg, svfloat32_t fallback, svfloat32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        /// float32_t svclasta[_n_f32](svbool_t pg, float32_t fallback, svfloat32_t data)
        ///   CLASTA Wtied, Pg, Wtied, Zdata.S
        ///   CLASTA Stied, Pg, Stied, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe float ConditionalExtractAfterLastActiveElement(Vector<float> mask, float defaultValues, Vector<float> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svfloat64_t svclasta[_f64](svbool_t pg, svfloat64_t fallback, svfloat64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<double> ConditionalExtractAfterLastActiveElement(Vector<double> mask, Vector<double> defaultValue, Vector<double> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svfloat64_t svclasta[_f64](svbool_t pg, svfloat64_t fallback, svfloat64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        /// float64_t svclasta[_n_f64](svbool_t pg, float64_t fallback, svfloat64_t data)
        ///   CLASTA Xtied, Pg, Xtied, Zdata.D
        ///   CLASTA Dtied, Pg, Dtied, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe double ConditionalExtractAfterLastActiveElement(Vector<double> mask, double defaultValues, Vector<double> data) => ConditionalExtractAfterLastActiveElement(mask, defaultValues, data);


        ///  ConditionalExtractAfterLastActiveElementAndReplicate : Conditionally extract element after last

        /// <summary>
        /// svint8_t svclasta[_s8](svbool_t pg, svint8_t fallback, svint8_t data)
        ///   CLASTA Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<sbyte> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<sbyte> mask, Vector<sbyte> defaultScalar, Vector<sbyte> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svint16_t svclasta[_s16](svbool_t pg, svint16_t fallback, svint16_t data)
        ///   CLASTA Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<short> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<short> mask, Vector<short> defaultScalar, Vector<short> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svint32_t svclasta[_s32](svbool_t pg, svint32_t fallback, svint32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<int> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<int> mask, Vector<int> defaultScalar, Vector<int> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svint64_t svclasta[_s64](svbool_t pg, svint64_t fallback, svint64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<long> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<long> mask, Vector<long> defaultScalar, Vector<long> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svuint8_t svclasta[_u8](svbool_t pg, svuint8_t fallback, svuint8_t data)
        ///   CLASTA Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<byte> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<byte> mask, Vector<byte> defaultScalar, Vector<byte> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svuint16_t svclasta[_u16](svbool_t pg, svuint16_t fallback, svuint16_t data)
        ///   CLASTA Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ushort> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<ushort> mask, Vector<ushort> defaultScalar, Vector<ushort> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svuint32_t svclasta[_u32](svbool_t pg, svuint32_t fallback, svuint32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<uint> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<uint> mask, Vector<uint> defaultScalar, Vector<uint> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svuint64_t svclasta[_u64](svbool_t pg, svuint64_t fallback, svuint64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ulong> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<ulong> mask, Vector<ulong> defaultScalar, Vector<ulong> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svfloat32_t svclasta[_f32](svbool_t pg, svfloat32_t fallback, svfloat32_t data)
        ///   CLASTA Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<float> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<float> mask, Vector<float> defaultScalar, Vector<float> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);

        /// <summary>
        /// svfloat64_t svclasta[_f64](svbool_t pg, svfloat64_t fallback, svfloat64_t data)
        ///   CLASTA Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTA Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTA <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_SCALABLE, REG_V31, REG_P7, REG_V31, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_CN_3A  CLASTA <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_2BYTE, REG_V12, REG_P1, REG_V15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTA <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R0, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clasta, EA_4BYTE, REG_R1, REG_P2, REG_V3, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<double> ConditionalExtractAfterLastActiveElementAndReplicate(Vector<double> mask, Vector<double> defaultScalar, Vector<double> data) => ConditionalExtractAfterLastActiveElementAndReplicate(mask, defaultScalar, data);


        ///  ConditionalExtractLastActiveElement : Conditionally extract last element

        /// <summary>
        /// svint8_t svclastb[_s8](svbool_t pg, svint8_t fallback, svint8_t data)
        ///   CLASTB Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<sbyte> ConditionalExtractLastActiveElement(Vector<sbyte> mask, Vector<sbyte> defaultValue, Vector<sbyte> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint8_t svclastb[_s8](svbool_t pg, svint8_t fallback, svint8_t data)
        ///   CLASTB Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.B, Pg, Zresult.B, Zdata.B
        /// int8_t svclastb[_n_s8](svbool_t pg, int8_t fallback, svint8_t data)
        ///   CLASTB Wtied, Pg, Wtied, Zdata.B
        ///   CLASTB Btied, Pg, Btied, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe sbyte ConditionalExtractLastActiveElement(Vector<sbyte> mask, sbyte defaultValues, Vector<sbyte> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svint16_t svclastb[_s16](svbool_t pg, svint16_t fallback, svint16_t data)
        ///   CLASTB Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> ConditionalExtractLastActiveElement(Vector<short> mask, Vector<short> defaultValue, Vector<short> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint16_t svclastb[_s16](svbool_t pg, svint16_t fallback, svint16_t data)
        ///   CLASTB Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.H, Pg, Zresult.H, Zdata.H
        /// int16_t svclastb[_n_s16](svbool_t pg, int16_t fallback, svint16_t data)
        ///   CLASTB Wtied, Pg, Wtied, Zdata.H
        ///   CLASTB Htied, Pg, Htied, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe short ConditionalExtractLastActiveElement(Vector<short> mask, short defaultValues, Vector<short> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svint32_t svclastb[_s32](svbool_t pg, svint32_t fallback, svint32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> ConditionalExtractLastActiveElement(Vector<int> mask, Vector<int> defaultValue, Vector<int> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint32_t svclastb[_s32](svbool_t pg, svint32_t fallback, svint32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        /// int32_t svclastb[_n_s32](svbool_t pg, int32_t fallback, svint32_t data)
        ///   CLASTB Wtied, Pg, Wtied, Zdata.S
        ///   CLASTB Stied, Pg, Stied, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int ConditionalExtractLastActiveElement(Vector<int> mask, int defaultValues, Vector<int> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svint64_t svclastb[_s64](svbool_t pg, svint64_t fallback, svint64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> ConditionalExtractLastActiveElement(Vector<long> mask, Vector<long> defaultValue, Vector<long> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svint64_t svclastb[_s64](svbool_t pg, svint64_t fallback, svint64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        /// int64_t svclastb[_n_s64](svbool_t pg, int64_t fallback, svint64_t data)
        ///   CLASTB Xtied, Pg, Xtied, Zdata.D
        ///   CLASTB Dtied, Pg, Dtied, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long ConditionalExtractLastActiveElement(Vector<long> mask, long defaultValues, Vector<long> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint8_t svclastb[_u8](svbool_t pg, svuint8_t fallback, svuint8_t data)
        ///   CLASTB Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<byte> ConditionalExtractLastActiveElement(Vector<byte> mask, Vector<byte> defaultValue, Vector<byte> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint8_t svclastb[_u8](svbool_t pg, svuint8_t fallback, svuint8_t data)
        ///   CLASTB Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.B, Pg, Zresult.B, Zdata.B
        /// uint8_t svclastb[_n_u8](svbool_t pg, uint8_t fallback, svuint8_t data)
        ///   CLASTB Wtied, Pg, Wtied, Zdata.B
        ///   CLASTB Btied, Pg, Btied, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe byte ConditionalExtractLastActiveElement(Vector<byte> mask, byte defaultValues, Vector<byte> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint16_t svclastb[_u16](svbool_t pg, svuint16_t fallback, svuint16_t data)
        ///   CLASTB Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> ConditionalExtractLastActiveElement(Vector<ushort> mask, Vector<ushort> defaultValue, Vector<ushort> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint16_t svclastb[_u16](svbool_t pg, svuint16_t fallback, svuint16_t data)
        ///   CLASTB Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.H, Pg, Zresult.H, Zdata.H
        /// uint16_t svclastb[_n_u16](svbool_t pg, uint16_t fallback, svuint16_t data)
        ///   CLASTB Wtied, Pg, Wtied, Zdata.H
        ///   CLASTB Htied, Pg, Htied, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ushort ConditionalExtractLastActiveElement(Vector<ushort> mask, ushort defaultValues, Vector<ushort> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint32_t svclastb[_u32](svbool_t pg, svuint32_t fallback, svuint32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> ConditionalExtractLastActiveElement(Vector<uint> mask, Vector<uint> defaultValue, Vector<uint> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint32_t svclastb[_u32](svbool_t pg, svuint32_t fallback, svuint32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        /// uint32_t svclastb[_n_u32](svbool_t pg, uint32_t fallback, svuint32_t data)
        ///   CLASTB Wtied, Pg, Wtied, Zdata.S
        ///   CLASTB Stied, Pg, Stied, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint ConditionalExtractLastActiveElement(Vector<uint> mask, uint defaultValues, Vector<uint> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svuint64_t svclastb[_u64](svbool_t pg, svuint64_t fallback, svuint64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> ConditionalExtractLastActiveElement(Vector<ulong> mask, Vector<ulong> defaultValue, Vector<ulong> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svuint64_t svclastb[_u64](svbool_t pg, svuint64_t fallback, svuint64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        /// uint64_t svclastb[_n_u64](svbool_t pg, uint64_t fallback, svuint64_t data)
        ///   CLASTB Xtied, Pg, Xtied, Zdata.D
        ///   CLASTB Dtied, Pg, Dtied, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong ConditionalExtractLastActiveElement(Vector<ulong> mask, ulong defaultValues, Vector<ulong> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svfloat32_t svclastb[_f32](svbool_t pg, svfloat32_t fallback, svfloat32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> ConditionalExtractLastActiveElement(Vector<float> mask, Vector<float> defaultValue, Vector<float> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svfloat32_t svclastb[_f32](svbool_t pg, svfloat32_t fallback, svfloat32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        /// float32_t svclastb[_n_f32](svbool_t pg, float32_t fallback, svfloat32_t data)
        ///   CLASTB Wtied, Pg, Wtied, Zdata.S
        ///   CLASTB Stied, Pg, Stied, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe float ConditionalExtractLastActiveElement(Vector<float> mask, float defaultValues, Vector<float> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);

        /// <summary>
        /// svfloat64_t svclastb[_f64](svbool_t pg, svfloat64_t fallback, svfloat64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> ConditionalExtractLastActiveElement(Vector<double> mask, Vector<double> defaultValue, Vector<double> data) => ConditionalExtractLastActiveElement(mask, defaultValue, data);

        /// <summary>
        /// svfloat64_t svclastb[_f64](svbool_t pg, svfloat64_t fallback, svfloat64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        /// float64_t svclastb[_n_f64](svbool_t pg, float64_t fallback, svfloat64_t data)
        ///   CLASTB Xtied, Pg, Xtied, Zdata.D
        ///   CLASTB Dtied, Pg, Dtied, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe double ConditionalExtractLastActiveElement(Vector<double> mask, double defaultValues, Vector<double> data) => ConditionalExtractLastActiveElement(mask, defaultValues, data);


        ///  ConditionalExtractLastActiveElementAndReplicate : Conditionally extract last element

        /// <summary>
        /// svint8_t svclastb[_s8](svbool_t pg, svint8_t fallback, svint8_t data)
        ///   CLASTB Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<sbyte> ConditionalExtractLastActiveElementAndReplicate(Vector<sbyte> mask, Vector<sbyte> fallback, Vector<sbyte> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svint16_t svclastb[_s16](svbool_t pg, svint16_t fallback, svint16_t data)
        ///   CLASTB Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> ConditionalExtractLastActiveElementAndReplicate(Vector<short> mask, Vector<short> fallback, Vector<short> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svint32_t svclastb[_s32](svbool_t pg, svint32_t fallback, svint32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> ConditionalExtractLastActiveElementAndReplicate(Vector<int> mask, Vector<int> fallback, Vector<int> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svint64_t svclastb[_s64](svbool_t pg, svint64_t fallback, svint64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> ConditionalExtractLastActiveElementAndReplicate(Vector<long> mask, Vector<long> fallback, Vector<long> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svuint8_t svclastb[_u8](svbool_t pg, svuint8_t fallback, svuint8_t data)
        ///   CLASTB Ztied.B, Pg, Ztied.B, Zdata.B
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.B, Pg, Zresult.B, Zdata.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<byte> ConditionalExtractLastActiveElementAndReplicate(Vector<byte> mask, Vector<byte> fallback, Vector<byte> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svuint16_t svclastb[_u16](svbool_t pg, svuint16_t fallback, svuint16_t data)
        ///   CLASTB Ztied.H, Pg, Ztied.H, Zdata.H
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.H, Pg, Zresult.H, Zdata.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> ConditionalExtractLastActiveElementAndReplicate(Vector<ushort> mask, Vector<ushort> fallback, Vector<ushort> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svuint32_t svclastb[_u32](svbool_t pg, svuint32_t fallback, svuint32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> ConditionalExtractLastActiveElementAndReplicate(Vector<uint> mask, Vector<uint> fallback, Vector<uint> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svuint64_t svclastb[_u64](svbool_t pg, svuint64_t fallback, svuint64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> ConditionalExtractLastActiveElementAndReplicate(Vector<ulong> mask, Vector<ulong> fallback, Vector<ulong> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svfloat32_t svclastb[_f32](svbool_t pg, svfloat32_t fallback, svfloat32_t data)
        ///   CLASTB Ztied.S, Pg, Ztied.S, Zdata.S
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.S, Pg, Zresult.S, Zdata.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> ConditionalExtractLastActiveElementAndReplicate(Vector<float> mask, Vector<float> fallback, Vector<float> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);

        /// <summary>
        /// svfloat64_t svclastb[_f64](svbool_t pg, svfloat64_t fallback, svfloat64_t data)
        ///   CLASTB Ztied.D, Pg, Ztied.D, Zdata.D
        ///   MOVPRFX Zresult, Zfallback; CLASTB Zresult.D, Pg, Zresult.D, Zdata.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CM_3A  CLASTB <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_SCALABLE, REG_V30, REG_P6, REG_V30, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CN_3A  CLASTB <V><dn>, <Pg>, <V><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_V13, REG_P2, REG_V16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_V14, REG_P0, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CO_3A  CLASTB <R><dn>, <Pg>, <R><dn>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_4BYTE, REG_R23, REG_P5, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_clastb, EA_8BYTE, REG_R3, REG_P6, REG_V9, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> ConditionalExtractLastActiveElementAndReplicate(Vector<double> mask, Vector<double> fallback, Vector<double> data) => ConditionalExtractLastActiveElementAndReplicate(mask, fallback, data);


        ///  ConditionalSelect : Conditionally select elements

        /// <summary>
        /// svint8_t svsel[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SEL Zresult.B, Pg, Zop1.B, Zop2.B
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<sbyte> ConditionalSelect(Vector<sbyte> mask, Vector<sbyte> left, Vector<sbyte> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svint16_t svsel[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SEL Zresult.H, Pg, Zop1.H, Zop2.H
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<short> ConditionalSelect(Vector<short> mask, Vector<short> left, Vector<short> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svint32_t svsel[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SEL Zresult.S, Pg, Zop1.S, Zop2.S
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<int> ConditionalSelect(Vector<int> mask, Vector<int> left, Vector<int> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svint64_t svsel[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SEL Zresult.D, Pg, Zop1.D, Zop2.D
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<long> ConditionalSelect(Vector<long> mask, Vector<long> left, Vector<long> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svuint8_t svsel[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   SEL Zresult.B, Pg, Zop1.B, Zop2.B
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<byte> ConditionalSelect(Vector<byte> mask, Vector<byte> left, Vector<byte> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svuint16_t svsel[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   SEL Zresult.H, Pg, Zop1.H, Zop2.H
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<ushort> ConditionalSelect(Vector<ushort> mask, Vector<ushort> left, Vector<ushort> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svuint32_t svsel[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   SEL Zresult.S, Pg, Zop1.S, Zop2.S
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<uint> ConditionalSelect(Vector<uint> mask, Vector<uint> left, Vector<uint> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svuint64_t svsel[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   SEL Zresult.D, Pg, Zop1.D, Zop2.D
        /// svbool_t svsel[_b](svbool_t pg, svbool_t op1, svbool_t op2)
        ///   SEL Presult.B, Pg, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<ulong> ConditionalSelect(Vector<ulong> mask, Vector<ulong> left, Vector<ulong> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svfloat32_t svsel[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   SEL Zresult.S, Pg, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<float> ConditionalSelect(Vector<float> mask, Vector<float> left, Vector<float> right) => ConditionalSelect(mask, left, right);

        /// <summary>
        /// svfloat64_t svsel[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   SEL Zresult.D, Pg, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_P4, REG_P6, REG_P13, REG_P10, INS_OPTS_SCALABLE_B); /* SEL <Pd>.B, <Pg>, <Pn>.B, <Pm>.B */
        ///    IF_SVE_CW_4A  SEL <Zd>.<T>, <Pv>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V29, REG_P15, REG_V28, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_sel, EA_SCALABLE, REG_V5, REG_P13, REG_V27, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<double> ConditionalSelect(Vector<double> mask, Vector<double> left, Vector<double> right) => ConditionalSelect(mask, left, right);


        ///  ConvertToDouble : Floating-point convert

        /// <summary>
        /// svfloat64_t svcvt_f64[_s32]_m(svfloat64_t inactive, svbool_t pg, svint32_t op)
        ///   SCVTF Ztied.D, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; SCVTF Zresult.D, Pg/M, Zop.S
        /// svfloat64_t svcvt_f64[_s32]_x(svbool_t pg, svint32_t op)
        ///   SCVTF Ztied.D, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; SCVTF Zresult.D, Pg/M, Zop.S
        /// svfloat64_t svcvt_f64[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; SCVTF Zresult.D, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_scvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ConvertToDouble(Vector<int> value) => ConvertToDouble(value);

        /// <summary>
        /// svfloat64_t svcvt_f64[_s64]_m(svfloat64_t inactive, svbool_t pg, svint64_t op)
        ///   SCVTF Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; SCVTF Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svcvt_f64[_s64]_x(svbool_t pg, svint64_t op)
        ///   SCVTF Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; SCVTF Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svcvt_f64[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; SCVTF Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_scvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ConvertToDouble(Vector<long> value) => ConvertToDouble(value);

        /// <summary>
        /// svfloat64_t svcvt_f64[_u32]_m(svfloat64_t inactive, svbool_t pg, svuint32_t op)
        ///   UCVTF Ztied.D, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; UCVTF Zresult.D, Pg/M, Zop.S
        /// svfloat64_t svcvt_f64[_u32]_x(svbool_t pg, svuint32_t op)
        ///   UCVTF Ztied.D, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; UCVTF Zresult.D, Pg/M, Zop.S
        /// svfloat64_t svcvt_f64[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; UCVTF Zresult.D, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_ucvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ConvertToDouble(Vector<uint> value) => ConvertToDouble(value);

        /// <summary>
        /// svfloat64_t svcvt_f64[_u64]_m(svfloat64_t inactive, svbool_t pg, svuint64_t op)
        ///   UCVTF Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; UCVTF Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svcvt_f64[_u64]_x(svbool_t pg, svuint64_t op)
        ///   UCVTF Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; UCVTF Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svcvt_f64[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; UCVTF Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_ucvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ConvertToDouble(Vector<ulong> value) => ConvertToDouble(value);

        /// <summary>
        /// svfloat64_t svcvt_f64[_f32]_m(svfloat64_t inactive, svbool_t pg, svfloat32_t op)
        ///   FCVT Ztied.D, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FCVT Zresult.D, Pg/M, Zop.S
        /// svfloat64_t svcvt_f64[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FCVT Ztied.D, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FCVT Zresult.D, Pg/M, Zop.S
        /// svfloat64_t svcvt_f64[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVT Zresult.D, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_fcvt - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ConvertToDouble(Vector<float> value) => ConvertToDouble(value);


        ///  ConvertToInt32 : Floating-point convert

        /// <summary>
        /// svint32_t svcvt_s32[_f32]_m(svint32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FCVTZS Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FCVTZS Zresult.S, Pg/M, Zop.S
        /// svint32_t svcvt_s32[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FCVTZS Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FCVTZS Zresult.S, Pg/M, Zop.S
        /// svint32_t svcvt_s32[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FCVTZS Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_fcvtzs - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ConvertToInt32(Vector<float> value) => ConvertToInt32(value);

        /// <summary>
        /// svint32_t svcvt_s32[_f64]_m(svint32_t inactive, svbool_t pg, svfloat64_t op)
        ///   FCVTZS Ztied.S, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FCVTZS Zresult.S, Pg/M, Zop.D
        /// svint32_t svcvt_s32[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FCVTZS Ztied.S, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FCVTZS Zresult.S, Pg/M, Zop.D
        /// svint32_t svcvt_s32[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVTZS Zresult.S, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_fcvtzs - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ConvertToInt32(Vector<double> value) => ConvertToInt32(value);


        ///  ConvertToInt64 : Floating-point convert

        /// <summary>
        /// svint64_t svcvt_s64[_f32]_m(svint64_t inactive, svbool_t pg, svfloat32_t op)
        ///   FCVTZS Ztied.D, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FCVTZS Zresult.D, Pg/M, Zop.S
        /// svint64_t svcvt_s64[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FCVTZS Ztied.D, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FCVTZS Zresult.D, Pg/M, Zop.S
        /// svint64_t svcvt_s64[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVTZS Zresult.D, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_fcvtzs - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ConvertToInt64(Vector<float> value) => ConvertToInt64(value);

        /// <summary>
        /// svint64_t svcvt_s64[_f64]_m(svint64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FCVTZS Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FCVTZS Zresult.D, Pg/M, Zop.D
        /// svint64_t svcvt_s64[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FCVTZS Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FCVTZS Zresult.D, Pg/M, Zop.D
        /// svint64_t svcvt_s64[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVTZS Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_fcvtzs - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ConvertToInt64(Vector<double> value) => ConvertToInt64(value);


        ///  ConvertToSingle : Floating-point convert

        /// <summary>
        /// svfloat32_t svcvt_f32[_s32]_m(svfloat32_t inactive, svbool_t pg, svint32_t op)
        ///   SCVTF Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; SCVTF Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svcvt_f32[_s32]_x(svbool_t pg, svint32_t op)
        ///   SCVTF Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; SCVTF Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svcvt_f32[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; SCVTF Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_scvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ConvertToSingle(Vector<int> value) => ConvertToSingle(value);

        /// <summary>
        /// svfloat32_t svcvt_f32[_s64]_m(svfloat32_t inactive, svbool_t pg, svint64_t op)
        ///   SCVTF Ztied.S, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; SCVTF Zresult.S, Pg/M, Zop.D
        /// svfloat32_t svcvt_f32[_s64]_x(svbool_t pg, svint64_t op)
        ///   SCVTF Ztied.S, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; SCVTF Zresult.S, Pg/M, Zop.D
        /// svfloat32_t svcvt_f32[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; SCVTF Zresult.S, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_scvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ConvertToSingle(Vector<long> value) => ConvertToSingle(value);

        /// <summary>
        /// svfloat32_t svcvt_f32[_u32]_m(svfloat32_t inactive, svbool_t pg, svuint32_t op)
        ///   UCVTF Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; UCVTF Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svcvt_f32[_u32]_x(svbool_t pg, svuint32_t op)
        ///   UCVTF Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; UCVTF Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svcvt_f32[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; UCVTF Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_ucvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ConvertToSingle(Vector<uint> value) => ConvertToSingle(value);

        /// <summary>
        /// svfloat32_t svcvt_f32[_u64]_m(svfloat32_t inactive, svbool_t pg, svuint64_t op)
        ///   UCVTF Ztied.S, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; UCVTF Zresult.S, Pg/M, Zop.D
        /// svfloat32_t svcvt_f32[_u64]_x(svbool_t pg, svuint64_t op)
        ///   UCVTF Ztied.S, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; UCVTF Zresult.S, Pg/M, Zop.D
        /// svfloat32_t svcvt_f32[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; UCVTF Zresult.S, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_ucvtf - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ConvertToSingle(Vector<ulong> value) => ConvertToSingle(value);

        /// <summary>
        /// svfloat32_t svcvt_f32[_f64]_m(svfloat32_t inactive, svbool_t pg, svfloat64_t op)
        ///   FCVT Ztied.S, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FCVT Zresult.S, Pg/M, Zop.D
        /// svfloat32_t svcvt_f32[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FCVT Ztied.S, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FCVT Zresult.S, Pg/M, Zop.D
        /// svfloat32_t svcvt_f32[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVT Zresult.S, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_fcvt - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ConvertToSingle(Vector<double> value) => ConvertToSingle(value);


        ///  ConvertToUInt32 : Floating-point convert

        /// <summary>
        /// svuint32_t svcvt_u32[_f32]_m(svuint32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FCVTZU Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FCVTZU Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcvt_u32[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FCVTZU Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FCVTZU Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcvt_u32[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FCVTZU Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_fcvtzu - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ConvertToUInt32(Vector<float> value) => ConvertToUInt32(value);

        /// <summary>
        /// svuint32_t svcvt_u32[_f64]_m(svuint32_t inactive, svbool_t pg, svfloat64_t op)
        ///   FCVTZU Ztied.S, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FCVTZU Zresult.S, Pg/M, Zop.D
        /// svuint32_t svcvt_u32[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FCVTZU Ztied.S, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FCVTZU Zresult.S, Pg/M, Zop.D
        /// svuint32_t svcvt_u32[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVTZU Zresult.S, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_fcvtzu - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ConvertToUInt32(Vector<double> value) => ConvertToUInt32(value);


        ///  ConvertToUInt64 : Floating-point convert

        /// <summary>
        /// svuint64_t svcvt_u64[_f32]_m(svuint64_t inactive, svbool_t pg, svfloat32_t op)
        ///   FCVTZU Ztied.D, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FCVTZU Zresult.D, Pg/M, Zop.S
        /// svuint64_t svcvt_u64[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FCVTZU Ztied.D, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FCVTZU Zresult.D, Pg/M, Zop.S
        /// svuint64_t svcvt_u64[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVTZU Zresult.D, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///   sve_fcvtzu - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ConvertToUInt64(Vector<float> value) => ConvertToUInt64(value);

        /// <summary>
        /// svuint64_t svcvt_u64[_f64]_m(svuint64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FCVTZU Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FCVTZU Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcvt_u64[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FCVTZU Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FCVTZU Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcvt_u64[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FCVTZU Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///   sve_fcvtzu - not implemented in coreclr
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ConvertToUInt64(Vector<double> value) => ConvertToUInt64(value);


        ///  Count16BitElements : Count the number of 16-bit elements in a vector

        /// <summary>
        /// uint64_t svcnth_pat(enum svpattern pattern)
        ///   CNTH Xresult, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_BL_1A  CNTH <Xd>{, <pattern>{, MUL #<imm>}}
        ///        theEmitter->emitIns_R_PATTERN_I(INS_sve_cnth, EA_8BYTE, REG_R12, SVE_PATTERN_VL7, 5);
        ///        theEmitter->emitIns_R_PATTERN_I(INS_sve_cnth, EA_8BYTE, REG_R5, SVE_PATTERN_ALL, 13);
        /// </summary>
        public static unsafe ulong Count16BitElements([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => Count16BitElements(pattern);


        ///  Count32BitElements : Count the number of 32-bit elements in a vector

        /// <summary>
        /// uint64_t svcntw_pat(enum svpattern pattern)
        ///   CNTW Xresult, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_BL_1A  CNTW <Xd>{, <pattern>{, MUL #<imm>}}
        ///        theEmitter->emitIns_R_PATTERN_I(INS_sve_cntw, EA_8BYTE, REG_R23, SVE_PATTERN_VL256, 7);
        /// </summary>
        public static unsafe ulong Count32BitElements([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => Count32BitElements(pattern);


        ///  Count64BitElements : Count the number of 64-bit elements in a vector

        /// <summary>
        /// uint64_t svcntd_pat(enum svpattern pattern)
        ///   CNTD Xresult, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_BL_1A  CNTD <Xd>{, <pattern>{, MUL #<imm>}}
        ///        theEmitter->emitIns_R_PATTERN_I(INS_sve_cntd, EA_8BYTE, REG_R30, SVE_PATTERN_VL1, 16);
        ///        theEmitter->emitIns_R_PATTERN_I(INS_sve_cntd, EA_8BYTE, REG_R15, SVE_PATTERN_MUL3, 10);
        /// </summary>
        public static unsafe ulong Count64BitElements([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => Count64BitElements(pattern);


        ///  Count8BitElements : Count the number of 8-bit elements in a vector

        /// <summary>
        /// uint64_t svcntb_pat(enum svpattern pattern)
        ///   CNTB Xresult, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_BL_1A  CNTB <Xd>{, <pattern>{, MUL #<imm>}}
        ///        theEmitter->emitIns_R_PATTERN_I(INS_sve_cntb, EA_8BYTE, REG_R0, SVE_PATTERN_POW2, 1);
        ///        theEmitter->emitIns_R_PATTERN_I(INS_sve_cntb, EA_8BYTE, REG_R21, SVE_PATTERN_MUL4, 8);
        /// </summary>
        public static unsafe ulong Count8BitElements([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => Count8BitElements(pattern);



        ///  CreateBreakAfterMask : Break after first true condition

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CreateBreakAfterMask(Vector<sbyte> totalMask, Vector<sbyte> fromMask) => CreateBreakAfterMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CreateBreakAfterMask(Vector<short> totalMask, Vector<short> fromMask) => CreateBreakAfterMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CreateBreakAfterMask(Vector<int> totalMask, Vector<int> fromMask) => CreateBreakAfterMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CreateBreakAfterMask(Vector<long> totalMask, Vector<long> fromMask) => CreateBreakAfterMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CreateBreakAfterMask(Vector<byte> totalMask, Vector<byte> fromMask) => CreateBreakAfterMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CreateBreakAfterMask(Vector<ushort> totalMask, Vector<ushort> fromMask) => CreateBreakAfterMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CreateBreakAfterMask(Vector<uint> totalMask, Vector<uint> fromMask) => CreateBreakAfterMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrka[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKA Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrka[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKA Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKA <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brka, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CreateBreakAfterMask(Vector<ulong> totalMask, Vector<ulong> fromMask) => CreateBreakAfterMask(totalMask, fromMask);


        ///  CreateBreakAfterPropagateMask : Break after first true condition, propagating from previous partition

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<sbyte> CreateBreakAfterPropagateMask(Vector<sbyte> mask, Vector<sbyte> left, Vector<sbyte> right) => CreateBreakAfterPropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<short> CreateBreakAfterPropagateMask(Vector<short> mask, Vector<short> left, Vector<short> right) => CreateBreakAfterPropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<int> CreateBreakAfterPropagateMask(Vector<int> mask, Vector<int> left, Vector<int> right) => CreateBreakAfterPropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<long> CreateBreakAfterPropagateMask(Vector<long> mask, Vector<long> left, Vector<long> right) => CreateBreakAfterPropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> CreateBreakAfterPropagateMask(Vector<byte> mask, Vector<byte> left, Vector<byte> right) => CreateBreakAfterPropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ushort> CreateBreakAfterPropagateMask(Vector<ushort> mask, Vector<ushort> left, Vector<ushort> right) => CreateBreakAfterPropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<uint> CreateBreakAfterPropagateMask(Vector<uint> mask, Vector<uint> left, Vector<uint> right) => CreateBreakAfterPropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpa[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPA Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPA <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpa, EA_SCALABLE, REG_P0, REG_P1, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ulong> CreateBreakAfterPropagateMask(Vector<ulong> mask, Vector<ulong> left, Vector<ulong> right) => CreateBreakAfterPropagateMask(mask, left, right);


        ///  CreateBreakBeforeMask : Break before first true condition

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CreateBreakBeforeMask(Vector<sbyte> totalMask, Vector<sbyte> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CreateBreakBeforeMask(Vector<short> totalMask, Vector<short> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CreateBreakBeforeMask(Vector<int> totalMask, Vector<int> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CreateBreakBeforeMask(Vector<long> totalMask, Vector<long> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CreateBreakBeforeMask(Vector<byte> totalMask, Vector<byte> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CreateBreakBeforeMask(Vector<ushort> totalMask, Vector<ushort> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CreateBreakBeforeMask(Vector<uint> totalMask, Vector<uint> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkb[_b]_m(svbool_t inactive, svbool_t pg, svbool_t op)
        ///   BRKB Ptied.B, Pg/M, Pop.B
        /// svbool_t svbrkb[_b]_z(svbool_t pg, svbool_t op)
        ///   BRKB Presult.B, Pg/Z, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DB_3A  BRKB <Pd>.B, <Pg>/<ZM>, <Pn>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkb, EA_SCALABLE, REG_P2, REG_P9, REG_P14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_PREDICATE_MERGE);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CreateBreakBeforeMask(Vector<ulong> totalMask, Vector<ulong> fromMask) => CreateBreakBeforeMask(totalMask, fromMask);


        ///  CreateBreakBeforePropagateMask : Break before first true condition, propagating from previous partition

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<sbyte> CreateBreakBeforePropagateMask(Vector<sbyte> mask, Vector<sbyte> left, Vector<sbyte> right) => CreateBreakBeforePropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<short> CreateBreakBeforePropagateMask(Vector<short> mask, Vector<short> left, Vector<short> right) => CreateBreakBeforePropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<int> CreateBreakBeforePropagateMask(Vector<int> mask, Vector<int> left, Vector<int> right) => CreateBreakBeforePropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<long> CreateBreakBeforePropagateMask(Vector<long> mask, Vector<long> left, Vector<long> right) => CreateBreakBeforePropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> CreateBreakBeforePropagateMask(Vector<byte> mask, Vector<byte> left, Vector<byte> right) => CreateBreakBeforePropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ushort> CreateBreakBeforePropagateMask(Vector<ushort> mask, Vector<ushort> left, Vector<ushort> right) => CreateBreakBeforePropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<uint> CreateBreakBeforePropagateMask(Vector<uint> mask, Vector<uint> left, Vector<uint> right) => CreateBreakBeforePropagateMask(mask, left, right);

        /// <summary>
        /// svbool_t svbrkpb[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKPB Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DA_4A  BRKPB <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_brkpb, EA_SCALABLE, REG_P7, REG_P8, REG_P11, REG_P13, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ulong> CreateBreakBeforePropagateMask(Vector<ulong> mask, Vector<ulong> left, Vector<ulong> right) => CreateBreakBeforePropagateMask(mask, left, right);


        ///  CreateBreakPropagateMask : Propagate break to next partition

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> CreateBreakPropagateMask(Vector<sbyte> totalMask, Vector<sbyte> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> CreateBreakPropagateMask(Vector<short> totalMask, Vector<short> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> CreateBreakPropagateMask(Vector<int> totalMask, Vector<int> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> CreateBreakPropagateMask(Vector<long> totalMask, Vector<long> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> CreateBreakPropagateMask(Vector<byte> totalMask, Vector<byte> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> CreateBreakPropagateMask(Vector<ushort> totalMask, Vector<ushort> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> CreateBreakPropagateMask(Vector<uint> totalMask, Vector<uint> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);

        /// <summary>
        /// svbool_t svbrkn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   BRKN Ptied2.B, Pg/Z, Pop1.B, Ptied2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DC_3A  BRKN <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B
        ///        theEmitter->emitIns_R_R_R(INS_sve_brkn, EA_SCALABLE, REG_P0, REG_P8, REG_P15, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> CreateBreakPropagateMask(Vector<ulong> totalMask, Vector<ulong> fromMask) => CreateBreakPropagateMask(totalMask, fromMask);


        ///  CreateFalseMaskByte : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<byte> CreateFalseMaskByte() => CreateFalseMaskByte();


        ///  CreateFalseMaskDouble : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<double> CreateFalseMaskDouble() => CreateFalseMaskDouble();


        ///  CreateFalseMaskInt16 : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<short> CreateFalseMaskInt16() => CreateFalseMaskInt16();


        ///  CreateFalseMaskInt32 : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<int> CreateFalseMaskInt32() => CreateFalseMaskInt32();


        ///  CreateFalseMaskInt64 : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<long> CreateFalseMaskInt64() => CreateFalseMaskInt64();


        ///  CreateFalseMaskSByte : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<sbyte> CreateFalseMaskSByte() => CreateFalseMaskSByte();


        ///  CreateFalseMaskSingle : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<float> CreateFalseMaskSingle() => CreateFalseMaskSingle();


        ///  CreateFalseMaskUInt16 : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<ushort> CreateFalseMaskUInt16() => CreateFalseMaskUInt16();


        ///  CreateFalseMaskUInt32 : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<uint> CreateFalseMaskUInt32() => CreateFalseMaskUInt32();


        ///  CreateFalseMaskUInt64 : Set all predicate elements to false

        /// <summary>
        /// svbool_t svpfalse[_b]()
        ///   PFALSE Presult.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DJ_1A  PFALSE <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_pfalse, EA_SCALABLE, REG_P13);
        /// </summary>
        public static unsafe Vector<ulong> CreateFalseMaskUInt64() => CreateFalseMaskUInt64();


        ///  CreateMaskForFirstActiveElement : Set the first active predicate element to true

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<sbyte> CreateMaskForFirstActiveElement(Vector<sbyte> totalMask, Vector<sbyte> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<short> CreateMaskForFirstActiveElement(Vector<short> totalMask, Vector<short> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<int> CreateMaskForFirstActiveElement(Vector<int> totalMask, Vector<int> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<long> CreateMaskForFirstActiveElement(Vector<long> totalMask, Vector<long> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> CreateMaskForFirstActiveElement(Vector<byte> totalMask, Vector<byte> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ushort> CreateMaskForFirstActiveElement(Vector<ushort> totalMask, Vector<ushort> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<uint> CreateMaskForFirstActiveElement(Vector<uint> totalMask, Vector<uint> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpfirst[_b](svbool_t pg, svbool_t op)
        ///   PFIRST Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DD_2A  PFIRST <Pdn>.B, <Pg>, <Pdn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_pfirst, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ulong> CreateMaskForFirstActiveElement(Vector<ulong> totalMask, Vector<ulong> fromMask) => CreateMaskForFirstActiveElement(totalMask, fromMask);


        ///  CreateMaskForNextActiveElement : Find next active predicate

        /// <summary>
        /// svbool_t svpnext_b8(svbool_t pg, svbool_t op)
        ///   PNEXT Ptied.B, Pg, Ptied.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DF_2A  PNEXT <Pdn>.<T>, <Pv>, <Pdn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_pnext, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> CreateMaskForNextActiveElement(Vector<byte> totalMask, Vector<byte> fromMask) => CreateMaskForNextActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpnext_b16(svbool_t pg, svbool_t op)
        ///   PNEXT Ptied.H, Pg, Ptied.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DF_2A  PNEXT <Pdn>.<T>, <Pv>, <Pdn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_pnext, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ushort> CreateMaskForNextActiveElement(Vector<ushort> totalMask, Vector<ushort> fromMask) => CreateMaskForNextActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpnext_b32(svbool_t pg, svbool_t op)
        ///   PNEXT Ptied.S, Pg, Ptied.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DF_2A  PNEXT <Pdn>.<T>, <Pv>, <Pdn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_pnext, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<uint> CreateMaskForNextActiveElement(Vector<uint> totalMask, Vector<uint> fromMask) => CreateMaskForNextActiveElement(totalMask, fromMask);

        /// <summary>
        /// svbool_t svpnext_b64(svbool_t pg, svbool_t op)
        ///   PNEXT Ptied.D, Pg, Ptied.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DF_2A  PNEXT <Pdn>.<T>, <Pv>, <Pdn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_pnext, EA_SCALABLE, REG_P0, REG_P15, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ulong> CreateMaskForNextActiveElement(Vector<ulong> totalMask, Vector<ulong> fromMask) => CreateMaskForNextActiveElement(totalMask, fromMask);



        ///  CreateTrueMaskByte : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b8(enum svpattern pattern)
        ///   PTRUE Presult.B, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<byte> CreateTrueMaskByte([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskByte(pattern);


        ///  CreateTrueMaskDouble : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b8(enum svpattern pattern)
        ///   PTRUE Presult.B, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> CreateTrueMaskDouble([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskDouble(pattern);


        ///  CreateTrueMaskInt16 : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b8(enum svpattern pattern)
        ///   PTRUE Presult.B, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> CreateTrueMaskInt16([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskInt16(pattern);


        ///  CreateTrueMaskInt32 : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b8(enum svpattern pattern)
        ///   PTRUE Presult.B, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> CreateTrueMaskInt32([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskInt32(pattern);


        ///  CreateTrueMaskInt64 : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b8(enum svpattern pattern)
        ///   PTRUE Presult.B, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> CreateTrueMaskInt64([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskInt64(pattern);


        ///  CreateTrueMaskSByte : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b8(enum svpattern pattern)
        ///   PTRUE Presult.B, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<sbyte> CreateTrueMaskSByte([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskSByte(pattern);


        ///  CreateTrueMaskSingle : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b8(enum svpattern pattern)
        ///   PTRUE Presult.B, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> CreateTrueMaskSingle([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskSingle(pattern);


        ///  CreateTrueMaskUInt16 : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b16(enum svpattern pattern)
        ///   PTRUE Presult.H, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> CreateTrueMaskUInt16([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskUInt16(pattern);


        ///  CreateTrueMaskUInt32 : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b32(enum svpattern pattern)
        ///   PTRUE Presult.S, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> CreateTrueMaskUInt32([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskUInt32(pattern);


        ///  CreateTrueMaskUInt64 : Set predicate elements to true

        /// <summary>
        /// svbool_t svptrue_pat_b64(enum svpattern pattern)
        ///   PTRUE Presult.D, pattern
        ///
        /// codegenarm64test:
        ///    IF_SVE_DE_1A  PTRUE <Pd>.<T>{, <pattern>}
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P0, INS_OPTS_SCALABLE_B, SVE_PATTERN_POW2);
        ///        theEmitter->emitIns_R_PATTERN(INS_sve_ptrue, EA_SCALABLE, REG_P7, INS_OPTS_SCALABLE_H, SVE_PATTERN_MUL3);
        ///    IF_SVE_DZ_1A  PTRUE <PNd>.<T>
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P8, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R(INS_sve_ptrue, EA_SCALABLE, REG_P11, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> CreateTrueMaskUInt64([ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => CreateTrueMaskUInt64(pattern);


        ///  CreateWhileLessThanMask16Bit : While incrementing scalar is less than

        /// <summary>
        /// svbool_t svwhilelt_b16[_s32](int32_t op1, int32_t op2)
        ///   WHILELT Presult.H, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanMask16Bit(int left, int right) => CreateWhileLessThanMask16Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b16[_s64](int64_t op1, int64_t op2)
        ///   WHILELT Presult.H, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanMask16Bit(long left, long right) => CreateWhileLessThanMask16Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b16[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELO Presult.H, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanMask16Bit(uint left, uint right) => CreateWhileLessThanMask16Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b16[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELO Presult.H, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanMask16Bit(ulong left, ulong right) => CreateWhileLessThanMask16Bit(left, right);


        ///  CreateWhileLessThanMask32Bit : While incrementing scalar is less than

        /// <summary>
        /// svbool_t svwhilelt_b32[_s32](int32_t op1, int32_t op2)
        ///   WHILELT Presult.S, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanMask32Bit(int left, int right) => CreateWhileLessThanMask32Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b32[_s64](int64_t op1, int64_t op2)
        ///   WHILELT Presult.S, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanMask32Bit(long left, long right) => CreateWhileLessThanMask32Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b32[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELO Presult.S, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanMask32Bit(uint left, uint right) => CreateWhileLessThanMask32Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b32[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELO Presult.S, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanMask32Bit(ulong left, ulong right) => CreateWhileLessThanMask32Bit(left, right);


        ///  CreateWhileLessThanMask64Bit : While incrementing scalar is less than

        /// <summary>
        /// svbool_t svwhilelt_b64[_s32](int32_t op1, int32_t op2)
        ///   WHILELT Presult.D, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanMask64Bit(int left, int right) => CreateWhileLessThanMask64Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b64[_s64](int64_t op1, int64_t op2)
        ///   WHILELT Presult.D, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanMask64Bit(long left, long right) => CreateWhileLessThanMask64Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b64[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELO Presult.D, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanMask64Bit(uint left, uint right) => CreateWhileLessThanMask64Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b64[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELO Presult.D, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanMask64Bit(ulong left, ulong right) => CreateWhileLessThanMask64Bit(left, right);


        ///  CreateWhileLessThanMask8Bit : While incrementing scalar is less than

        /// <summary>
        /// svbool_t svwhilelt_b8[_s32](int32_t op1, int32_t op2)
        ///   WHILELT Presult.B, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanMask8Bit(int left, int right) => CreateWhileLessThanMask8Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b8[_s64](int64_t op1, int64_t op2)
        ///   WHILELT Presult.B, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELT <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_4BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELT {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P7, REG_R14, REG_R15, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELT <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P14, REG_R12, REG_R13, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelt, EA_8BYTE, REG_P15, REG_R14, REG_R15, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanMask8Bit(long left, long right) => CreateWhileLessThanMask8Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b8[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELO Presult.B, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanMask8Bit(uint left, uint right) => CreateWhileLessThanMask8Bit(left, right);

        /// <summary>
        /// svbool_t svwhilelt_b8[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELO Presult.B, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELO <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_4BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELO {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P5, REG_R10, REG_R11, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELO <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P10, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilelo, EA_8BYTE, REG_P11, REG_R6, REG_R7, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanMask8Bit(ulong left, ulong right) => CreateWhileLessThanMask8Bit(left, right);


        ///  CreateWhileLessThanOrEqualMask16Bit : While incrementing scalar is less than or equal to

        /// <summary>
        /// svbool_t svwhilele_b16[_s32](int32_t op1, int32_t op2)
        ///   WHILELE Presult.H, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanOrEqualMask16Bit(int left, int right) => CreateWhileLessThanOrEqualMask16Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b16[_s64](int64_t op1, int64_t op2)
        ///   WHILELE Presult.H, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanOrEqualMask16Bit(long left, long right) => CreateWhileLessThanOrEqualMask16Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b16[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELS Presult.H, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanOrEqualMask16Bit(uint left, uint right) => CreateWhileLessThanOrEqualMask16Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b16[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELS Presult.H, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ushort> CreateWhileLessThanOrEqualMask16Bit(ulong left, ulong right) => CreateWhileLessThanOrEqualMask16Bit(left, right);


        ///  CreateWhileLessThanOrEqualMask32Bit : While incrementing scalar is less than or equal to

        /// <summary>
        /// svbool_t svwhilele_b32[_s32](int32_t op1, int32_t op2)
        ///   WHILELE Presult.S, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanOrEqualMask32Bit(int left, int right) => CreateWhileLessThanOrEqualMask32Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b32[_s64](int64_t op1, int64_t op2)
        ///   WHILELE Presult.S, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanOrEqualMask32Bit(long left, long right) => CreateWhileLessThanOrEqualMask32Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b32[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELS Presult.S, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanOrEqualMask32Bit(uint left, uint right) => CreateWhileLessThanOrEqualMask32Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b32[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELS Presult.S, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<uint> CreateWhileLessThanOrEqualMask32Bit(ulong left, ulong right) => CreateWhileLessThanOrEqualMask32Bit(left, right);


        ///  CreateWhileLessThanOrEqualMask64Bit : While incrementing scalar is less than or equal to

        /// <summary>
        /// svbool_t svwhilele_b64[_s32](int32_t op1, int32_t op2)
        ///   WHILELE Presult.D, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanOrEqualMask64Bit(int left, int right) => CreateWhileLessThanOrEqualMask64Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b64[_s64](int64_t op1, int64_t op2)
        ///   WHILELE Presult.D, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanOrEqualMask64Bit(long left, long right) => CreateWhileLessThanOrEqualMask64Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b64[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELS Presult.D, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanOrEqualMask64Bit(uint left, uint right) => CreateWhileLessThanOrEqualMask64Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b64[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELS Presult.D, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<ulong> CreateWhileLessThanOrEqualMask64Bit(ulong left, ulong right) => CreateWhileLessThanOrEqualMask64Bit(left, right);


        ///  CreateWhileLessThanOrEqualMask8Bit : While incrementing scalar is less than or equal to

        /// <summary>
        /// svbool_t svwhilele_b8[_s32](int32_t op1, int32_t op2)
        ///   WHILELE Presult.B, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanOrEqualMask8Bit(int left, int right) => CreateWhileLessThanOrEqualMask8Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b8[_s64](int64_t op1, int64_t op2)
        ///   WHILELE Presult.B, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELE <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_4BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_DX_3A  WHILELE {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P4, REG_R8, REG_R9, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELE <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P8, REG_R0, REG_R1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilele, EA_8BYTE, REG_P9, REG_R2, REG_R3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanOrEqualMask8Bit(long left, long right) => CreateWhileLessThanOrEqualMask8Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b8[_u32](uint32_t op1, uint32_t op2)
        ///   WHILELS Presult.B, Wop1, Wop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanOrEqualMask8Bit(uint left, uint right) => CreateWhileLessThanOrEqualMask8Bit(left, right);

        /// <summary>
        /// svbool_t svwhilele_b8[_u64](uint64_t op1, uint64_t op2)
        ///   WHILELS Presult.B, Xop1, Xop2
        ///
        /// codegenarm64test:
        ///    IF_SVE_DT_3A  WHILELS <Pd>.<T>, <R><n>, <R><m>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_4BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DX_3A  WHILELS {<Pd1>.<T>, <Pd2>.<T>}, <Xn>, <Xm>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P6, REG_R12, REG_R13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_PREDICATE_PAIR);
        ///    IF_SVE_DY_3A  WHILELS <PNd>.<T>, <Xn>, <Xm>, <vl>
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P12, REG_R8, REG_R9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R_R(INS_sve_whilels, EA_8BYTE, REG_P13, REG_R10, REG_R11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe Vector<byte> CreateWhileLessThanOrEqualMask8Bit(ulong left, ulong right) => CreateWhileLessThanOrEqualMask8Bit(left, right);


        ///  Divide : Divide

        /// <summary>
        /// svint32_t svdiv[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SDIV Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svdiv[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SDIV Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   SDIVR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; SDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svdiv[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; SDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; SDIVR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AC_3A  SDIV <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdiv, EA_SCALABLE, REG_V3, REG_P2, REG_V9, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Divide(Vector<int> left, Vector<int> right) => Divide(left, right);

        /// <summary>
        /// svint64_t svdiv[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SDIV Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svdiv[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SDIV Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   SDIVR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; SDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svdiv[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; SDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; SDIVR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AC_3A  SDIV <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdiv, EA_SCALABLE, REG_V3, REG_P2, REG_V9, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Divide(Vector<long> left, Vector<long> right) => Divide(left, right);

        /// <summary>
        /// svuint32_t svdiv[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UDIV Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; UDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svdiv[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UDIV Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   UDIVR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; UDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svdiv[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; UDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; UDIVR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AC_3A  UDIV <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_udiv, EA_SCALABLE, REG_V1, REG_P0, REG_V0, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Divide(Vector<uint> left, Vector<uint> right) => Divide(left, right);

        /// <summary>
        /// svuint64_t svdiv[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UDIV Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; UDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svdiv[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UDIV Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   UDIVR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; UDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svdiv[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; UDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; UDIVR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AC_3A  UDIV <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_udiv, EA_SCALABLE, REG_V1, REG_P0, REG_V0, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Divide(Vector<ulong> left, Vector<ulong> right) => Divide(left, right);

        /// <summary>
        /// svfloat32_t svdiv[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FDIV Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svdiv[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FDIV Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FDIVR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svdiv[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FDIV Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FDIVR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FDIV <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fdiv, EA_SCALABLE, REG_V28, REG_P0, REG_V7, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Divide(Vector<float> left, Vector<float> right) => Divide(left, right);

        /// <summary>
        /// svfloat64_t svdiv[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FDIV Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svdiv[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FDIV Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FDIVR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svdiv[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FDIV Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FDIVR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FDIV <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fdiv, EA_SCALABLE, REG_V28, REG_P0, REG_V7, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Divide(Vector<double> left, Vector<double> right) => Divide(left, right);



        ///  DotProduct : Dot product

        /// <summary>
        /// svint32_t svdot[_s32](svint32_t op1, svint8_t op2, svint8_t op3)
        ///   SDOT Ztied1.S, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult, Zop1; SDOT Zresult.S, Zop2.B, Zop3.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  SDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V1, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  SDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V9, REG_V10, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V11, REG_V12, REG_V5, 1, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  SDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V0, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V2, REG_V3, REG_V5, 1);
        ///    IF_SVE_EF_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<int> DotProduct(Vector<int> addend, Vector<sbyte> left, Vector<sbyte> right) => DotProduct(addend, left, right);

        /// <summary>
        /// svint64_t svdot[_s64](svint64_t op1, svint16_t op2, svint16_t op3)
        ///   SDOT Ztied1.D, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult, Zop1; SDOT Zresult.D, Zop2.H, Zop3.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  SDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V1, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  SDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V9, REG_V10, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V11, REG_V12, REG_V5, 1, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  SDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V0, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V2, REG_V3, REG_V5, 1);
        ///    IF_SVE_EF_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<long> DotProduct(Vector<long> addend, Vector<short> left, Vector<short> right) => DotProduct(addend, left, right);

        /// <summary>
        /// svuint32_t svdot[_u32](svuint32_t op1, svuint8_t op2, svuint8_t op3)
        ///   UDOT Ztied1.S, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult, Zop1; UDOT Zresult.S, Zop2.B, Zop3.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  UDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V5, REG_V6, REG_V2, 2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V7, REG_V8, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  UDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V13, REG_V14, REG_V6, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V15, REG_V16, REG_V7, 3, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  UDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V4, REG_V5, REG_V10, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V15, 1);
        ///    IF_SVE_EF_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<uint> DotProduct(Vector<uint> addend, Vector<byte> left, Vector<byte> right) => DotProduct(addend, left, right);

        /// <summary>
        /// svuint64_t svdot[_u64](svuint64_t op1, svuint16_t op2, svuint16_t op3)
        ///   UDOT Ztied1.D, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult, Zop1; UDOT Zresult.D, Zop2.H, Zop3.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  UDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V5, REG_V6, REG_V2, 2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V7, REG_V8, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  UDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V13, REG_V14, REG_V6, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V15, REG_V16, REG_V7, 3, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  UDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V4, REG_V5, REG_V10, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V15, 1);
        ///    IF_SVE_EF_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ulong> DotProduct(Vector<ulong> addend, Vector<ushort> left, Vector<ushort> right) => DotProduct(addend, left, right);


        ///  DotProductBySelectedScalar : Dot product

        /// <summary>
        /// svint32_t svdot_lane[_s32](svint32_t op1, svint8_t op2, svint8_t op3, uint64_t imm_index)
        ///   SDOT Ztied1.S, Zop2.B, Zop3.B[imm_index]
        ///   MOVPRFX Zresult, Zop1; SDOT Zresult.S, Zop2.B, Zop3.B[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  SDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V1, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  SDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V9, REG_V10, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V11, REG_V12, REG_V5, 1, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  SDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V0, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V2, REG_V3, REG_V5, 1);
        ///    IF_SVE_EF_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<int> DotProductBySelectedScalar(Vector<int> addend, Vector<sbyte> left, Vector<sbyte> right, [ConstantExpected] byte rightIndex) => DotProductBySelectedScalar(addend, left, right, rightIndex);

        /// <summary>
        /// svint64_t svdot_lane[_s64](svint64_t op1, svint16_t op2, svint16_t op3, uint64_t imm_index)
        ///   SDOT Ztied1.D, Zop2.H, Zop3.H[imm_index]
        ///   MOVPRFX Zresult, Zop1; SDOT Zresult.D, Zop2.H, Zop3.H[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  SDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V1, REG_V2, REG_V0, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V3, REG_V4, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  SDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V9, REG_V10, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V11, REG_V12, REG_V5, 1, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  SDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V0, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_sdot, EA_SCALABLE, REG_V2, REG_V3, REG_V5, 1);
        ///    IF_SVE_EF_3A  SDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_sdot, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<long> DotProductBySelectedScalar(Vector<long> addend, Vector<short> left, Vector<short> right, [ConstantExpected] byte rightIndex) => DotProductBySelectedScalar(addend, left, right, rightIndex);

        /// <summary>
        /// svuint32_t svdot_lane[_u32](svuint32_t op1, svuint8_t op2, svuint8_t op3, uint64_t imm_index)
        ///   UDOT Ztied1.S, Zop2.B, Zop3.B[imm_index]
        ///   MOVPRFX Zresult, Zop1; UDOT Zresult.S, Zop2.B, Zop3.B[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  UDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V5, REG_V6, REG_V2, 2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V7, REG_V8, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  UDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V13, REG_V14, REG_V6, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V15, REG_V16, REG_V7, 3, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  UDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V4, REG_V5, REG_V10, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V15, 1);
        ///    IF_SVE_EF_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<uint> DotProductBySelectedScalar(Vector<uint> addend, Vector<byte> left, Vector<byte> right, [ConstantExpected] byte rightIndex) => DotProductBySelectedScalar(addend, left, right, rightIndex);

        /// <summary>
        /// svuint64_t svdot_lane[_u64](svuint64_t op1, svuint16_t op2, svuint16_t op3, uint64_t imm_index)
        ///   UDOT Ztied1.D, Zop2.H, Zop3.H[imm_index]
        ///   MOVPRFX Zresult, Zop1; UDOT Zresult.D, Zop2.H, Zop3.H[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_EH_3A  UDOT <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EG_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V5, REG_V6, REG_V2, 2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V7, REG_V8, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_EY_3A  UDOT <Zda>.S, <Zn>.B, <Zm>.B[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V13, REG_V14, REG_V6, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V15, REG_V16, REG_V7, 3, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_EY_3B  UDOT <Zda>.D, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V4, REG_V5, REG_V10, 0);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_udot, EA_SCALABLE, REG_V6, REG_V7, REG_V15, 1);
        ///    IF_SVE_EF_3A  UDOT <Zda>.S, <Zn>.H, <Zm>.H
        ///        theEmitter->emitIns_R_R_R(INS_sve_udot, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ulong> DotProductBySelectedScalar(Vector<ulong> addend, Vector<ushort> left, Vector<ushort> right, [ConstantExpected] byte rightIndex) => DotProductBySelectedScalar(addend, left, right, rightIndex);


        ///  DuplicateSelectedScalarToVector : Broadcast a scalar value

        /// <summary>
        /// svint8_t svdup_lane[_s8](svint8_t data, uint8_t index)
        ///   DUP Zresult.B, Zdata.B[index]
        ///   TBL Zresult.B, Zdata.B, Zindex.B
        /// svint8_t svdupq_lane[_s8](svint8_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<sbyte> DuplicateSelectedScalarToVector(Vector<sbyte> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svint16_t svdup_lane[_s16](svint16_t data, uint16_t index)
        ///   DUP Zresult.H, Zdata.H[index]
        ///   TBL Zresult.H, Zdata.H, Zindex.H
        /// svint16_t svdupq_lane[_s16](svint16_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<short> DuplicateSelectedScalarToVector(Vector<short> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svint32_t svdup_lane[_s32](svint32_t data, uint32_t index)
        ///   DUP Zresult.S, Zdata.S[index]
        ///   TBL Zresult.S, Zdata.S, Zindex.S
        /// svint32_t svdupq_lane[_s32](svint32_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<int> DuplicateSelectedScalarToVector(Vector<int> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svint64_t svdup_lane[_s64](svint64_t data, uint64_t index)
        ///   DUP Zresult.D, Zdata.D[index]
        ///   TBL Zresult.D, Zdata.D, Zindex.D
        /// svint64_t svdupq_lane[_s64](svint64_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<long> DuplicateSelectedScalarToVector(Vector<long> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svuint8_t svdup_lane[_u8](svuint8_t data, uint8_t index)
        ///   DUP Zresult.B, Zdata.B[index]
        ///   TBL Zresult.B, Zdata.B, Zindex.B
        /// svuint8_t svdupq_lane[_u8](svuint8_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<byte> DuplicateSelectedScalarToVector(Vector<byte> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svuint16_t svdup_lane[_u16](svuint16_t data, uint16_t index)
        ///   DUP Zresult.H, Zdata.H[index]
        ///   TBL Zresult.H, Zdata.H, Zindex.H
        /// svuint16_t svdupq_lane[_u16](svuint16_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<ushort> DuplicateSelectedScalarToVector(Vector<ushort> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svuint32_t svdup_lane[_u32](svuint32_t data, uint32_t index)
        ///   DUP Zresult.S, Zdata.S[index]
        ///   TBL Zresult.S, Zdata.S, Zindex.S
        /// svuint32_t svdupq_lane[_u32](svuint32_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<uint> DuplicateSelectedScalarToVector(Vector<uint> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svuint64_t svdup_lane[_u64](svuint64_t data, uint64_t index)
        ///   DUP Zresult.D, Zdata.D[index]
        ///   TBL Zresult.D, Zdata.D, Zindex.D
        /// svuint64_t svdupq_lane[_u64](svuint64_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<ulong> DuplicateSelectedScalarToVector(Vector<ulong> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svfloat32_t svdup_lane[_f32](svfloat32_t data, uint32_t index)
        ///   DUP Zresult.S, Zdata.S[index]
        ///   TBL Zresult.S, Zdata.S, Zindex.S
        /// svfloat32_t svdupq_lane[_f32](svfloat32_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<float> DuplicateSelectedScalarToVector(Vector<float> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);

        /// <summary>
        /// svfloat64_t svdup_lane[_f64](svfloat64_t data, uint64_t index)
        ///   DUP Zresult.D, Zdata.D[index]
        ///   TBL Zresult.D, Zdata.D, Zindex.D
        /// svfloat64_t svdupq_lane[_f64](svfloat64_t data, uint64_t index)
        ///   DUP Zresult.Q, Zdata.Q[index]
        ///   TBL Zresult.D, Zdata.D, Zindices_d.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_EB_1A  DUP <Zd>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_SHIFT);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_dup, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CB_2A  DUP <Zd>.<T>, <R><n|SP>
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V2, REG_R3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_4BYTE, REG_V1, REG_R5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_dup, EA_8BYTE, REG_V4, REG_SP, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<double> DuplicateSelectedScalarToVector(Vector<double> data, [ConstantExpected] byte index) => DuplicateSelectedScalarToVector(data, index);


        ///  ExtractAfterLastScalar : Extract element after last

        /// <summary>
        /// int8_t svlasta[_s8](svbool_t pg, svint8_t op)
        ///   LASTA Wresult, Pg, Zop.B
        ///   LASTA Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe sbyte ExtractAfterLastScalar(Vector<sbyte> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// int16_t svlasta[_s16](svbool_t pg, svint16_t op)
        ///   LASTA Wresult, Pg, Zop.H
        ///   LASTA Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe short ExtractAfterLastScalar(Vector<short> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// int32_t svlasta[_s32](svbool_t pg, svint32_t op)
        ///   LASTA Wresult, Pg, Zop.S
        ///   LASTA Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe int ExtractAfterLastScalar(Vector<int> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// int64_t svlasta[_s64](svbool_t pg, svint64_t op)
        ///   LASTA Xresult, Pg, Zop.D
        ///   LASTA Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe long ExtractAfterLastScalar(Vector<long> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// uint8_t svlasta[_u8](svbool_t pg, svuint8_t op)
        ///   LASTA Wresult, Pg, Zop.B
        ///   LASTA Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe byte ExtractAfterLastScalar(Vector<byte> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// uint16_t svlasta[_u16](svbool_t pg, svuint16_t op)
        ///   LASTA Wresult, Pg, Zop.H
        ///   LASTA Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe ushort ExtractAfterLastScalar(Vector<ushort> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// uint32_t svlasta[_u32](svbool_t pg, svuint32_t op)
        ///   LASTA Wresult, Pg, Zop.S
        ///   LASTA Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe uint ExtractAfterLastScalar(Vector<uint> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// uint64_t svlasta[_u64](svbool_t pg, svuint64_t op)
        ///   LASTA Xresult, Pg, Zop.D
        ///   LASTA Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe ulong ExtractAfterLastScalar(Vector<ulong> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// float32_t svlasta[_f32](svbool_t pg, svfloat32_t op)
        ///   LASTA Wresult, Pg, Zop.S
        ///   LASTA Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe float ExtractAfterLastScalar(Vector<float> value) => ExtractAfterLastScalar(value);

        /// <summary>
        /// float64_t svlasta[_f64](svbool_t pg, svfloat64_t op)
        ///   LASTA Xresult, Pg, Zop.D
        ///   LASTA Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe double ExtractAfterLastScalar(Vector<double> value) => ExtractAfterLastScalar(value);


        ///  ExtractAfterLastVector : Extract element after last

        /// <summary>
        /// int8_t svlasta[_s8](svbool_t pg, svint8_t op)
        ///   LASTA Wresult, Pg, Zop.B
        ///   LASTA Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ExtractAfterLastVector(Vector<sbyte> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// int16_t svlasta[_s16](svbool_t pg, svint16_t op)
        ///   LASTA Wresult, Pg, Zop.H
        ///   LASTA Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ExtractAfterLastVector(Vector<short> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// int32_t svlasta[_s32](svbool_t pg, svint32_t op)
        ///   LASTA Wresult, Pg, Zop.S
        ///   LASTA Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ExtractAfterLastVector(Vector<int> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// int64_t svlasta[_s64](svbool_t pg, svint64_t op)
        ///   LASTA Xresult, Pg, Zop.D
        ///   LASTA Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ExtractAfterLastVector(Vector<long> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// uint8_t svlasta[_u8](svbool_t pg, svuint8_t op)
        ///   LASTA Wresult, Pg, Zop.B
        ///   LASTA Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> ExtractAfterLastVector(Vector<byte> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// uint16_t svlasta[_u16](svbool_t pg, svuint16_t op)
        ///   LASTA Wresult, Pg, Zop.H
        ///   LASTA Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ExtractAfterLastVector(Vector<ushort> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// uint32_t svlasta[_u32](svbool_t pg, svuint32_t op)
        ///   LASTA Wresult, Pg, Zop.S
        ///   LASTA Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ExtractAfterLastVector(Vector<uint> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// uint64_t svlasta[_u64](svbool_t pg, svuint64_t op)
        ///   LASTA Xresult, Pg, Zop.D
        ///   LASTA Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ExtractAfterLastVector(Vector<ulong> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// float32_t svlasta[_f32](svbool_t pg, svfloat32_t op)
        ///   LASTA Wresult, Pg, Zop.S
        ///   LASTA Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ExtractAfterLastVector(Vector<float> value) => ExtractAfterLastVector(value);

        /// <summary>
        /// float64_t svlasta[_f64](svbool_t pg, svfloat64_t op)
        ///   LASTA Xresult, Pg, Zop.D
        ///   LASTA Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTA <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_1BYTE, REG_V6, REG_P1, REG_V27, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_2BYTE, REG_V5, REG_P2, REG_V26, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTA <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R1, REG_P5, REG_V23, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lasta, EA_4BYTE, REG_R0, REG_P6, REG_V22, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ExtractAfterLastVector(Vector<double> value) => ExtractAfterLastVector(value);


        ///  ExtractLastScalar : Extract last element

        /// <summary>
        /// int8_t svlastb[_s8](svbool_t pg, svint8_t op)
        ///   LASTB Wresult, Pg, Zop.B
        ///   LASTB Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe sbyte ExtractLastScalar(Vector<sbyte> value) => ExtractLastScalar(value);

        /// <summary>
        /// int16_t svlastb[_s16](svbool_t pg, svint16_t op)
        ///   LASTB Wresult, Pg, Zop.H
        ///   LASTB Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe short ExtractLastScalar(Vector<short> value) => ExtractLastScalar(value);

        /// <summary>
        /// int32_t svlastb[_s32](svbool_t pg, svint32_t op)
        ///   LASTB Wresult, Pg, Zop.S
        ///   LASTB Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe int ExtractLastScalar(Vector<int> value) => ExtractLastScalar(value);

        /// <summary>
        /// int64_t svlastb[_s64](svbool_t pg, svint64_t op)
        ///   LASTB Xresult, Pg, Zop.D
        ///   LASTB Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe long ExtractLastScalar(Vector<long> value) => ExtractLastScalar(value);

        /// <summary>
        /// uint8_t svlastb[_u8](svbool_t pg, svuint8_t op)
        ///   LASTB Wresult, Pg, Zop.B
        ///   LASTB Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe byte ExtractLastScalar(Vector<byte> value) => ExtractLastScalar(value);

        /// <summary>
        /// uint16_t svlastb[_u16](svbool_t pg, svuint16_t op)
        ///   LASTB Wresult, Pg, Zop.H
        ///   LASTB Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe ushort ExtractLastScalar(Vector<ushort> value) => ExtractLastScalar(value);

        /// <summary>
        /// uint32_t svlastb[_u32](svbool_t pg, svuint32_t op)
        ///   LASTB Wresult, Pg, Zop.S
        ///   LASTB Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe uint ExtractLastScalar(Vector<uint> value) => ExtractLastScalar(value);

        /// <summary>
        /// uint64_t svlastb[_u64](svbool_t pg, svuint64_t op)
        ///   LASTB Xresult, Pg, Zop.D
        ///   LASTB Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe ulong ExtractLastScalar(Vector<ulong> value) => ExtractLastScalar(value);

        /// <summary>
        /// float32_t svlastb[_f32](svbool_t pg, svfloat32_t op)
        ///   LASTB Wresult, Pg, Zop.S
        ///   LASTB Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe float ExtractLastScalar(Vector<float> value) => ExtractLastScalar(value);

        /// <summary>
        /// float64_t svlastb[_f64](svbool_t pg, svfloat64_t op)
        ///   LASTB Xresult, Pg, Zop.D
        ///   LASTB Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe double ExtractLastScalar(Vector<double> value) => ExtractLastScalar(value);


        ///  ExtractLastVector : Extract last element

        /// <summary>
        /// int8_t svlastb[_s8](svbool_t pg, svint8_t op)
        ///   LASTB Wresult, Pg, Zop.B
        ///   LASTB Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ExtractLastVector(Vector<sbyte> value) => ExtractLastVector(value);

        /// <summary>
        /// int16_t svlastb[_s16](svbool_t pg, svint16_t op)
        ///   LASTB Wresult, Pg, Zop.H
        ///   LASTB Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ExtractLastVector(Vector<short> value) => ExtractLastVector(value);

        /// <summary>
        /// int32_t svlastb[_s32](svbool_t pg, svint32_t op)
        ///   LASTB Wresult, Pg, Zop.S
        ///   LASTB Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ExtractLastVector(Vector<int> value) => ExtractLastVector(value);

        /// <summary>
        /// int64_t svlastb[_s64](svbool_t pg, svint64_t op)
        ///   LASTB Xresult, Pg, Zop.D
        ///   LASTB Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ExtractLastVector(Vector<long> value) => ExtractLastVector(value);

        /// <summary>
        /// uint8_t svlastb[_u8](svbool_t pg, svuint8_t op)
        ///   LASTB Wresult, Pg, Zop.B
        ///   LASTB Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> ExtractLastVector(Vector<byte> value) => ExtractLastVector(value);

        /// <summary>
        /// uint16_t svlastb[_u16](svbool_t pg, svuint16_t op)
        ///   LASTB Wresult, Pg, Zop.H
        ///   LASTB Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ExtractLastVector(Vector<ushort> value) => ExtractLastVector(value);

        /// <summary>
        /// uint32_t svlastb[_u32](svbool_t pg, svuint32_t op)
        ///   LASTB Wresult, Pg, Zop.S
        ///   LASTB Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ExtractLastVector(Vector<uint> value) => ExtractLastVector(value);

        /// <summary>
        /// uint64_t svlastb[_u64](svbool_t pg, svuint64_t op)
        ///   LASTB Xresult, Pg, Zop.D
        ///   LASTB Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ExtractLastVector(Vector<ulong> value) => ExtractLastVector(value);

        /// <summary>
        /// float32_t svlastb[_f32](svbool_t pg, svfloat32_t op)
        ///   LASTB Wresult, Pg, Zop.S
        ///   LASTB Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ExtractLastVector(Vector<float> value) => ExtractLastVector(value);

        /// <summary>
        /// float64_t svlastb[_f64](svbool_t pg, svfloat64_t op)
        ///   LASTB Xresult, Pg, Zop.D
        ///   LASTB Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CR_3A  LASTB <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_V4, REG_P3, REG_V25, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_V3, REG_P4, REG_V24, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_SIMD_SCALAR);
        ///    IF_SVE_CS_3A  LASTB <R><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_4BYTE, REG_R30, REG_P7, REG_V21, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_lastb, EA_8BYTE, REG_R29, REG_P0, REG_V20, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ExtractLastVector(Vector<double> value) => ExtractLastVector(value);


        ///  ExtractVector : Extract vector from pair of vectors

        /// <summary>
        /// svint8_t svext[_s8](svint8_t op1, svint8_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<sbyte> ExtractVector(Vector<sbyte> upper, Vector<sbyte> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svint16_t svext[_s16](svint16_t op1, svint16_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 2
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 2
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<short> ExtractVector(Vector<short> upper, Vector<short> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svint32_t svext[_s32](svint32_t op1, svint32_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 4
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 4
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<int> ExtractVector(Vector<int> upper, Vector<int> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svint64_t svext[_s64](svint64_t op1, svint64_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 8
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 8
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<long> ExtractVector(Vector<long> upper, Vector<long> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svuint8_t svext[_u8](svuint8_t op1, svuint8_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<byte> ExtractVector(Vector<byte> upper, Vector<byte> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svuint16_t svext[_u16](svuint16_t op1, svuint16_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 2
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 2
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ushort> ExtractVector(Vector<ushort> upper, Vector<ushort> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svuint32_t svext[_u32](svuint32_t op1, svuint32_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 4
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 4
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<uint> ExtractVector(Vector<uint> upper, Vector<uint> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svuint64_t svext[_u64](svuint64_t op1, svuint64_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 8
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 8
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ulong> ExtractVector(Vector<ulong> upper, Vector<ulong> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svfloat32_t svext[_f32](svfloat32_t op1, svfloat32_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 4
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 4
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<float> ExtractVector(Vector<float> upper, Vector<float> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);

        /// <summary>
        /// svfloat64_t svext[_f64](svfloat64_t op1, svfloat64_t op2, uint64_t imm3)
        ///   EXT Ztied1.B, Ztied1.B, Zop2.B, #imm3 * 8
        ///   MOVPRFX Zresult, Zop1; EXT Zresult.B, Zresult.B, Zop2.B, #imm3 * 8
        ///
        /// codegenarm64test:
        ///   sve_ext - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<double> ExtractVector(Vector<double> upper, Vector<double> lower, [ConstantExpected] byte index) => ExtractVector(upper, lower, index);


        ///  FloatingPointExponentialAccelerator : Floating-point exponential accelerator

        /// <summary>
        /// svfloat32_t svexpa[_f32](svuint32_t op)
        ///   FEXPA Zresult.S, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BJ_2A  FEXPA <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_fexpa, EA_SCALABLE, REG_V0, REG_V1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_fexpa, EA_SCALABLE, REG_V3, REG_V0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_fexpa, EA_SCALABLE, REG_V1, REG_V0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> FloatingPointExponentialAccelerator(Vector<uint> value) => FloatingPointExponentialAccelerator(value);

        /// <summary>
        /// svfloat64_t svexpa[_f64](svuint64_t op)
        ///   FEXPA Zresult.D, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BJ_2A  FEXPA <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_fexpa, EA_SCALABLE, REG_V0, REG_V1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_fexpa, EA_SCALABLE, REG_V3, REG_V0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_fexpa, EA_SCALABLE, REG_V1, REG_V0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> FloatingPointExponentialAccelerator(Vector<ulong> value) => FloatingPointExponentialAccelerator(value);


        ///  FusedMultiplyAdd : Multiply-add, addend first

        /// <summary>
        /// svfloat32_t svmla[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FMLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; FMLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svmla[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FMLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   FMAD Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   FMAD Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FMLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svmla[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMAD Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; FMAD Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_P0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_GU_3A  FMLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> FusedMultiplyAdd(Vector<float> addend, Vector<float> left, Vector<float> right) => FusedMultiplyAdd(addend, left, right);

        /// <summary>
        /// svfloat64_t svmla[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FMLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; FMLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svmla[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FMLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   FMAD Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   FMAD Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FMLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svmla[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMAD Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; FMAD Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_P0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_GU_3A  FMLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> FusedMultiplyAdd(Vector<double> addend, Vector<double> left, Vector<double> right) => FusedMultiplyAdd(addend, left, right);


        ///  FusedMultiplyAddBySelectedScalar : Multiply-add, addend first

        /// <summary>
        /// svfloat32_t svmla_lane[_f32](svfloat32_t op1, svfloat32_t op2, svfloat32_t op3, uint64_t imm_index)
        ///   FMLA Ztied1.S, Zop2.S, Zop3.S[imm_index]
        ///   MOVPRFX Zresult, Zop1; FMLA Zresult.S, Zop2.S, Zop3.S[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_P0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_GU_3A  FMLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> FusedMultiplyAddBySelectedScalar(Vector<float> addend, Vector<float> left, Vector<float> right, [ConstantExpected] byte rightIndex) => FusedMultiplyAddBySelectedScalar(addend, left, right, rightIndex);

        /// <summary>
        /// svfloat64_t svmla_lane[_f64](svfloat64_t op1, svfloat64_t op2, svfloat64_t op3, uint64_t imm_index)
        ///   FMLA Ztied1.D, Zop2.D, Zop3.D[imm_index]
        ///   MOVPRFX Zresult, Zop1; FMLA Zresult.D, Zop2.D, Zop3.D[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_P0, REG_V1, REG_V2, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_GU_3A  FMLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmla, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> FusedMultiplyAddBySelectedScalar(Vector<double> addend, Vector<double> left, Vector<double> right, [ConstantExpected] byte rightIndex) => FusedMultiplyAddBySelectedScalar(addend, left, right, rightIndex);


        ///  FusedMultiplyAddNegated : Negated multiply-add, addend first

        /// <summary>
        /// svfloat32_t svnmla[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FNMLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; FNMLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svnmla[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FNMLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   FNMAD Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   FNMAD Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FNMLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svnmla[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FNMLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FNMAD Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; FNMAD Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FNMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fnmla, EA_SCALABLE, REG_V6, REG_P4, REG_V7, REG_V8, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> FusedMultiplyAddNegated(Vector<float> addend, Vector<float> left, Vector<float> right) => FusedMultiplyAddNegated(addend, left, right);

        /// <summary>
        /// svfloat64_t svnmla[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FNMLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; FNMLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svnmla[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FNMLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   FNMAD Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   FNMAD Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FNMLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svnmla[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FNMLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FNMAD Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; FNMAD Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FNMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fnmla, EA_SCALABLE, REG_V6, REG_P4, REG_V7, REG_V8, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> FusedMultiplyAddNegated(Vector<double> addend, Vector<double> left, Vector<double> right) => FusedMultiplyAddNegated(addend, left, right);


        ///  FusedMultiplySubtract : Multiply-subtract, minuend first

        /// <summary>
        /// svfloat32_t svmls[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FMLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; FMLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svmls[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FMLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   FMSB Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   FMSB Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FMLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svmls[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMSB Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; FMSB Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmls, EA_SCALABLE, REG_V3, REG_P2, REG_V4, REG_V5, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3A  FMLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> FusedMultiplySubtract(Vector<float> minuend, Vector<float> left, Vector<float> right) => FusedMultiplySubtract(minuend, left, right);

        /// <summary>
        /// svfloat64_t svmls[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FMLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; FMLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svmls[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FMLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   FMSB Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   FMSB Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FMLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svmls[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMSB Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; FMSB Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmls, EA_SCALABLE, REG_V3, REG_P2, REG_V4, REG_V5, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3A  FMLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> FusedMultiplySubtract(Vector<double> minuend, Vector<double> left, Vector<double> right) => FusedMultiplySubtract(minuend, left, right);


        ///  FusedMultiplySubtractBySelectedScalar : Multiply-subtract, minuend first

        /// <summary>
        /// svfloat32_t svmls_lane[_f32](svfloat32_t op1, svfloat32_t op2, svfloat32_t op3, uint64_t imm_index)
        ///   FMLS Ztied1.S, Zop2.S, Zop3.S[imm_index]
        ///   MOVPRFX Zresult, Zop1; FMLS Zresult.S, Zop2.S, Zop3.S[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmls, EA_SCALABLE, REG_V3, REG_P2, REG_V4, REG_V5, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3A  FMLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> FusedMultiplySubtractBySelectedScalar(Vector<float> minuend, Vector<float> left, Vector<float> right, [ConstantExpected] byte rightIndex) => FusedMultiplySubtractBySelectedScalar(minuend, left, right, rightIndex);

        /// <summary>
        /// svfloat64_t svmls_lane[_f64](svfloat64_t op1, svfloat64_t op2, svfloat64_t op3, uint64_t imm_index)
        ///   FMLS Ztied1.D, Zop2.D, Zop3.D[imm_index]
        ///   MOVPRFX Zresult, Zop1; FMLS Zresult.D, Zop2.D, Zop3.D[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FMLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fmls, EA_SCALABLE, REG_V3, REG_P2, REG_V4, REG_V5, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3A  FMLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GU_3B  FMLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmls, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> FusedMultiplySubtractBySelectedScalar(Vector<double> minuend, Vector<double> left, Vector<double> right, [ConstantExpected] byte rightIndex) => FusedMultiplySubtractBySelectedScalar(minuend, left, right, rightIndex);


        ///  FusedMultiplySubtractNegated : Negated multiply-subtract, minuend first

        /// <summary>
        /// svfloat32_t svnmls[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FNMLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; FNMLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svnmls[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   FNMLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   FNMSB Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   FNMSB Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FNMLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svfloat32_t svnmls[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FNMLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FNMSB Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; FNMSB Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FNMLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fnmls, EA_SCALABLE, REG_V9, REG_P6, REG_V10, REG_V11, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> FusedMultiplySubtractNegated(Vector<float> minuend, Vector<float> left, Vector<float> right) => FusedMultiplySubtractNegated(minuend, left, right);

        /// <summary>
        /// svfloat64_t svnmls[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FNMLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; FNMLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svnmls[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   FNMLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   FNMSB Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   FNMSB Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FNMLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svfloat64_t svnmls[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FNMLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FNMSB Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; FNMSB Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HU_4A  FNMLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_fnmls, EA_SCALABLE, REG_V9, REG_P6, REG_V10, REG_V11, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> FusedMultiplySubtractNegated(Vector<double> minuend, Vector<double> left, Vector<double> right) => FusedMultiplySubtractNegated(minuend, left, right);


        ///  GatherPrefetch16Bit : Prefetch halfwords

        /// <summary>
        /// void svprfh_gather_[s32]index(svbool_t pg, const void *base, svint32_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<short> mask, void* address, Vector<int> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfh_gather_[s64]index(svbool_t pg, const void *base, svint64_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<short> mask, void* address, Vector<long> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfh_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFH op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<short> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfh_gather_[u32]index(svbool_t pg, const void *base, svuint32_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<short> mask, void* address, Vector<uint> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfh_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFH op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<short> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfh_gather_[u64]index(svbool_t pg, const void *base, svuint64_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<short> mask, void* address, Vector<ulong> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfh_gather_[s32]index(svbool_t pg, const void *base, svint32_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<ushort> mask, void* address, Vector<int> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfh_gather_[s64]index(svbool_t pg, const void *base, svint64_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<ushort> mask, void* address, Vector<long> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfh_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFH op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<ushort> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfh_gather_[u32]index(svbool_t pg, const void *base, svuint32_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<ushort> mask, void* address, Vector<uint> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfh_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFH op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<ushort> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfh_gather_[u64]index(svbool_t pg, const void *base, svuint64_t indices, enum svprfop op)
        ///   PRFH op, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch16Bit(Vector<ushort> mask, void* address, Vector<ulong> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch16Bit(mask, address, indices, prefetchType);


        ///  GatherPrefetch32Bit : Prefetch words

        /// <summary>
        /// void svprfw_gather_[s32]index(svbool_t pg, const void *base, svint32_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<int> mask, void* address, Vector<int> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfw_gather_[s64]index(svbool_t pg, const void *base, svint64_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<int> mask, void* address, Vector<long> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfw_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFW op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<int> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfw_gather_[u32]index(svbool_t pg, const void *base, svuint32_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<int> mask, void* address, Vector<uint> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfw_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFW op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<int> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfw_gather_[u64]index(svbool_t pg, const void *base, svuint64_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<int> mask, void* address, Vector<ulong> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfw_gather_[s32]index(svbool_t pg, const void *base, svint32_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<uint> mask, void* address, Vector<int> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfw_gather_[s64]index(svbool_t pg, const void *base, svint64_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<uint> mask, void* address, Vector<long> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfw_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFW op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<uint> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfw_gather_[u32]index(svbool_t pg, const void *base, svuint32_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<uint> mask, void* address, Vector<uint> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfw_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFW op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<uint> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfw_gather_[u64]index(svbool_t pg, const void *base, svuint64_t indices, enum svprfop op)
        ///   PRFW op, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch32Bit(Vector<uint> mask, void* address, Vector<ulong> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch32Bit(mask, address, indices, prefetchType);


        ///  GatherPrefetch64Bit : Prefetch doublewords

        /// <summary>
        /// void svprfd_gather_[s32]index(svbool_t pg, const void *base, svint32_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.S, SXTW #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<long> mask, void* address, Vector<int> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfd_gather_[s64]index(svbool_t pg, const void *base, svint64_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<long> mask, void* address, Vector<long> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfd_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFD op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<long> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfd_gather_[u32]index(svbool_t pg, const void *base, svuint32_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.S, UXTW #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<long> mask, void* address, Vector<uint> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfd_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFD op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<long> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfd_gather_[u64]index(svbool_t pg, const void *base, svuint64_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<long> mask, void* address, Vector<ulong> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfd_gather_[s32]index(svbool_t pg, const void *base, svint32_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.S, SXTW #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<ulong> mask, void* address, Vector<int> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfd_gather_[s64]index(svbool_t pg, const void *base, svint64_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<ulong> mask, void* address, Vector<long> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfd_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFD op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<ulong> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfd_gather_[u32]index(svbool_t pg, const void *base, svuint32_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.S, UXTW #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<ulong> mask, void* address, Vector<uint> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);

        /// <summary>
        /// void svprfd_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFD op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<ulong> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfd_gather_[u64]index(svbool_t pg, const void *base, svuint64_t indices, enum svprfop op)
        ///   PRFD op, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void GatherPrefetch64Bit(Vector<ulong> mask, void* address, Vector<ulong> indices, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch64Bit(mask, address, indices, prefetchType);


        ///  GatherPrefetch8Bit : Prefetch bytes

        /// <summary>
        /// void svprfb_gather_[s32]offset(svbool_t pg, const void *base, svint32_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<sbyte> mask, void* address, Vector<int> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);

        /// <summary>
        /// void svprfb_gather_[s64]offset(svbool_t pg, const void *base, svint64_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<sbyte> mask, void* address, Vector<long> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);

        /// <summary>
        /// void svprfb_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFB op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<sbyte> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfb_gather_[u32]offset(svbool_t pg, const void *base, svuint32_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<sbyte> mask, void* address, Vector<uint> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);

        /// <summary>
        /// void svprfb_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFB op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<sbyte> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfb_gather_[u64]offset(svbool_t pg, const void *base, svuint64_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<sbyte> mask, void* address, Vector<ulong> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);

        /// <summary>
        /// void svprfb_gather_[s32]offset(svbool_t pg, const void *base, svint32_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<byte> mask, void* address, Vector<int> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);

        /// <summary>
        /// void svprfb_gather_[s64]offset(svbool_t pg, const void *base, svint64_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<byte> mask, void* address, Vector<long> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);

        /// <summary>
        /// void svprfb_gather[_u32base](svbool_t pg, svuint32_t bases, enum svprfop op)
        ///   PRFB op, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<byte> mask, Vector<uint> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfb_gather_[u32]offset(svbool_t pg, const void *base, svuint32_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<byte> mask, void* address, Vector<uint> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);

        /// <summary>
        /// void svprfb_gather[_u64base](svbool_t pg, svuint64_t bases, enum svprfop op)
        ///   PRFB op, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<byte> mask, Vector<ulong> addresses, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, addresses, prefetchType);

        /// <summary>
        /// void svprfb_gather_[u64]offset(svbool_t pg, const void *base, svuint64_t offsets, enum svprfop op)
        ///   PRFB op, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void GatherPrefetch8Bit(Vector<byte> mask, void* address, Vector<ulong> offsets, [ConstantExpected] SvePrefetchType prefetchType) => GatherPrefetch8Bit(mask, address, offsets, prefetchType);


        ///  GatherVector : Unextended load

        /// <summary>
        /// svint32_t svld1_gather_[s32]index[_s32](svbool_t pg, const int32_t *base, svint32_t indices)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVector(Vector<int> mask, int* address, Vector<int> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svint32_t svld1_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LD1W Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVector(Vector<int> mask, Vector<uint> addresses) => GatherVector(mask, addresses);

        /// <summary>
        /// svint32_t svld1_gather_[u32]index[_s32](svbool_t pg, const int32_t *base, svuint32_t indices)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVector(Vector<int> mask, int* address, Vector<uint> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svint64_t svld1_gather_[s64]index[_s64](svbool_t pg, const int64_t *base, svint64_t indices)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVector(Vector<long> mask, long* address, Vector<long> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svint64_t svld1_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1D Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVector(Vector<long> mask, Vector<ulong> addresses) => GatherVector(mask, addresses);

        /// <summary>
        /// svint64_t svld1_gather_[u64]index[_s64](svbool_t pg, const int64_t *base, svuint64_t indices)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVector(Vector<long> mask, long* address, Vector<ulong> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1_gather_[s32]index[_u32](svbool_t pg, const uint32_t *base, svint32_t indices)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVector(Vector<uint> mask, uint* address, Vector<int> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LD1W Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVector(Vector<uint> mask, Vector<uint> addresses) => GatherVector(mask, addresses);

        /// <summary>
        /// svuint32_t svld1_gather_[u32]index[_u32](svbool_t pg, const uint32_t *base, svuint32_t indices)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVector(Vector<uint> mask, uint* address, Vector<uint> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1_gather_[s64]index[_u64](svbool_t pg, const uint64_t *base, svint64_t indices)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVector(Vector<ulong> mask, ulong* address, Vector<long> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1D Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVector(Vector<ulong> mask, Vector<ulong> addresses) => GatherVector(mask, addresses);

        /// <summary>
        /// svuint64_t svld1_gather_[u64]index[_u64](svbool_t pg, const uint64_t *base, svuint64_t indices)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVector(Vector<ulong> mask, ulong* address, Vector<ulong> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svfloat32_t svld1_gather_[s32]index[_f32](svbool_t pg, const float32_t *base, svint32_t indices)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVector(Vector<float> mask, float* address, Vector<int> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svfloat32_t svld1_gather[_u32base]_f32(svbool_t pg, svuint32_t bases)
        ///   LD1W Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVector(Vector<float> mask, Vector<uint> addresses) => GatherVector(mask, addresses);

        /// <summary>
        /// svfloat32_t svld1_gather_[u32]index[_f32](svbool_t pg, const float32_t *base, svuint32_t indices)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVector(Vector<float> mask, float* address, Vector<uint> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svfloat64_t svld1_gather_[s64]index[_f64](svbool_t pg, const float64_t *base, svint64_t indices)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVector(Vector<double> mask, double* address, Vector<long> indices) => GatherVector(mask, address, indices);

        /// <summary>
        /// svfloat64_t svld1_gather[_u64base]_f64(svbool_t pg, svuint64_t bases)
        ///   LD1D Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVector(Vector<double> mask, Vector<ulong> addresses) => GatherVector(mask, addresses);

        /// <summary>
        /// svfloat64_t svld1_gather_[u64]index[_f64](svbool_t pg, const float64_t *base, svuint64_t indices)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVector(Vector<double> mask, double* address, Vector<ulong> indices) => GatherVector(mask, address, indices);


        ///  GatherVectorByteZeroExtend : Load 8-bit data and zero-extend

        /// <summary>
        /// svint32_t svld1ub_gather_[s32]offset_s32(svbool_t pg, const uint8_t *base, svint32_t offsets)
        ///   LD1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorByteZeroExtend(Vector<int> mask, byte* address, Vector<int> indices) => GatherVectorByteZeroExtend(mask, address, indices);

        /// <summary>
        /// svint32_t svld1ub_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LD1B Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorByteZeroExtend(Vector<int> mask, Vector<uint> addresses) => GatherVectorByteZeroExtend(mask, addresses);

        /// <summary>
        /// svint32_t svld1ub_gather_[u32]offset_s32(svbool_t pg, const uint8_t *base, svuint32_t offsets)
        ///   LD1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorByteZeroExtend(Vector<int> mask, byte* address, Vector<uint> indices) => GatherVectorByteZeroExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1ub_gather_[s64]offset_s64(svbool_t pg, const uint8_t *base, svint64_t offsets)
        ///   LD1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorByteZeroExtend(Vector<long> mask, byte* address, Vector<long> indices) => GatherVectorByteZeroExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1ub_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1B Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorByteZeroExtend(Vector<long> mask, Vector<ulong> addresses) => GatherVectorByteZeroExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1ub_gather_[u64]offset_s64(svbool_t pg, const uint8_t *base, svuint64_t offsets)
        ///   LD1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorByteZeroExtend(Vector<long> mask, byte* address, Vector<ulong> indices) => GatherVectorByteZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1ub_gather_[s32]offset_u32(svbool_t pg, const uint8_t *base, svint32_t offsets)
        ///   LD1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorByteZeroExtend(Vector<uint> mask, byte* address, Vector<int> indices) => GatherVectorByteZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1ub_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LD1B Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorByteZeroExtend(Vector<uint> mask, Vector<uint> addresses) => GatherVectorByteZeroExtend(mask, addresses);

        /// <summary>
        /// svuint32_t svld1ub_gather_[u32]offset_u32(svbool_t pg, const uint8_t *base, svuint32_t offsets)
        ///   LD1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorByteZeroExtend(Vector<uint> mask, byte* address, Vector<uint> indices) => GatherVectorByteZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1ub_gather_[s64]offset_u64(svbool_t pg, const uint8_t *base, svint64_t offsets)
        ///   LD1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorByteZeroExtend(Vector<ulong> mask, byte* address, Vector<long> indices) => GatherVectorByteZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1ub_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1B Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorByteZeroExtend(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorByteZeroExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1ub_gather_[u64]offset_u64(svbool_t pg, const uint8_t *base, svuint64_t offsets)
        ///   LD1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorByteZeroExtend(Vector<ulong> mask, byte* address, Vector<ulong> indices) => GatherVectorByteZeroExtend(mask, address, indices);


        ///  GatherVectorByteZeroExtendFirstFaulting : Load 8-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1ub_gather_[s32]offset_s32(svbool_t pg, const uint8_t *base, svint32_t offsets)
        ///   LDFF1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorByteZeroExtendFirstFaulting(Vector<int> mask, byte* address, Vector<int> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint32_t svldff1ub_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LDFF1B Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorByteZeroExtendFirstFaulting(Vector<int> mask, Vector<uint> addresses) => GatherVectorByteZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint32_t svldff1ub_gather_[u32]offset_s32(svbool_t pg, const uint8_t *base, svuint32_t offsets)
        ///   LDFF1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorByteZeroExtendFirstFaulting(Vector<int> mask, byte* address, Vector<uint> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1ub_gather_[s64]offset_s64(svbool_t pg, const uint8_t *base, svint64_t offsets)
        ///   LDFF1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorByteZeroExtendFirstFaulting(Vector<long> mask, byte* address, Vector<long> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1ub_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1B Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorByteZeroExtendFirstFaulting(Vector<long> mask, Vector<ulong> addresses) => GatherVectorByteZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1ub_gather_[u64]offset_s64(svbool_t pg, const uint8_t *base, svuint64_t offsets)
        ///   LDFF1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorByteZeroExtendFirstFaulting(Vector<long> mask, byte* address, Vector<ulong> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1ub_gather_[s32]offset_u32(svbool_t pg, const uint8_t *base, svint32_t offsets)
        ///   LDFF1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorByteZeroExtendFirstFaulting(Vector<uint> mask, byte* address, Vector<int> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1ub_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LDFF1B Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorByteZeroExtendFirstFaulting(Vector<uint> mask, Vector<uint> addresses) => GatherVectorByteZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint32_t svldff1ub_gather_[u32]offset_u32(svbool_t pg, const uint8_t *base, svuint32_t offsets)
        ///   LDFF1B Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorByteZeroExtendFirstFaulting(Vector<uint> mask, byte* address, Vector<uint> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1ub_gather_[s64]offset_u64(svbool_t pg, const uint8_t *base, svint64_t offsets)
        ///   LDFF1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorByteZeroExtendFirstFaulting(Vector<ulong> mask, byte* address, Vector<long> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1ub_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1B Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorByteZeroExtendFirstFaulting(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorByteZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1ub_gather_[u64]offset_u64(svbool_t pg, const uint8_t *base, svuint64_t offsets)
        ///   LDFF1B Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorByteZeroExtendFirstFaulting(Vector<ulong> mask, byte* address, Vector<ulong> offsets) => GatherVectorByteZeroExtendFirstFaulting(mask, address, offsets);


        ///  GatherVectorFirstFaulting : Unextended load, first-faulting

        /// <summary>
        /// svint32_t svldff1_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LDFF1W Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorFirstFaulting(Vector<int> mask, Vector<uint> addresses) => GatherVectorFirstFaulting(mask, addresses);

        /// <summary>
        /// svint32_t svldff1_gather_[s32]index[_s32](svbool_t pg, const int32_t *base, svint32_t indices)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorFirstFaulting(Vector<int> mask, int* address, Vector<int> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint32_t svldff1_gather_[u32]index[_s32](svbool_t pg, const int32_t *base, svuint32_t indices)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorFirstFaulting(Vector<int> mask, int* address, Vector<uint> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1D Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorFirstFaulting(Vector<long> mask, Vector<ulong> addresses) => GatherVectorFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1_gather_[s64]index[_s64](svbool_t pg, const int64_t *base, svint64_t indices)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorFirstFaulting(Vector<long> mask, long* address, Vector<long> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1_gather_[u64]index[_s64](svbool_t pg, const int64_t *base, svuint64_t indices)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorFirstFaulting(Vector<long> mask, long* address, Vector<ulong> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint32_t svldff1_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LDFF1W Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorFirstFaulting(Vector<uint> mask, Vector<uint> addresses) => GatherVectorFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint32_t svldff1_gather_[s32]index[_u32](svbool_t pg, const uint32_t *base, svint32_t indices)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorFirstFaulting(Vector<uint> mask, uint* address, Vector<int> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint32_t svldff1_gather_[u32]index[_u32](svbool_t pg, const uint32_t *base, svuint32_t indices)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorFirstFaulting(Vector<uint> mask, uint* address, Vector<uint> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1D Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorFirstFaulting(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1_gather_[s64]index[_u64](svbool_t pg, const uint64_t *base, svint64_t indices)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorFirstFaulting(Vector<ulong> mask, ulong* address, Vector<long> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1_gather_[u64]index[_u64](svbool_t pg, const uint64_t *base, svuint64_t indices)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorFirstFaulting(Vector<ulong> mask, ulong* address, Vector<ulong> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svfloat32_t svldff1_gather_[s32]index[_f32](svbool_t pg, const float32_t *base, svint32_t indices)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVectorFirstFaulting(Vector<float> mask, float* address, Vector<int> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svfloat32_t svldff1_gather[_u32base]_f32(svbool_t pg, svuint32_t bases)
        ///   LDFF1W Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVectorFirstFaulting(Vector<float> mask, Vector<uint> addresses) => GatherVectorFirstFaulting(mask, addresses);

        /// <summary>
        /// svfloat32_t svldff1_gather_[u32]index[_f32](svbool_t pg, const float32_t *base, svuint32_t indices)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVectorFirstFaulting(Vector<float> mask, float* address, Vector<uint> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svfloat64_t svldff1_gather_[s64]index[_f64](svbool_t pg, const float64_t *base, svint64_t indices)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVectorFirstFaulting(Vector<double> mask, double* address, Vector<long> indices) => GatherVectorFirstFaulting(mask, address, indices);

        /// <summary>
        /// svfloat64_t svldff1_gather[_u64base]_f64(svbool_t pg, svuint64_t bases)
        ///   LDFF1D Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVectorFirstFaulting(Vector<double> mask, Vector<ulong> addresses) => GatherVectorFirstFaulting(mask, addresses);

        /// <summary>
        /// svfloat64_t svldff1_gather_[u64]index[_f64](svbool_t pg, const float64_t *base, svuint64_t indices)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVectorFirstFaulting(Vector<double> mask, double* address, Vector<ulong> indices) => GatherVectorFirstFaulting(mask, address, indices);


        ///  GatherVectorInt16SignExtend : Load 16-bit data and sign-extend

        /// <summary>
        /// svint32_t svld1sh_gather_[s32]index_s32(svbool_t pg, const int16_t *base, svint32_t indices)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16SignExtend(Vector<int> mask, short* address, Vector<int> indices) => GatherVectorInt16SignExtend(mask, address, indices);

        /// <summary>
        /// svint32_t svld1sh_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LD1SH Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16SignExtend(Vector<int> mask, Vector<uint> addresses) => GatherVectorInt16SignExtend(mask, addresses);

        /// <summary>
        /// svint32_t svld1sh_gather_[u32]index_s32(svbool_t pg, const int16_t *base, svuint32_t indices)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16SignExtend(Vector<int> mask, short* address, Vector<uint> indices) => GatherVectorInt16SignExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1sh_gather_[s64]index_s64(svbool_t pg, const int16_t *base, svint64_t indices)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16SignExtend(Vector<long> mask, short* address, Vector<long> indices) => GatherVectorInt16SignExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1sh_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1SH Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16SignExtend(Vector<long> mask, Vector<ulong> addresses) => GatherVectorInt16SignExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1sh_gather_[u64]index_s64(svbool_t pg, const int16_t *base, svuint64_t indices)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16SignExtend(Vector<long> mask, short* address, Vector<ulong> indices) => GatherVectorInt16SignExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1sh_gather_[s32]index_u32(svbool_t pg, const int16_t *base, svint32_t indices)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16SignExtend(Vector<uint> mask, short* address, Vector<int> indices) => GatherVectorInt16SignExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1sh_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LD1SH Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16SignExtend(Vector<uint> mask, Vector<uint> addresses) => GatherVectorInt16SignExtend(mask, addresses);

        /// <summary>
        /// svuint32_t svld1sh_gather_[u32]index_u32(svbool_t pg, const int16_t *base, svuint32_t indices)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16SignExtend(Vector<uint> mask, short* address, Vector<uint> indices) => GatherVectorInt16SignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sh_gather_[s64]index_u64(svbool_t pg, const int16_t *base, svint64_t indices)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16SignExtend(Vector<ulong> mask, short* address, Vector<long> indices) => GatherVectorInt16SignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sh_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1SH Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16SignExtend(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorInt16SignExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1sh_gather_[u64]index_u64(svbool_t pg, const int16_t *base, svuint64_t indices)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16SignExtend(Vector<ulong> mask, short* address, Vector<ulong> indices) => GatherVectorInt16SignExtend(mask, address, indices);


        ///  GatherVectorInt16SignExtendFirstFaulting : Load 16-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1sh_gather_[s32]index_s32(svbool_t pg, const int16_t *base, svint32_t indices)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16SignExtendFirstFaulting(Vector<int> mask, short* address, Vector<int> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint32_t svldff1sh_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LDFF1SH Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16SignExtendFirstFaulting(Vector<int> mask, Vector<uint> addresses) => GatherVectorInt16SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint32_t svldff1sh_gather_[u32]index_s32(svbool_t pg, const int16_t *base, svuint32_t indices)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16SignExtendFirstFaulting(Vector<int> mask, short* address, Vector<uint> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1sh_gather_[s64]index_s64(svbool_t pg, const int16_t *base, svint64_t indices)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16SignExtendFirstFaulting(Vector<long> mask, short* address, Vector<long> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1sh_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SH Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16SignExtendFirstFaulting(Vector<long> mask, Vector<ulong> addresses) => GatherVectorInt16SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1sh_gather_[u64]index_s64(svbool_t pg, const int16_t *base, svuint64_t indices)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16SignExtendFirstFaulting(Vector<long> mask, short* address, Vector<ulong> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint32_t svldff1sh_gather_[s32]index_u32(svbool_t pg, const int16_t *base, svint32_t indices)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16SignExtendFirstFaulting(Vector<uint> mask, short* address, Vector<int> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint32_t svldff1sh_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LDFF1SH Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16SignExtendFirstFaulting(Vector<uint> mask, Vector<uint> addresses) => GatherVectorInt16SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint32_t svldff1sh_gather_[u32]index_u32(svbool_t pg, const int16_t *base, svuint32_t indices)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16SignExtendFirstFaulting(Vector<uint> mask, short* address, Vector<uint> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1sh_gather_[s64]index_u64(svbool_t pg, const int16_t *base, svint64_t indices)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16SignExtendFirstFaulting(Vector<ulong> mask, short* address, Vector<long> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1sh_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SH Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16SignExtendFirstFaulting(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorInt16SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1sh_gather_[u64]index_u64(svbool_t pg, const int16_t *base, svuint64_t indices)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16SignExtendFirstFaulting(Vector<ulong> mask, short* address, Vector<ulong> indices) => GatherVectorInt16SignExtendFirstFaulting(mask, address, indices);


        ///  GatherVectorInt16WithByteOffsetsSignExtend : Load 16-bit data and sign-extend

        /// <summary>
        /// svint32_t svld1sh_gather_[s32]offset_s32(svbool_t pg, const int16_t *base, svint32_t offsets)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16WithByteOffsetsSignExtend(Vector<int> mask, short* address, Vector<int> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svint32_t svld1sh_gather_[u32]offset_s32(svbool_t pg, const int16_t *base, svuint32_t offsets)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16WithByteOffsetsSignExtend(Vector<int> mask, short* address, Vector<uint> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1sh_gather_[s64]offset_s64(svbool_t pg, const int16_t *base, svint64_t offsets)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16WithByteOffsetsSignExtend(Vector<long> mask, short* address, Vector<long> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1sh_gather_[u64]offset_s64(svbool_t pg, const int16_t *base, svuint64_t offsets)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16WithByteOffsetsSignExtend(Vector<long> mask, short* address, Vector<ulong> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint32_t svld1sh_gather_[s32]offset_u32(svbool_t pg, const int16_t *base, svint32_t offsets)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16WithByteOffsetsSignExtend(Vector<uint> mask, short* address, Vector<int> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint32_t svld1sh_gather_[u32]offset_u32(svbool_t pg, const int16_t *base, svuint32_t offsets)
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16WithByteOffsetsSignExtend(Vector<uint> mask, short* address, Vector<uint> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1sh_gather_[s64]offset_u64(svbool_t pg, const int16_t *base, svint64_t offsets)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16WithByteOffsetsSignExtend(Vector<ulong> mask, short* address, Vector<long> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1sh_gather_[u64]offset_u64(svbool_t pg, const int16_t *base, svuint64_t offsets)
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16WithByteOffsetsSignExtend(Vector<ulong> mask, short* address, Vector<ulong> offsets) => GatherVectorInt16WithByteOffsetsSignExtend(mask, address, offsets);


        ///  GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting : Load 16-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1sh_gather_[s32]offset_s32(svbool_t pg, const int16_t *base, svint32_t offsets)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<int> mask, short* address, Vector<int> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint32_t svldff1sh_gather_[u32]offset_s32(svbool_t pg, const int16_t *base, svuint32_t offsets)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<int> mask, short* address, Vector<uint> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1sh_gather_[s64]offset_s64(svbool_t pg, const int16_t *base, svint64_t offsets)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<long> mask, short* address, Vector<long> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1sh_gather_[u64]offset_s64(svbool_t pg, const int16_t *base, svuint64_t offsets)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<long> mask, short* address, Vector<ulong> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1sh_gather_[s32]offset_u32(svbool_t pg, const int16_t *base, svint32_t offsets)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<uint> mask, short* address, Vector<int> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1sh_gather_[u32]offset_u32(svbool_t pg, const int16_t *base, svuint32_t offsets)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<uint> mask, short* address, Vector<uint> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sh_gather_[s64]offset_u64(svbool_t pg, const int16_t *base, svint64_t offsets)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<ulong> mask, short* address, Vector<long> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sh_gather_[u64]offset_u64(svbool_t pg, const int16_t *base, svuint64_t offsets)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(Vector<ulong> mask, short* address, Vector<ulong> offsets) => GatherVectorInt16WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);


        ///  GatherVectorInt32SignExtend : Load 32-bit data and sign-extend

        /// <summary>
        /// svint64_t svld1sw_gather_[s64]index_s64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32SignExtend(Vector<int> mask, int* address, Vector<int> indices) => GatherVectorInt32SignExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1sw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32SignExtend(Vector<int> mask, Vector<uint> addresses) => GatherVectorInt32SignExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1sw_gather_[u64]index_s64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32SignExtend(Vector<int> mask, int* address, Vector<uint> indices) => GatherVectorInt32SignExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1sw_gather_[s64]index_s64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32SignExtend(Vector<long> mask, int* address, Vector<long> indices) => GatherVectorInt32SignExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1sw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32SignExtend(Vector<long> mask, Vector<ulong> addresses) => GatherVectorInt32SignExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1sw_gather_[u64]index_s64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32SignExtend(Vector<long> mask, int* address, Vector<ulong> indices) => GatherVectorInt32SignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sw_gather_[s64]index_u64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32SignExtend(Vector<uint> mask, int* address, Vector<int> indices) => GatherVectorInt32SignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32SignExtend(Vector<uint> mask, Vector<uint> addresses) => GatherVectorInt32SignExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1sw_gather_[u64]index_u64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32SignExtend(Vector<uint> mask, int* address, Vector<uint> indices) => GatherVectorInt32SignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sw_gather_[s64]index_u64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32SignExtend(Vector<ulong> mask, int* address, Vector<long> indices) => GatherVectorInt32SignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32SignExtend(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorInt32SignExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1sw_gather_[u64]index_u64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32SignExtend(Vector<ulong> mask, int* address, Vector<ulong> indices) => GatherVectorInt32SignExtend(mask, address, indices);


        ///  GatherVectorInt32SignExtendFirstFaulting : Load 32-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint64_t svldff1sw_gather_[s64]index_s64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32SignExtendFirstFaulting(Vector<int> mask, int* address, Vector<int> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1sw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32SignExtendFirstFaulting(Vector<int> mask, Vector<uint> addresses) => GatherVectorInt32SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1sw_gather_[u64]index_s64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32SignExtendFirstFaulting(Vector<int> mask, int* address, Vector<uint> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1sw_gather_[s64]index_s64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32SignExtendFirstFaulting(Vector<long> mask, int* address, Vector<long> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1sw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32SignExtendFirstFaulting(Vector<long> mask, Vector<ulong> addresses) => GatherVectorInt32SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1sw_gather_[u64]index_s64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32SignExtendFirstFaulting(Vector<long> mask, int* address, Vector<ulong> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[s64]index_u64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32SignExtendFirstFaulting(Vector<uint> mask, int* address, Vector<int> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1sw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32SignExtendFirstFaulting(Vector<uint> mask, Vector<uint> addresses) => GatherVectorInt32SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[u64]index_u64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32SignExtendFirstFaulting(Vector<uint> mask, int* address, Vector<uint> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[s64]index_u64(svbool_t pg, const int32_t *base, svint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32SignExtendFirstFaulting(Vector<ulong> mask, int* address, Vector<long> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1sw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SW Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32SignExtendFirstFaulting(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorInt32SignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[u64]index_u64(svbool_t pg, const int32_t *base, svuint64_t indices)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32SignExtendFirstFaulting(Vector<ulong> mask, int* address, Vector<ulong> indices) => GatherVectorInt32SignExtendFirstFaulting(mask, address, indices);


        ///  GatherVectorInt32WithByteOffsetsSignExtend : Load 32-bit data and sign-extend

        /// <summary>
        /// svint64_t svld1sw_gather_[s64]offset_s64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32WithByteOffsetsSignExtend(Vector<int> mask, int* address, Vector<int> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1sw_gather_[u64]offset_s64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32WithByteOffsetsSignExtend(Vector<int> mask, int* address, Vector<uint> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1sw_gather_[s64]offset_s64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32WithByteOffsetsSignExtend(Vector<long> mask, int* address, Vector<long> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1sw_gather_[u64]offset_s64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32WithByteOffsetsSignExtend(Vector<long> mask, int* address, Vector<ulong> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1sw_gather_[s64]offset_u64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32WithByteOffsetsSignExtend(Vector<uint> mask, int* address, Vector<int> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1sw_gather_[u64]offset_u64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32WithByteOffsetsSignExtend(Vector<uint> mask, int* address, Vector<uint> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1sw_gather_[s64]offset_u64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32WithByteOffsetsSignExtend(Vector<ulong> mask, int* address, Vector<long> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1sw_gather_[u64]offset_u64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32WithByteOffsetsSignExtend(Vector<ulong> mask, int* address, Vector<ulong> offsets) => GatherVectorInt32WithByteOffsetsSignExtend(mask, address, offsets);


        ///  GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting : Load 32-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint64_t svldff1sw_gather_[s64]offset_s64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<int> mask, int* address, Vector<int> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1sw_gather_[u64]offset_s64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<int> mask, int* address, Vector<uint> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1sw_gather_[s64]offset_s64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<long> mask, int* address, Vector<long> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1sw_gather_[u64]offset_s64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<long> mask, int* address, Vector<ulong> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[s64]offset_u64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<uint> mask, int* address, Vector<int> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[u64]offset_u64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<uint> mask, int* address, Vector<uint> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[s64]offset_u64(svbool_t pg, const int32_t *base, svint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<ulong> mask, int* address, Vector<long> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sw_gather_[u64]offset_u64(svbool_t pg, const int32_t *base, svuint64_t offsets)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(Vector<ulong> mask, int* address, Vector<ulong> offsets) => GatherVectorInt32WithByteOffsetsSignExtendFirstFaulting(mask, address, offsets);


        ///  GatherVectorSByteSignExtend : Load 8-bit data and sign-extend

        /// <summary>
        /// svint32_t svld1sb_gather_[s32]offset_s32(svbool_t pg, const int8_t *base, svint32_t offsets)
        ///   LD1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorSByteSignExtend(Vector<int> mask, sbyte* address, Vector<int> indices) => GatherVectorSByteSignExtend(mask, address, indices);

        /// <summary>
        /// svint32_t svld1sb_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LD1SB Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorSByteSignExtend(Vector<int> mask, Vector<uint> addresses) => GatherVectorSByteSignExtend(mask, addresses);

        /// <summary>
        /// svint32_t svld1sb_gather_[u32]offset_s32(svbool_t pg, const int8_t *base, svuint32_t offsets)
        ///   LD1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorSByteSignExtend(Vector<int> mask, sbyte* address, Vector<uint> indices) => GatherVectorSByteSignExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1sb_gather_[s64]offset_s64(svbool_t pg, const int8_t *base, svint64_t offsets)
        ///   LD1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorSByteSignExtend(Vector<long> mask, sbyte* address, Vector<long> indices) => GatherVectorSByteSignExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1sb_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1SB Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorSByteSignExtend(Vector<long> mask, Vector<ulong> addresses) => GatherVectorSByteSignExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1sb_gather_[u64]offset_s64(svbool_t pg, const int8_t *base, svuint64_t offsets)
        ///   LD1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorSByteSignExtend(Vector<long> mask, sbyte* address, Vector<ulong> indices) => GatherVectorSByteSignExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1sb_gather_[s32]offset_u32(svbool_t pg, const int8_t *base, svint32_t offsets)
        ///   LD1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorSByteSignExtend(Vector<uint> mask, sbyte* address, Vector<int> indices) => GatherVectorSByteSignExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1sb_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LD1SB Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorSByteSignExtend(Vector<uint> mask, Vector<uint> addresses) => GatherVectorSByteSignExtend(mask, addresses);

        /// <summary>
        /// svuint32_t svld1sb_gather_[u32]offset_u32(svbool_t pg, const int8_t *base, svuint32_t offsets)
        ///   LD1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorSByteSignExtend(Vector<uint> mask, sbyte* address, Vector<uint> indices) => GatherVectorSByteSignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sb_gather_[s64]offset_u64(svbool_t pg, const int8_t *base, svint64_t offsets)
        ///   LD1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorSByteSignExtend(Vector<ulong> mask, sbyte* address, Vector<long> indices) => GatherVectorSByteSignExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1sb_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1SB Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorSByteSignExtend(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorSByteSignExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1sb_gather_[u64]offset_u64(svbool_t pg, const int8_t *base, svuint64_t offsets)
        ///   LD1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorSByteSignExtend(Vector<ulong> mask, sbyte* address, Vector<ulong> indices) => GatherVectorSByteSignExtend(mask, address, indices);


        ///  GatherVectorSByteSignExtendFirstFaulting : Load 8-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1sb_gather_[s32]offset_s32(svbool_t pg, const int8_t *base, svint32_t offsets)
        ///   LDFF1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorSByteSignExtendFirstFaulting(Vector<int> mask, sbyte* address, Vector<int> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint32_t svldff1sb_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LDFF1SB Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorSByteSignExtendFirstFaulting(Vector<int> mask, Vector<uint> addresses) => GatherVectorSByteSignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint32_t svldff1sb_gather_[u32]offset_s32(svbool_t pg, const int8_t *base, svuint32_t offsets)
        ///   LDFF1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorSByteSignExtendFirstFaulting(Vector<int> mask, sbyte* address, Vector<uint> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1sb_gather_[s64]offset_s64(svbool_t pg, const int8_t *base, svint64_t offsets)
        ///   LDFF1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorSByteSignExtendFirstFaulting(Vector<long> mask, sbyte* address, Vector<long> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1sb_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SB Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorSByteSignExtendFirstFaulting(Vector<long> mask, Vector<ulong> addresses) => GatherVectorSByteSignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1sb_gather_[u64]offset_s64(svbool_t pg, const int8_t *base, svuint64_t offsets)
        ///   LDFF1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorSByteSignExtendFirstFaulting(Vector<long> mask, sbyte* address, Vector<ulong> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1sb_gather_[s32]offset_u32(svbool_t pg, const int8_t *base, svint32_t offsets)
        ///   LDFF1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorSByteSignExtendFirstFaulting(Vector<uint> mask, sbyte* address, Vector<int> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1sb_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LDFF1SB Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorSByteSignExtendFirstFaulting(Vector<uint> mask, Vector<uint> addresses) => GatherVectorSByteSignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint32_t svldff1sb_gather_[u32]offset_u32(svbool_t pg, const int8_t *base, svuint32_t offsets)
        ///   LDFF1SB Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorSByteSignExtendFirstFaulting(Vector<uint> mask, sbyte* address, Vector<uint> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sb_gather_[s64]offset_u64(svbool_t pg, const int8_t *base, svint64_t offsets)
        ///   LDFF1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorSByteSignExtendFirstFaulting(Vector<ulong> mask, sbyte* address, Vector<long> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1sb_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1SB Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorSByteSignExtendFirstFaulting(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorSByteSignExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1sb_gather_[u64]offset_u64(svbool_t pg, const int8_t *base, svuint64_t offsets)
        ///   LDFF1SB Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorSByteSignExtendFirstFaulting(Vector<ulong> mask, sbyte* address, Vector<ulong> offsets) => GatherVectorSByteSignExtendFirstFaulting(mask, address, offsets);


        ///  GatherVectorUInt16WithByteOffsetsZeroExtend : Load 16-bit data and zero-extend

        /// <summary>
        /// svint32_t svld1uh_gather_[s32]offset_s32(svbool_t pg, const uint16_t *base, svint32_t offsets)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<int> mask, ushort* address, Vector<int> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svint32_t svld1uh_gather_[u32]offset_s32(svbool_t pg, const uint16_t *base, svuint32_t offsets)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<int> mask, ushort* address, Vector<uint> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1uh_gather_[s64]offset_s64(svbool_t pg, const uint16_t *base, svint64_t offsets)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<long> mask, ushort* address, Vector<long> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1uh_gather_[u64]offset_s64(svbool_t pg, const uint16_t *base, svuint64_t offsets)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<long> mask, ushort* address, Vector<ulong> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint32_t svld1uh_gather_[s32]offset_u32(svbool_t pg, const uint16_t *base, svint32_t offsets)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<uint> mask, ushort* address, Vector<int> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint32_t svld1uh_gather_[u32]offset_u32(svbool_t pg, const uint16_t *base, svuint32_t offsets)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<uint> mask, ushort* address, Vector<uint> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1uh_gather_[s64]offset_u64(svbool_t pg, const uint16_t *base, svint64_t offsets)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<ulong> mask, ushort* address, Vector<long> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1uh_gather_[u64]offset_u64(svbool_t pg, const uint16_t *base, svuint64_t offsets)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16WithByteOffsetsZeroExtend(Vector<ulong> mask, ushort* address, Vector<ulong> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtend(mask, address, offsets);


        ///  GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting : Load 16-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1uh_gather_[s32]offset_s32(svbool_t pg, const uint16_t *base, svint32_t offsets)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<int> mask, ushort* address, Vector<int> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint32_t svldff1uh_gather_[u32]offset_s32(svbool_t pg, const uint16_t *base, svuint32_t offsets)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<int> mask, ushort* address, Vector<uint> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1uh_gather_[s64]offset_s64(svbool_t pg, const uint16_t *base, svint64_t offsets)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<long> mask, ushort* address, Vector<long> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1uh_gather_[u64]offset_s64(svbool_t pg, const uint16_t *base, svuint64_t offsets)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<long> mask, ushort* address, Vector<ulong> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1uh_gather_[s32]offset_u32(svbool_t pg, const uint16_t *base, svint32_t offsets)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<uint> mask, ushort* address, Vector<int> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1uh_gather_[u32]offset_u32(svbool_t pg, const uint16_t *base, svuint32_t offsets)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<uint> mask, ushort* address, Vector<uint> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1uh_gather_[s64]offset_u64(svbool_t pg, const uint16_t *base, svint64_t offsets)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<ulong> mask, ushort* address, Vector<long> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1uh_gather_[u64]offset_u64(svbool_t pg, const uint16_t *base, svuint64_t offsets)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(Vector<ulong> mask, ushort* address, Vector<ulong> offsets) => GatherVectorUInt16WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);


        ///  GatherVectorUInt16ZeroExtend : Load 16-bit data and zero-extend

        /// <summary>
        /// svint32_t svld1uh_gather_[s32]index_s32(svbool_t pg, const uint16_t *base, svint32_t indices)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16ZeroExtend(Vector<int> mask, ushort* address, Vector<int> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);

        /// <summary>
        /// svint32_t svld1uh_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LD1H Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16ZeroExtend(Vector<int> mask, Vector<uint> addresses) => GatherVectorUInt16ZeroExtend(mask, addresses);

        /// <summary>
        /// svint32_t svld1uh_gather_[u32]index_s32(svbool_t pg, const uint16_t *base, svuint32_t indices)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16ZeroExtend(Vector<int> mask, ushort* address, Vector<uint> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1uh_gather_[s64]index_s64(svbool_t pg, const uint16_t *base, svint64_t indices)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16ZeroExtend(Vector<long> mask, ushort* address, Vector<long> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1uh_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1H Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16ZeroExtend(Vector<long> mask, Vector<ulong> addresses) => GatherVectorUInt16ZeroExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1uh_gather_[u64]index_s64(svbool_t pg, const uint16_t *base, svuint64_t indices)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16ZeroExtend(Vector<long> mask, ushort* address, Vector<ulong> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1uh_gather_[s32]index_u32(svbool_t pg, const uint16_t *base, svint32_t indices)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16ZeroExtend(Vector<uint> mask, ushort* address, Vector<int> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint32_t svld1uh_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LD1H Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16ZeroExtend(Vector<uint> mask, Vector<uint> addresses) => GatherVectorUInt16ZeroExtend(mask, addresses);

        /// <summary>
        /// svuint32_t svld1uh_gather_[u32]index_u32(svbool_t pg, const uint16_t *base, svuint32_t indices)
        ///   LD1H Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16ZeroExtend(Vector<uint> mask, ushort* address, Vector<uint> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1uh_gather_[s64]index_u64(svbool_t pg, const uint16_t *base, svint64_t indices)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16ZeroExtend(Vector<ulong> mask, ushort* address, Vector<long> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1uh_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1H Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16ZeroExtend(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorUInt16ZeroExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1uh_gather_[u64]index_u64(svbool_t pg, const uint16_t *base, svuint64_t indices)
        ///   LD1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16ZeroExtend(Vector<ulong> mask, ushort* address, Vector<ulong> indices) => GatherVectorUInt16ZeroExtend(mask, address, indices);


        ///  GatherVectorUInt16ZeroExtendFirstFaulting : Load 16-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1uh_gather_[s32]index_s32(svbool_t pg, const uint16_t *base, svint32_t indices)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<int> mask, ushort* address, Vector<int> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint32_t svldff1uh_gather[_u32base]_s32(svbool_t pg, svuint32_t bases)
        ///   LDFF1H Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<int> mask, Vector<uint> addresses) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint32_t svldff1uh_gather_[u32]index_s32(svbool_t pg, const uint16_t *base, svuint32_t indices)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<int> mask, ushort* address, Vector<uint> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1uh_gather_[s64]index_s64(svbool_t pg, const uint16_t *base, svint64_t indices)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<long> mask, ushort* address, Vector<long> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1uh_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1H Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<long> mask, Vector<ulong> addresses) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1uh_gather_[u64]index_s64(svbool_t pg, const uint16_t *base, svuint64_t indices)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<long> mask, ushort* address, Vector<ulong> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint32_t svldff1uh_gather_[s32]index_u32(svbool_t pg, const uint16_t *base, svint32_t indices)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<uint> mask, ushort* address, Vector<int> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint32_t svldff1uh_gather[_u32base]_u32(svbool_t pg, svuint32_t bases)
        ///   LDFF1H Zresult.S, Pg/Z, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<uint> mask, Vector<uint> addresses) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint32_t svldff1uh_gather_[u32]index_u32(svbool_t pg, const uint16_t *base, svuint32_t indices)
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<uint> mask, ushort* address, Vector<uint> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1uh_gather_[s64]index_u64(svbool_t pg, const uint16_t *base, svint64_t indices)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<ulong> mask, ushort* address, Vector<long> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1uh_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1H Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1uh_gather_[u64]index_u64(svbool_t pg, const uint16_t *base, svuint64_t indices)
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt16ZeroExtendFirstFaulting(Vector<ulong> mask, ushort* address, Vector<ulong> indices) => GatherVectorUInt16ZeroExtendFirstFaulting(mask, address, indices);


        ///  GatherVectorUInt32WithByteOffsetsZeroExtend : Load 32-bit data and zero-extend

        /// <summary>
        /// svint64_t svld1uw_gather_[s64]offset_s64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<int> mask, uint* address, Vector<int> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1uw_gather_[u64]offset_s64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<int> mask, uint* address, Vector<uint> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1uw_gather_[s64]offset_s64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<long> mask, uint* address, Vector<long> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1uw_gather_[u64]offset_s64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<long> mask, uint* address, Vector<ulong> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1uw_gather_[s64]offset_u64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<uint> mask, uint* address, Vector<int> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1uw_gather_[u64]offset_u64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<uint> mask, uint* address, Vector<uint> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1uw_gather_[s64]offset_u64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<ulong> mask, uint* address, Vector<long> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1uw_gather_[u64]offset_u64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32WithByteOffsetsZeroExtend(Vector<ulong> mask, uint* address, Vector<ulong> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtend(mask, address, offsets);


        ///  GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting : Load 32-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint64_t svldff1uw_gather_[s64]offset_s64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<int> mask, uint* address, Vector<int> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1uw_gather_[u64]offset_s64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<int> mask, uint* address, Vector<uint> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1uw_gather_[s64]offset_s64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<long> mask, uint* address, Vector<long> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1uw_gather_[u64]offset_s64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<long> mask, uint* address, Vector<ulong> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[s64]offset_u64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<uint> mask, uint* address, Vector<int> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[u64]offset_u64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<uint> mask, uint* address, Vector<uint> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[s64]offset_u64(svbool_t pg, const uint32_t *base, svint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<ulong> mask, uint* address, Vector<long> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[u64]offset_u64(svbool_t pg, const uint32_t *base, svuint64_t offsets)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(Vector<ulong> mask, uint* address, Vector<ulong> offsets) => GatherVectorUInt32WithByteOffsetsZeroExtendFirstFaulting(mask, address, offsets);


        ///  GatherVectorUInt32ZeroExtend : Load 32-bit data and zero-extend

        /// <summary>
        /// svint64_t svld1uw_gather_[s64]index_s64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32ZeroExtend(Vector<int> mask, uint* address, Vector<int> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1uw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32ZeroExtend(Vector<int> mask, Vector<uint> addresses) => GatherVectorUInt32ZeroExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1uw_gather_[u64]index_s64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32ZeroExtend(Vector<int> mask, uint* address, Vector<uint> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1uw_gather_[s64]index_s64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32ZeroExtend(Vector<long> mask, uint* address, Vector<long> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);

        /// <summary>
        /// svint64_t svld1uw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LD1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32ZeroExtend(Vector<long> mask, Vector<ulong> addresses) => GatherVectorUInt32ZeroExtend(mask, addresses);

        /// <summary>
        /// svint64_t svld1uw_gather_[u64]index_s64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32ZeroExtend(Vector<long> mask, uint* address, Vector<ulong> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1uw_gather_[s64]index_u64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32ZeroExtend(Vector<uint> mask, uint* address, Vector<int> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1uw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32ZeroExtend(Vector<uint> mask, Vector<uint> addresses) => GatherVectorUInt32ZeroExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1uw_gather_[u64]index_u64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32ZeroExtend(Vector<uint> mask, uint* address, Vector<uint> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1uw_gather_[s64]index_u64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32ZeroExtend(Vector<ulong> mask, uint* address, Vector<long> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);

        /// <summary>
        /// svuint64_t svld1uw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LD1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32ZeroExtend(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorUInt32ZeroExtend(mask, addresses);

        /// <summary>
        /// svuint64_t svld1uw_gather_[u64]index_u64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LD1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32ZeroExtend(Vector<ulong> mask, uint* address, Vector<ulong> indices) => GatherVectorUInt32ZeroExtend(mask, address, indices);


        ///  GatherVectorUInt32ZeroExtendFirstFaulting : Load 32-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint64_t svldff1uw_gather_[s64]index_s64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<int> mask, uint* address, Vector<int> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1uw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<int> mask, Vector<uint> addresses) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1uw_gather_[u64]index_s64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<int> mask, uint* address, Vector<uint> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1uw_gather_[s64]index_s64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<long> mask, uint* address, Vector<long> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svint64_t svldff1uw_gather[_u64base]_s64(svbool_t pg, svuint64_t bases)
        ///   LDFF1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<long> mask, Vector<ulong> addresses) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svint64_t svldff1uw_gather_[u64]index_s64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<long> mask, uint* address, Vector<ulong> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[s64]index_u64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<uint> mask, uint* address, Vector<int> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1uw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<uint> mask, Vector<uint> addresses) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[u64]index_u64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<uint> mask, uint* address, Vector<uint> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[s64]index_u64(svbool_t pg, const uint32_t *base, svint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<ulong> mask, uint* address, Vector<long> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);

        /// <summary>
        /// svuint64_t svldff1uw_gather[_u64base]_u64(svbool_t pg, svuint64_t bases)
        ///   LDFF1W Zresult.D, Pg/Z, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<ulong> mask, Vector<ulong> addresses) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, addresses);

        /// <summary>
        /// svuint64_t svldff1uw_gather_[u64]index_u64(svbool_t pg, const uint32_t *base, svuint64_t indices)
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorUInt32ZeroExtendFirstFaulting(Vector<ulong> mask, uint* address, Vector<ulong> indices) => GatherVectorUInt32ZeroExtendFirstFaulting(mask, address, indices);


        ///  GatherVectorWithByteOffsetFirstFaulting : Unextended load, first-faulting

        /// <summary>
        /// svint32_t svldff1_gather_[s32]offset[_s32](svbool_t pg, const int32_t *base, svint32_t offsets)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorWithByteOffsetFirstFaulting(Vector<int> mask, int* address, Vector<int> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint32_t svldff1_gather_[u32]offset[_s32](svbool_t pg, const int32_t *base, svuint32_t offsets)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorWithByteOffsetFirstFaulting(Vector<int> mask, int* address, Vector<uint> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1_gather_[s64]offset[_s64](svbool_t pg, const int64_t *base, svint64_t offsets)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorWithByteOffsetFirstFaulting(Vector<long> mask, long* address, Vector<long> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svint64_t svldff1_gather_[u64]offset[_s64](svbool_t pg, const int64_t *base, svuint64_t offsets)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorWithByteOffsetFirstFaulting(Vector<long> mask, long* address, Vector<ulong> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1_gather_[s32]offset[_u32](svbool_t pg, const uint32_t *base, svint32_t offsets)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorWithByteOffsetFirstFaulting(Vector<uint> mask, uint* address, Vector<int> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint32_t svldff1_gather_[u32]offset[_u32](svbool_t pg, const uint32_t *base, svuint32_t offsets)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorWithByteOffsetFirstFaulting(Vector<uint> mask, uint* address, Vector<uint> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1_gather_[s64]offset[_u64](svbool_t pg, const uint64_t *base, svint64_t offsets)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorWithByteOffsetFirstFaulting(Vector<ulong> mask, ulong* address, Vector<long> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svuint64_t svldff1_gather_[u64]offset[_u64](svbool_t pg, const uint64_t *base, svuint64_t offsets)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorWithByteOffsetFirstFaulting(Vector<ulong> mask, ulong* address, Vector<ulong> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svfloat32_t svldff1_gather_[s32]offset[_f32](svbool_t pg, const float32_t *base, svint32_t offsets)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVectorWithByteOffsetFirstFaulting(Vector<float> mask, float* address, Vector<int> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svfloat32_t svldff1_gather_[u32]offset[_f32](svbool_t pg, const float32_t *base, svuint32_t offsets)
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVectorWithByteOffsetFirstFaulting(Vector<float> mask, float* address, Vector<uint> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svfloat64_t svldff1_gather_[s64]offset[_f64](svbool_t pg, const float64_t *base, svint64_t offsets)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVectorWithByteOffsetFirstFaulting(Vector<double> mask, double* address, Vector<long> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);

        /// <summary>
        /// svfloat64_t svldff1_gather_[u64]offset[_f64](svbool_t pg, const float64_t *base, svuint64_t offsets)
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVectorWithByteOffsetFirstFaulting(Vector<double> mask, double* address, Vector<ulong> offsets) => GatherVectorWithByteOffsetFirstFaulting(mask, address, offsets);


        ///  GatherVectorWithByteOffsets : Unextended load

        /// <summary>
        /// svint32_t svld1_gather_[s32]offset[_s32](svbool_t pg, const int32_t *base, svint32_t offsets)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorWithByteOffsets(Vector<int> mask, int* address, Vector<int> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svint32_t svld1_gather_[u32]offset[_s32](svbool_t pg, const int32_t *base, svuint32_t offsets)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> GatherVectorWithByteOffsets(Vector<int> mask, int* address, Vector<uint> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1_gather_[s64]offset[_s64](svbool_t pg, const int64_t *base, svint64_t offsets)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorWithByteOffsets(Vector<long> mask, long* address, Vector<long> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svint64_t svld1_gather_[u64]offset[_s64](svbool_t pg, const int64_t *base, svuint64_t offsets)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> GatherVectorWithByteOffsets(Vector<long> mask, long* address, Vector<ulong> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svuint32_t svld1_gather_[s32]offset[_u32](svbool_t pg, const uint32_t *base, svint32_t offsets)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorWithByteOffsets(Vector<uint> mask, uint* address, Vector<int> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svuint32_t svld1_gather_[u32]offset[_u32](svbool_t pg, const uint32_t *base, svuint32_t offsets)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> GatherVectorWithByteOffsets(Vector<uint> mask, uint* address, Vector<uint> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1_gather_[s64]offset[_u64](svbool_t pg, const uint64_t *base, svint64_t offsets)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorWithByteOffsets(Vector<ulong> mask, ulong* address, Vector<long> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svuint64_t svld1_gather_[u64]offset[_u64](svbool_t pg, const uint64_t *base, svuint64_t offsets)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> GatherVectorWithByteOffsets(Vector<ulong> mask, ulong* address, Vector<ulong> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svfloat32_t svld1_gather_[s32]offset[_f32](svbool_t pg, const float32_t *base, svint32_t offsets)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVectorWithByteOffsets(Vector<float> mask, float* address, Vector<int> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svfloat32_t svld1_gather_[u32]offset[_f32](svbool_t pg, const float32_t *base, svuint32_t offsets)
        ///   LD1W Zresult.S, Pg/Z, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> GatherVectorWithByteOffsets(Vector<float> mask, float* address, Vector<uint> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svfloat64_t svld1_gather_[s64]offset[_f64](svbool_t pg, const float64_t *base, svint64_t offsets)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVectorWithByteOffsets(Vector<double> mask, double* address, Vector<long> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);

        /// <summary>
        /// svfloat64_t svld1_gather_[u64]offset[_f64](svbool_t pg, const float64_t *base, svuint64_t offsets)
        ///   LD1D Zresult.D, Pg/Z, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> GatherVectorWithByteOffsets(Vector<double> mask, double* address, Vector<ulong> offsets) => GatherVectorWithByteOffsets(mask, address, offsets);


        ///  GetActiveElementCount : Count set predicate bits

        /// <summary>
        /// uint64_t svcntp_b8(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<sbyte> mask, Vector<sbyte> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b8(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<short> mask, Vector<short> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b8(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<int> mask, Vector<int> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b8(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<long> mask, Vector<long> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b8(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<byte> mask, Vector<byte> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b16(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<ushort> mask, Vector<ushort> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b32(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<uint> mask, Vector<uint> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b64(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<ulong> mask, Vector<ulong> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b8(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<float> mask, Vector<float> from) => GetActiveElementCount(mask, from);

        /// <summary>
        /// uint64_t svcntp_b8(svbool_t pg, svbool_t op)
        ///   CNTP Xresult, Pg, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DK_3A  CNTP <Xd>, <Pg>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cntp, EA_8BYTE, REG_R29, REG_P0, REG_P15, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DL_2A  CNTP <Xd>, <PNn>.<T>, <vl>
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_VL_4X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_2X);
        ///        theEmitter->emitIns_R_R(INS_sve_cntp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_VL_4X);
        /// </summary>
        public static unsafe ulong GetActiveElementCount(Vector<double> mask, Vector<double> from) => GetActiveElementCount(mask, from);


        ///  GetFfr : Read FFR, returning predicate of succesfully loaded elements

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<sbyte> GetFfr() => GetFfr();

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<short> GetFfr() => GetFfr();

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<int> GetFfr() => GetFfr();

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<long> GetFfr() => GetFfr();

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<byte> GetFfr() => GetFfr();

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<ushort> GetFfr() => GetFfr();

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<uint> GetFfr() => GetFfr();

        /// <summary>
        /// svbool_t svrdffr()
        ///   RDFFR Presult.B
        /// svbool_t svrdffr_z(svbool_t pg)
        ///   RDFFR Presult.B, Pg/Z
        ///
        /// codegenarm64test:
        ///    IF_SVE_DG_2A  RDFFR <Pd>.B, <Pg>/Z
        ///        theEmitter->emitIns_R_R(INS_sve_rdffr, EA_SCALABLE, REG_P10, REG_P15, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_DH_1A  RDFFR <Pd>.B
        ///        theEmitter->emitIns_R(INS_sve_rdffr, EA_SCALABLE, REG_P8);
        /// </summary>
        public static unsafe Vector<ulong> GetFfr() => GetFfr();


        ///  InsertIntoShiftedVector : Insert scalar into shifted vector

        /// <summary>
        /// svint8_t svinsr[_n_s8](svint8_t op1, int8_t op2)
        ///   INSR Ztied1.B, Wop2
        ///   INSR Ztied1.B, Bop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<sbyte> InsertIntoShiftedVector(Vector<sbyte> left, sbyte right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svint16_t svinsr[_n_s16](svint16_t op1, int16_t op2)
        ///   INSR Ztied1.H, Wop2
        ///   INSR Ztied1.H, Hop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<short> InsertIntoShiftedVector(Vector<short> left, short right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svint32_t svinsr[_n_s32](svint32_t op1, int32_t op2)
        ///   INSR Ztied1.S, Wop2
        ///   INSR Ztied1.S, Sop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<int> InsertIntoShiftedVector(Vector<int> left, int right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svint64_t svinsr[_n_s64](svint64_t op1, int64_t op2)
        ///   INSR Ztied1.D, Xop2
        ///   INSR Ztied1.D, Dop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<long> InsertIntoShiftedVector(Vector<long> left, long right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svuint8_t svinsr[_n_u8](svuint8_t op1, uint8_t op2)
        ///   INSR Ztied1.B, Wop2
        ///   INSR Ztied1.B, Bop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<byte> InsertIntoShiftedVector(Vector<byte> left, byte right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svuint16_t svinsr[_n_u16](svuint16_t op1, uint16_t op2)
        ///   INSR Ztied1.H, Wop2
        ///   INSR Ztied1.H, Hop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ushort> InsertIntoShiftedVector(Vector<ushort> left, ushort right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svuint32_t svinsr[_n_u32](svuint32_t op1, uint32_t op2)
        ///   INSR Ztied1.S, Wop2
        ///   INSR Ztied1.S, Sop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<uint> InsertIntoShiftedVector(Vector<uint> left, uint right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svuint64_t svinsr[_n_u64](svuint64_t op1, uint64_t op2)
        ///   INSR Ztied1.D, Xop2
        ///   INSR Ztied1.D, Dop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ulong> InsertIntoShiftedVector(Vector<ulong> left, ulong right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svfloat32_t svinsr[_n_f32](svfloat32_t op1, float32_t op2)
        ///   INSR Ztied1.S, Wop2
        ///   INSR Ztied1.S, Sop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<float> InsertIntoShiftedVector(Vector<float> left, float right) => InsertIntoShiftedVector(left, right);

        /// <summary>
        /// svfloat64_t svinsr[_n_f64](svfloat64_t op1, float64_t op2)
        ///   INSR Ztied1.D, Xop2
        ///   INSR Ztied1.D, Dop2
        ///
        /// codegenarm64test:
        ///   sve_insr - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<double> InsertIntoShiftedVector(Vector<double> left, double right) => InsertIntoShiftedVector(left, right);


        ///  LeadingSignCount : Count leading sign bits

        /// <summary>
        /// svuint8_t svcls[_s8]_m(svuint8_t inactive, svbool_t pg, svint8_t op)
        ///   CLS Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; CLS Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcls[_s8]_x(svbool_t pg, svint8_t op)
        ///   CLS Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; CLS Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcls[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; CLS Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cls, EA_SCALABLE, REG_V31, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> LeadingSignCount(Vector<sbyte> value) => LeadingSignCount(value);

        /// <summary>
        /// svuint16_t svcls[_s16]_m(svuint16_t inactive, svbool_t pg, svint16_t op)
        ///   CLS Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; CLS Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcls[_s16]_x(svbool_t pg, svint16_t op)
        ///   CLS Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; CLS Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcls[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; CLS Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cls, EA_SCALABLE, REG_V31, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> LeadingSignCount(Vector<short> value) => LeadingSignCount(value);

        /// <summary>
        /// svuint32_t svcls[_s32]_m(svuint32_t inactive, svbool_t pg, svint32_t op)
        ///   CLS Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CLS Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcls[_s32]_x(svbool_t pg, svint32_t op)
        ///   CLS Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CLS Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcls[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CLS Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cls, EA_SCALABLE, REG_V31, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LeadingSignCount(Vector<int> value) => LeadingSignCount(value);

        /// <summary>
        /// svuint64_t svcls[_s64]_m(svuint64_t inactive, svbool_t pg, svint64_t op)
        ///   CLS Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CLS Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcls[_s64]_x(svbool_t pg, svint64_t op)
        ///   CLS Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CLS Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcls[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CLS Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLS <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cls, EA_SCALABLE, REG_V31, REG_P0, REG_V0, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LeadingSignCount(Vector<long> value) => LeadingSignCount(value);


        ///  LeadingZeroCount : Count leading zero bits

        /// <summary>
        /// svuint8_t svclz[_s8]_m(svuint8_t inactive, svbool_t pg, svint8_t op)
        ///   CLZ Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.B, Pg/M, Zop.B
        /// svuint8_t svclz[_s8]_x(svbool_t pg, svint8_t op)
        ///   CLZ Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.B, Pg/M, Zop.B
        /// svuint8_t svclz[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; CLZ Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> LeadingZeroCount(Vector<sbyte> value) => LeadingZeroCount(value);

        /// <summary>
        /// svuint8_t svclz[_u8]_m(svuint8_t inactive, svbool_t pg, svuint8_t op)
        ///   CLZ Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.B, Pg/M, Zop.B
        /// svuint8_t svclz[_u8]_x(svbool_t pg, svuint8_t op)
        ///   CLZ Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.B, Pg/M, Zop.B
        /// svuint8_t svclz[_u8]_z(svbool_t pg, svuint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; CLZ Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> LeadingZeroCount(Vector<byte> value) => LeadingZeroCount(value);

        /// <summary>
        /// svuint16_t svclz[_s16]_m(svuint16_t inactive, svbool_t pg, svint16_t op)
        ///   CLZ Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.H, Pg/M, Zop.H
        /// svuint16_t svclz[_s16]_x(svbool_t pg, svint16_t op)
        ///   CLZ Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.H, Pg/M, Zop.H
        /// svuint16_t svclz[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; CLZ Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> LeadingZeroCount(Vector<short> value) => LeadingZeroCount(value);

        /// <summary>
        /// svuint16_t svclz[_u16]_m(svuint16_t inactive, svbool_t pg, svuint16_t op)
        ///   CLZ Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.H, Pg/M, Zop.H
        /// svuint16_t svclz[_u16]_x(svbool_t pg, svuint16_t op)
        ///   CLZ Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.H, Pg/M, Zop.H
        /// svuint16_t svclz[_u16]_z(svbool_t pg, svuint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; CLZ Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> LeadingZeroCount(Vector<ushort> value) => LeadingZeroCount(value);

        /// <summary>
        /// svuint32_t svclz[_s32]_m(svuint32_t inactive, svbool_t pg, svint32_t op)
        ///   CLZ Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.S, Pg/M, Zop.S
        /// svuint32_t svclz[_s32]_x(svbool_t pg, svint32_t op)
        ///   CLZ Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.S, Pg/M, Zop.S
        /// svuint32_t svclz[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CLZ Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LeadingZeroCount(Vector<int> value) => LeadingZeroCount(value);

        /// <summary>
        /// svuint32_t svclz[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   CLZ Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.S, Pg/M, Zop.S
        /// svuint32_t svclz[_u32]_x(svbool_t pg, svuint32_t op)
        ///   CLZ Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.S, Pg/M, Zop.S
        /// svuint32_t svclz[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CLZ Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LeadingZeroCount(Vector<uint> value) => LeadingZeroCount(value);

        /// <summary>
        /// svuint64_t svclz[_s64]_m(svuint64_t inactive, svbool_t pg, svint64_t op)
        ///   CLZ Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.D, Pg/M, Zop.D
        /// svuint64_t svclz[_s64]_x(svbool_t pg, svint64_t op)
        ///   CLZ Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.D, Pg/M, Zop.D
        /// svuint64_t svclz[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CLZ Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LeadingZeroCount(Vector<long> value) => LeadingZeroCount(value);

        /// <summary>
        /// svuint64_t svclz[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   CLZ Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CLZ Zresult.D, Pg/M, Zop.D
        /// svuint64_t svclz[_u64]_x(svbool_t pg, svuint64_t op)
        ///   CLZ Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CLZ Zresult.D, Pg/M, Zop.D
        /// svuint64_t svclz[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CLZ Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CLZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_clz, EA_SCALABLE, REG_V30, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LeadingZeroCount(Vector<ulong> value) => LeadingZeroCount(value);


        ///  LoadVector : Unextended load

        /// <summary>
        /// svint8_t svld1[_s8](svbool_t pg, const int8_t *base)
        ///   LD1B Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.B, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<sbyte> LoadVector(Vector<sbyte> mask, sbyte* address) => LoadVector(mask, address);

        /// <summary>
        /// svint16_t svld1[_s16](svbool_t pg, const int16_t *base)
        ///   LD1H Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1H Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> LoadVector(Vector<short> mask, short* address) => LoadVector(mask, address);

        /// <summary>
        /// svint32_t svld1[_s32](svbool_t pg, const int32_t *base)
        ///   LD1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVector(Vector<int> mask, int* address) => LoadVector(mask, address);

        /// <summary>
        /// svint64_t svld1[_s64](svbool_t pg, const int64_t *base)
        ///   LD1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVector(Vector<long> mask, long* address) => LoadVector(mask, address);

        /// <summary>
        /// svuint8_t svld1[_u8](svbool_t pg, const uint8_t *base)
        ///   LD1B Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.B, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<byte> LoadVector(Vector<byte> mask, byte* address) => LoadVector(mask, address);

        /// <summary>
        /// svuint16_t svld1[_u16](svbool_t pg, const uint16_t *base)
        ///   LD1H Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1H Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> LoadVector(Vector<ushort> mask, ushort* address) => LoadVector(mask, address);

        /// <summary>
        /// svuint32_t svld1[_u32](svbool_t pg, const uint32_t *base)
        ///   LD1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVector(Vector<uint> mask, uint* address) => LoadVector(mask, address);

        /// <summary>
        /// svuint64_t svld1[_u64](svbool_t pg, const uint64_t *base)
        ///   LD1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVector(Vector<ulong> mask, ulong* address) => LoadVector(mask, address);

        /// <summary>
        /// svfloat32_t svld1[_f32](svbool_t pg, const float32_t *base)
        ///   LD1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> LoadVector(Vector<float> mask, float* address) => LoadVector(mask, address);

        /// <summary>
        /// svfloat64_t svld1[_f64](svbool_t pg, const float64_t *base)
        ///   LD1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V5, REG_P3, REG_R4, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IH_3A_A  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 5, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_IU_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_C  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_II_4A  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_II_4A_B  LD1D {<Zt>.Q }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R4, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_D  LD1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1d, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1d, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> LoadVector(Vector<double> mask, double* address) => LoadVector(mask, address);


        ///  LoadVector128AndReplicateToVector : Load and replicate 128 bits of data

        /// <summary>
        /// svint8_t svld1rq[_s8](svbool_t pg, const int8_t *base)
        ///   LD1RQB Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LD1RQB Zresult.B, Pg/Z, [Xarray, #index]
        ///   LD1RQB Zresult.B, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQB {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqb, EA_SCALABLE, REG_V6, REG_P7, REG_R8, 64, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IP_4A  LD1RQB {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqb, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R2, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<sbyte> LoadVector128AndReplicateToVector(Vector<sbyte> mask, sbyte* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svint16_t svld1rq[_s16](svbool_t pg, const int16_t *base)
        ///   LD1RQH Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1RQH Zresult.H, Pg/Z, [Xarray, #index * 2]
        ///   LD1RQH Zresult.H, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQH {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqh, EA_SCALABLE, REG_V4, REG_P5, REG_R6, 112, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IP_4A  LD1RQH {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqh, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<short> LoadVector128AndReplicateToVector(Vector<short> mask, short* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svint32_t svld1rq[_s32](svbool_t pg, const int32_t *base)
        ///   LD1RQW Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1RQW Zresult.S, Pg/Z, [Xarray, #index * 4]
        ///   LD1RQW Zresult.S, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQW {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqw, EA_SCALABLE, REG_V31, REG_P2, REG_R1, -16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IP_4A  LD1RQW {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<int> LoadVector128AndReplicateToVector(Vector<int> mask, int* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svint64_t svld1rq[_s64](svbool_t pg, const int64_t *base)
        ///   LD1RQD Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD1RQD Zresult.D, Pg/Z, [Xarray, #index * 8]
        ///   LD1RQD Zresult.D, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQD {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqd, EA_SCALABLE, REG_V9, REG_P0, REG_R1, -128, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IP_4A  LD1RQD {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqd, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<long> LoadVector128AndReplicateToVector(Vector<long> mask, long* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svuint8_t svld1rq[_u8](svbool_t pg, const uint8_t *base)
        ///   LD1RQB Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LD1RQB Zresult.B, Pg/Z, [Xarray, #index]
        ///   LD1RQB Zresult.B, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQB {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqb, EA_SCALABLE, REG_V6, REG_P7, REG_R8, 64, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IP_4A  LD1RQB {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqb, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R2, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> LoadVector128AndReplicateToVector(Vector<byte> mask, byte* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svuint16_t svld1rq[_u16](svbool_t pg, const uint16_t *base)
        ///   LD1RQH Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1RQH Zresult.H, Pg/Z, [Xarray, #index * 2]
        ///   LD1RQH Zresult.H, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQH {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqh, EA_SCALABLE, REG_V4, REG_P5, REG_R6, 112, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IP_4A  LD1RQH {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqh, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<ushort> LoadVector128AndReplicateToVector(Vector<ushort> mask, ushort* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svuint32_t svld1rq[_u32](svbool_t pg, const uint32_t *base)
        ///   LD1RQW Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1RQW Zresult.S, Pg/Z, [Xarray, #index * 4]
        ///   LD1RQW Zresult.S, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQW {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqw, EA_SCALABLE, REG_V31, REG_P2, REG_R1, -16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IP_4A  LD1RQW {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<uint> LoadVector128AndReplicateToVector(Vector<uint> mask, uint* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svuint64_t svld1rq[_u64](svbool_t pg, const uint64_t *base)
        ///   LD1RQD Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD1RQD Zresult.D, Pg/Z, [Xarray, #index * 8]
        ///   LD1RQD Zresult.D, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQD {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqd, EA_SCALABLE, REG_V9, REG_P0, REG_R1, -128, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IP_4A  LD1RQD {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqd, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<ulong> LoadVector128AndReplicateToVector(Vector<ulong> mask, ulong* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svfloat32_t svld1rq[_f32](svbool_t pg, const float32_t *base)
        ///   LD1RQW Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1RQW Zresult.S, Pg/Z, [Xarray, #index * 4]
        ///   LD1RQW Zresult.S, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQW {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqw, EA_SCALABLE, REG_V31, REG_P2, REG_R1, -16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IP_4A  LD1RQW {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<float> LoadVector128AndReplicateToVector(Vector<float> mask, float* address) => LoadVector128AndReplicateToVector(mask, address);

        /// <summary>
        /// svfloat64_t svld1rq[_f64](svbool_t pg, const float64_t *base)
        ///   LD1RQD Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD1RQD Zresult.D, Pg/Z, [Xarray, #index * 8]
        ///   LD1RQD Zresult.D, Pg/Z, [Xbase, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IO_3A  LD1RQD {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1rqd, EA_SCALABLE, REG_V9, REG_P0, REG_R1, -128, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IP_4A  LD1RQD {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1rqd, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<double> LoadVector128AndReplicateToVector(Vector<double> mask, double* address) => LoadVector128AndReplicateToVector(mask, address);


        ///  LoadVectorByteNonFaultingZeroExtendToInt16 : Load 8-bit data and zero-extend, non-faulting

        /// <summary>
        /// svint16_t svldnf1ub_s16(svbool_t pg, const uint8_t *base)
        ///   LDNF1B Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> LoadVectorByteNonFaultingZeroExtendToInt16(byte* address) => LoadVectorByteNonFaultingZeroExtendToInt16(address);


        ///  LoadVectorByteNonFaultingZeroExtendToInt32 : Load 8-bit data and zero-extend, non-faulting

        /// <summary>
        /// svint32_t svldnf1ub_s32(svbool_t pg, const uint8_t *base)
        ///   LDNF1B Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> LoadVectorByteNonFaultingZeroExtendToInt32(byte* address) => LoadVectorByteNonFaultingZeroExtendToInt32(address);


        ///  LoadVectorByteNonFaultingZeroExtendToInt64 : Load 8-bit data and zero-extend, non-faulting

        /// <summary>
        /// svint64_t svldnf1ub_s64(svbool_t pg, const uint8_t *base)
        ///   LDNF1B Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> LoadVectorByteNonFaultingZeroExtendToInt64(byte* address) => LoadVectorByteNonFaultingZeroExtendToInt64(address);


        ///  LoadVectorByteNonFaultingZeroExtendToUInt16 : Load 8-bit data and zero-extend, non-faulting

        /// <summary>
        /// svuint16_t svldnf1ub_u16(svbool_t pg, const uint8_t *base)
        ///   LDNF1B Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorByteNonFaultingZeroExtendToUInt16(byte* address) => LoadVectorByteNonFaultingZeroExtendToUInt16(address);


        ///  LoadVectorByteNonFaultingZeroExtendToUInt32 : Load 8-bit data and zero-extend, non-faulting

        /// <summary>
        /// svuint32_t svldnf1ub_u32(svbool_t pg, const uint8_t *base)
        ///   LDNF1B Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LoadVectorByteNonFaultingZeroExtendToUInt32(byte* address) => LoadVectorByteNonFaultingZeroExtendToUInt32(address);


        ///  LoadVectorByteNonFaultingZeroExtendToUInt64 : Load 8-bit data and zero-extend, non-faulting

        /// <summary>
        /// svuint64_t svldnf1ub_u64(svbool_t pg, const uint8_t *base)
        ///   LDNF1B Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorByteNonFaultingZeroExtendToUInt64(byte* address) => LoadVectorByteNonFaultingZeroExtendToUInt64(address);


        ///  LoadVectorByteZeroExtendFirstFaulting : Load 8-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint16_t svldff1ub_s16(svbool_t pg, const uint8_t *base)
        ///   LDFF1B Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.H, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> LoadVectorByteZeroExtendFirstFaulting(Vector<short> mask, byte* address) => LoadVectorByteZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svint32_t svldff1ub_s32(svbool_t pg, const uint8_t *base)
        ///   LDFF1B Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.S, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorByteZeroExtendFirstFaulting(Vector<int> mask, byte* address) => LoadVectorByteZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svint64_t svldff1ub_s64(svbool_t pg, const uint8_t *base)
        ///   LDFF1B Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.D, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorByteZeroExtendFirstFaulting(Vector<long> mask, byte* address) => LoadVectorByteZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint16_t svldff1ub_u16(svbool_t pg, const uint8_t *base)
        ///   LDFF1B Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.H, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorByteZeroExtendFirstFaulting(Vector<ushort> mask, byte* address) => LoadVectorByteZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint32_t svldff1ub_u32(svbool_t pg, const uint8_t *base)
        ///   LDFF1B Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.S, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorByteZeroExtendFirstFaulting(Vector<uint> mask, byte* address) => LoadVectorByteZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint64_t svldff1ub_u64(svbool_t pg, const uint8_t *base)
        ///   LDFF1B Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.D, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorByteZeroExtendFirstFaulting(Vector<ulong> mask, byte* address) => LoadVectorByteZeroExtendFirstFaulting(mask, address);


        ///  LoadVectorByteZeroExtendToInt16 : Load 8-bit data and zero-extend

        /// <summary>
        /// svint16_t svld1ub_s16(svbool_t pg, const uint8_t *base)
        ///   LD1B Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> LoadVectorByteZeroExtendToInt16(Vector<short> mask, byte* address) => LoadVectorByteZeroExtendToInt16(mask, address);


        ///  LoadVectorByteZeroExtendToInt32 : Load 8-bit data and zero-extend

        /// <summary>
        /// svint32_t svld1ub_s32(svbool_t pg, const uint8_t *base)
        ///   LD1B Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorByteZeroExtendToInt32(Vector<int> mask, byte* address) => LoadVectorByteZeroExtendToInt32(mask, address);


        ///  LoadVectorByteZeroExtendToInt64 : Load 8-bit data and zero-extend

        /// <summary>
        /// svint64_t svld1ub_s64(svbool_t pg, const uint8_t *base)
        ///   LD1B Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorByteZeroExtendToInt64(Vector<long> mask, byte* address) => LoadVectorByteZeroExtendToInt64(mask, address);


        ///  LoadVectorByteZeroExtendToUInt16 : Load 8-bit data and zero-extend

        /// <summary>
        /// svuint16_t svld1ub_u16(svbool_t pg, const uint8_t *base)
        ///   LD1B Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorByteZeroExtendToUInt16(Vector<ushort> mask, byte* address) => LoadVectorByteZeroExtendToUInt16(mask, address);


        ///  LoadVectorByteZeroExtendToUInt32 : Load 8-bit data and zero-extend

        /// <summary>
        /// svuint32_t svld1ub_u32(svbool_t pg, const uint8_t *base)
        ///   LD1B Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorByteZeroExtendToUInt32(Vector<uint> mask, byte* address) => LoadVectorByteZeroExtendToUInt32(mask, address);


        ///  LoadVectorByteZeroExtendToUInt64 : Load 8-bit data and zero-extend

        /// <summary>
        /// svuint64_t svld1ub_u64(svbool_t pg, const uint8_t *base)
        ///   LD1B Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LD1B Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_E  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P1, REG_R3, 7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_H  LD1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1b, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1b, EA_SCALABLE, REG_V0, REG_P0, REG_V1, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorByteZeroExtendToUInt64(Vector<ulong> mask, byte* address) => LoadVectorByteZeroExtendToUInt64(mask, address);


        ///  LoadVectorFirstFaulting : Unextended load, first-faulting

        /// <summary>
        /// svint8_t svldff1[_s8](svbool_t pg, const int8_t *base)
        ///   LDFF1B Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.B, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<sbyte> LoadVectorFirstFaulting(Vector<sbyte> mask, sbyte* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svint16_t svldff1[_s16](svbool_t pg, const int16_t *base)
        ///   LDFF1H Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1H Zresult.H, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> LoadVectorFirstFaulting(Vector<short> mask, short* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svint32_t svldff1[_s32](svbool_t pg, const int32_t *base)
        ///   LDFF1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, XZR, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorFirstFaulting(Vector<int> mask, int* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svint64_t svldff1[_s64](svbool_t pg, const int64_t *base)
        ///   LDFF1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, XZR, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorFirstFaulting(Vector<long> mask, long* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svuint8_t svldff1[_u8](svbool_t pg, const uint8_t *base)
        ///   LDFF1B Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LDFF1B Zresult.B, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1B {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1B {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V2, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_E  LDFF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1b, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_R1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1b, EA_SCALABLE, REG_V4, REG_P3, REG_V1, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<byte> LoadVectorFirstFaulting(Vector<byte> mask, byte* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svuint16_t svldff1[_u16](svbool_t pg, const uint16_t *base)
        ///   LDFF1H Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1H Zresult.H, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorFirstFaulting(Vector<ushort> mask, ushort* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svuint32_t svldff1[_u32](svbool_t pg, const uint32_t *base)
        ///   LDFF1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, XZR, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorFirstFaulting(Vector<uint> mask, uint* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svuint64_t svldff1[_u64](svbool_t pg, const uint64_t *base)
        ///   LDFF1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, XZR, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorFirstFaulting(Vector<ulong> mask, ulong* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svfloat32_t svldff1[_f32](svbool_t pg, const float32_t *base)
        ///   LDFF1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDFF1W Zresult.S, Pg/Z, [Xbase, XZR, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> LoadVectorFirstFaulting(Vector<float> mask, float* address) => LoadVectorFirstFaulting(mask, address);

        /// <summary>
        /// svfloat64_t svldff1[_f64](svbool_t pg, const float64_t *base)
        ///   LDFF1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LDFF1D Zresult.D, Pg/Z, [Xbase, XZR, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V6, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V5, REG_P6, REG_R7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1d, EA_SCALABLE, REG_V2, REG_P6, REG_R5, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1d, EA_SCALABLE, REG_V7, REG_P3, REG_V1, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> LoadVectorFirstFaulting(Vector<double> mask, double* address) => LoadVectorFirstFaulting(mask, address);


        ///  LoadVectorInt16NonFaultingSignExtendToInt32 : Load 16-bit data and sign-extend, non-faulting

        /// <summary>
        /// svint32_t svldnf1sh_s32(svbool_t pg, const int16_t *base)
        ///   LDNF1SH Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> LoadVectorInt16NonFaultingSignExtendToInt32(short* address) => LoadVectorInt16NonFaultingSignExtendToInt32(address);


        ///  LoadVectorInt16NonFaultingSignExtendToInt64 : Load 16-bit data and sign-extend, non-faulting

        /// <summary>
        /// svint64_t svldnf1sh_s64(svbool_t pg, const int16_t *base)
        ///   LDNF1SH Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> LoadVectorInt16NonFaultingSignExtendToInt64(short* address) => LoadVectorInt16NonFaultingSignExtendToInt64(address);


        ///  LoadVectorInt16NonFaultingSignExtendToUInt32 : Load 16-bit data and sign-extend, non-faulting

        /// <summary>
        /// svuint32_t svldnf1sh_u32(svbool_t pg, const int16_t *base)
        ///   LDNF1SH Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LoadVectorInt16NonFaultingSignExtendToUInt32(short* address) => LoadVectorInt16NonFaultingSignExtendToUInt32(address);


        ///  LoadVectorInt16NonFaultingSignExtendToUInt64 : Load 16-bit data and sign-extend, non-faulting

        /// <summary>
        /// svuint64_t svldnf1sh_u64(svbool_t pg, const int16_t *base)
        ///   LDNF1SH Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sh, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorInt16NonFaultingSignExtendToUInt64(short* address) => LoadVectorInt16NonFaultingSignExtendToUInt64(address);


        ///  LoadVectorInt16SignExtendFirstFaulting : Load 16-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1sh_s32(svbool_t pg, const int16_t *base)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorInt16SignExtendFirstFaulting(Vector<int> mask, short* address) => LoadVectorInt16SignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svint64_t svldff1sh_s64(svbool_t pg, const int16_t *base)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorInt16SignExtendFirstFaulting(Vector<long> mask, short* address) => LoadVectorInt16SignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint32_t svldff1sh_u32(svbool_t pg, const int16_t *base)
        ///   LDFF1SH Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1SH Zresult.S, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorInt16SignExtendFirstFaulting(Vector<uint> mask, short* address) => LoadVectorInt16SignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint64_t svldff1sh_u64(svbool_t pg, const int16_t *base)
        ///   LDFF1SH Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1SH Zresult.D, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_V5, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sh, EA_SCALABLE, REG_V4, REG_P3, REG_R1, REG_R2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sh, EA_SCALABLE, REG_V3, REG_P5, REG_V4, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorInt16SignExtendFirstFaulting(Vector<ulong> mask, short* address) => LoadVectorInt16SignExtendFirstFaulting(mask, address);


        ///  LoadVectorInt16SignExtendToInt32 : Load 16-bit data and sign-extend

        /// <summary>
        /// svint32_t svld1sh_s32(svbool_t pg, const int16_t *base)
        ///   LD1SH Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorInt16SignExtendToInt32(Vector<int> mask, short* address) => LoadVectorInt16SignExtendToInt32(mask, address);


        ///  LoadVectorInt16SignExtendToInt64 : Load 16-bit data and sign-extend

        /// <summary>
        /// svint64_t svld1sh_s64(svbool_t pg, const int16_t *base)
        ///   LD1SH Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorInt16SignExtendToInt64(Vector<long> mask, short* address) => LoadVectorInt16SignExtendToInt64(mask, address);


        ///  LoadVectorInt16SignExtendToUInt32 : Load 16-bit data and sign-extend

        /// <summary>
        /// svuint32_t svld1sh_u32(svbool_t pg, const int16_t *base)
        ///   LD1SH Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1SH Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorInt16SignExtendToUInt32(Vector<uint> mask, short* address) => LoadVectorInt16SignExtendToUInt32(mask, address);


        ///  LoadVectorInt16SignExtendToUInt64 : Load 16-bit data and sign-extend

        /// <summary>
        /// svuint64_t svld1sh_u64(svbool_t pg, const int16_t *base)
        ///   LD1SH Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1SH Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_F  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V7, REG_P3, REG_R5, 2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V3, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_G  LD1SH {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1SH {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sh, EA_SCALABLE, REG_V2, REG_P4, REG_V3, 2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorInt16SignExtendToUInt64(Vector<ulong> mask, short* address) => LoadVectorInt16SignExtendToUInt64(mask, address);


        ///  LoadVectorInt32NonFaultingSignExtendToInt64 : Load 32-bit data and sign-extend, non-faulting

        /// <summary>
        /// svint64_t svldnf1sw_s64(svbool_t pg, const int32_t *base)
        ///   LDNF1SW Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A  LDNF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sw, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> LoadVectorInt32NonFaultingSignExtendToInt64(int* address) => LoadVectorInt32NonFaultingSignExtendToInt64(address);


        ///  LoadVectorInt32NonFaultingSignExtendToUInt64 : Load 32-bit data and sign-extend, non-faulting

        /// <summary>
        /// svuint64_t svldnf1sw_u64(svbool_t pg, const int32_t *base)
        ///   LDNF1SW Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A  LDNF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sw, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorInt32NonFaultingSignExtendToUInt64(int* address) => LoadVectorInt32NonFaultingSignExtendToUInt64(address);


        ///  LoadVectorInt32SignExtendFirstFaulting : Load 32-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint64_t svldff1sw_s64(svbool_t pg, const int32_t *base)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, XZR, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorInt32SignExtendFirstFaulting(Vector<long> mask, int* address) => LoadVectorInt32SignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint64_t svldff1sw_u64(svbool_t pg, const int32_t *base)
        ///   LDFF1SW Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDFF1SW Zresult.D, Pg/Z, [Xbase, XZR, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IU_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V0, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IG_4A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P0, REG_R10, REG_V9, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sw, EA_SCALABLE, REG_V3, REG_P4, REG_R6, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sw, EA_SCALABLE, REG_V2, REG_P0, REG_V4, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorInt32SignExtendFirstFaulting(Vector<ulong> mask, int* address) => LoadVectorInt32SignExtendFirstFaulting(mask, address);


        ///  LoadVectorInt32SignExtendToInt64 : Load 32-bit data and sign-extend

        /// <summary>
        /// svint64_t svld1sw_s64(svbool_t pg, const int32_t *base)
        ///   LD1SW Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorInt32SignExtendToInt64(Vector<long> mask, int* address) => LoadVectorInt32SignExtendToInt64(mask, address);


        ///  LoadVectorInt32SignExtendToUInt64 : Load 32-bit data and sign-extend

        /// <summary>
        /// svuint64_t svld1sw_u64(svbool_t pg, const int32_t *base)
        ///   LD1SW Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1SW Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P5, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IU_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_IU_4A_A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_IK_4A  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IU_4B_B  LD1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sw, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IV_3A  LD1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sw, EA_SCALABLE, REG_V6, REG_P5, REG_V4, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorInt32SignExtendToUInt64(Vector<ulong> mask, int* address) => LoadVectorInt32SignExtendToUInt64(mask, address);


        ///  LoadVectorNonFaulting : Unextended load, non-faulting

        /// <summary>
        /// svint8_t svldnf1[_s8](svbool_t pg, const int8_t *base)
        ///   LDNF1B Zresult.B, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> LoadVectorNonFaulting(sbyte* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svint16_t svldnf1[_s16](svbool_t pg, const int16_t *base)
        ///   LDNF1H Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> LoadVectorNonFaulting(short* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svint32_t svldnf1[_s32](svbool_t pg, const int32_t *base)
        ///   LDNF1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> LoadVectorNonFaulting(int* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svint64_t svldnf1[_s64](svbool_t pg, const int64_t *base)
        ///   LDNF1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A  LDNF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1d, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> LoadVectorNonFaulting(long* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svuint8_t svldnf1[_u8](svbool_t pg, const uint8_t *base)
        ///   LDNF1B Zresult.B, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_C  LDNF1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, -2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1b, EA_SCALABLE, REG_V2, REG_P5, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> LoadVectorNonFaulting(byte* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svuint16_t svldnf1[_u16](svbool_t pg, const uint16_t *base)
        ///   LDNF1H Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorNonFaulting(ushort* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svuint32_t svldnf1[_u32](svbool_t pg, const uint32_t *base)
        ///   LDNF1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LoadVectorNonFaulting(uint* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svuint64_t svldnf1[_u64](svbool_t pg, const uint64_t *base)
        ///   LDNF1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A  LDNF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1d, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorNonFaulting(ulong* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svfloat32_t svldnf1[_f32](svbool_t pg, const float32_t *base)
        ///   LDNF1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> LoadVectorNonFaulting(float* address) => LoadVectorNonFaulting(address);

        /// <summary>
        /// svfloat64_t svldnf1[_f64](svbool_t pg, const float64_t *base)
        ///   LDNF1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A  LDNF1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1d, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> LoadVectorNonFaulting(double* address) => LoadVectorNonFaulting(address);


        ///  LoadVectorNonTemporal : Unextended load, non-temporal

        /// <summary>
        /// svint8_t svldnt1[_s8](svbool_t pg, const int8_t *base)
        ///   LDNT1B Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LDNT1B Zresult.B, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, -5, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IF_4A  LDNT1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1b, EA_SCALABLE, REG_V3, REG_P2, REG_V1, REG_R0, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A_A  LDNT1B {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1b, EA_SCALABLE, REG_V0, REG_P2, REG_V4, REG_R3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1b, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<sbyte> LoadVectorNonTemporal(Vector<sbyte> mask, sbyte* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svint16_t svldnt1[_s16](svbool_t pg, const int16_t *base)
        ///   LDNT1H Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDNT1H Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1h, EA_SCALABLE, REG_V6, REG_P7, REG_R8, 0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IF_4A  LDNT1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1h, EA_SCALABLE, REG_V0, REG_P1, REG_V2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A_A  LDNT1H {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1h, EA_SCALABLE, REG_V1, REG_P4, REG_V3, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<short> LoadVectorNonTemporal(Vector<short> mask, short* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svint32_t svldnt1[_s32](svbool_t pg, const int32_t *base)
        ///   LDNT1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDNT1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, -8, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V4, REG_ZR, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A_A  LDNT1W {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V4, REG_P1, REG_V2, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V2, REG_P0, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<int> LoadVectorNonTemporal(Vector<int> mask, int* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svint64_t svldnt1[_s64](svbool_t pg, const int64_t *base)
        ///   LDNT1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LDNT1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, -1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IX_4A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1d, EA_SCALABLE, REG_V4, REG_P2, REG_V1, REG_R3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorNonTemporal(Vector<long> mask, long* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svuint8_t svldnt1[_u8](svbool_t pg, const uint8_t *base)
        ///   LDNT1B Zresult.B, Pg/Z, [Xarray, Xindex]
        ///   LDNT1B Zresult.B, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, -5, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IF_4A  LDNT1B {<Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1b, EA_SCALABLE, REG_V3, REG_P2, REG_V1, REG_R0, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A_A  LDNT1B {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1b, EA_SCALABLE, REG_V0, REG_P2, REG_V4, REG_R3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1B {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1b, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> LoadVectorNonTemporal(Vector<byte> mask, byte* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svuint16_t svldnt1[_u16](svbool_t pg, const uint16_t *base)
        ///   LDNT1H Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDNT1H Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1h, EA_SCALABLE, REG_V6, REG_P7, REG_R8, 0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IF_4A  LDNT1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1h, EA_SCALABLE, REG_V0, REG_P1, REG_V2, REG_R3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A_A  LDNT1H {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1h, EA_SCALABLE, REG_V1, REG_P4, REG_V3, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorNonTemporal(Vector<ushort> mask, ushort* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svuint32_t svldnt1[_u32](svbool_t pg, const uint32_t *base)
        ///   LDNT1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDNT1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, -8, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V4, REG_ZR, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A_A  LDNT1W {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V4, REG_P1, REG_V2, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V2, REG_P0, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorNonTemporal(Vector<uint> mask, uint* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svuint64_t svldnt1[_u64](svbool_t pg, const uint64_t *base)
        ///   LDNT1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LDNT1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, -1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IX_4A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1d, EA_SCALABLE, REG_V4, REG_P2, REG_V1, REG_R3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorNonTemporal(Vector<ulong> mask, ulong* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svfloat32_t svldnt1[_f32](svbool_t pg, const float32_t *base)
        ///   LDNT1W Zresult.S, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDNT1W Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, -8, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V4, REG_ZR, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IF_4A_A  LDNT1W {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V4, REG_P1, REG_V2, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1w, EA_SCALABLE, REG_V2, REG_P0, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe Vector<float> LoadVectorNonTemporal(Vector<float> mask, float* address) => LoadVectorNonTemporal(mask, address);

        /// <summary>
        /// svfloat64_t svldnt1[_f64](svbool_t pg, const float64_t *base)
        ///   LDNT1D Zresult.D, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LDNT1D Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IM_3A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnt1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, -1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IN_4A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_IX_4A  LDNT1D {<Zt>.D }, <Pg>/Z, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldnt1d, EA_SCALABLE, REG_V4, REG_P2, REG_V1, REG_R3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> LoadVectorNonTemporal(Vector<double> mask, double* address) => LoadVectorNonTemporal(mask, address);


        ///  LoadVectorSByteNonFaultingSignExtendToInt16 : Load 8-bit data and sign-extend, non-faulting

        /// <summary>
        /// svint16_t svldnf1sb_s16(svbool_t pg, const int8_t *base)
        ///   LDNF1SB Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> LoadVectorSByteNonFaultingSignExtendToInt16(sbyte* address) => LoadVectorSByteNonFaultingSignExtendToInt16(address);


        ///  LoadVectorSByteNonFaultingSignExtendToInt32 : Load 8-bit data and sign-extend, non-faulting

        /// <summary>
        /// svint32_t svldnf1sb_s32(svbool_t pg, const int8_t *base)
        ///   LDNF1SB Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> LoadVectorSByteNonFaultingSignExtendToInt32(sbyte* address) => LoadVectorSByteNonFaultingSignExtendToInt32(address);


        ///  LoadVectorSByteNonFaultingSignExtendToInt64 : Load 8-bit data and sign-extend, non-faulting

        /// <summary>
        /// svint64_t svldnf1sb_s64(svbool_t pg, const int8_t *base)
        ///   LDNF1SB Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> LoadVectorSByteNonFaultingSignExtendToInt64(sbyte* address) => LoadVectorSByteNonFaultingSignExtendToInt64(address);


        ///  LoadVectorSByteNonFaultingSignExtendToUInt16 : Load 8-bit data and sign-extend, non-faulting

        /// <summary>
        /// svuint16_t svldnf1sb_u16(svbool_t pg, const int8_t *base)
        ///   LDNF1SB Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorSByteNonFaultingSignExtendToUInt16(sbyte* address) => LoadVectorSByteNonFaultingSignExtendToUInt16(address);


        ///  LoadVectorSByteNonFaultingSignExtendToUInt32 : Load 8-bit data and sign-extend, non-faulting

        /// <summary>
        /// svuint32_t svldnf1sb_u32(svbool_t pg, const int8_t *base)
        ///   LDNF1SB Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LoadVectorSByteNonFaultingSignExtendToUInt32(sbyte* address) => LoadVectorSByteNonFaultingSignExtendToUInt32(address);


        ///  LoadVectorSByteNonFaultingSignExtendToUInt64 : Load 8-bit data and sign-extend, non-faulting

        /// <summary>
        /// svuint64_t svldnf1sb_u64(svbool_t pg, const int8_t *base)
        ///   LDNF1SB Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1sb, EA_SCALABLE, REG_V0, REG_P4, REG_R1, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorSByteNonFaultingSignExtendToUInt64(sbyte* address) => LoadVectorSByteNonFaultingSignExtendToUInt64(address);


        ///  LoadVectorSByteSignExtendFirstFaulting : Load 8-bit data and sign-extend, first-faulting

        /// <summary>
        /// svint16_t svldff1sb_s16(svbool_t pg, const int8_t *base)
        ///   LDFF1SB Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LDFF1SB Zresult.H, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> LoadVectorSByteSignExtendFirstFaulting(Vector<short> mask, sbyte* address) => LoadVectorSByteSignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svint32_t svldff1sb_s32(svbool_t pg, const int8_t *base)
        ///   LDFF1SB Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LDFF1SB Zresult.S, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorSByteSignExtendFirstFaulting(Vector<int> mask, sbyte* address) => LoadVectorSByteSignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svint64_t svldff1sb_s64(svbool_t pg, const int8_t *base)
        ///   LDFF1SB Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LDFF1SB Zresult.D, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorSByteSignExtendFirstFaulting(Vector<long> mask, sbyte* address) => LoadVectorSByteSignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint16_t svldff1sb_u16(svbool_t pg, const int8_t *base)
        ///   LDFF1SB Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LDFF1SB Zresult.H, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorSByteSignExtendFirstFaulting(Vector<ushort> mask, sbyte* address) => LoadVectorSByteSignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint32_t svldff1sb_u32(svbool_t pg, const int8_t *base)
        ///   LDFF1SB Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LDFF1SB Zresult.S, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorSByteSignExtendFirstFaulting(Vector<uint> mask, sbyte* address) => LoadVectorSByteSignExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint64_t svldff1sb_u64(svbool_t pg, const int8_t *base)
        ///   LDFF1SB Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LDFF1SB Zresult.D, Pg/Z, [Xbase, XZR]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P1, REG_R4, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_D  LDFF1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1sb, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LDFF1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1sb, EA_SCALABLE, REG_V2, REG_P6, REG_V0, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorSByteSignExtendFirstFaulting(Vector<ulong> mask, sbyte* address) => LoadVectorSByteSignExtendFirstFaulting(mask, address);


        ///  LoadVectorSByteSignExtendToInt16 : Load 8-bit data and sign-extend

        /// <summary>
        /// svint16_t svld1sb_s16(svbool_t pg, const int8_t *base)
        ///   LD1SB Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LD1SB Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> LoadVectorSByteSignExtendToInt16(Vector<short> mask, sbyte* address) => LoadVectorSByteSignExtendToInt16(mask, address);


        ///  LoadVectorSByteSignExtendToInt32 : Load 8-bit data and sign-extend

        /// <summary>
        /// svint32_t svld1sb_s32(svbool_t pg, const int8_t *base)
        ///   LD1SB Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LD1SB Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorSByteSignExtendToInt32(Vector<int> mask, sbyte* address) => LoadVectorSByteSignExtendToInt32(mask, address);


        ///  LoadVectorSByteSignExtendToInt64 : Load 8-bit data and sign-extend

        /// <summary>
        /// svint64_t svld1sb_s64(svbool_t pg, const int8_t *base)
        ///   LD1SB Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LD1SB Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorSByteSignExtendToInt64(Vector<long> mask, sbyte* address) => LoadVectorSByteSignExtendToInt64(mask, address);


        ///  LoadVectorSByteSignExtendToUInt16 : Load 8-bit data and sign-extend

        /// <summary>
        /// svuint16_t svld1sb_u16(svbool_t pg, const int8_t *base)
        ///   LD1SB Zresult.H, Pg/Z, [Xarray, Xindex]
        ///   LD1SB Zresult.H, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> LoadVectorSByteSignExtendToUInt16(Vector<ushort> mask, sbyte* address) => LoadVectorSByteSignExtendToUInt16(mask, address);


        ///  LoadVectorSByteSignExtendToUInt32 : Load 8-bit data and sign-extend

        /// <summary>
        /// svuint32_t svld1sb_u32(svbool_t pg, const int8_t *base)
        ///   LD1SB Zresult.S, Pg/Z, [Xarray, Xindex]
        ///   LD1SB Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorSByteSignExtendToUInt32(Vector<uint> mask, sbyte* address) => LoadVectorSByteSignExtendToUInt32(mask, address);


        ///  LoadVectorSByteSignExtendToUInt64 : Load 8-bit data and sign-extend

        /// <summary>
        /// svuint64_t svld1sb_u64(svbool_t pg, const int8_t *base)
        ///   LD1SB Zresult.D, Pg/Z, [Xarray, Xindex]
        ///   LD1SB Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_D  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P0, REG_R2, 6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P0, REG_R1, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_A  LD1SB {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V6, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_F  LD1SB {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1sb, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HX_3A_B  LD1SB {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1sb, EA_SCALABLE, REG_V2, REG_P7, REG_V3, 5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorSByteSignExtendToUInt64(Vector<ulong> mask, sbyte* address) => LoadVectorSByteSignExtendToUInt64(mask, address);


        ///  LoadVectorUInt16NonFaultingZeroExtendToInt32 : Load 16-bit data and zero-extend, non-faulting

        /// <summary>
        /// svint32_t svldnf1uh_s32(svbool_t pg, const uint16_t *base)
        ///   LDNF1H Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> LoadVectorUInt16NonFaultingZeroExtendToInt32(ushort* address) => LoadVectorUInt16NonFaultingZeroExtendToInt32(address);


        ///  LoadVectorUInt16NonFaultingZeroExtendToInt64 : Load 16-bit data and zero-extend, non-faulting

        /// <summary>
        /// svint64_t svldnf1uh_s64(svbool_t pg, const uint16_t *base)
        ///   LDNF1H Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> LoadVectorUInt16NonFaultingZeroExtendToInt64(ushort* address) => LoadVectorUInt16NonFaultingZeroExtendToInt64(address);


        ///  LoadVectorUInt16NonFaultingZeroExtendToUInt32 : Load 16-bit data and zero-extend, non-faulting

        /// <summary>
        /// svuint32_t svldnf1uh_u32(svbool_t pg, const uint16_t *base)
        ///   LDNF1H Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> LoadVectorUInt16NonFaultingZeroExtendToUInt32(ushort* address) => LoadVectorUInt16NonFaultingZeroExtendToUInt32(address);


        ///  LoadVectorUInt16NonFaultingZeroExtendToUInt64 : Load 16-bit data and zero-extend, non-faulting

        /// <summary>
        /// svuint64_t svldnf1uh_u64(svbool_t pg, const uint16_t *base)
        ///   LDNF1H Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_B  LDNF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1h, EA_SCALABLE, REG_V1, REG_P3, REG_R2, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorUInt16NonFaultingZeroExtendToUInt64(ushort* address) => LoadVectorUInt16NonFaultingZeroExtendToUInt64(address);


        ///  LoadVectorUInt16ZeroExtendFirstFaulting : Load 16-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint32_t svldff1uh_s32(svbool_t pg, const uint16_t *base)
        ///   LDFF1H Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorUInt16ZeroExtendFirstFaulting(Vector<int> mask, ushort* address) => LoadVectorUInt16ZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svint64_t svldff1uh_s64(svbool_t pg, const uint16_t *base)
        ///   LDFF1H Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorUInt16ZeroExtendFirstFaulting(Vector<long> mask, ushort* address) => LoadVectorUInt16ZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint32_t svldff1uh_u32(svbool_t pg, const uint16_t *base)
        ///   LDFF1H Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1H Zresult.S, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorUInt16ZeroExtendFirstFaulting(Vector<uint> mask, ushort* address) => LoadVectorUInt16ZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint64_t svldff1uh_u64(svbool_t pg, const uint16_t *base)
        ///   LDFF1H Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LDFF1H Zresult.D, Pg/Z, [Xbase, XZR, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P1, REG_R3, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P5, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V1, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V0, REG_P2, REG_R6, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_G  LDFF1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1h, EA_SCALABLE, REG_V3, REG_P1, REG_R4, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1h, EA_SCALABLE, REG_V4, REG_P7, REG_V3, 6, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorUInt16ZeroExtendFirstFaulting(Vector<ulong> mask, ushort* address) => LoadVectorUInt16ZeroExtendFirstFaulting(mask, address);


        ///  LoadVectorUInt16ZeroExtendToInt32 : Load 16-bit data and zero-extend

        /// <summary>
        /// svint32_t svld1uh_s32(svbool_t pg, const uint16_t *base)
        ///   LD1H Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1H Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> LoadVectorUInt16ZeroExtendToInt32(Vector<int> mask, ushort* address) => LoadVectorUInt16ZeroExtendToInt32(mask, address);


        ///  LoadVectorUInt16ZeroExtendToInt64 : Load 16-bit data and zero-extend

        /// <summary>
        /// svint64_t svld1uh_s64(svbool_t pg, const uint16_t *base)
        ///   LD1H Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1H Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorUInt16ZeroExtendToInt64(Vector<long> mask, ushort* address) => LoadVectorUInt16ZeroExtendToInt64(mask, address);


        ///  LoadVectorUInt16ZeroExtendToUInt32 : Load 16-bit data and zero-extend

        /// <summary>
        /// svuint32_t svld1uh_u32(svbool_t pg, const uint16_t *base)
        ///   LD1H Zresult.S, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1H Zresult.S, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> LoadVectorUInt16ZeroExtendToUInt32(Vector<uint> mask, ushort* address) => LoadVectorUInt16ZeroExtendToUInt32(mask, address);


        ///  LoadVectorUInt16ZeroExtendToUInt64 : Load 16-bit data and zero-extend

        /// <summary>
        /// svuint64_t svld1uh_u64(svbool_t pg, const uint16_t *base)
        ///   LD1H Zresult.D, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD1H Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IJ_3A_G  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R6, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HW_4A  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P3, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V2, REG_P1, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P5, REG_R4, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1H {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1H {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IK_4A_I  LD1H {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1h, EA_SCALABLE, REG_V4, REG_P2, REG_R3, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1H {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1h, EA_SCALABLE, REG_V1, REG_P0, REG_V2, 0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorUInt16ZeroExtendToUInt64(Vector<ulong> mask, ushort* address) => LoadVectorUInt16ZeroExtendToUInt64(mask, address);


        ///  LoadVectorUInt32NonFaultingZeroExtendToInt64 : Load 32-bit data and zero-extend, non-faulting

        /// <summary>
        /// svint64_t svldnf1uw_s64(svbool_t pg, const uint32_t *base)
        ///   LDNF1W Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> LoadVectorUInt32NonFaultingZeroExtendToInt64(uint* address) => LoadVectorUInt32NonFaultingZeroExtendToInt64(address);


        ///  LoadVectorUInt32NonFaultingZeroExtendToUInt64 : Load 32-bit data and zero-extend, non-faulting

        /// <summary>
        /// svuint64_t svldnf1uw_u64(svbool_t pg, const uint32_t *base)
        ///   LDNF1W Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IL_3A_A  LDNF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldnf1w, EA_SCALABLE, REG_V0, REG_P2, REG_R4, 5, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorUInt32NonFaultingZeroExtendToUInt64(uint* address) => LoadVectorUInt32NonFaultingZeroExtendToUInt64(address);


        ///  LoadVectorUInt32ZeroExtendFirstFaulting : Load 32-bit data and zero-extend, first-faulting

        /// <summary>
        /// svint64_t svldff1uw_s64(svbool_t pg, const uint32_t *base)
        ///   LDFF1W Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, XZR, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorUInt32ZeroExtendFirstFaulting(Vector<long> mask, uint* address) => LoadVectorUInt32ZeroExtendFirstFaulting(mask, address);

        /// <summary>
        /// svuint64_t svldff1uw_u64(svbool_t pg, const uint32_t *base)
        ///   LDFF1W Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LDFF1W Zresult.D, Pg/Z, [Xbase, XZR, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HW_4A  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V5, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P5, REG_R2, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V3, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LDFF1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IG_4A_F  LDFF1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_R3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ldff1w, EA_SCALABLE, REG_V1, REG_P0, REG_R2, REG_ZR, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LDFF1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ldff1w, EA_SCALABLE, REG_V2, REG_P1, REG_V3, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorUInt32ZeroExtendFirstFaulting(Vector<ulong> mask, uint* address) => LoadVectorUInt32ZeroExtendFirstFaulting(mask, address);


        ///  LoadVectorUInt32ZeroExtendToInt64 : Load 32-bit data and zero-extend

        /// <summary>
        /// svint64_t svld1uw_s64(svbool_t pg, const uint32_t *base)
        ///   LD1W Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1W Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> LoadVectorUInt32ZeroExtendToInt64(Vector<long> mask, uint* address) => LoadVectorUInt32ZeroExtendToInt64(mask, address);


        ///  LoadVectorUInt32ZeroExtendToUInt64 : Load 32-bit data and zero-extend

        /// <summary>
        /// svuint64_t svld1uw_u64(svbool_t pg, const uint32_t *base)
        ///   LD1W Zresult.D, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD1W Zresult.D, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IH_3A_F  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, 3, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_HW_4A  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_V1, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_A  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HW_4A_B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V4, REG_P5, REG_R3, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_HW_4A_C  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V5, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_HW_4B  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HW_4B_D  LD1W {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_II_4A_H  LD1W {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld1w, EA_SCALABLE, REG_V5, REG_P3, REG_R4, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HX_3A_E  LD1W {<Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld1w, EA_SCALABLE, REG_V1, REG_P2, REG_V9, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> LoadVectorUInt32ZeroExtendToUInt64(Vector<ulong> mask, uint* address) => LoadVectorUInt32ZeroExtendToUInt64(mask, address);


        ///  LoadVectorx2 : Load two-element tuples into two vectors

        /// <summary>
        /// svint8x2_t svld2[_s8](svbool_t pg, const int8_t *base)
        ///   LD2B {Zresult0.B, Zresult1.B}, Pg/Z, [Xarray, Xindex]
        ///   LD2B {Zresult0.B, Zresult1.B}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2B {<Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, -16, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IT_4A  LD2B {<Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe (Vector<sbyte>, Vector<sbyte>) LoadVectorx2(Vector<sbyte> mask, sbyte* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svint16x2_t svld2[_s16](svbool_t pg, const int16_t *base)
        ///   LD2H {Zresult0.H, Zresult1.H}, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD2H {Zresult0.H, Zresult1.H}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2H {<Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2h, EA_SCALABLE, REG_V6, REG_P5, REG_R4, 8, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IT_4A  LD2H {<Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2h, EA_SCALABLE, REG_V8, REG_P5, REG_R9, REG_R10, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<short>, Vector<short>) LoadVectorx2(Vector<short> mask, short* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svint32x2_t svld2[_s32](svbool_t pg, const int32_t *base)
        ///   LD2W {Zresult0.S, Zresult1.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD2W {Zresult0.S, Zresult1.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2W {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2w, EA_SCALABLE, REG_V0, REG_P0, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD2W {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2w, EA_SCALABLE, REG_V6, REG_P5, REG_R4, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<int>, Vector<int>) LoadVectorx2(Vector<int> mask, int* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svint64x2_t svld2[_s64](svbool_t pg, const int64_t *base)
        ///   LD2D {Zresult0.D, Zresult1.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD2D {Zresult0.D, Zresult1.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2D {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2d, EA_SCALABLE, REG_V4, REG_P5, REG_R7, 14, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD2D {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2d, EA_SCALABLE, REG_V7, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<long>, Vector<long>) LoadVectorx2(Vector<long> mask, long* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svuint8x2_t svld2[_u8](svbool_t pg, const uint8_t *base)
        ///   LD2B {Zresult0.B, Zresult1.B}, Pg/Z, [Xarray, Xindex]
        ///   LD2B {Zresult0.B, Zresult1.B}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2B {<Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, -16, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IT_4A  LD2B {<Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe (Vector<byte>, Vector<byte>) LoadVectorx2(Vector<byte> mask, byte* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svuint16x2_t svld2[_u16](svbool_t pg, const uint16_t *base)
        ///   LD2H {Zresult0.H, Zresult1.H}, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD2H {Zresult0.H, Zresult1.H}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2H {<Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2h, EA_SCALABLE, REG_V6, REG_P5, REG_R4, 8, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IT_4A  LD2H {<Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2h, EA_SCALABLE, REG_V8, REG_P5, REG_R9, REG_R10, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<ushort>, Vector<ushort>) LoadVectorx2(Vector<ushort> mask, ushort* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svuint32x2_t svld2[_u32](svbool_t pg, const uint32_t *base)
        ///   LD2W {Zresult0.S, Zresult1.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD2W {Zresult0.S, Zresult1.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2W {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2w, EA_SCALABLE, REG_V0, REG_P0, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD2W {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2w, EA_SCALABLE, REG_V6, REG_P5, REG_R4, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<uint>, Vector<uint>) LoadVectorx2(Vector<uint> mask, uint* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svuint64x2_t svld2[_u64](svbool_t pg, const uint64_t *base)
        ///   LD2D {Zresult0.D, Zresult1.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD2D {Zresult0.D, Zresult1.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2D {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2d, EA_SCALABLE, REG_V4, REG_P5, REG_R7, 14, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD2D {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2d, EA_SCALABLE, REG_V7, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<ulong>, Vector<ulong>) LoadVectorx2(Vector<ulong> mask, ulong* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svfloat32x2_t svld2[_f32](svbool_t pg, const float32_t *base)
        ///   LD2W {Zresult0.S, Zresult1.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD2W {Zresult0.S, Zresult1.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2W {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2w, EA_SCALABLE, REG_V0, REG_P0, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD2W {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2w, EA_SCALABLE, REG_V6, REG_P5, REG_R4, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<float>, Vector<float>) LoadVectorx2(Vector<float> mask, float* address) => LoadVectorx2(mask, address);

        /// <summary>
        /// svfloat64x2_t svld2[_f64](svbool_t pg, const float64_t *base)
        ///   LD2D {Zresult0.D, Zresult1.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD2D {Zresult0.D, Zresult1.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD2D {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld2d, EA_SCALABLE, REG_V4, REG_P5, REG_R7, 14, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD2D {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld2d, EA_SCALABLE, REG_V7, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<double>, Vector<double>) LoadVectorx2(Vector<double> mask, double* address) => LoadVectorx2(mask, address);


        ///  LoadVectorx3 : Load three-element tuples into three vectors

        /// <summary>
        /// svint8x3_t svld3[_s8](svbool_t pg, const int8_t *base)
        ///   LD3B {Zresult0.B - Zresult2.B}, Pg/Z, [Xarray, Xindex]
        ///   LD3B {Zresult0.B - Zresult2.B}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3b, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 21, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IT_4A  LD3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3b, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R2, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe (Vector<sbyte>, Vector<sbyte>, Vector<sbyte>) LoadVectorx3(Vector<sbyte> mask, sbyte* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svint16x3_t svld3[_s16](svbool_t pg, const int16_t *base)
        ///   LD3H {Zresult0.H - Zresult2.H}, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD3H {Zresult0.H - Zresult2.H}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3h, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 21, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IT_4A  LD3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3h, EA_SCALABLE, REG_V30, REG_P2, REG_R9, REG_R4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<short>, Vector<short>, Vector<short>) LoadVectorx3(Vector<short> mask, short* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svint32x3_t svld3[_s32](svbool_t pg, const int32_t *base)
        ///   LD3W {Zresult0.S - Zresult2.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD3W {Zresult0.S - Zresult2.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3w, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3w, EA_SCALABLE, REG_V1, REG_P3, REG_R2, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<int>, Vector<int>, Vector<int>) LoadVectorx3(Vector<int> mask, int* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svint64x3_t svld3[_s64](svbool_t pg, const int64_t *base)
        ///   LD3D {Zresult0.D - Zresult2.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD3D {Zresult0.D - Zresult2.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3d, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -24, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3d, EA_SCALABLE, REG_V4, REG_P3, REG_R8, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<long>, Vector<long>, Vector<long>) LoadVectorx3(Vector<long> mask, long* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svuint8x3_t svld3[_u8](svbool_t pg, const uint8_t *base)
        ///   LD3B {Zresult0.B - Zresult2.B}, Pg/Z, [Xarray, Xindex]
        ///   LD3B {Zresult0.B - Zresult2.B}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3b, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 21, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IT_4A  LD3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3b, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R2, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe (Vector<byte>, Vector<byte>, Vector<byte>) LoadVectorx3(Vector<byte> mask, byte* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svuint16x3_t svld3[_u16](svbool_t pg, const uint16_t *base)
        ///   LD3H {Zresult0.H - Zresult2.H}, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD3H {Zresult0.H - Zresult2.H}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3h, EA_SCALABLE, REG_V0, REG_P0, REG_R0, 21, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IT_4A  LD3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3h, EA_SCALABLE, REG_V30, REG_P2, REG_R9, REG_R4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<ushort>, Vector<ushort>, Vector<ushort>) LoadVectorx3(Vector<ushort> mask, ushort* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svuint32x3_t svld3[_u32](svbool_t pg, const uint32_t *base)
        ///   LD3W {Zresult0.S - Zresult2.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD3W {Zresult0.S - Zresult2.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3w, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3w, EA_SCALABLE, REG_V1, REG_P3, REG_R2, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<uint>, Vector<uint>, Vector<uint>) LoadVectorx3(Vector<uint> mask, uint* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svuint64x3_t svld3[_u64](svbool_t pg, const uint64_t *base)
        ///   LD3D {Zresult0.D - Zresult2.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD3D {Zresult0.D - Zresult2.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3d, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -24, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3d, EA_SCALABLE, REG_V4, REG_P3, REG_R8, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<ulong>, Vector<ulong>, Vector<ulong>) LoadVectorx3(Vector<ulong> mask, ulong* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svfloat32x3_t svld3[_f32](svbool_t pg, const float32_t *base)
        ///   LD3W {Zresult0.S - Zresult2.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD3W {Zresult0.S - Zresult2.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3w, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3w, EA_SCALABLE, REG_V1, REG_P3, REG_R2, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<float>, Vector<float>, Vector<float>) LoadVectorx3(Vector<float> mask, float* address) => LoadVectorx3(mask, address);

        /// <summary>
        /// svfloat64x3_t svld3[_f64](svbool_t pg, const float64_t *base)
        ///   LD3D {Zresult0.D - Zresult2.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD3D {Zresult0.D - Zresult2.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld3d, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -24, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld3d, EA_SCALABLE, REG_V4, REG_P3, REG_R8, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<double>, Vector<double>, Vector<double>) LoadVectorx3(Vector<double> mask, double* address) => LoadVectorx3(mask, address);


        ///  LoadVectorx4 : Load four-element tuples into four vectors

        /// <summary>
        /// svint8x4_t svld4[_s8](svbool_t pg, const int8_t *base)
        ///   LD4B {Zresult0.B - Zresult3.B}, Pg/Z, [Xarray, Xindex]
        ///   LD4B {Zresult0.B - Zresult3.B}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4b, EA_SCALABLE, REG_V31, REG_P2, REG_R1, -32, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IT_4A  LD4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe (Vector<sbyte>, Vector<sbyte>, Vector<sbyte>, Vector<sbyte>) LoadVectorx4(Vector<sbyte> mask, sbyte* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svint16x4_t svld4[_s16](svbool_t pg, const int16_t *base)
        ///   LD4H {Zresult0.H - Zresult3.H}, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD4H {Zresult0.H - Zresult3.H}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, -32, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IT_4A  LD4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4h, EA_SCALABLE, REG_V13, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<short>, Vector<short>, Vector<short>, Vector<short>) LoadVectorx4(Vector<short> mask, short* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svint32x4_t svld4[_s32](svbool_t pg, const int32_t *base)
        ///   LD4W {Zresult0.S - Zresult3.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD4W {Zresult0.S - Zresult3.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4w, EA_SCALABLE, REG_V10, REG_P3, REG_R2, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<int>, Vector<int>, Vector<int>, Vector<int>) LoadVectorx4(Vector<int> mask, int* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svint64x4_t svld4[_s64](svbool_t pg, const int64_t *base)
        ///   LD4D {Zresult0.D - Zresult3.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD4D {Zresult0.D - Zresult3.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4d, EA_SCALABLE, REG_V8, REG_P0, REG_R0, 28, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<long>, Vector<long>, Vector<long>, Vector<long>) LoadVectorx4(Vector<long> mask, long* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svuint8x4_t svld4[_u8](svbool_t pg, const uint8_t *base)
        ///   LD4B {Zresult0.B - Zresult3.B}, Pg/Z, [Xarray, Xindex]
        ///   LD4B {Zresult0.B - Zresult3.B}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4b, EA_SCALABLE, REG_V31, REG_P2, REG_R1, -32, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IT_4A  LD4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe (Vector<byte>, Vector<byte>, Vector<byte>, Vector<byte>) LoadVectorx4(Vector<byte> mask, byte* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svuint16x4_t svld4[_u16](svbool_t pg, const uint16_t *base)
        ///   LD4H {Zresult0.H - Zresult3.H}, Pg/Z, [Xarray, Xindex, LSL #1]
        ///   LD4H {Zresult0.H - Zresult3.H}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4h, EA_SCALABLE, REG_V5, REG_P4, REG_R3, -32, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IT_4A  LD4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4h, EA_SCALABLE, REG_V13, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<ushort>, Vector<ushort>, Vector<ushort>, Vector<ushort>) LoadVectorx4(Vector<ushort> mask, ushort* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svuint32x4_t svld4[_u32](svbool_t pg, const uint32_t *base)
        ///   LD4W {Zresult0.S - Zresult3.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD4W {Zresult0.S - Zresult3.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4w, EA_SCALABLE, REG_V10, REG_P3, REG_R2, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<uint>, Vector<uint>, Vector<uint>, Vector<uint>) LoadVectorx4(Vector<uint> mask, uint* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svuint64x4_t svld4[_u64](svbool_t pg, const uint64_t *base)
        ///   LD4D {Zresult0.D - Zresult3.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD4D {Zresult0.D - Zresult3.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4d, EA_SCALABLE, REG_V8, REG_P0, REG_R0, 28, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<ulong>, Vector<ulong>, Vector<ulong>, Vector<ulong>) LoadVectorx4(Vector<ulong> mask, ulong* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svfloat32x4_t svld4[_f32](svbool_t pg, const float32_t *base)
        ///   LD4W {Zresult0.S - Zresult3.S}, Pg/Z, [Xarray, Xindex, LSL #2]
        ///   LD4W {Zresult0.S - Zresult3.S}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, 28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IT_4A  LD4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4w, EA_SCALABLE, REG_V10, REG_P3, REG_R2, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<float>, Vector<float>, Vector<float>, Vector<float>) LoadVectorx4(Vector<float> mask, float* address) => LoadVectorx4(mask, address);

        /// <summary>
        /// svfloat64x4_t svld4[_f64](svbool_t pg, const float64_t *base)
        ///   LD4D {Zresult0.D - Zresult3.D}, Pg/Z, [Xarray, Xindex, LSL #3]
        ///   LD4D {Zresult0.D - Zresult3.D}, Pg/Z, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_IS_3A  LD4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_ld4d, EA_SCALABLE, REG_V8, REG_P0, REG_R0, 28, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IT_4A  LD4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_ld4d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_R1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe (Vector<double>, Vector<double>, Vector<double>, Vector<double>) LoadVectorx4(Vector<double> mask, double* address) => LoadVectorx4(mask, address);


        ///  Max : Maximum

        /// <summary>
        /// svint8_t svmax[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SMAX Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svmax[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SMAX Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   SMAX Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svmax[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; SMAX Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; SMAX Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smax, EA_SCALABLE, REG_V24, REG_P0, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_ED_1A  SMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V1, 127, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Max(Vector<sbyte> left, Vector<sbyte> right) => Max(left, right);

        /// <summary>
        /// svint16_t svmax[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SMAX Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svmax[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SMAX Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   SMAX Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svmax[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; SMAX Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; SMAX Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smax, EA_SCALABLE, REG_V24, REG_P0, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_ED_1A  SMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V1, 127, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Max(Vector<short> left, Vector<short> right) => Max(left, right);

        /// <summary>
        /// svint32_t svmax[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SMAX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svmax[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SMAX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   SMAX Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svmax[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; SMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; SMAX Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smax, EA_SCALABLE, REG_V24, REG_P0, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_ED_1A  SMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V1, 127, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Max(Vector<int> left, Vector<int> right) => Max(left, right);

        /// <summary>
        /// svint64_t svmax[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SMAX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svmax[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SMAX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   SMAX Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; SMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svmax[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; SMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; SMAX Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smax, EA_SCALABLE, REG_V24, REG_P0, REG_V2, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_ED_1A  SMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_smax, EA_SCALABLE, REG_V1, 127, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Max(Vector<long> left, Vector<long> right) => Max(left, right);

        /// <summary>
        /// svuint8_t svmax[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   UMAX Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svmax[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   UMAX Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   UMAX Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svmax[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; UMAX Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; UMAX Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umax, EA_SCALABLE, REG_V15, REG_P4, REG_V2, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_ED_1A  UMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V5, 255, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Max(Vector<byte> left, Vector<byte> right) => Max(left, right);

        /// <summary>
        /// svuint16_t svmax[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   UMAX Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svmax[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   UMAX Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   UMAX Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svmax[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; UMAX Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; UMAX Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umax, EA_SCALABLE, REG_V15, REG_P4, REG_V2, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_ED_1A  UMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V5, 255, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Max(Vector<ushort> left, Vector<ushort> right) => Max(left, right);

        /// <summary>
        /// svuint32_t svmax[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UMAX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svmax[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UMAX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   UMAX Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svmax[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; UMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; UMAX Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umax, EA_SCALABLE, REG_V15, REG_P4, REG_V2, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_ED_1A  UMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V5, 255, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Max(Vector<uint> left, Vector<uint> right) => Max(left, right);

        /// <summary>
        /// svuint64_t svmax[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UMAX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svmax[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UMAX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   UMAX Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; UMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svmax[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; UMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; UMAX Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umax, EA_SCALABLE, REG_V15, REG_P4, REG_V2, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_ED_1A  UMAX <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V4, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_umax, EA_SCALABLE, REG_V5, 255, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Max(Vector<ulong> left, Vector<ulong> right) => Max(left, right);

        /// <summary>
        /// svfloat32_t svmax[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMAX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmax[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMAX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FMAX Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmax[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMAX Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMAX Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmax, EA_SCALABLE, REG_V30, REG_P2, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HM_2A  FMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmax, EA_SCALABLE, REG_V1, REG_P0, 0.0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmax, EA_SCALABLE, REG_V1, REG_P0, 1.0, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Max(Vector<float> left, Vector<float> right) => Max(left, right);

        /// <summary>
        /// svfloat64_t svmax[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMAX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmax[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMAX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FMAX Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmax[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMAX Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMAX Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmax, EA_SCALABLE, REG_V30, REG_P2, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HM_2A  FMAX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmax, EA_SCALABLE, REG_V1, REG_P0, 0.0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmax, EA_SCALABLE, REG_V1, REG_P0, 1.0, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Max(Vector<double> left, Vector<double> right) => Max(left, right);


        ///  MaxAcross : Maximum reduction to scalar

        /// <summary>
        /// int8_t svmaxv[_s8](svbool_t pg, svint8_t op)
        ///   SMAXV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smaxv, EA_8BYTE, REG_V15, REG_P7, REG_V4, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> MaxAcross(Vector<sbyte> value) => MaxAcross(value);

        /// <summary>
        /// int16_t svmaxv[_s16](svbool_t pg, svint16_t op)
        ///   SMAXV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smaxv, EA_8BYTE, REG_V15, REG_P7, REG_V4, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> MaxAcross(Vector<short> value) => MaxAcross(value);

        /// <summary>
        /// int32_t svmaxv[_s32](svbool_t pg, svint32_t op)
        ///   SMAXV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smaxv, EA_8BYTE, REG_V15, REG_P7, REG_V4, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> MaxAcross(Vector<int> value) => MaxAcross(value);

        /// <summary>
        /// int64_t svmaxv[_s64](svbool_t pg, svint64_t op)
        ///   SMAXV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smaxv, EA_8BYTE, REG_V15, REG_P7, REG_V4, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> MaxAcross(Vector<long> value) => MaxAcross(value);

        /// <summary>
        /// uint8_t svmaxv[_u8](svbool_t pg, svuint8_t op)
        ///   UMAXV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umaxv, EA_2BYTE, REG_V17, REG_P5, REG_V24, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> MaxAcross(Vector<byte> value) => MaxAcross(value);

        /// <summary>
        /// uint16_t svmaxv[_u16](svbool_t pg, svuint16_t op)
        ///   UMAXV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umaxv, EA_2BYTE, REG_V17, REG_P5, REG_V24, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> MaxAcross(Vector<ushort> value) => MaxAcross(value);

        /// <summary>
        /// uint32_t svmaxv[_u32](svbool_t pg, svuint32_t op)
        ///   UMAXV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umaxv, EA_2BYTE, REG_V17, REG_P5, REG_V24, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> MaxAcross(Vector<uint> value) => MaxAcross(value);

        /// <summary>
        /// uint64_t svmaxv[_u64](svbool_t pg, svuint64_t op)
        ///   UMAXV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umaxv, EA_2BYTE, REG_V17, REG_P5, REG_V24, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> MaxAcross(Vector<ulong> value) => MaxAcross(value);

        /// <summary>
        /// float32_t svmaxv[_f32](svbool_t pg, svfloat32_t op)
        ///   FMAXV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmaxv, EA_4BYTE, REG_V23, REG_P5, REG_V5, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MaxAcross(Vector<float> value) => MaxAcross(value);

        /// <summary>
        /// float64_t svmaxv[_f64](svbool_t pg, svfloat64_t op)
        ///   FMAXV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMAXV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmaxv, EA_4BYTE, REG_V23, REG_P5, REG_V5, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MaxAcross(Vector<double> value) => MaxAcross(value);


        ///  MaxNumber : Maximum number

        /// <summary>
        /// svfloat32_t svmaxnm[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMAXNM Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FMAXNM Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmaxnm[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMAXNM Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FMAXNM Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FMAXNM Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmaxnm[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMAXNM Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMAXNM Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMAXNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmaxnm, EA_SCALABLE, REG_V31, REG_P3, REG_V4, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HM_2A  FMAXNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmaxnm, EA_SCALABLE, REG_V3, REG_P4, 0.0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmaxnm, EA_SCALABLE, REG_V3, REG_P4, 1.0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MaxNumber(Vector<float> left, Vector<float> right) => MaxNumber(left, right);

        /// <summary>
        /// svfloat64_t svmaxnm[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMAXNM Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FMAXNM Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmaxnm[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMAXNM Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FMAXNM Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FMAXNM Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmaxnm[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMAXNM Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMAXNM Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMAXNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmaxnm, EA_SCALABLE, REG_V31, REG_P3, REG_V4, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HM_2A  FMAXNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmaxnm, EA_SCALABLE, REG_V3, REG_P4, 0.0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmaxnm, EA_SCALABLE, REG_V3, REG_P4, 1.0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MaxNumber(Vector<double> left, Vector<double> right) => MaxNumber(left, right);


        ///  MaxNumberAcross : Maximum number reduction to scalar

        /// <summary>
        /// float32_t svmaxnmv[_f32](svbool_t pg, svfloat32_t op)
        ///   FMAXNMV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMAXNMV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmaxnmv, EA_2BYTE, REG_V22, REG_P6, REG_V6, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MaxNumberAcross(Vector<float> value) => MaxNumberAcross(value);

        /// <summary>
        /// float64_t svmaxnmv[_f64](svbool_t pg, svfloat64_t op)
        ///   FMAXNMV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMAXNMV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmaxnmv, EA_2BYTE, REG_V22, REG_P6, REG_V6, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MaxNumberAcross(Vector<double> value) => MaxNumberAcross(value);


        ///  Min : Minimum

        /// <summary>
        /// svint8_t svmin[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SMIN Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svmin[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SMIN Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   SMIN Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svmin[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; SMIN Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; SMIN Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smin, EA_SCALABLE, REG_V9, REG_P1, REG_V27, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_ED_1A  SMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V2, -128, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Min(Vector<sbyte> left, Vector<sbyte> right) => Min(left, right);

        /// <summary>
        /// svint16_t svmin[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SMIN Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svmin[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SMIN Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   SMIN Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svmin[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; SMIN Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; SMIN Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smin, EA_SCALABLE, REG_V9, REG_P1, REG_V27, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_ED_1A  SMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V2, -128, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Min(Vector<short> left, Vector<short> right) => Min(left, right);

        /// <summary>
        /// svint32_t svmin[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SMIN Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svmin[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SMIN Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   SMIN Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svmin[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; SMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; SMIN Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smin, EA_SCALABLE, REG_V9, REG_P1, REG_V27, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_ED_1A  SMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V2, -128, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Min(Vector<int> left, Vector<int> right) => Min(left, right);

        /// <summary>
        /// svint64_t svmin[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SMIN Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svmin[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SMIN Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   SMIN Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; SMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svmin[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; SMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; SMIN Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  SMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_smin, EA_SCALABLE, REG_V9, REG_P1, REG_V27, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_ED_1A  SMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V2, -128, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_smin, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Min(Vector<long> left, Vector<long> right) => Min(left, right);

        /// <summary>
        /// svuint8_t svmin[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   UMIN Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svmin[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   UMIN Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   UMIN Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svmin[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; UMIN Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; UMIN Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umin, EA_SCALABLE, REG_V12, REG_P7, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_ED_1A  UMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V6, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V7, 255, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Min(Vector<byte> left, Vector<byte> right) => Min(left, right);

        /// <summary>
        /// svuint16_t svmin[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   UMIN Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svmin[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   UMIN Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   UMIN Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svmin[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; UMIN Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; UMIN Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umin, EA_SCALABLE, REG_V12, REG_P7, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_ED_1A  UMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V6, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V7, 255, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Min(Vector<ushort> left, Vector<ushort> right) => Min(left, right);

        /// <summary>
        /// svuint32_t svmin[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UMIN Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svmin[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   UMIN Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   UMIN Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svmin[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; UMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; UMIN Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umin, EA_SCALABLE, REG_V12, REG_P7, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_ED_1A  UMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V6, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V7, 255, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Min(Vector<uint> left, Vector<uint> right) => Min(left, right);

        /// <summary>
        /// svuint64_t svmin[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UMIN Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svmin[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   UMIN Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   UMIN Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; UMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svmin[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; UMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; UMIN Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AD_3A  UMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_umin, EA_SCALABLE, REG_V12, REG_P7, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_ED_1A  UMIN <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V6, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_umin, EA_SCALABLE, REG_V7, 255, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Min(Vector<ulong> left, Vector<ulong> right) => Min(left, right);

        /// <summary>
        /// svfloat32_t svmin[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMIN Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmin[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMIN Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FMIN Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmin[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMIN Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMIN Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmin, EA_SCALABLE, REG_V0, REG_P4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HM_2A  FMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmin, EA_SCALABLE, REG_V6, REG_P5, 0.0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmin, EA_SCALABLE, REG_V6, REG_P5, 1.0, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Min(Vector<float> left, Vector<float> right) => Min(left, right);

        /// <summary>
        /// svfloat64_t svmin[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMIN Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmin[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMIN Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FMIN Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmin[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMIN Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMIN Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmin, EA_SCALABLE, REG_V0, REG_P4, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HM_2A  FMIN <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmin, EA_SCALABLE, REG_V6, REG_P5, 0.0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmin, EA_SCALABLE, REG_V6, REG_P5, 1.0, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Min(Vector<double> left, Vector<double> right) => Min(left, right);


        ///  MinAcross : Minimum reduction to scalar

        /// <summary>
        /// int8_t svminv[_s8](svbool_t pg, svint8_t op)
        ///   SMINV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sminv, EA_4BYTE, REG_V16, REG_P6, REG_V14, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> MinAcross(Vector<sbyte> value) => MinAcross(value);

        /// <summary>
        /// int16_t svminv[_s16](svbool_t pg, svint16_t op)
        ///   SMINV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sminv, EA_4BYTE, REG_V16, REG_P6, REG_V14, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> MinAcross(Vector<short> value) => MinAcross(value);

        /// <summary>
        /// int32_t svminv[_s32](svbool_t pg, svint32_t op)
        ///   SMINV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sminv, EA_4BYTE, REG_V16, REG_P6, REG_V14, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> MinAcross(Vector<int> value) => MinAcross(value);

        /// <summary>
        /// int64_t svminv[_s64](svbool_t pg, svint64_t op)
        ///   SMINV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  SMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sminv, EA_4BYTE, REG_V16, REG_P6, REG_V14, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> MinAcross(Vector<long> value) => MinAcross(value);

        /// <summary>
        /// uint8_t svminv[_u8](svbool_t pg, svuint8_t op)
        ///   UMINV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uminv, EA_1BYTE, REG_V18, REG_P4, REG_V31, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> MinAcross(Vector<byte> value) => MinAcross(value);

        /// <summary>
        /// uint16_t svminv[_u16](svbool_t pg, svuint16_t op)
        ///   UMINV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uminv, EA_1BYTE, REG_V18, REG_P4, REG_V31, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> MinAcross(Vector<ushort> value) => MinAcross(value);

        /// <summary>
        /// uint32_t svminv[_u32](svbool_t pg, svuint32_t op)
        ///   UMINV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uminv, EA_1BYTE, REG_V18, REG_P4, REG_V31, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> MinAcross(Vector<uint> value) => MinAcross(value);

        /// <summary>
        /// uint64_t svminv[_u64](svbool_t pg, svuint64_t op)
        ///   UMINV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AK_3A  UMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uminv, EA_1BYTE, REG_V18, REG_P4, REG_V31, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> MinAcross(Vector<ulong> value) => MinAcross(value);

        /// <summary>
        /// float32_t svminv[_f32](svbool_t pg, svfloat32_t op)
        ///   FMINV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fminv, EA_4BYTE, REG_V25, REG_P3, REG_V3, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MinAcross(Vector<float> value) => MinAcross(value);

        /// <summary>
        /// float64_t svminv[_f64](svbool_t pg, svfloat64_t op)
        ///   FMINV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMINV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fminv, EA_4BYTE, REG_V25, REG_P3, REG_V3, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MinAcross(Vector<double> value) => MinAcross(value);


        ///  MinNumber : Minimum number

        /// <summary>
        /// svfloat32_t svminnm[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMINNM Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FMINNM Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svminnm[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMINNM Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FMINNM Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FMINNM Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svminnm[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMINNM Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMINNM Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMINNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fminnm, EA_SCALABLE, REG_V1, REG_P5, REG_V2, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HM_2A  FMINNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fminnm, EA_SCALABLE, REG_V2, REG_P4, 0.0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fminnm, EA_SCALABLE, REG_V2, REG_P4, 1.0, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MinNumber(Vector<float> left, Vector<float> right) => MinNumber(left, right);

        /// <summary>
        /// svfloat64_t svminnm[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMINNM Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FMINNM Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svminnm[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMINNM Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FMINNM Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FMINNM Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svminnm[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMINNM Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMINNM Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMINNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fminnm, EA_SCALABLE, REG_V1, REG_P5, REG_V2, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_HM_2A  FMINNM <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fminnm, EA_SCALABLE, REG_V2, REG_P4, 0.0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fminnm, EA_SCALABLE, REG_V2, REG_P4, 1.0, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MinNumber(Vector<double> left, Vector<double> right) => MinNumber(left, right);


        ///  MinNumberAcross : Minimum number reduction to scalar

        /// <summary>
        /// float32_t svminnmv[_f32](svbool_t pg, svfloat32_t op)
        ///   FMINNMV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMINNMV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fminnmv, EA_8BYTE, REG_V24, REG_P4, REG_V4, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MinNumberAcross(Vector<float> value) => MinNumberAcross(value);

        /// <summary>
        /// float64_t svminnmv[_f64](svbool_t pg, svfloat64_t op)
        ///   FMINNMV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HE_3A  FMINNMV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fminnmv, EA_8BYTE, REG_V24, REG_P4, REG_V4, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MinNumberAcross(Vector<double> value) => MinNumberAcross(value);



        ///  Multiply : Multiply

        /// <summary>
        /// svint8_t svmul[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MUL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svmul[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MUL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MUL Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svmul[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; MUL Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; MUL Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Multiply(Vector<sbyte> left, Vector<sbyte> right) => Multiply(left, right);

        /// <summary>
        /// svint16_t svmul[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MUL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svmul[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MUL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MUL Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svmul[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; MUL Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; MUL Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Multiply(Vector<short> left, Vector<short> right) => Multiply(left, right);

        /// <summary>
        /// svint32_t svmul[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MUL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svmul[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MUL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MUL Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svmul[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; MUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; MUL Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Multiply(Vector<int> left, Vector<int> right) => Multiply(left, right);

        /// <summary>
        /// svint64_t svmul[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MUL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svmul[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MUL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MUL Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svmul[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; MUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; MUL Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Multiply(Vector<long> left, Vector<long> right) => Multiply(left, right);

        /// <summary>
        /// svuint8_t svmul[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MUL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svmul[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MUL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MUL Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svmul[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; MUL Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; MUL Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Multiply(Vector<byte> left, Vector<byte> right) => Multiply(left, right);

        /// <summary>
        /// svuint16_t svmul[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MUL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svmul[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MUL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MUL Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svmul[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; MUL Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; MUL Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Multiply(Vector<ushort> left, Vector<ushort> right) => Multiply(left, right);

        /// <summary>
        /// svuint32_t svmul[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MUL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svmul[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MUL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MUL Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svmul[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; MUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; MUL Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Multiply(Vector<uint> left, Vector<uint> right) => Multiply(left, right);

        /// <summary>
        /// svuint64_t svmul[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MUL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svmul[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MUL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MUL Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; MUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svmul[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; MUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; MUL Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AE_3A  MUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_P1, REG_V3, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_BD_3A  MUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_mul, EA_SCALABLE, REG_V5, REG_V0, REG_V31, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_FD_3A  MUL <Zd>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FD_3B  MUL <Zd>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FD_3C  MUL <Zd>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mul, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_EE_1A  MUL <Zdn>.<T>, <Zdn>.<T>, #<imm>
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V0, -128, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V1, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V2, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_I(INS_sve_mul, EA_SCALABLE, REG_V3, 127, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Multiply(Vector<ulong> left, Vector<ulong> right) => Multiply(left, right);

        /// <summary>
        /// svfloat32_t svmul[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMUL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FMUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmul[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMUL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FMUL Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   FMUL Zresult.S, Zop1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FMUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmul[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMUL Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMUL Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V2, REG_P6, REG_V1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FMUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_GX_3A  FMUL <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GX_3B  FMUL <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HM_2A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 0.5, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 2.0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Multiply(Vector<float> left, Vector<float> right) => Multiply(left, right);

        /// <summary>
        /// svfloat64_t svmul[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMUL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FMUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmul[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMUL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FMUL Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   FMUL Zresult.D, Zop1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FMUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmul[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMUL Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMUL Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V2, REG_P6, REG_V1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FMUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_GX_3A  FMUL <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GX_3B  FMUL <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HM_2A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 0.5, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 2.0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Multiply(Vector<double> left, Vector<double> right) => Multiply(left, right);


        ///  MultiplyAdd : Multiply-add, addend first

        /// <summary>
        /// svint8_t svmla[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2, svint8_t op3)
        ///   MLA Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svint8_t svmla[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2, svint8_t op3)
        ///   MLA Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MAD Ztied2.B, Pg/M, Zop3.B, Zop1.B
        ///   MAD Ztied3.B, Pg/M, Zop2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svint8_t svmla[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2, svint8_t op3)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; MLA Zresult.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; MAD Zresult.B, Pg/M, Zop3.B, Zop1.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop3.B; MAD Zresult.B, Pg/M, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> MultiplyAdd(Vector<sbyte> addend, Vector<sbyte> left, Vector<sbyte> right) => MultiplyAdd(addend, left, right);

        /// <summary>
        /// svint16_t svmla[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2, svint16_t op3)
        ///   MLA Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svint16_t svmla[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2, svint16_t op3)
        ///   MLA Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MAD Ztied2.H, Pg/M, Zop3.H, Zop1.H
        ///   MAD Ztied3.H, Pg/M, Zop2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svint16_t svmla[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2, svint16_t op3)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; MLA Zresult.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; MAD Zresult.H, Pg/M, Zop3.H, Zop1.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop3.H; MAD Zresult.H, Pg/M, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> MultiplyAdd(Vector<short> addend, Vector<short> left, Vector<short> right) => MultiplyAdd(addend, left, right);

        /// <summary>
        /// svint32_t svmla[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2, svint32_t op3)
        ///   MLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svint32_t svmla[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2, svint32_t op3)
        ///   MLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MAD Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   MAD Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svint32_t svmla[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2, svint32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; MLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; MAD Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; MAD Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> MultiplyAdd(Vector<int> addend, Vector<int> left, Vector<int> right) => MultiplyAdd(addend, left, right);

        /// <summary>
        /// svint64_t svmla[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2, svint64_t op3)
        ///   MLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svint64_t svmla[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2, svint64_t op3)
        ///   MLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MAD Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   MAD Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svint64_t svmla[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2, svint64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; MLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; MAD Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; MAD Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> MultiplyAdd(Vector<long> addend, Vector<long> left, Vector<long> right) => MultiplyAdd(addend, left, right);

        /// <summary>
        /// svuint8_t svmla[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2, svuint8_t op3)
        ///   MLA Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svuint8_t svmla[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2, svuint8_t op3)
        ///   MLA Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MAD Ztied2.B, Pg/M, Zop3.B, Zop1.B
        ///   MAD Ztied3.B, Pg/M, Zop2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svuint8_t svmla[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2, svuint8_t op3)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; MLA Zresult.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; MAD Zresult.B, Pg/M, Zop3.B, Zop1.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop3.B; MAD Zresult.B, Pg/M, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> MultiplyAdd(Vector<byte> addend, Vector<byte> left, Vector<byte> right) => MultiplyAdd(addend, left, right);

        /// <summary>
        /// svuint16_t svmla[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2, svuint16_t op3)
        ///   MLA Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svuint16_t svmla[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2, svuint16_t op3)
        ///   MLA Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MAD Ztied2.H, Pg/M, Zop3.H, Zop1.H
        ///   MAD Ztied3.H, Pg/M, Zop2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svuint16_t svmla[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2, svuint16_t op3)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; MLA Zresult.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; MAD Zresult.H, Pg/M, Zop3.H, Zop1.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop3.H; MAD Zresult.H, Pg/M, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> MultiplyAdd(Vector<ushort> addend, Vector<ushort> left, Vector<ushort> right) => MultiplyAdd(addend, left, right);

        /// <summary>
        /// svuint32_t svmla[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2, svuint32_t op3)
        ///   MLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svuint32_t svmla[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2, svuint32_t op3)
        ///   MLA Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MAD Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   MAD Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svuint32_t svmla[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2, svuint32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; MLA Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; MAD Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; MAD Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> MultiplyAdd(Vector<uint> addend, Vector<uint> left, Vector<uint> right) => MultiplyAdd(addend, left, right);

        /// <summary>
        /// svuint64_t svmla[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2, svuint64_t op3)
        ///   MLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svuint64_t svmla[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2, svuint64_t op3)
        ///   MLA Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MAD Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   MAD Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; MLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svuint64_t svmla[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2, svuint64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; MLA Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; MAD Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; MAD Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mla, EA_SCALABLE, REG_V0, REG_P0, REG_P0, REG_V19, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_FF_3A  MLA <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V0, REG_V1, REG_V1, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V2, REG_V3, REG_V3, 3, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V8, REG_V9, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V10, REG_V11, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLA <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V16, REG_V17, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mla, EA_SCALABLE, REG_V18, REG_V19, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> MultiplyAdd(Vector<ulong> addend, Vector<ulong> left, Vector<ulong> right) => MultiplyAdd(addend, left, right);




        ///  MultiplyAddRotateComplex : Complex multiply-add with rotate

        /// <summary>
        /// svfloat32_t svcmla[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3, uint64_t imm_rotation)
        ///   FCMLA Ztied1.S, Pg/M, Zop2.S, Zop3.S, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCMLA Zresult.S, Pg/M, Zop2.S, Zop3.S, #imm_rotation
        /// svfloat32_t svcmla[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3, uint64_t imm_rotation)
        ///   FCMLA Ztied1.S, Pg/M, Zop2.S, Zop3.S, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCMLA Zresult.S, Pg/M, Zop2.S, Zop3.S, #imm_rotation
        /// svfloat32_t svcmla[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2, svfloat32_t op3, uint64_t imm_rotation)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FCMLA Zresult.S, Pg/M, Zop2.S, Zop3.S, #imm_rotation
        ///
        /// codegenarm64test:
        ///    IF_SVE_GV_3A  FCMLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>], <const>
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V0, REG_V1, REG_V0, 0, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_V3, REG_V5, 1, 90, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V4, REG_V5, REG_V10, 0, 180, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V6, REG_V7, REG_V15, 1, 270, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GT_4A  FCMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>, <const>
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P1, REG_V3, REG_V4, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V0, REG_P2, REG_V1, REG_V5, 90, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P3, REG_V0, REG_V6, 180, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P3, REG_V0, REG_V6, 270, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MultiplyAddRotateComplex(Vector<float> addend, Vector<float> left, Vector<float> right, [ConstantExpected] byte rotation) => MultiplyAddRotateComplex(addend, left, right, rotation);

        /// <summary>
        /// svfloat64_t svcmla[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3, uint64_t imm_rotation)
        ///   FCMLA Ztied1.D, Pg/M, Zop2.D, Zop3.D, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCMLA Zresult.D, Pg/M, Zop2.D, Zop3.D, #imm_rotation
        /// svfloat64_t svcmla[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3, uint64_t imm_rotation)
        ///   FCMLA Ztied1.D, Pg/M, Zop2.D, Zop3.D, #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCMLA Zresult.D, Pg/M, Zop2.D, Zop3.D, #imm_rotation
        /// svfloat64_t svcmla[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2, svfloat64_t op3, uint64_t imm_rotation)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FCMLA Zresult.D, Pg/M, Zop2.D, Zop3.D, #imm_rotation
        ///
        /// codegenarm64test:
        ///    IF_SVE_GV_3A  FCMLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>], <const>
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V0, REG_V1, REG_V0, 0, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_V3, REG_V5, 1, 90, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V4, REG_V5, REG_V10, 0, 180, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V6, REG_V7, REG_V15, 1, 270, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GT_4A  FCMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>, <const>
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P1, REG_V3, REG_V4, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V0, REG_P2, REG_V1, REG_V5, 90, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P3, REG_V0, REG_V6, 180, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P3, REG_V0, REG_V6, 270, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MultiplyAddRotateComplex(Vector<double> addend, Vector<double> left, Vector<double> right, [ConstantExpected] byte rotation) => MultiplyAddRotateComplex(addend, left, right, rotation);


        ///  MultiplyAddRotateComplexBySelectedScalar : Complex multiply-add with rotate

        /// <summary>
        /// svfloat32_t svcmla_lane[_f32](svfloat32_t op1, svfloat32_t op2, svfloat32_t op3, uint64_t imm_index, uint64_t imm_rotation)
        ///   FCMLA Ztied1.S, Zop2.S, Zop3.S[imm_index], #imm_rotation
        ///   MOVPRFX Zresult, Zop1; FCMLA Zresult.S, Zop2.S, Zop3.S[imm_index], #imm_rotation
        ///
        /// codegenarm64test:
        ///    IF_SVE_GV_3A  FCMLA <Zda>.S, <Zn>.S, <Zm>.S[<imm>], <const>
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V0, REG_V1, REG_V0, 0, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_V3, REG_V5, 1, 90, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V4, REG_V5, REG_V10, 0, 180, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I_I(INS_sve_fcmla, EA_SCALABLE, REG_V6, REG_V7, REG_V15, 1, 270, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GT_4A  FCMLA <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>, <const>
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P1, REG_V3, REG_V4, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V0, REG_P2, REG_V1, REG_V5, 90, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P3, REG_V0, REG_V6, 180, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R_I(INS_sve_fcmla, EA_SCALABLE, REG_V2, REG_P3, REG_V0, REG_V6, 270, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> MultiplyAddRotateComplexBySelectedScalar(Vector<float> addend, Vector<float> left, Vector<float> right, [ConstantExpected] byte rightIndex, [ConstantExpected] byte rotation) => MultiplyAddRotateComplexBySelectedScalar(addend, left, right, rightIndex, rotation);


        ///  MultiplyBySelectedScalar : Multiply

        /// <summary>
        /// svfloat32_t svmul_lane[_f32](svfloat32_t op1, svfloat32_t op2, uint64_t imm_index)
        ///   FMUL Zresult.S, Zop1.S, Zop2.S[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V2, REG_P6, REG_V1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FMUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_GX_3A  FMUL <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GX_3B  FMUL <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HM_2A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 0.5, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 2.0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> MultiplyBySelectedScalar(Vector<float> left, Vector<float> right, [ConstantExpected] byte rightIndex) => MultiplyBySelectedScalar(left, right, rightIndex);

        /// <summary>
        /// svfloat64_t svmul_lane[_f64](svfloat64_t op1, svfloat64_t op2, uint64_t imm_index)
        ///   FMUL Zresult.D, Zop1.D, Zop2.D[imm_index]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V2, REG_P6, REG_V1, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FMUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_GX_3A  FMUL <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V0, REG_V2, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V4, REG_V6, REG_V3, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V8, REG_V10, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V12, REG_V14, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_GX_3B  FMUL <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V1, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V3, REG_V2, REG_V5, 1, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_V4, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_fmul, EA_SCALABLE, REG_V7, REG_V6, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HM_2A  FMUL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 0.5, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fmul, EA_SCALABLE, REG_V5, REG_P1, 2.0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> MultiplyBySelectedScalar(Vector<double> left, Vector<double> right, [ConstantExpected] byte rightIndex) => MultiplyBySelectedScalar(left, right, rightIndex);


        ///  MultiplyExtended : Multiply extended (0=2)

        /// <summary>
        /// svfloat32_t svmulx[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMULX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FMULX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmulx[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FMULX Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FMULX Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; FMULX Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svmulx[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FMULX Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FMULX Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMULX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmulx, EA_SCALABLE, REG_V3, REG_P7, REG_V0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> MultiplyExtended(Vector<float> left, Vector<float> right) => MultiplyExtended(left, right);

        /// <summary>
        /// svfloat64_t svmulx[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMULX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FMULX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmulx[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FMULX Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FMULX Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; FMULX Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svmulx[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FMULX Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FMULX Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FMULX <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fmulx, EA_SCALABLE, REG_V3, REG_P7, REG_V0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> MultiplyExtended(Vector<double> left, Vector<double> right) => MultiplyExtended(left, right);



        ///  MultiplySubtract : Multiply-subtract, minuend first

        /// <summary>
        /// svint8_t svmls[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2, svint8_t op3)
        ///   MLS Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svint8_t svmls[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2, svint8_t op3)
        ///   MLS Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MSB Ztied2.B, Pg/M, Zop3.B, Zop1.B
        ///   MSB Ztied3.B, Pg/M, Zop2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svint8_t svmls[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2, svint8_t op3)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; MLS Zresult.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; MSB Zresult.B, Pg/M, Zop3.B, Zop1.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop3.B; MSB Zresult.B, Pg/M, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> MultiplySubtract(Vector<sbyte> minuend, Vector<sbyte> left, Vector<sbyte> right) => MultiplySubtract(minuend, left, right);

        /// <summary>
        /// svint16_t svmls[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2, svint16_t op3)
        ///   MLS Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svint16_t svmls[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2, svint16_t op3)
        ///   MLS Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MSB Ztied2.H, Pg/M, Zop3.H, Zop1.H
        ///   MSB Ztied3.H, Pg/M, Zop2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svint16_t svmls[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2, svint16_t op3)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; MLS Zresult.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; MSB Zresult.H, Pg/M, Zop3.H, Zop1.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop3.H; MSB Zresult.H, Pg/M, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> MultiplySubtract(Vector<short> minuend, Vector<short> left, Vector<short> right) => MultiplySubtract(minuend, left, right);

        /// <summary>
        /// svint32_t svmls[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2, svint32_t op3)
        ///   MLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svint32_t svmls[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2, svint32_t op3)
        ///   MLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MSB Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   MSB Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svint32_t svmls[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2, svint32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; MLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; MSB Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; MSB Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> MultiplySubtract(Vector<int> minuend, Vector<int> left, Vector<int> right) => MultiplySubtract(minuend, left, right);

        /// <summary>
        /// svint64_t svmls[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2, svint64_t op3)
        ///   MLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svint64_t svmls[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2, svint64_t op3)
        ///   MLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MSB Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   MSB Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svint64_t svmls[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2, svint64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; MLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; MSB Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; MSB Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> MultiplySubtract(Vector<long> minuend, Vector<long> left, Vector<long> right) => MultiplySubtract(minuend, left, right);

        /// <summary>
        /// svuint8_t svmls[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2, svuint8_t op3)
        ///   MLS Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svuint8_t svmls[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2, svuint8_t op3)
        ///   MLS Ztied1.B, Pg/M, Zop2.B, Zop3.B
        ///   MSB Ztied2.B, Pg/M, Zop3.B, Zop1.B
        ///   MSB Ztied3.B, Pg/M, Zop2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.B, Pg/M, Zop2.B, Zop3.B
        /// svuint8_t svmls[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2, svuint8_t op3)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; MLS Zresult.B, Pg/M, Zop2.B, Zop3.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; MSB Zresult.B, Pg/M, Zop3.B, Zop1.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop3.B; MSB Zresult.B, Pg/M, Zop2.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> MultiplySubtract(Vector<byte> minuend, Vector<byte> left, Vector<byte> right) => MultiplySubtract(minuend, left, right);

        /// <summary>
        /// svuint16_t svmls[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2, svuint16_t op3)
        ///   MLS Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svuint16_t svmls[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2, svuint16_t op3)
        ///   MLS Ztied1.H, Pg/M, Zop2.H, Zop3.H
        ///   MSB Ztied2.H, Pg/M, Zop3.H, Zop1.H
        ///   MSB Ztied3.H, Pg/M, Zop2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.H, Pg/M, Zop2.H, Zop3.H
        /// svuint16_t svmls[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2, svuint16_t op3)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; MLS Zresult.H, Pg/M, Zop2.H, Zop3.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; MSB Zresult.H, Pg/M, Zop3.H, Zop1.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop3.H; MSB Zresult.H, Pg/M, Zop2.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> MultiplySubtract(Vector<ushort> minuend, Vector<ushort> left, Vector<ushort> right) => MultiplySubtract(minuend, left, right);

        /// <summary>
        /// svuint32_t svmls[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2, svuint32_t op3)
        ///   MLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svuint32_t svmls[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2, svuint32_t op3)
        ///   MLS Ztied1.S, Pg/M, Zop2.S, Zop3.S
        ///   MSB Ztied2.S, Pg/M, Zop3.S, Zop1.S
        ///   MSB Ztied3.S, Pg/M, Zop2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        /// svuint32_t svmls[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2, svuint32_t op3)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; MLS Zresult.S, Pg/M, Zop2.S, Zop3.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; MSB Zresult.S, Pg/M, Zop3.S, Zop1.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop3.S; MSB Zresult.S, Pg/M, Zop2.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> MultiplySubtract(Vector<uint> minuend, Vector<uint> left, Vector<uint> right) => MultiplySubtract(minuend, left, right);

        /// <summary>
        /// svuint64_t svmls[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2, svuint64_t op3)
        ///   MLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svuint64_t svmls[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2, svuint64_t op3)
        ///   MLS Ztied1.D, Pg/M, Zop2.D, Zop3.D
        ///   MSB Ztied2.D, Pg/M, Zop3.D, Zop1.D
        ///   MSB Ztied3.D, Pg/M, Zop2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; MLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        /// svuint64_t svmls[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2, svuint64_t op3)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; MLS Zresult.D, Pg/M, Zop2.D, Zop3.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; MSB Zresult.D, Pg/M, Zop3.D, Zop1.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop3.D; MSB Zresult.D, Pg/M, Zop2.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AR_4A  MLS <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_mls, EA_SCALABLE, REG_V2, REG_P1, REG_V31, REG_V31, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3A  MLS <Zda>.H, <Zn>.H, <Zm>.H[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V4, REG_V5, REG_V5, 5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V6, REG_V7, REG_V7, 7, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_FF_3B  MLS <Zda>.S, <Zn>.S, <Zm>.S[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V12, REG_V13, REG_V5, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V14, REG_V15, REG_V7, 3, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_FF_3C  MLS <Zda>.D, <Zn>.D, <Zm>.D[<imm>]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V20, REG_V21, REG_V10, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_mls, EA_SCALABLE, REG_V22, REG_V23, REG_V15, 1, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> MultiplySubtract(Vector<ulong> minuend, Vector<ulong> left, Vector<ulong> right) => MultiplySubtract(minuend, left, right);




        ///  Negate : Negate

        /// <summary>
        /// svint8_t svneg[_s8]_m(svint8_t inactive, svbool_t pg, svint8_t op)
        ///   NEG Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; NEG Zresult.B, Pg/M, Zop.B
        /// svint8_t svneg[_s8]_x(svbool_t pg, svint8_t op)
        ///   NEG Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; NEG Zresult.B, Pg/M, Zop.B
        /// svint8_t svneg[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; NEG Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  NEG <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_neg, EA_SCALABLE, REG_V23, REG_P0, REG_V8, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Negate(Vector<sbyte> value) => Negate(value);

        /// <summary>
        /// svint16_t svneg[_s16]_m(svint16_t inactive, svbool_t pg, svint16_t op)
        ///   NEG Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; NEG Zresult.H, Pg/M, Zop.H
        /// svint16_t svneg[_s16]_x(svbool_t pg, svint16_t op)
        ///   NEG Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; NEG Zresult.H, Pg/M, Zop.H
        /// svint16_t svneg[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; NEG Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  NEG <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_neg, EA_SCALABLE, REG_V23, REG_P0, REG_V8, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Negate(Vector<short> value) => Negate(value);

        /// <summary>
        /// svint32_t svneg[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   NEG Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; NEG Zresult.S, Pg/M, Zop.S
        /// svint32_t svneg[_s32]_x(svbool_t pg, svint32_t op)
        ///   NEG Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; NEG Zresult.S, Pg/M, Zop.S
        /// svint32_t svneg[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; NEG Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  NEG <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_neg, EA_SCALABLE, REG_V23, REG_P0, REG_V8, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Negate(Vector<int> value) => Negate(value);

        /// <summary>
        /// svint64_t svneg[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   NEG Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; NEG Zresult.D, Pg/M, Zop.D
        /// svint64_t svneg[_s64]_x(svbool_t pg, svint64_t op)
        ///   NEG Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; NEG Zresult.D, Pg/M, Zop.D
        /// svint64_t svneg[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; NEG Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  NEG <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_neg, EA_SCALABLE, REG_V23, REG_P0, REG_V8, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Negate(Vector<long> value) => Negate(value);

        /// <summary>
        /// svfloat32_t svneg[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FNEG Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FNEG Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svneg[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FNEG Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FNEG Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svneg[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FNEG Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  FNEG <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fneg, EA_SCALABLE, REG_V26, REG_P5, REG_V5, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Negate(Vector<float> value) => Negate(value);

        /// <summary>
        /// svfloat64_t svneg[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FNEG Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FNEG Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svneg[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FNEG Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FNEG Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svneg[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FNEG Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  FNEG <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fneg, EA_SCALABLE, REG_V26, REG_P5, REG_V5, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Negate(Vector<double> value) => Negate(value);




        ///  Not : Bitwise invert

        /// <summary>
        /// svint8_t svnot[_s8]_m(svint8_t inactive, svbool_t pg, svint8_t op)
        ///   NOT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.B, Pg/M, Zop.B
        /// svint8_t svnot[_s8]_x(svbool_t pg, svint8_t op)
        ///   NOT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; NOT Zresult.B, Pg/M, Zop.B
        /// svint8_t svnot[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; NOT Zresult.B, Pg/M, Zop.B
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Not(Vector<sbyte> value) => Not(value);

        /// <summary>
        /// svint16_t svnot[_s16]_m(svint16_t inactive, svbool_t pg, svint16_t op)
        ///   NOT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.H, Pg/M, Zop.H
        /// svint16_t svnot[_s16]_x(svbool_t pg, svint16_t op)
        ///   NOT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; NOT Zresult.H, Pg/M, Zop.H
        /// svint16_t svnot[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; NOT Zresult.H, Pg/M, Zop.H
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Not(Vector<short> value) => Not(value);

        /// <summary>
        /// svint32_t svnot[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   NOT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.S, Pg/M, Zop.S
        /// svint32_t svnot[_s32]_x(svbool_t pg, svint32_t op)
        ///   NOT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; NOT Zresult.S, Pg/M, Zop.S
        /// svint32_t svnot[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; NOT Zresult.S, Pg/M, Zop.S
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Not(Vector<int> value) => Not(value);

        /// <summary>
        /// svint64_t svnot[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   NOT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.D, Pg/M, Zop.D
        /// svint64_t svnot[_s64]_x(svbool_t pg, svint64_t op)
        ///   NOT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; NOT Zresult.D, Pg/M, Zop.D
        /// svint64_t svnot[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; NOT Zresult.D, Pg/M, Zop.D
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Not(Vector<long> value) => Not(value);

        /// <summary>
        /// svuint8_t svnot[_u8]_m(svuint8_t inactive, svbool_t pg, svuint8_t op)
        ///   NOT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svnot[_u8]_x(svbool_t pg, svuint8_t op)
        ///   NOT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; NOT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svnot[_u8]_z(svbool_t pg, svuint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; NOT Zresult.B, Pg/M, Zop.B
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Not(Vector<byte> value) => Not(value);

        /// <summary>
        /// svuint16_t svnot[_u16]_m(svuint16_t inactive, svbool_t pg, svuint16_t op)
        ///   NOT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svnot[_u16]_x(svbool_t pg, svuint16_t op)
        ///   NOT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; NOT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svnot[_u16]_z(svbool_t pg, svuint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; NOT Zresult.H, Pg/M, Zop.H
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Not(Vector<ushort> value) => Not(value);

        /// <summary>
        /// svuint32_t svnot[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   NOT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svnot[_u32]_x(svbool_t pg, svuint32_t op)
        ///   NOT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; NOT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svnot[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; NOT Zresult.S, Pg/M, Zop.S
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Not(Vector<uint> value) => Not(value);

        /// <summary>
        /// svuint64_t svnot[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   NOT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; NOT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svnot[_u64]_x(svbool_t pg, svuint64_t op)
        ///   NOT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; NOT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svnot[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; NOT Zresult.D, Pg/M, Zop.D
        /// svbool_t svnot[_b]_z(svbool_t pg, svbool_t op)
        ///   EOR Presult.B, Pg/Z, Pop.B, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_P9, REG_P5, REG_P15, INS_OPTS_SCALABLE_B); /* NOT <Pd>.B, <Pg>/Z, <Pn>.B */
        ///    IF_SVE_AP_3A  NOT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_not, EA_SCALABLE, REG_V25, REG_P6, REG_V6, INS_OPTS_SCALABLE_B);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Not(Vector<ulong> value) => Not(value);


        ///  Or : Bitwise inclusive OR

        /// <summary>
        /// svint8_t svorr[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   ORR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svorr[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   ORR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   ORR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svint8_t svorr[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; ORR Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; ORR Zresult.B, Pg/M, Zresult.B, Zop1.B
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Or(Vector<sbyte> left, Vector<sbyte> right) => Or(left, right);

        /// <summary>
        /// svint16_t svorr[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   ORR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svorr[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   ORR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   ORR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svint16_t svorr[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; ORR Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; ORR Zresult.H, Pg/M, Zresult.H, Zop1.H
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Or(Vector<short> left, Vector<short> right) => Or(left, right);

        /// <summary>
        /// svint32_t svorr[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   ORR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svorr[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   ORR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   ORR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svint32_t svorr[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; ORR Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; ORR Zresult.S, Pg/M, Zresult.S, Zop1.S
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Or(Vector<int> left, Vector<int> right) => Or(left, right);

        /// <summary>
        /// svint64_t svorr[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   ORR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svorr[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   ORR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   ORR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svint64_t svorr[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; ORR Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; ORR Zresult.D, Pg/M, Zresult.D, Zop1.D
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Or(Vector<long> left, Vector<long> right) => Or(left, right);

        /// <summary>
        /// svuint8_t svorr[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   ORR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svorr[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   ORR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   ORR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svuint8_t svorr[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; ORR Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; ORR Zresult.B, Pg/M, Zresult.B, Zop1.B
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Or(Vector<byte> left, Vector<byte> right) => Or(left, right);

        /// <summary>
        /// svuint16_t svorr[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   ORR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svorr[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   ORR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   ORR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svuint16_t svorr[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; ORR Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; ORR Zresult.H, Pg/M, Zresult.H, Zop1.H
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Or(Vector<ushort> left, Vector<ushort> right) => Or(left, right);

        /// <summary>
        /// svuint32_t svorr[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   ORR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svorr[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   ORR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   ORR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svuint32_t svorr[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; ORR Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; ORR Zresult.S, Pg/M, Zresult.S, Zop1.S
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Or(Vector<uint> left, Vector<uint> right) => Or(left, right);

        /// <summary>
        /// svuint64_t svorr[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   ORR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ORR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svorr[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   ORR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   ORR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   ORR Zresult.D, Zop1.D, Zop2.D
        /// svuint64_t svorr[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; ORR Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; ORR Zresult.D, Pg/M, Zresult.D, Zop1.D
        /// svbool_t svorr[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  ORR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V29, REG_P7, REG_V31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_orr, EA_SCALABLE, REG_P0, REG_P0, REG_P15, REG_P12, INS_OPTS_SCALABLE_B); /* ORR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  ORR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_orr, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Or(Vector<ulong> left, Vector<ulong> right) => Or(left, right);


        ///  OrAcross : Bitwise inclusive OR reduction to scalar

        /// <summary>
        /// int8_t svorv[_s8](svbool_t pg, svint8_t op)
        ///   ORV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> OrAcross(Vector<sbyte> value) => OrAcross(value);

        /// <summary>
        /// int16_t svorv[_s16](svbool_t pg, svint16_t op)
        ///   ORV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> OrAcross(Vector<short> value) => OrAcross(value);

        /// <summary>
        /// int32_t svorv[_s32](svbool_t pg, svint32_t op)
        ///   ORV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> OrAcross(Vector<int> value) => OrAcross(value);

        /// <summary>
        /// int64_t svorv[_s64](svbool_t pg, svint64_t op)
        ///   ORV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> OrAcross(Vector<long> value) => OrAcross(value);

        /// <summary>
        /// uint8_t svorv[_u8](svbool_t pg, svuint8_t op)
        ///   ORV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> OrAcross(Vector<byte> value) => OrAcross(value);

        /// <summary>
        /// uint16_t svorv[_u16](svbool_t pg, svuint16_t op)
        ///   ORV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> OrAcross(Vector<ushort> value) => OrAcross(value);

        /// <summary>
        /// uint32_t svorv[_u32](svbool_t pg, svuint32_t op)
        ///   ORV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> OrAcross(Vector<uint> value) => OrAcross(value);

        /// <summary>
        /// uint64_t svorv[_u64](svbool_t pg, svuint64_t op)
        ///   ORV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  ORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_4BYTE, REG_V2, REG_P2, REG_V2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_orv, EA_8BYTE, REG_V3, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> OrAcross(Vector<ulong> value) => OrAcross(value);


        ///  OrNot : Bitwise NOR

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> OrNot(Vector<sbyte> left, Vector<sbyte> right) => OrNot(left, right);

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> OrNot(Vector<short> left, Vector<short> right) => OrNot(left, right);

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> OrNot(Vector<int> left, Vector<int> right) => OrNot(left, right);

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> OrNot(Vector<long> left, Vector<long> right) => OrNot(left, right);

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> OrNot(Vector<byte> left, Vector<byte> right) => OrNot(left, right);

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> OrNot(Vector<ushort> left, Vector<ushort> right) => OrNot(left, right);

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> OrNot(Vector<uint> left, Vector<uint> right) => OrNot(left, right);

        /// <summary>
        /// svbool_t svnor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   NOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        /// svbool_t svorn[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   ORN Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_nor, EA_SCALABLE, REG_P5, REG_P13, REG_P10, REG_P7, INS_OPTS_SCALABLE_B); /* NOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> OrNot(Vector<ulong> left, Vector<ulong> right) => OrNot(left, right);


        ///  PopCount : Count nonzero bits

        /// <summary>
        /// svuint8_t svcnt[_s8]_m(svuint8_t inactive, svbool_t pg, svint8_t op)
        ///   CNT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcnt[_s8]_x(svbool_t pg, svint8_t op)
        ///   CNT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; CNT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcnt[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; CNT Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> PopCount(Vector<sbyte> value) => PopCount(value);

        /// <summary>
        /// svuint8_t svcnt[_u8]_m(svuint8_t inactive, svbool_t pg, svuint8_t op)
        ///   CNT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcnt[_u8]_x(svbool_t pg, svuint8_t op)
        ///   CNT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; CNT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svcnt[_u8]_z(svbool_t pg, svuint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; CNT Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> PopCount(Vector<byte> value) => PopCount(value);

        /// <summary>
        /// svuint16_t svcnt[_s16]_m(svuint16_t inactive, svbool_t pg, svint16_t op)
        ///   CNT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcnt[_s16]_x(svbool_t pg, svint16_t op)
        ///   CNT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; CNT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcnt[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; CNT Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> PopCount(Vector<short> value) => PopCount(value);

        /// <summary>
        /// svuint16_t svcnt[_u16]_m(svuint16_t inactive, svbool_t pg, svuint16_t op)
        ///   CNT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcnt[_u16]_x(svbool_t pg, svuint16_t op)
        ///   CNT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; CNT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svcnt[_u16]_z(svbool_t pg, svuint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; CNT Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> PopCount(Vector<ushort> value) => PopCount(value);

        /// <summary>
        /// svuint32_t svcnt[_s32]_m(svuint32_t inactive, svbool_t pg, svint32_t op)
        ///   CNT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnt[_s32]_x(svbool_t pg, svint32_t op)
        ///   CNT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CNT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnt[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CNT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> PopCount(Vector<int> value) => PopCount(value);

        /// <summary>
        /// svuint32_t svcnt[_f32]_m(svuint32_t inactive, svbool_t pg, svfloat32_t op)
        ///   CNT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnt[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   CNT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CNT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnt[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CNT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> PopCount(Vector<float> value) => PopCount(value);

        /// <summary>
        /// svuint32_t svcnt[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   CNT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnt[_u32]_x(svbool_t pg, svuint32_t op)
        ///   CNT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; CNT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svcnt[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; CNT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> PopCount(Vector<uint> value) => PopCount(value);

        /// <summary>
        /// svuint64_t svcnt[_s64]_m(svuint64_t inactive, svbool_t pg, svint64_t op)
        ///   CNT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnt[_s64]_x(svbool_t pg, svint64_t op)
        ///   CNT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CNT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnt[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CNT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> PopCount(Vector<long> value) => PopCount(value);

        /// <summary>
        /// svuint64_t svcnt[_f64]_m(svuint64_t inactive, svbool_t pg, svfloat64_t op)
        ///   CNT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnt[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   CNT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CNT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnt[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CNT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> PopCount(Vector<double> value) => PopCount(value);

        /// <summary>
        /// svuint64_t svcnt[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   CNT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; CNT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnt[_u64]_x(svbool_t pg, svuint64_t op)
        ///   CNT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; CNT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svcnt[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; CNT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AP_3A  CNT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_cnt, EA_SCALABLE, REG_V28, REG_P3, REG_V3, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> PopCount(Vector<ulong> value) => PopCount(value);


        ///  PrefetchBytes : Prefetch bytes

        /// <summary>
        /// void svprfb(svbool_t pg, const void *base, enum svprfop op)
        ///   PRFB op, Pg, [Xarray, Xindex]
        ///   PRFB op, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL1STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL2STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PSTL3STRM, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST6, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST7, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_SXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST14, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_CONST15, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_S_UXTW);
        ///    IF_SVE_HY_3A_A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///    IF_SVE_HY_3B  PRFB <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_HZ_2A_B  PRFB <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_V2, 31, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFB <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, -32);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P2, REG_R3, 17);
        ///    IF_SVE_IB_3A  PRFB <prfop>, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfb, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R1, REG_R2);
        /// </summary>
        public static unsafe void PrefetchBytes(Vector<byte> mask, void* address, [ConstantExpected] SvePrefetchType prefetchType) => PrefetchBytes(mask, address, prefetchType);


        ///  PrefetchInt16 : Prefetch halfwords

        /// <summary>
        /// void svprfh(svbool_t pg, const void *base, enum svprfop op)
        ///   PRFH op, Pg, [Xarray, Xindex, LSL #1]
        ///   PRFH op, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R8, REG_V9, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFH <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFH <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_V4, 62, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFH <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P1, REG_R2, 0);
        ///    IF_SVE_IB_3A  PRFH <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfh, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R7, REG_R8, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void PrefetchInt16(Vector<ushort> mask, void* address, [ConstantExpected] SvePrefetchType prefetchType) => PrefetchInt16(mask, address, prefetchType);


        ///  PrefetchInt32 : Prefetch words

        /// <summary>
        /// void svprfw(svbool_t pg, const void *base, enum svprfop op)
        ///   PRFW op, Pg, [Xarray, Xindex, LSL #2]
        ///   PRFW op, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R2, REG_V1, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFW <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P3, REG_R2, REG_V1, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFW <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_V5, 124, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFW <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P0, REG_R5, -32);
        ///    IF_SVE_IB_3A  PRFW <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfw, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R1, REG_R9, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void PrefetchInt32(Vector<uint> mask, void* address, [ConstantExpected] SvePrefetchType prefetchType) => PrefetchInt32(mask, address, prefetchType);


        ///  PrefetchInt64 : Prefetch doublewords

        /// <summary>
        /// void svprfd(svbool_t pg, const void *base, enum svprfop op)
        ///   PRFD op, Pg, [Xarray, Xindex, LSL #3]
        ///   PRFD op, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_HY_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3A_A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P6, REG_R5, REG_V4, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_HY_3B  PRFD <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, REG_V3, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_HZ_2A_B  PRFD <prfop>, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P4, REG_V3, 248, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_IA_2A  PRFD <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_PRFOP_R_R_I(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P7, REG_R4, 31);
        ///    IF_SVE_IB_3A  PRFD <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_PRFOP_R_R_R(INS_sve_prfd, EA_SCALABLE, SVE_PRFOP_PLDL1KEEP, REG_P5, REG_R4, REG_R3, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void PrefetchInt64(Vector<ulong> mask, void* address, [ConstantExpected] SvePrefetchType prefetchType) => PrefetchInt64(mask, address, prefetchType);


        ///  ReciprocalEstimate : Reciprocal estimate

        /// <summary>
        /// svfloat32_t svrecpe[_f32](svfloat32_t op)
        ///   FRECPE Zresult.S, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HF_2A  FRECPE <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_frecpe, EA_SCALABLE, REG_V0, REG_V2, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<float> ReciprocalEstimate(Vector<float> value) => ReciprocalEstimate(value);

        /// <summary>
        /// svfloat64_t svrecpe[_f64](svfloat64_t op)
        ///   FRECPE Zresult.D, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HF_2A  FRECPE <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_frecpe, EA_SCALABLE, REG_V0, REG_V2, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<double> ReciprocalEstimate(Vector<double> value) => ReciprocalEstimate(value);


        ///  ReciprocalExponent : Reciprocal exponent

        /// <summary>
        /// svfloat32_t svrecpx[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FRECPX Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FRECPX Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrecpx[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FRECPX Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FRECPX Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrecpx[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FRECPX Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HR_3A  FRECPX <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frecpx, EA_SCALABLE, REG_V5, REG_P5, REG_V5, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> ReciprocalExponent(Vector<float> value) => ReciprocalExponent(value);

        /// <summary>
        /// svfloat64_t svrecpx[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FRECPX Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FRECPX Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrecpx[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FRECPX Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FRECPX Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrecpx[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FRECPX Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HR_3A  FRECPX <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frecpx, EA_SCALABLE, REG_V5, REG_P5, REG_V5, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> ReciprocalExponent(Vector<double> value) => ReciprocalExponent(value);


        ///  ReciprocalSqrtEstimate : Reciprocal square root estimate

        /// <summary>
        /// svfloat32_t svrsqrte[_f32](svfloat32_t op)
        ///   FRSQRTE Zresult.S, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HF_2A  FRSQRTE <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_frsqrte, EA_SCALABLE, REG_V5, REG_V3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_frsqrte, EA_SCALABLE, REG_V9, REG_V5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> ReciprocalSqrtEstimate(Vector<float> value) => ReciprocalSqrtEstimate(value);

        /// <summary>
        /// svfloat64_t svrsqrte[_f64](svfloat64_t op)
        ///   FRSQRTE Zresult.D, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HF_2A  FRSQRTE <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_frsqrte, EA_SCALABLE, REG_V5, REG_V3, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_frsqrte, EA_SCALABLE, REG_V9, REG_V5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> ReciprocalSqrtEstimate(Vector<double> value) => ReciprocalSqrtEstimate(value);


        ///  ReciprocalSqrtStep : Reciprocal square root step

        /// <summary>
        /// svfloat32_t svrsqrts[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   FRSQRTS Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HK_3A  FRSQRTS <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frsqrts, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<float> ReciprocalSqrtStep(Vector<float> left, Vector<float> right) => ReciprocalSqrtStep(left, right);

        /// <summary>
        /// svfloat64_t svrsqrts[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   FRSQRTS Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HK_3A  FRSQRTS <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frsqrts, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<double> ReciprocalSqrtStep(Vector<double> left, Vector<double> right) => ReciprocalSqrtStep(left, right);


        ///  ReciprocalStep : Reciprocal step

        /// <summary>
        /// svfloat32_t svrecps[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   FRECPS Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HK_3A  FRECPS <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frecps, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<float> ReciprocalStep(Vector<float> left, Vector<float> right) => ReciprocalStep(left, right);

        /// <summary>
        /// svfloat64_t svrecps[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   FRECPS Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HK_3A  FRECPS <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frecps, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<double> ReciprocalStep(Vector<double> left, Vector<double> right) => ReciprocalStep(left, right);


        ///  ReverseBits : Reverse bits

        /// <summary>
        /// svint8_t svrbit[_s8]_m(svint8_t inactive, svbool_t pg, svint8_t op)
        ///   RBIT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.B, Pg/M, Zop.B
        /// svint8_t svrbit[_s8]_x(svbool_t pg, svint8_t op)
        ///   RBIT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.B, Pg/M, Zop.B
        /// svint8_t svrbit[_s8]_z(svbool_t pg, svint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; RBIT Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ReverseBits(Vector<sbyte> value) => ReverseBits(value);

        /// <summary>
        /// svint16_t svrbit[_s16]_m(svint16_t inactive, svbool_t pg, svint16_t op)
        ///   RBIT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.H, Pg/M, Zop.H
        /// svint16_t svrbit[_s16]_x(svbool_t pg, svint16_t op)
        ///   RBIT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.H, Pg/M, Zop.H
        /// svint16_t svrbit[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; RBIT Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ReverseBits(Vector<short> value) => ReverseBits(value);

        /// <summary>
        /// svint32_t svrbit[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   RBIT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.S, Pg/M, Zop.S
        /// svint32_t svrbit[_s32]_x(svbool_t pg, svint32_t op)
        ///   RBIT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.S, Pg/M, Zop.S
        /// svint32_t svrbit[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; RBIT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ReverseBits(Vector<int> value) => ReverseBits(value);

        /// <summary>
        /// svint64_t svrbit[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   RBIT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.D, Pg/M, Zop.D
        /// svint64_t svrbit[_s64]_x(svbool_t pg, svint64_t op)
        ///   RBIT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.D, Pg/M, Zop.D
        /// svint64_t svrbit[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; RBIT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ReverseBits(Vector<long> value) => ReverseBits(value);

        /// <summary>
        /// svuint8_t svrbit[_u8]_m(svuint8_t inactive, svbool_t pg, svuint8_t op)
        ///   RBIT Ztied.B, Pg/M, Zop.B
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svrbit[_u8]_x(svbool_t pg, svuint8_t op)
        ///   RBIT Ztied.B, Pg/M, Ztied.B
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.B, Pg/M, Zop.B
        /// svuint8_t svrbit[_u8]_z(svbool_t pg, svuint8_t op)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop.B; RBIT Zresult.B, Pg/M, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> ReverseBits(Vector<byte> value) => ReverseBits(value);

        /// <summary>
        /// svuint16_t svrbit[_u16]_m(svuint16_t inactive, svbool_t pg, svuint16_t op)
        ///   RBIT Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svrbit[_u16]_x(svbool_t pg, svuint16_t op)
        ///   RBIT Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.H, Pg/M, Zop.H
        /// svuint16_t svrbit[_u16]_z(svbool_t pg, svuint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; RBIT Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ReverseBits(Vector<ushort> value) => ReverseBits(value);

        /// <summary>
        /// svuint32_t svrbit[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   RBIT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svrbit[_u32]_x(svbool_t pg, svuint32_t op)
        ///   RBIT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.S, Pg/M, Zop.S
        /// svuint32_t svrbit[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; RBIT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ReverseBits(Vector<uint> value) => ReverseBits(value);

        /// <summary>
        /// svuint64_t svrbit[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   RBIT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; RBIT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrbit[_u64]_x(svbool_t pg, svuint64_t op)
        ///   RBIT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; RBIT Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrbit[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; RBIT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  RBIT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_rbit, EA_SCALABLE, REG_V28, REG_P1, REG_V19, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ReverseBits(Vector<ulong> value) => ReverseBits(value);


        ///  ReverseElement : Reverse all elements

        /// <summary>
        /// svint8_t svrev[_s8](svint8_t op)
        ///   REV Zresult.B, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<sbyte> ReverseElement(Vector<sbyte> value) => ReverseElement(value);

        /// <summary>
        /// svint16_t svrev[_s16](svint16_t op)
        ///   REV Zresult.H, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<short> ReverseElement(Vector<short> value) => ReverseElement(value);

        /// <summary>
        /// svint32_t svrev[_s32](svint32_t op)
        ///   REV Zresult.S, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<int> ReverseElement(Vector<int> value) => ReverseElement(value);

        /// <summary>
        /// svint64_t svrev[_s64](svint64_t op)
        ///   REV Zresult.D, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<long> ReverseElement(Vector<long> value) => ReverseElement(value);

        /// <summary>
        /// svuint8_t svrev[_u8](svuint8_t op)
        ///   REV Zresult.B, Zop.B
        /// svbool_t svrev_b8(svbool_t op)
        ///   REV Presult.B, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<byte> ReverseElement(Vector<byte> value) => ReverseElement(value);

        /// <summary>
        /// svuint16_t svrev[_u16](svuint16_t op)
        ///   REV Zresult.H, Zop.H
        /// svbool_t svrev_b16(svbool_t op)
        ///   REV Presult.H, Pop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<ushort> ReverseElement(Vector<ushort> value) => ReverseElement(value);

        /// <summary>
        /// svuint32_t svrev[_u32](svuint32_t op)
        ///   REV Zresult.S, Zop.S
        /// svbool_t svrev_b32(svbool_t op)
        ///   REV Presult.S, Pop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<uint> ReverseElement(Vector<uint> value) => ReverseElement(value);

        /// <summary>
        /// svuint64_t svrev[_u64](svuint64_t op)
        ///   REV Zresult.D, Zop.D
        /// svbool_t svrev_b64(svbool_t op)
        ///   REV Presult.D, Pop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<ulong> ReverseElement(Vector<ulong> value) => ReverseElement(value);

        /// <summary>
        /// svfloat32_t svrev[_f32](svfloat32_t op)
        ///   REV Zresult.S, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<float> ReverseElement(Vector<float> value) => ReverseElement(value);

        /// <summary>
        /// svfloat64_t svrev[_f64](svfloat64_t op)
        ///   REV Zresult.D, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CJ_2A  REV <Pd>.<T>, <Pn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P1, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P4, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P3, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_P0, REG_P6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_CG_2A  REV <Zd>.<T>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V3, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V7, REG_V1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R(INS_sve_rev, EA_SCALABLE, REG_V2, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<double> ReverseElement(Vector<double> value) => ReverseElement(value);


        ///  ReverseElement16 : Reverse halfwords within elements

        /// <summary>
        /// svint32_t svrevh[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   REVH Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; REVH Zresult.S, Pg/M, Zop.S
        /// svint32_t svrevh[_s32]_x(svbool_t pg, svint32_t op)
        ///   REVH Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; REVH Zresult.S, Pg/M, Zop.S
        /// svint32_t svrevh[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; REVH Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ReverseElement16(Vector<int> value) => ReverseElement16(value);

        /// <summary>
        /// svint64_t svrevh[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   REVH Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; REVH Zresult.D, Pg/M, Zop.D
        /// svint64_t svrevh[_s64]_x(svbool_t pg, svint64_t op)
        ///   REVH Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; REVH Zresult.D, Pg/M, Zop.D
        /// svint64_t svrevh[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; REVH Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ReverseElement16(Vector<long> value) => ReverseElement16(value);

        /// <summary>
        /// svuint32_t svrevh[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   REVH Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; REVH Zresult.S, Pg/M, Zop.S
        /// svuint32_t svrevh[_u32]_x(svbool_t pg, svuint32_t op)
        ///   REVH Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; REVH Zresult.S, Pg/M, Zop.S
        /// svuint32_t svrevh[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; REVH Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ReverseElement16(Vector<uint> value) => ReverseElement16(value);

        /// <summary>
        /// svuint64_t svrevh[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   REVH Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; REVH Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrevh[_u64]_x(svbool_t pg, svuint64_t op)
        ///   REVH Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; REVH Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrevh[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; REVH Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revh, EA_SCALABLE, REG_V26, REG_P3, REG_V17, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ReverseElement16(Vector<ulong> value) => ReverseElement16(value);


        ///  ReverseElement32 : Reverse words within elements

        /// <summary>
        /// svint64_t svrevw[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   REVW Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; REVW Zresult.D, Pg/M, Zop.D
        /// svint64_t svrevw[_s64]_x(svbool_t pg, svint64_t op)
        ///   REVW Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; REVW Zresult.D, Pg/M, Zop.D
        /// svint64_t svrevw[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; REVW Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVW <Zd>.D, <Pg>/M, <Zn>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_revw, EA_SCALABLE, REG_V25, REG_P4, REG_V16, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ReverseElement32(Vector<long> value) => ReverseElement32(value);

        /// <summary>
        /// svuint64_t svrevw[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   REVW Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; REVW Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrevw[_u64]_x(svbool_t pg, svuint64_t op)
        ///   REVW Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; REVW Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrevw[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; REVW Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVW <Zd>.D, <Pg>/M, <Zn>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_revw, EA_SCALABLE, REG_V25, REG_P4, REG_V16, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ReverseElement32(Vector<ulong> value) => ReverseElement32(value);


        ///  ReverseElement8 : Reverse bytes within elements

        /// <summary>
        /// svint16_t svrevb[_s16]_m(svint16_t inactive, svbool_t pg, svint16_t op)
        ///   REVB Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; REVB Zresult.H, Pg/M, Zop.H
        /// svint16_t svrevb[_s16]_x(svbool_t pg, svint16_t op)
        ///   REVB Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; REVB Zresult.H, Pg/M, Zop.H
        /// svint16_t svrevb[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; REVB Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ReverseElement8(Vector<short> value) => ReverseElement8(value);

        /// <summary>
        /// svint32_t svrevb[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   REVB Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; REVB Zresult.S, Pg/M, Zop.S
        /// svint32_t svrevb[_s32]_x(svbool_t pg, svint32_t op)
        ///   REVB Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; REVB Zresult.S, Pg/M, Zop.S
        /// svint32_t svrevb[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; REVB Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ReverseElement8(Vector<int> value) => ReverseElement8(value);

        /// <summary>
        /// svint64_t svrevb[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   REVB Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; REVB Zresult.D, Pg/M, Zop.D
        /// svint64_t svrevb[_s64]_x(svbool_t pg, svint64_t op)
        ///   REVB Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; REVB Zresult.D, Pg/M, Zop.D
        /// svint64_t svrevb[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; REVB Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ReverseElement8(Vector<long> value) => ReverseElement8(value);

        /// <summary>
        /// svuint16_t svrevb[_u16]_m(svuint16_t inactive, svbool_t pg, svuint16_t op)
        ///   REVB Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; REVB Zresult.H, Pg/M, Zop.H
        /// svuint16_t svrevb[_u16]_x(svbool_t pg, svuint16_t op)
        ///   REVB Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; REVB Zresult.H, Pg/M, Zop.H
        /// svuint16_t svrevb[_u16]_z(svbool_t pg, svuint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; REVB Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ReverseElement8(Vector<ushort> value) => ReverseElement8(value);

        /// <summary>
        /// svuint32_t svrevb[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   REVB Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; REVB Zresult.S, Pg/M, Zop.S
        /// svuint32_t svrevb[_u32]_x(svbool_t pg, svuint32_t op)
        ///   REVB Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; REVB Zresult.S, Pg/M, Zop.S
        /// svuint32_t svrevb[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; REVB Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ReverseElement8(Vector<uint> value) => ReverseElement8(value);

        /// <summary>
        /// svuint64_t svrevb[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   REVB Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; REVB Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrevb[_u64]_x(svbool_t pg, svuint64_t op)
        ///   REVB Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; REVB Zresult.D, Pg/M, Zop.D
        /// svuint64_t svrevb[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; REVB Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CU_3A  REVB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_revb, EA_SCALABLE, REG_V27, REG_P2, REG_V18, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ReverseElement8(Vector<ulong> value) => ReverseElement8(value);


        ///  RoundAwayFromZero : Round to nearest, ties away from zero

        /// <summary>
        /// svfloat32_t svrinta[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FRINTA Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FRINTA Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrinta[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FRINTA Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FRINTA Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrinta[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FRINTA Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTA <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frinta, EA_SCALABLE, REG_V26, REG_P7, REG_V2, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> RoundAwayFromZero(Vector<float> value) => RoundAwayFromZero(value);

        /// <summary>
        /// svfloat64_t svrinta[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FRINTA Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FRINTA Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrinta[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FRINTA Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FRINTA Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrinta[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FRINTA Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTA <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frinta, EA_SCALABLE, REG_V26, REG_P7, REG_V2, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> RoundAwayFromZero(Vector<double> value) => RoundAwayFromZero(value);


        ///  RoundToNearest : Round to nearest, ties to even

        /// <summary>
        /// svfloat32_t svrintn[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FRINTN Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FRINTN Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintn[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FRINTN Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FRINTN Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintn[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FRINTN Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTN <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintn, EA_SCALABLE, REG_V29, REG_P4, REG_V10, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> RoundToNearest(Vector<float> value) => RoundToNearest(value);

        /// <summary>
        /// svfloat64_t svrintn[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FRINTN Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FRINTN Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintn[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FRINTN Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FRINTN Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintn[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FRINTN Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTN <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintn, EA_SCALABLE, REG_V29, REG_P4, REG_V10, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> RoundToNearest(Vector<double> value) => RoundToNearest(value);


        ///  RoundToNegativeInfinity : Round towards -

        /// <summary>
        /// svfloat32_t svrintm[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FRINTM Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FRINTM Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintm[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FRINTM Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FRINTM Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintm[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FRINTM Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTM <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintm, EA_SCALABLE, REG_V28, REG_P5, REG_V0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> RoundToNegativeInfinity(Vector<float> value) => RoundToNegativeInfinity(value);

        /// <summary>
        /// svfloat64_t svrintm[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FRINTM Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FRINTM Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintm[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FRINTM Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FRINTM Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintm[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FRINTM Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTM <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintm, EA_SCALABLE, REG_V28, REG_P5, REG_V0, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> RoundToNegativeInfinity(Vector<double> value) => RoundToNegativeInfinity(value);


        ///  RoundToPositiveInfinity : Round towards +

        /// <summary>
        /// svfloat32_t svrintp[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FRINTP Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FRINTP Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintp[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FRINTP Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FRINTP Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintp[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FRINTP Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTP <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintp, EA_SCALABLE, REG_V30, REG_P3, REG_V11, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> RoundToPositiveInfinity(Vector<float> value) => RoundToPositiveInfinity(value);

        /// <summary>
        /// svfloat64_t svrintp[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FRINTP Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FRINTP Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintp[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FRINTP Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FRINTP Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintp[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FRINTP Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTP <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintp, EA_SCALABLE, REG_V30, REG_P3, REG_V11, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> RoundToPositiveInfinity(Vector<double> value) => RoundToPositiveInfinity(value);


        ///  RoundToZero : Round towards zero

        /// <summary>
        /// svfloat32_t svrintz[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FRINTZ Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FRINTZ Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintz[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FRINTZ Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FRINTZ Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svrintz[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FRINTZ Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintz, EA_SCALABLE, REG_V0, REG_P0, REG_V13, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> RoundToZero(Vector<float> value) => RoundToZero(value);

        /// <summary>
        /// svfloat64_t svrintz[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FRINTZ Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FRINTZ Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintz[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FRINTZ Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FRINTZ Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svrintz[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FRINTZ Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HQ_3A  FRINTZ <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_frintz, EA_SCALABLE, REG_V0, REG_P0, REG_V13, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> RoundToZero(Vector<double> value) => RoundToZero(value);




        ///  SaturatingDecrementBy16BitElementCount : Saturating decrement by number of halfword elements

        /// <summary>
        /// int32_t svqdech_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECH Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdech - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingDecrementBy16BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqdech_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECH Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdech - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingDecrementBy16BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqdech_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECH Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdech - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingDecrementBy16BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqdech_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECH Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdech - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingDecrementBy16BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// svint16_t svqdech_pat[_s16](svint16_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECH Ztied.H, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; SQDECH Zresult.H, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdech - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<short> SaturatingDecrementBy16BitElementCount(Vector<short> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// svuint16_t svqdech_pat[_u16](svuint16_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECH Ztied.H, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; UQDECH Zresult.H, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdech - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ushort> SaturatingDecrementBy16BitElementCount(Vector<ushort> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy16BitElementCount(value, scale, pattern);


        ///  SaturatingDecrementBy32BitElementCount : Saturating decrement by number of word elements

        /// <summary>
        /// int32_t svqdecw_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECW Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecw - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingDecrementBy32BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqdecw_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECW Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecw - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingDecrementBy32BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqdecw_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECW Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecw - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingDecrementBy32BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqdecw_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECW Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecw - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingDecrementBy32BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// svint32_t svqdecw_pat[_s32](svint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECW Ztied.S, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; SQDECW Zresult.S, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecw - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<int> SaturatingDecrementBy32BitElementCount(Vector<int> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// svuint32_t svqdecw_pat[_u32](svuint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECW Ztied.S, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; UQDECW Zresult.S, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecw - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<uint> SaturatingDecrementBy32BitElementCount(Vector<uint> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy32BitElementCount(value, scale, pattern);


        ///  SaturatingDecrementBy64BitElementCount : Saturating decrement by number of doubleword elements

        /// <summary>
        /// int32_t svqdecd_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECD Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecd - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingDecrementBy64BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqdecd_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECD Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecd - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingDecrementBy64BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqdecd_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECD Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecd - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingDecrementBy64BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqdecd_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECD Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecd - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingDecrementBy64BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// svint64_t svqdecd_pat[_s64](svint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECD Ztied.D, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; SQDECD Zresult.D, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecd - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<long> SaturatingDecrementBy64BitElementCount(Vector<long> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// svuint64_t svqdecd_pat[_u64](svuint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECD Ztied.D, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; UQDECD Zresult.D, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecd - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ulong> SaturatingDecrementBy64BitElementCount(Vector<ulong> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy64BitElementCount(value, scale, pattern);


        ///  SaturatingDecrementBy8BitElementCount : Saturating decrement by number of byte elements

        /// <summary>
        /// int32_t svqdecb_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECB Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecb - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingDecrementBy8BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy8BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqdecb_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQDECB Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqdecb - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingDecrementBy8BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy8BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqdecb_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECB Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecb - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingDecrementBy8BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy8BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqdecb_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQDECB Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqdecb - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingDecrementBy8BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingDecrementBy8BitElementCount(value, scale, pattern);


        ///  SaturatingDecrementByActiveElementCount : Saturating decrement by active element count

        /// <summary>
        /// svint16_t svqdecp[_s16](svint16_t op, svbool_t pg)
        ///   SQDECP Ztied.H, Pg
        ///   MOVPRFX Zresult, Zop; SQDECP Zresult.H, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> SaturatingDecrementByActiveElementCount(Vector<short> value, Vector<short> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// svint32_t svqdecp[_s32](svint32_t op, svbool_t pg)
        ///   SQDECP Ztied.S, Pg
        ///   MOVPRFX Zresult, Zop; SQDECP Zresult.S, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> SaturatingDecrementByActiveElementCount(Vector<int> value, Vector<int> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// svint64_t svqdecp[_s64](svint64_t op, svbool_t pg)
        ///   SQDECP Ztied.D, Pg
        ///   MOVPRFX Zresult, Zop; SQDECP Zresult.D, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> SaturatingDecrementByActiveElementCount(Vector<long> value, Vector<long> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqdecp[_n_s32]_b8(int32_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.B, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingDecrementByActiveElementCount(int value, Vector<byte> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqdecp[_n_s64]_b8(int64_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingDecrementByActiveElementCount(long value, Vector<byte> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqdecp[_n_u32]_b8(uint32_t op, svbool_t pg)
        ///   UQDECP Wtied, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingDecrementByActiveElementCount(uint value, Vector<byte> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqdecp[_n_u64]_b8(uint64_t op, svbool_t pg)
        ///   UQDECP Xtied, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingDecrementByActiveElementCount(ulong value, Vector<byte> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqdecp[_n_s32]_b16(int32_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.H, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingDecrementByActiveElementCount(int value, Vector<ushort> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqdecp[_n_s64]_b16(int64_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingDecrementByActiveElementCount(long value, Vector<ushort> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqdecp[_n_u32]_b16(uint32_t op, svbool_t pg)
        ///   UQDECP Wtied, Pg.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingDecrementByActiveElementCount(uint value, Vector<ushort> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqdecp[_n_u64]_b16(uint64_t op, svbool_t pg)
        ///   UQDECP Xtied, Pg.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingDecrementByActiveElementCount(ulong value, Vector<ushort> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// svuint16_t svqdecp[_u16](svuint16_t op, svbool_t pg)
        ///   UQDECP Ztied.H, Pg
        ///   MOVPRFX Zresult, Zop; UQDECP Zresult.H, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> SaturatingDecrementByActiveElementCount(Vector<ushort> value, Vector<ushort> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqdecp[_n_s32]_b32(int32_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.S, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingDecrementByActiveElementCount(int value, Vector<uint> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqdecp[_n_s64]_b32(int64_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingDecrementByActiveElementCount(long value, Vector<uint> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqdecp[_n_u32]_b32(uint32_t op, svbool_t pg)
        ///   UQDECP Wtied, Pg.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingDecrementByActiveElementCount(uint value, Vector<uint> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqdecp[_n_u64]_b32(uint64_t op, svbool_t pg)
        ///   UQDECP Xtied, Pg.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingDecrementByActiveElementCount(ulong value, Vector<uint> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// svuint32_t svqdecp[_u32](svuint32_t op, svbool_t pg)
        ///   UQDECP Ztied.S, Pg
        ///   MOVPRFX Zresult, Zop; UQDECP Zresult.S, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> SaturatingDecrementByActiveElementCount(Vector<uint> value, Vector<uint> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqdecp[_n_s32]_b64(int32_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.D, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingDecrementByActiveElementCount(int value, Vector<ulong> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqdecp[_n_s64]_b64(int64_t op, svbool_t pg)
        ///   SQDECP Xtied, Pg.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQDECP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqdecp, EA_SCALABLE, REG_V2, REG_P2, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingDecrementByActiveElementCount(long value, Vector<ulong> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqdecp[_n_u32]_b64(uint32_t op, svbool_t pg)
        ///   UQDECP Wtied, Pg.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingDecrementByActiveElementCount(uint value, Vector<ulong> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqdecp[_n_u64]_b64(uint64_t op, svbool_t pg)
        ///   UQDECP Xtied, Pg.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingDecrementByActiveElementCount(ulong value, Vector<ulong> from) => SaturatingDecrementByActiveElementCount(value, from);

        /// <summary>
        /// svuint64_t svqdecp[_u64](svuint64_t op, svbool_t pg)
        ///   UQDECP Ztied.D, Pg
        ///   MOVPRFX Zresult, Zop; UQDECP Zresult.D, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQDECP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQDECP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V6, REG_P6, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V7, REG_P7, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqdecp, EA_SCALABLE, REG_V8, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> SaturatingDecrementByActiveElementCount(Vector<ulong> value, Vector<ulong> from) => SaturatingDecrementByActiveElementCount(value, from);


        ///  SaturatingIncrementBy16BitElementCount : Saturating increment by number of halfword elements

        /// <summary>
        /// int32_t svqinch_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCH Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqinch - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingIncrementBy16BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqinch_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCH Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqinch - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingIncrementBy16BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqinch_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCH Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqinch - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingIncrementBy16BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqinch_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCH Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqinch - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingIncrementBy16BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// svint16_t svqinch_pat[_s16](svint16_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCH Ztied.H, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; SQINCH Zresult.H, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqinch - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<short> SaturatingIncrementBy16BitElementCount(Vector<short> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy16BitElementCount(value, scale, pattern);

        /// <summary>
        /// svuint16_t svqinch_pat[_u16](svuint16_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCH Ztied.H, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; UQINCH Zresult.H, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqinch - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ushort> SaturatingIncrementBy16BitElementCount(Vector<ushort> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy16BitElementCount(value, scale, pattern);


        ///  SaturatingIncrementBy32BitElementCount : Saturating increment by number of word elements

        /// <summary>
        /// int32_t svqincw_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCW Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincw - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingIncrementBy32BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqincw_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCW Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincw - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingIncrementBy32BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqincw_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCW Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincw - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingIncrementBy32BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqincw_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCW Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincw - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingIncrementBy32BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// svint32_t svqincw_pat[_s32](svint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCW Ztied.S, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; SQINCW Zresult.S, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincw - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<int> SaturatingIncrementBy32BitElementCount(Vector<int> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy32BitElementCount(value, scale, pattern);

        /// <summary>
        /// svuint32_t svqincw_pat[_u32](svuint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCW Ztied.S, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; UQINCW Zresult.S, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincw - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<uint> SaturatingIncrementBy32BitElementCount(Vector<uint> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy32BitElementCount(value, scale, pattern);


        ///  SaturatingIncrementBy64BitElementCount : Saturating increment by number of doubleword elements

        /// <summary>
        /// int32_t svqincd_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCD Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincd - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingIncrementBy64BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqincd_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCD Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincd - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingIncrementBy64BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqincd_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCD Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincd - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingIncrementBy64BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqincd_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCD Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincd - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingIncrementBy64BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// svint64_t svqincd_pat[_s64](svint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCD Ztied.D, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; SQINCD Zresult.D, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincd - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<long> SaturatingIncrementBy64BitElementCount(Vector<long> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy64BitElementCount(value, scale, pattern);

        /// <summary>
        /// svuint64_t svqincd_pat[_u64](svuint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCD Ztied.D, pattern, MUL #imm_factor
        ///   MOVPRFX Zresult, Zop; UQINCD Zresult.D, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincd - not implemented in coreclr
        /// </summary>
        public static unsafe Vector<ulong> SaturatingIncrementBy64BitElementCount(Vector<ulong> value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy64BitElementCount(value, scale, pattern);


        ///  SaturatingIncrementBy8BitElementCount : Saturating increment by number of byte elements

        /// <summary>
        /// int32_t svqincb_pat[_n_s32](int32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCB Xtied, Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincb - not implemented in coreclr
        /// </summary>
        public static unsafe int SaturatingIncrementBy8BitElementCount(int value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy8BitElementCount(value, scale, pattern);

        /// <summary>
        /// int64_t svqincb_pat[_n_s64](int64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   SQINCB Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_sqincb - not implemented in coreclr
        /// </summary>
        public static unsafe long SaturatingIncrementBy8BitElementCount(long value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy8BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint32_t svqincb_pat[_n_u32](uint32_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCB Wtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincb - not implemented in coreclr
        /// </summary>
        public static unsafe uint SaturatingIncrementBy8BitElementCount(uint value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy8BitElementCount(value, scale, pattern);

        /// <summary>
        /// uint64_t svqincb_pat[_n_u64](uint64_t op, enum svpattern pattern, uint64_t imm_factor)
        ///   UQINCB Xtied, pattern, MUL #imm_factor
        ///
        /// codegenarm64test:
        ///   sve_uqincb - not implemented in coreclr
        /// </summary>
        public static unsafe ulong SaturatingIncrementBy8BitElementCount(ulong value, [ConstantExpected] byte scale, [ConstantExpected] SveMaskPattern pattern = SveMaskPattern.All) => SaturatingIncrementBy8BitElementCount(value, scale, pattern);


        ///  SaturatingIncrementByActiveElementCount : Saturating increment by active element count

        /// <summary>
        /// svint16_t svqincp[_s16](svint16_t op, svbool_t pg)
        ///   SQINCP Ztied.H, Pg
        ///   MOVPRFX Zresult, Zop; SQINCP Zresult.H, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> SaturatingIncrementByActiveElementCount(Vector<short> value, Vector<short> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// svint32_t svqincp[_s32](svint32_t op, svbool_t pg)
        ///   SQINCP Ztied.S, Pg
        ///   MOVPRFX Zresult, Zop; SQINCP Zresult.S, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> SaturatingIncrementByActiveElementCount(Vector<int> value, Vector<int> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// svint64_t svqincp[_s64](svint64_t op, svbool_t pg)
        ///   SQINCP Ztied.D, Pg
        ///   MOVPRFX Zresult, Zop; SQINCP Zresult.D, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> SaturatingIncrementByActiveElementCount(Vector<long> value, Vector<long> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqincp[_n_s32]_b8(int32_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.B, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingIncrementByActiveElementCount(int value, Vector<byte> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqincp[_n_s64]_b8(int64_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingIncrementByActiveElementCount(long value, Vector<byte> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqincp[_n_u32]_b8(uint32_t op, svbool_t pg)
        ///   UQINCP Wtied, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingIncrementByActiveElementCount(uint value, Vector<byte> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqincp[_n_u64]_b8(uint64_t op, svbool_t pg)
        ///   UQINCP Xtied, Pg.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingIncrementByActiveElementCount(ulong value, Vector<byte> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqincp[_n_s32]_b16(int32_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.H, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingIncrementByActiveElementCount(int value, Vector<ushort> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqincp[_n_s64]_b16(int64_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingIncrementByActiveElementCount(long value, Vector<ushort> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqincp[_n_u32]_b16(uint32_t op, svbool_t pg)
        ///   UQINCP Wtied, Pg.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingIncrementByActiveElementCount(uint value, Vector<ushort> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqincp[_n_u64]_b16(uint64_t op, svbool_t pg)
        ///   UQINCP Xtied, Pg.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingIncrementByActiveElementCount(ulong value, Vector<ushort> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// svuint16_t svqincp[_u16](svuint16_t op, svbool_t pg)
        ///   UQINCP Ztied.H, Pg
        ///   MOVPRFX Zresult, Zop; UQINCP Zresult.H, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> SaturatingIncrementByActiveElementCount(Vector<ushort> value, Vector<ushort> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqincp[_n_s32]_b32(int32_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.S, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingIncrementByActiveElementCount(int value, Vector<uint> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqincp[_n_s64]_b32(int64_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingIncrementByActiveElementCount(long value, Vector<uint> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqincp[_n_u32]_b32(uint32_t op, svbool_t pg)
        ///   UQINCP Wtied, Pg.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingIncrementByActiveElementCount(uint value, Vector<uint> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqincp[_n_u64]_b32(uint64_t op, svbool_t pg)
        ///   UQINCP Xtied, Pg.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingIncrementByActiveElementCount(ulong value, Vector<uint> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// svuint32_t svqincp[_u32](svuint32_t op, svbool_t pg)
        ///   UQINCP Ztied.S, Pg
        ///   MOVPRFX Zresult, Zop; UQINCP Zresult.S, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> SaturatingIncrementByActiveElementCount(Vector<uint> value, Vector<uint> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int32_t svqincp[_n_s32]_b64(int32_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.D, Wtied
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe int SaturatingIncrementByActiveElementCount(int value, Vector<ulong> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// int64_t svqincp[_n_s64]_b64(int64_t op, svbool_t pg)
        ///   SQINCP Xtied, Pg.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  SQINCP <Xdn>, <Pm>.<T>, <Wdn>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  SQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V3, REG_P3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V4, REG_P4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_sqincp, EA_SCALABLE, REG_V5, REG_P5, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe long SaturatingIncrementByActiveElementCount(long value, Vector<ulong> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint32_t svqincp[_n_u32]_b64(uint32_t op, svbool_t pg)
        ///   UQINCP Wtied, Pg.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe uint SaturatingIncrementByActiveElementCount(uint value, Vector<ulong> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// uint64_t svqincp[_n_u64]_b64(uint64_t op, svbool_t pg)
        ///   UQINCP Xtied, Pg.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe ulong SaturatingIncrementByActiveElementCount(ulong value, Vector<ulong> from) => SaturatingIncrementByActiveElementCount(value, from);

        /// <summary>
        /// svuint64_t svqincp[_u64](svuint64_t op, svbool_t pg)
        ///   UQINCP Ztied.D, Pg
        ///   MOVPRFX Zresult, Zop; UQINCP Zresult.D, Pg
        ///
        /// codegenarm64test:
        ///    IF_SVE_DO_2A  UQINCP <Wdn>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R0, REG_P0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R1, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R2, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_4BYTE, REG_R3, REG_P3, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R4, REG_P4, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R5, REG_P5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R6, REG_P6, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_8BYTE, REG_R7, REG_P7, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_DP_2A  UQINCP <Zdn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V9, REG_P1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V10, REG_P2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R(INS_sve_uqincp, EA_SCALABLE, REG_V11, REG_P3, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> SaturatingIncrementByActiveElementCount(Vector<ulong> value, Vector<ulong> from) => SaturatingIncrementByActiveElementCount(value, from);


        ///  Scale : Adjust exponent

        /// <summary>
        /// svfloat32_t svscale[_f32]_m(svbool_t pg, svfloat32_t op1, svint32_t op2)
        ///   FSCALE Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FSCALE Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svscale[_f32]_x(svbool_t pg, svfloat32_t op1, svint32_t op2)
        ///   FSCALE Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FSCALE Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svscale[_f32]_z(svbool_t pg, svfloat32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FSCALE Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FSCALE <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fscale, EA_SCALABLE, REG_V4, REG_P6, REG_V31, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Scale(Vector<float> left, Vector<int> right) => Scale(left, right);

        /// <summary>
        /// svfloat64_t svscale[_f64]_m(svbool_t pg, svfloat64_t op1, svint64_t op2)
        ///   FSCALE Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FSCALE Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svscale[_f64]_x(svbool_t pg, svfloat64_t op1, svint64_t op2)
        ///   FSCALE Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FSCALE Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svscale[_f64]_z(svbool_t pg, svfloat64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FSCALE Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FSCALE <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fscale, EA_SCALABLE, REG_V4, REG_P6, REG_V31, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Scale(Vector<double> left, Vector<long> right) => Scale(left, right);


        ///  Scatter : Non-truncating store

        /// <summary>
        /// void svst1_scatter_[s32]offset[_s32](svbool_t pg, int32_t *base, svint32_t offsets, svint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zoffsets.S, SXTW]
        /// void svst1_scatter_[s32]index[_s32](svbool_t pg, int32_t *base, svint32_t indices, svint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<int> mask, int* address, Vector<int> indicies, Vector<int> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter[_u32base_s32](svbool_t pg, svuint32_t bases, svint32_t data)
        ///   ST1W Zdata.S, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<int> mask, Vector<uint> addresses, Vector<int> data) => Scatter(mask, addresses, data);

        /// <summary>
        /// void svst1_scatter_[u32]offset[_s32](svbool_t pg, int32_t *base, svuint32_t offsets, svint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zoffsets.S, UXTW]
        /// void svst1_scatter_[u32]index[_s32](svbool_t pg, int32_t *base, svuint32_t indices, svint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<int> mask, int* address, Vector<uint> indicies, Vector<int> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter_[s64]offset[_s64](svbool_t pg, int64_t *base, svint64_t offsets, svint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zoffsets.D]
        /// void svst1_scatter_[s64]index[_s64](svbool_t pg, int64_t *base, svint64_t indices, svint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<long> mask, long* address, Vector<long> indicies, Vector<long> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter[_u64base_s64](svbool_t pg, svuint64_t bases, svint64_t data)
        ///   ST1D Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<long> mask, Vector<ulong> addresses, Vector<long> data) => Scatter(mask, addresses, data);

        /// <summary>
        /// void svst1_scatter_[u64]offset[_s64](svbool_t pg, int64_t *base, svuint64_t offsets, svint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zoffsets.D]
        /// void svst1_scatter_[u64]index[_s64](svbool_t pg, int64_t *base, svuint64_t indices, svint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<long> mask, long* address, Vector<ulong> indicies, Vector<long> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter_[s32]offset[_u32](svbool_t pg, uint32_t *base, svint32_t offsets, svuint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zoffsets.S, SXTW]
        /// void svst1_scatter_[s32]index[_u32](svbool_t pg, uint32_t *base, svint32_t indices, svuint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<uint> mask, uint* address, Vector<int> indicies, Vector<uint> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter[_u32base_u32](svbool_t pg, svuint32_t bases, svuint32_t data)
        ///   ST1W Zdata.S, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<uint> mask, Vector<uint> addresses, Vector<uint> data) => Scatter(mask, addresses, data);

        /// <summary>
        /// void svst1_scatter_[u32]offset[_u32](svbool_t pg, uint32_t *base, svuint32_t offsets, svuint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zoffsets.S, UXTW]
        /// void svst1_scatter_[u32]index[_u32](svbool_t pg, uint32_t *base, svuint32_t indices, svuint32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<uint> mask, uint* address, Vector<uint> indicies, Vector<uint> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter_[s64]offset[_u64](svbool_t pg, uint64_t *base, svint64_t offsets, svuint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zoffsets.D]
        /// void svst1_scatter_[s64]index[_u64](svbool_t pg, uint64_t *base, svint64_t indices, svuint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<ulong> mask, ulong* address, Vector<long> indicies, Vector<ulong> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter[_u64base_u64](svbool_t pg, svuint64_t bases, svuint64_t data)
        ///   ST1D Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<ulong> mask, Vector<ulong> addresses, Vector<ulong> data) => Scatter(mask, addresses, data);

        /// <summary>
        /// void svst1_scatter_[u64]offset[_u64](svbool_t pg, uint64_t *base, svuint64_t offsets, svuint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zoffsets.D]
        /// void svst1_scatter_[u64]index[_u64](svbool_t pg, uint64_t *base, svuint64_t indices, svuint64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<ulong> mask, ulong* address, Vector<ulong> indicies, Vector<ulong> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter_[s32]offset[_f32](svbool_t pg, float32_t *base, svint32_t offsets, svfloat32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zoffsets.S, SXTW]
        /// void svst1_scatter_[s32]index[_f32](svbool_t pg, float32_t *base, svint32_t indices, svfloat32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zindices.S, SXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<float> mask, float* address, Vector<int> indicies, Vector<float> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter[_u32base_f32](svbool_t pg, svuint32_t bases, svfloat32_t data)
        ///   ST1W Zdata.S, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<float> mask, Vector<uint> addresses, Vector<float> data) => Scatter(mask, addresses, data);

        /// <summary>
        /// void svst1_scatter_[u32]offset[_f32](svbool_t pg, float32_t *base, svuint32_t offsets, svfloat32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zoffsets.S, UXTW]
        /// void svst1_scatter_[u32]index[_f32](svbool_t pg, float32_t *base, svuint32_t indices, svfloat32_t data)
        ///   ST1W Zdata.S, Pg, [Xbase, Zindices.S, UXTW #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<float> mask, float* address, Vector<uint> indicies, Vector<float> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter_[s64]offset[_f64](svbool_t pg, float64_t *base, svint64_t offsets, svfloat64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zoffsets.D]
        /// void svst1_scatter_[s64]index[_f64](svbool_t pg, float64_t *base, svint64_t indices, svfloat64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<double> mask, double* address, Vector<long> indicies, Vector<double> data) => Scatter(mask, address, indicies, data);

        /// <summary>
        /// void svst1_scatter[_u64base_f64](svbool_t pg, svuint64_t bases, svfloat64_t data)
        ///   ST1D Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<double> mask, Vector<ulong> addresses, Vector<double> data) => Scatter(mask, addresses, data);

        /// <summary>
        /// void svst1_scatter_[u64]offset[_f64](svbool_t pg, float64_t *base, svuint64_t offsets, svfloat64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zoffsets.D]
        /// void svst1_scatter_[u64]index[_f64](svbool_t pg, float64_t *base, svuint64_t indices, svfloat64_t data)
        ///   ST1D Zdata.D, Pg, [Xbase, Zindices.D, LSL #3]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter(Vector<double> mask, double* address, Vector<ulong> indicies, Vector<double> data) => Scatter(mask, address, indicies, data);


        ///  Scatter16BitNarrowing : Truncate to 16 bits and store

        /// <summary>
        /// void svst1h_scatter[_u32base_s32](svbool_t pg, svuint32_t bases, svint32_t data)
        ///   ST1H Zdata.S, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitNarrowing(Vector<int> mask, Vector<uint> addresses, Vector<int> data) => Scatter16BitNarrowing(mask, addresses, data);

        /// <summary>
        /// void svst1h_scatter[_u64base_s64](svbool_t pg, svuint64_t bases, svint64_t data)
        ///   ST1H Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitNarrowing(Vector<long> mask, Vector<ulong> addresses, Vector<long> data) => Scatter16BitNarrowing(mask, addresses, data);

        /// <summary>
        /// void svst1h_scatter[_u32base_u32](svbool_t pg, svuint32_t bases, svuint32_t data)
        ///   ST1H Zdata.S, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitNarrowing(Vector<uint> mask, Vector<uint> addresses, Vector<uint> data) => Scatter16BitNarrowing(mask, addresses, data);

        /// <summary>
        /// void svst1h_scatter[_u64base_u64](svbool_t pg, svuint64_t bases, svuint64_t data)
        ///   ST1H Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitNarrowing(Vector<ulong> mask, Vector<ulong> addresses, Vector<ulong> data) => Scatter16BitNarrowing(mask, addresses, data);


        ///  Scatter16BitWithByteOffsetsNarrowing : Truncate to 16 bits and store

        /// <summary>
        /// void svst1h_scatter_[s32]offset[_s32](svbool_t pg, int16_t *base, svint32_t offsets, svint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<int> mask, short* address, Vector<int> offsets, Vector<int> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[u32]offset[_s32](svbool_t pg, int16_t *base, svuint32_t offsets, svint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<int> mask, short* address, Vector<uint> offsets, Vector<int> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[s32]index[_s32](svbool_t pg, int16_t *base, svint32_t indices, svint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<int> mask, short* address, Vector<int> indices, Vector<int> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1h_scatter_[u32]index[_s32](svbool_t pg, int16_t *base, svuint32_t indices, svint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<int> mask, short* address, Vector<uint> indices, Vector<int> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1h_scatter_[s64]offset[_s64](svbool_t pg, int16_t *base, svint64_t offsets, svint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<long> mask, short* address, Vector<long> offsets, Vector<long> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[u64]offset[_s64](svbool_t pg, int16_t *base, svuint64_t offsets, svint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<long> mask, short* address, Vector<ulong> offsets, Vector<long> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[s64]index[_s64](svbool_t pg, int16_t *base, svint64_t indices, svint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<long> mask, short* address, Vector<long> indices, Vector<long> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1h_scatter_[u64]index[_s64](svbool_t pg, int16_t *base, svuint64_t indices, svint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<long> mask, short* address, Vector<ulong> indices, Vector<long> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1h_scatter_[s32]offset[_u32](svbool_t pg, uint16_t *base, svint32_t offsets, svuint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<uint> mask, ushort* address, Vector<int> offsets, Vector<uint> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[u32]offset[_u32](svbool_t pg, uint16_t *base, svuint32_t offsets, svuint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<uint> mask, ushort* address, Vector<uint> offsets, Vector<uint> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[s32]index[_u32](svbool_t pg, uint16_t *base, svint32_t indices, svuint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zindices.S, SXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<uint> mask, ushort* address, Vector<int> indices, Vector<uint> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1h_scatter_[u32]index[_u32](svbool_t pg, uint16_t *base, svuint32_t indices, svuint32_t data)
        ///   ST1H Zdata.S, Pg, [Xbase, Zindices.S, UXTW #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<uint> mask, ushort* address, Vector<uint> indices, Vector<uint> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1h_scatter_[s64]offset[_u64](svbool_t pg, uint16_t *base, svint64_t offsets, svuint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<ulong> mask, ushort* address, Vector<long> offsets, Vector<ulong> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[u64]offset[_u64](svbool_t pg, uint16_t *base, svuint64_t offsets, svuint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<ulong> mask, ushort* address, Vector<ulong> offsets, Vector<ulong> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1h_scatter_[s64]index[_u64](svbool_t pg, uint16_t *base, svint64_t indices, svuint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<ulong> mask, ushort* address, Vector<long> indices, Vector<ulong> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1h_scatter_[u64]index[_u64](svbool_t pg, uint16_t *base, svuint64_t indices, svuint64_t data)
        ///   ST1H Zdata.D, Pg, [Xbase, Zindices.D, LSL #1]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter16BitWithByteOffsetsNarrowing(Vector<ulong> mask, ushort* address, Vector<ulong> indices, Vector<ulong> data) => Scatter16BitWithByteOffsetsNarrowing(mask, address, indices, data);


        ///  Scatter32BitNarrowing : Truncate to 32 bits and store

        /// <summary>
        /// void svst1w_scatter[_u64base_s64](svbool_t pg, svuint64_t bases, svint64_t data)
        ///   ST1W Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitNarrowing(Vector<long> mask, Vector<ulong> addresses, Vector<long> data) => Scatter32BitNarrowing(mask, addresses, data);

        /// <summary>
        /// void svst1w_scatter[_u64base_u64](svbool_t pg, svuint64_t bases, svuint64_t data)
        ///   ST1W Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitNarrowing(Vector<ulong> mask, Vector<ulong> addresses, Vector<ulong> data) => Scatter32BitNarrowing(mask, addresses, data);


        ///  Scatter32BitWithByteOffsetsNarrowing : Truncate to 32 bits and store

        /// <summary>
        /// void svst1w_scatter_[s64]offset[_s64](svbool_t pg, int32_t *base, svint64_t offsets, svint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<long> mask, int* address, Vector<long> offsets, Vector<long> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1w_scatter_[u64]offset[_s64](svbool_t pg, int32_t *base, svuint64_t offsets, svint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<long> mask, int* address, Vector<ulong> offsets, Vector<long> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1w_scatter_[s64]index[_s64](svbool_t pg, int32_t *base, svint64_t indices, svint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<long> mask, int* address, Vector<long> indices, Vector<long> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1w_scatter_[u64]index[_s64](svbool_t pg, int32_t *base, svuint64_t indices, svint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<long> mask, int* address, Vector<ulong> indices, Vector<long> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1w_scatter_[s64]offset[_u64](svbool_t pg, uint32_t *base, svint64_t offsets, svuint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<ulong> mask, uint* address, Vector<long> offsets, Vector<ulong> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1w_scatter_[u64]offset[_u64](svbool_t pg, uint32_t *base, svuint64_t offsets, svuint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<ulong> mask, uint* address, Vector<ulong> offsets, Vector<ulong> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1w_scatter_[s64]index[_u64](svbool_t pg, uint32_t *base, svint64_t indices, svuint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<ulong> mask, uint* address, Vector<long> indices, Vector<ulong> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, indices, data);

        /// <summary>
        /// void svst1w_scatter_[u64]index[_u64](svbool_t pg, uint32_t *base, svuint64_t indices, svuint64_t data)
        ///   ST1W Zdata.D, Pg, [Xbase, Zindices.D, LSL #2]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter32BitWithByteOffsetsNarrowing(Vector<ulong> mask, uint* address, Vector<ulong> indices, Vector<ulong> data) => Scatter32BitWithByteOffsetsNarrowing(mask, address, indices, data);


        ///  Scatter8BitNarrowing : Truncate to 8 bits and store

        /// <summary>
        /// void svst1b_scatter[_u32base_s32](svbool_t pg, svuint32_t bases, svint32_t data)
        ///   ST1B Zdata.S, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitNarrowing(Vector<int> mask, Vector<uint> addresses, Vector<int> data) => Scatter8BitNarrowing(mask, addresses, data);

        /// <summary>
        /// void svst1b_scatter[_u64base_s64](svbool_t pg, svuint64_t bases, svint64_t data)
        ///   ST1B Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitNarrowing(Vector<long> mask, Vector<ulong> addresses, Vector<long> data) => Scatter8BitNarrowing(mask, addresses, data);

        /// <summary>
        /// void svst1b_scatter[_u32base_u32](svbool_t pg, svuint32_t bases, svuint32_t data)
        ///   ST1B Zdata.S, Pg, [Zbases.S, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitNarrowing(Vector<uint> mask, Vector<uint> addresses, Vector<uint> data) => Scatter8BitNarrowing(mask, addresses, data);

        /// <summary>
        /// void svst1b_scatter[_u64base_u64](svbool_t pg, svuint64_t bases, svuint64_t data)
        ///   ST1B Zdata.D, Pg, [Zbases.D, #0]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitNarrowing(Vector<ulong> mask, Vector<ulong> addresses, Vector<ulong> data) => Scatter8BitNarrowing(mask, addresses, data);


        ///  Scatter8BitWithByteOffsetsNarrowing : Truncate to 8 bits and store

        /// <summary>
        /// void svst1b_scatter_[s32]offset[_s32](svbool_t pg, int8_t *base, svint32_t offsets, svint32_t data)
        ///   ST1B Zdata.S, Pg, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<int> mask, sbyte* address, Vector<int> offsets, Vector<int> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1b_scatter_[u32]offset[_s32](svbool_t pg, int8_t *base, svuint32_t offsets, svint32_t data)
        ///   ST1B Zdata.S, Pg, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<int> mask, sbyte* address, Vector<uint> offsets, Vector<int> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1b_scatter_[s64]offset[_s64](svbool_t pg, int8_t *base, svint64_t offsets, svint64_t data)
        ///   ST1B Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<long> mask, sbyte* address, Vector<long> offsets, Vector<long> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1b_scatter_[u64]offset[_s64](svbool_t pg, int8_t *base, svuint64_t offsets, svint64_t data)
        ///   ST1B Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<long> mask, sbyte* address, Vector<ulong> offsets, Vector<long> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1b_scatter_[s32]offset[_u32](svbool_t pg, uint8_t *base, svint32_t offsets, svuint32_t data)
        ///   ST1B Zdata.S, Pg, [Xbase, Zoffsets.S, SXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<uint> mask, byte* address, Vector<int> offsets, Vector<uint> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1b_scatter_[u32]offset[_u32](svbool_t pg, uint8_t *base, svuint32_t offsets, svuint32_t data)
        ///   ST1B Zdata.S, Pg, [Xbase, Zoffsets.S, UXTW]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<uint> mask, byte* address, Vector<uint> offsets, Vector<uint> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1b_scatter_[s64]offset[_u64](svbool_t pg, uint8_t *base, svint64_t offsets, svuint64_t data)
        ///   ST1B Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<ulong> mask, byte* address, Vector<long> offsets, Vector<ulong> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);

        /// <summary>
        /// void svst1b_scatter_[u64]offset[_u64](svbool_t pg, uint8_t *base, svuint64_t offsets, svuint64_t data)
        ///   ST1B Zdata.D, Pg, [Xbase, Zoffsets.D]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Scatter8BitWithByteOffsetsNarrowing(Vector<ulong> mask, byte* address, Vector<ulong> offsets, Vector<ulong> data) => Scatter8BitWithByteOffsetsNarrowing(mask, address, offsets, data);


        ///  SetFfr : Write to the first-fault register

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<sbyte> value) => SetFfr(value);

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<short> value) => SetFfr(value);

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<int> value) => SetFfr(value);

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<long> value) => SetFfr(value);

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<byte> value) => SetFfr(value);

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<ushort> value) => SetFfr(value);

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<uint> value) => SetFfr(value);

        /// <summary>
        /// void svwrffr(svbool_t op)
        ///   WRFFR Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_DR_1A  WRFFR <Pn>.B
        ///        theEmitter->emitIns_R(INS_sve_wrffr, EA_SCALABLE, REG_P0);
        /// </summary>
        public static unsafe void SetFfr(Vector<ulong> value) => SetFfr(value);


        ///  ShiftLeftLogical : Logical shift left

        /// <summary>
        /// svint8_t svlsl[_s8]_m(svbool_t pg, svint8_t op1, svuint8_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svlsl[_s8]_x(svbool_t pg, svint8_t op1, svuint8_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   LSLR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svlsl[_s8]_z(svbool_t pg, svint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; LSL Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; LSLR Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ShiftLeftLogical(Vector<sbyte> left, Vector<byte> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svint8_t svlsl_wide[_s8]_m(svbool_t pg, svint8_t op1, svuint64_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.B, Pg/M, Zresult.B, Zop2.D
        /// svint8_t svlsl_wide[_s8]_x(svbool_t pg, svint8_t op1, svuint64_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   LSL Zresult.B, Zop1.B, Zop2.D
        /// svint8_t svlsl_wide[_s8]_z(svbool_t pg, svint8_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; LSL Zresult.B, Pg/M, Zresult.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ShiftLeftLogical(Vector<sbyte> left, Vector<ulong> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svint16_t svlsl[_s16]_m(svbool_t pg, svint16_t op1, svuint16_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svlsl[_s16]_x(svbool_t pg, svint16_t op1, svuint16_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   LSLR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svlsl[_s16]_z(svbool_t pg, svint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; LSL Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; LSLR Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ShiftLeftLogical(Vector<short> left, Vector<ushort> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svint16_t svlsl_wide[_s16]_m(svbool_t pg, svint16_t op1, svuint64_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.H, Pg/M, Zresult.H, Zop2.D
        /// svint16_t svlsl_wide[_s16]_x(svbool_t pg, svint16_t op1, svuint64_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   LSL Zresult.H, Zop1.H, Zop2.D
        /// svint16_t svlsl_wide[_s16]_z(svbool_t pg, svint16_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; LSL Zresult.H, Pg/M, Zresult.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ShiftLeftLogical(Vector<short> left, Vector<ulong> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svint32_t svlsl[_s32]_m(svbool_t pg, svint32_t op1, svuint32_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svlsl[_s32]_x(svbool_t pg, svint32_t op1, svuint32_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   LSLR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svlsl[_s32]_z(svbool_t pg, svint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; LSL Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; LSLR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ShiftLeftLogical(Vector<int> left, Vector<uint> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svint32_t svlsl_wide[_s32]_m(svbool_t pg, svint32_t op1, svuint64_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.S, Pg/M, Zresult.S, Zop2.D
        /// svint32_t svlsl_wide[_s32]_x(svbool_t pg, svint32_t op1, svuint64_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   LSL Zresult.S, Zop1.S, Zop2.D
        /// svint32_t svlsl_wide[_s32]_z(svbool_t pg, svint32_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; LSL Zresult.S, Pg/M, Zresult.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ShiftLeftLogical(Vector<int> left, Vector<ulong> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svint64_t svlsl[_s64]_m(svbool_t pg, svint64_t op1, svuint64_t op2)
        ///   LSL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svlsl[_s64]_x(svbool_t pg, svint64_t op1, svuint64_t op2)
        ///   LSL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   LSLR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svlsl[_s64]_z(svbool_t pg, svint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; LSL Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; LSLR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ShiftLeftLogical(Vector<long> left, Vector<ulong> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svuint8_t svlsl[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svlsl[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   LSLR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svlsl[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; LSL Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; LSLR Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> ShiftLeftLogical(Vector<byte> left, Vector<byte> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svuint8_t svlsl_wide[_u8]_m(svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.B, Pg/M, Zresult.B, Zop2.D
        /// svuint8_t svlsl_wide[_u8]_x(svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   LSL Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   LSL Zresult.B, Zop1.B, Zop2.D
        /// svuint8_t svlsl_wide[_u8]_z(svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; LSL Zresult.B, Pg/M, Zresult.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> ShiftLeftLogical(Vector<byte> left, Vector<ulong> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svuint16_t svlsl[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svlsl[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   LSLR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svlsl[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; LSL Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; LSLR Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ShiftLeftLogical(Vector<ushort> left, Vector<ushort> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svuint16_t svlsl_wide[_u16]_m(svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.H, Pg/M, Zresult.H, Zop2.D
        /// svuint16_t svlsl_wide[_u16]_x(svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   LSL Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   LSL Zresult.H, Zop1.H, Zop2.D
        /// svuint16_t svlsl_wide[_u16]_z(svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; LSL Zresult.H, Pg/M, Zresult.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ShiftLeftLogical(Vector<ushort> left, Vector<ulong> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svuint32_t svlsl[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svlsl[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   LSLR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svlsl[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; LSL Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; LSLR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ShiftLeftLogical(Vector<uint> left, Vector<uint> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svuint32_t svlsl_wide[_u32]_m(svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.S, Pg/M, Zresult.S, Zop2.D
        /// svuint32_t svlsl_wide[_u32]_x(svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   LSL Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   LSL Zresult.S, Zop1.S, Zop2.D
        /// svuint32_t svlsl_wide[_u32]_z(svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; LSL Zresult.S, Pg/M, Zresult.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ShiftLeftLogical(Vector<uint> left, Vector<ulong> right) => ShiftLeftLogical(left, right);

        /// <summary>
        /// svuint64_t svlsl[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   LSL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svlsl[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   LSL Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   LSLR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; LSL Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svlsl[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; LSL Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; LSLR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : left shifts  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V1, REG_P0, 0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V3, REG_P1, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V5, REG_P2, 7, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_P2, REG_V0, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AO_3A  LSL <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_P7, REG_V3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSL <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsl, EA_SCALABLE, REG_V19, REG_V0, REG_V12, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSL <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 15, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V0, 0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V31, REG_V31, 63, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsl, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ShiftLeftLogical(Vector<ulong> left, Vector<ulong> right) => ShiftLeftLogical(left, right);


        ///  ShiftRightArithmetic : Arithmetic shift right

        /// <summary>
        /// svint8_t svasr[_s8]_m(svbool_t pg, svint8_t op1, svuint8_t op2)
        ///   ASR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svasr[_s8]_x(svbool_t pg, svint8_t op1, svuint8_t op2)
        ///   ASR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   ASRR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svasr[_s8]_z(svbool_t pg, svint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; ASR Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; ASRR Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_P0, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V1, REG_P1, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V2, REG_P2, 3, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V3, REG_P3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P7, 8, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V5, REG_P0, REG_V21, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AO_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P3, REG_V24, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  ASR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V9, REG_V31, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  ASR <Zd>.<T>, <Zn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ShiftRightArithmetic(Vector<sbyte> left, Vector<byte> right) => ShiftRightArithmetic(left, right);

        /// <summary>
        /// svint8_t svasr_wide[_s8]_m(svbool_t pg, svint8_t op1, svuint64_t op2)
        ///   ASR Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.B, Pg/M, Zresult.B, Zop2.D
        /// svint8_t svasr_wide[_s8]_x(svbool_t pg, svint8_t op1, svuint64_t op2)
        ///   ASR Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   ASR Zresult.B, Zop1.B, Zop2.D
        /// svint8_t svasr_wide[_s8]_z(svbool_t pg, svint8_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; ASR Zresult.B, Pg/M, Zresult.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_P0, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V1, REG_P1, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V2, REG_P2, 3, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V3, REG_P3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P7, 8, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V5, REG_P0, REG_V21, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AO_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P3, REG_V24, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  ASR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V9, REG_V31, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  ASR <Zd>.<T>, <Zn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ShiftRightArithmetic(Vector<sbyte> left, Vector<ulong> right) => ShiftRightArithmetic(left, right);

        /// <summary>
        /// svint16_t svasr[_s16]_m(svbool_t pg, svint16_t op1, svuint16_t op2)
        ///   ASR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svasr[_s16]_x(svbool_t pg, svint16_t op1, svuint16_t op2)
        ///   ASR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   ASRR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svasr[_s16]_z(svbool_t pg, svint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; ASR Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; ASRR Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_P0, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V1, REG_P1, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V2, REG_P2, 3, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V3, REG_P3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P7, 8, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V5, REG_P0, REG_V21, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AO_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P3, REG_V24, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  ASR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V9, REG_V31, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  ASR <Zd>.<T>, <Zn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ShiftRightArithmetic(Vector<short> left, Vector<ushort> right) => ShiftRightArithmetic(left, right);

        /// <summary>
        /// svint16_t svasr_wide[_s16]_m(svbool_t pg, svint16_t op1, svuint64_t op2)
        ///   ASR Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.H, Pg/M, Zresult.H, Zop2.D
        /// svint16_t svasr_wide[_s16]_x(svbool_t pg, svint16_t op1, svuint64_t op2)
        ///   ASR Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   ASR Zresult.H, Zop1.H, Zop2.D
        /// svint16_t svasr_wide[_s16]_z(svbool_t pg, svint16_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; ASR Zresult.H, Pg/M, Zresult.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_P0, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V1, REG_P1, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V2, REG_P2, 3, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V3, REG_P3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P7, 8, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V5, REG_P0, REG_V21, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AO_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P3, REG_V24, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  ASR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V9, REG_V31, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  ASR <Zd>.<T>, <Zn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ShiftRightArithmetic(Vector<short> left, Vector<ulong> right) => ShiftRightArithmetic(left, right);

        /// <summary>
        /// svint32_t svasr[_s32]_m(svbool_t pg, svint32_t op1, svuint32_t op2)
        ///   ASR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svasr[_s32]_x(svbool_t pg, svint32_t op1, svuint32_t op2)
        ///   ASR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   ASRR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svasr[_s32]_z(svbool_t pg, svint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; ASR Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; ASRR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_P0, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V1, REG_P1, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V2, REG_P2, 3, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V3, REG_P3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P7, 8, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V5, REG_P0, REG_V21, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AO_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P3, REG_V24, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  ASR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V9, REG_V31, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  ASR <Zd>.<T>, <Zn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ShiftRightArithmetic(Vector<int> left, Vector<uint> right) => ShiftRightArithmetic(left, right);

        /// <summary>
        /// svint32_t svasr_wide[_s32]_m(svbool_t pg, svint32_t op1, svuint64_t op2)
        ///   ASR Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.S, Pg/M, Zresult.S, Zop2.D
        /// svint32_t svasr_wide[_s32]_x(svbool_t pg, svint32_t op1, svuint64_t op2)
        ///   ASR Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   ASR Zresult.S, Zop1.S, Zop2.D
        /// svint32_t svasr_wide[_s32]_z(svbool_t pg, svint32_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; ASR Zresult.S, Pg/M, Zresult.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_P0, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V1, REG_P1, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V2, REG_P2, 3, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V3, REG_P3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P7, 8, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V5, REG_P0, REG_V21, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AO_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P3, REG_V24, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  ASR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V9, REG_V31, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  ASR <Zd>.<T>, <Zn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ShiftRightArithmetic(Vector<int> left, Vector<ulong> right) => ShiftRightArithmetic(left, right);

        /// <summary>
        /// svint64_t svasr[_s64]_m(svbool_t pg, svint64_t op1, svuint64_t op2)
        ///   ASR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svasr[_s64]_x(svbool_t pg, svint64_t op1, svuint64_t op2)
        ///   ASR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   ASRR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; ASR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svasr[_s64]_z(svbool_t pg, svint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; ASR Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; ASRR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_P0, 1, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V1, REG_P1, 2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V2, REG_P2, 3, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V3, REG_P3, 7, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P7, 8, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AN_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V5, REG_P0, REG_V21, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AO_3A  ASR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V4, REG_P3, REG_V24, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  ASR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_asr, EA_SCALABLE, REG_V9, REG_V31, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  ASR <Zd>.<T>, <Zn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 7, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ShiftRightArithmetic(Vector<long> left, Vector<ulong> right) => ShiftRightArithmetic(left, right);


        ///  ShiftRightArithmeticForDivide : Arithmetic shift right for divide by immediate

        /// <summary>
        /// svint8_t svasrd[_n_s8]_m(svbool_t pg, svint8_t op1, uint64_t imm2)
        ///   ASRD Ztied1.B, Pg/M, Ztied1.B, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.B, Pg/M, Zresult.B, #imm2
        /// svint8_t svasrd[_n_s8]_x(svbool_t pg, svint8_t op1, uint64_t imm2)
        ///   ASRD Ztied1.B, Pg/M, Ztied1.B, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.B, Pg/M, Zresult.B, #imm2
        /// svint8_t svasrd[_n_s8]_z(svbool_t pg, svint8_t op1, uint64_t imm2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; ASRD Zresult.B, Pg/M, Zresult.B, #imm2
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASRD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V5, REG_P0, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V6, REG_P4, 8, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V7, REG_P7, 15, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V31, REG_P6, 16, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> ShiftRightArithmeticForDivide(Vector<sbyte> value, [ConstantExpected] byte control) => ShiftRightArithmeticForDivide(value, control);

        /// <summary>
        /// svint16_t svasrd[_n_s16]_m(svbool_t pg, svint16_t op1, uint64_t imm2)
        ///   ASRD Ztied1.H, Pg/M, Ztied1.H, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.H, Pg/M, Zresult.H, #imm2
        /// svint16_t svasrd[_n_s16]_x(svbool_t pg, svint16_t op1, uint64_t imm2)
        ///   ASRD Ztied1.H, Pg/M, Ztied1.H, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.H, Pg/M, Zresult.H, #imm2
        /// svint16_t svasrd[_n_s16]_z(svbool_t pg, svint16_t op1, uint64_t imm2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; ASRD Zresult.H, Pg/M, Zresult.H, #imm2
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASRD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V5, REG_P0, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V6, REG_P4, 8, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V7, REG_P7, 15, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V31, REG_P6, 16, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> ShiftRightArithmeticForDivide(Vector<short> value, [ConstantExpected] byte control) => ShiftRightArithmeticForDivide(value, control);

        /// <summary>
        /// svint32_t svasrd[_n_s32]_m(svbool_t pg, svint32_t op1, uint64_t imm2)
        ///   ASRD Ztied1.S, Pg/M, Ztied1.S, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.S, Pg/M, Zresult.S, #imm2
        /// svint32_t svasrd[_n_s32]_x(svbool_t pg, svint32_t op1, uint64_t imm2)
        ///   ASRD Ztied1.S, Pg/M, Ztied1.S, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.S, Pg/M, Zresult.S, #imm2
        /// svint32_t svasrd[_n_s32]_z(svbool_t pg, svint32_t op1, uint64_t imm2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; ASRD Zresult.S, Pg/M, Zresult.S, #imm2
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASRD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V5, REG_P0, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V6, REG_P4, 8, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V7, REG_P7, 15, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V31, REG_P6, 16, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> ShiftRightArithmeticForDivide(Vector<int> value, [ConstantExpected] byte control) => ShiftRightArithmeticForDivide(value, control);

        /// <summary>
        /// svint64_t svasrd[_n_s64]_m(svbool_t pg, svint64_t op1, uint64_t imm2)
        ///   ASRD Ztied1.D, Pg/M, Ztied1.D, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.D, Pg/M, Zresult.D, #imm2
        /// svint64_t svasrd[_n_s64]_x(svbool_t pg, svint64_t op1, uint64_t imm2)
        ///   ASRD Ztied1.D, Pg/M, Ztied1.D, #imm2
        ///   MOVPRFX Zresult, Zop1; ASRD Zresult.D, Pg/M, Zresult.D, #imm2
        /// svint64_t svasrd[_n_s64]_z(svbool_t pg, svint64_t op1, uint64_t imm2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; ASRD Zresult.D, Pg/M, Zresult.D, #imm2
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  ASRD <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V5, REG_P0, 1, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V6, REG_P4, 8, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V7, REG_P7, 15, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_asrd, EA_SCALABLE, REG_V31, REG_P6, 16, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> ShiftRightArithmeticForDivide(Vector<long> value, [ConstantExpected] byte control) => ShiftRightArithmeticForDivide(value, control);


        ///  ShiftRightLogical : Logical shift right

        /// <summary>
        /// svuint8_t svlsr[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   LSR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svlsr[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   LSR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   LSRR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svlsr[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; LSR Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; LSRR Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V8, REG_P5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V9, REG_P6, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_P7, 17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P1, 32, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AN_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P5, REG_V6, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AO_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V29, REG_V10, REG_V22, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSR <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> ShiftRightLogical(Vector<byte> left, Vector<byte> right) => ShiftRightLogical(left, right);

        /// <summary>
        /// svuint8_t svlsr_wide[_u8]_m(svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   LSR Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.B, Pg/M, Zresult.B, Zop2.D
        /// svuint8_t svlsr_wide[_u8]_x(svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   LSR Ztied1.B, Pg/M, Ztied1.B, Zop2.D
        ///   LSR Zresult.B, Zop1.B, Zop2.D
        /// svuint8_t svlsr_wide[_u8]_z(svbool_t pg, svuint8_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; LSR Zresult.B, Pg/M, Zresult.B, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V8, REG_P5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V9, REG_P6, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_P7, 17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P1, 32, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AN_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P5, REG_V6, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AO_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V29, REG_V10, REG_V22, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSR <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> ShiftRightLogical(Vector<byte> left, Vector<ulong> right) => ShiftRightLogical(left, right);

        /// <summary>
        /// svuint16_t svlsr[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   LSR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svlsr[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   LSR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   LSRR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svlsr[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; LSR Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; LSRR Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V8, REG_P5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V9, REG_P6, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_P7, 17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P1, 32, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AN_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P5, REG_V6, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AO_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V29, REG_V10, REG_V22, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSR <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ShiftRightLogical(Vector<ushort> left, Vector<ushort> right) => ShiftRightLogical(left, right);

        /// <summary>
        /// svuint16_t svlsr_wide[_u16]_m(svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   LSR Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.H, Pg/M, Zresult.H, Zop2.D
        /// svuint16_t svlsr_wide[_u16]_x(svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   LSR Ztied1.H, Pg/M, Ztied1.H, Zop2.D
        ///   LSR Zresult.H, Zop1.H, Zop2.D
        /// svuint16_t svlsr_wide[_u16]_z(svbool_t pg, svuint16_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; LSR Zresult.H, Pg/M, Zresult.H, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V8, REG_P5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V9, REG_P6, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_P7, 17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P1, 32, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AN_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P5, REG_V6, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AO_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V29, REG_V10, REG_V22, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSR <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ShiftRightLogical(Vector<ushort> left, Vector<ulong> right) => ShiftRightLogical(left, right);

        /// <summary>
        /// svuint32_t svlsr[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   LSR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svlsr[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   LSR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   LSRR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svlsr[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; LSR Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; LSRR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V8, REG_P5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V9, REG_P6, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_P7, 17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P1, 32, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AN_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P5, REG_V6, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AO_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V29, REG_V10, REG_V22, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSR <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ShiftRightLogical(Vector<uint> left, Vector<uint> right) => ShiftRightLogical(left, right);

        /// <summary>
        /// svuint32_t svlsr_wide[_u32]_m(svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   LSR Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.S, Pg/M, Zresult.S, Zop2.D
        /// svuint32_t svlsr_wide[_u32]_x(svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   LSR Ztied1.S, Pg/M, Ztied1.S, Zop2.D
        ///   LSR Zresult.S, Zop1.S, Zop2.D
        /// svuint32_t svlsr_wide[_u32]_z(svbool_t pg, svuint32_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; LSR Zresult.S, Pg/M, Zresult.S, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V8, REG_P5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V9, REG_P6, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_P7, 17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P1, 32, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AN_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P5, REG_V6, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AO_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V29, REG_V10, REG_V22, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSR <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ShiftRightLogical(Vector<uint> left, Vector<ulong> right) => ShiftRightLogical(left, right);

        /// <summary>
        /// svuint64_t svlsr[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   LSR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svlsr[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   LSR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   LSRR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   MOVPRFX Zresult, Zop1; LSR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svlsr[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; LSR Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; LSRR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AM_2A : right shifts  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V8, REG_P5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V9, REG_P6, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_P7, 17, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P1, 32, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_AN_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V5, REG_P5, REG_V6, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_AO_3A  LSR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_P0, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WIDE);
        ///    IF_SVE_BG_3A  LSR <Zd>.<T>, <Zn>.<T>, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_lsr, EA_SCALABLE, REG_V29, REG_V10, REG_V22, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED_WIDE);
        ///    IF_SVE_BF_2A  LSR <Zd>.<T>, <Zn>.<T>, #<const
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 8, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 5, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 4, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 16, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 9, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 32, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 15, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 16, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V0, 1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V31, REG_V31, 64, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 33, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_I(INS_sve_lsr, EA_SCALABLE, REG_V0, REG_V31, 32, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ShiftRightLogical(Vector<ulong> left, Vector<ulong> right) => ShiftRightLogical(left, right);


        ///  SignExtend16 : Sign-extend the low 16 bits

        /// <summary>
        /// svint32_t svexth[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   SXTH Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; SXTH Zresult.S, Pg/M, Zop.S
        /// svint32_t svexth[_s32]_x(svbool_t pg, svint32_t op)
        ///   SXTH Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; SXTH Zresult.S, Pg/M, Zop.S
        /// svint32_t svexth[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; SXTH Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  SXTH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxth, EA_SCALABLE, REG_V21, REG_P2, REG_V10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxth, EA_SCALABLE, REG_V21, REG_P2, REG_V10, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> SignExtend16(Vector<int> value) => SignExtend16(value);

        /// <summary>
        /// svint64_t svexth[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   SXTH Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; SXTH Zresult.D, Pg/M, Zop.D
        /// svint64_t svexth[_s64]_x(svbool_t pg, svint64_t op)
        ///   SXTH Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; SXTH Zresult.D, Pg/M, Zop.D
        /// svint64_t svexth[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; SXTH Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  SXTH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxth, EA_SCALABLE, REG_V21, REG_P2, REG_V10, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxth, EA_SCALABLE, REG_V21, REG_P2, REG_V10, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> SignExtend16(Vector<long> value) => SignExtend16(value);


        ///  SignExtend32 : Sign-extend the low 32 bits

        /// <summary>
        /// svint64_t svextw[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   SXTW Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; SXTW Zresult.D, Pg/M, Zop.D
        /// svint64_t svextw[_s64]_x(svbool_t pg, svint64_t op)
        ///   SXTW Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; SXTW Zresult.D, Pg/M, Zop.D
        /// svint64_t svextw[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; SXTW Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  SXTW <Zd>.D, <Pg>/M, <Zn>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtw, EA_SCALABLE, REG_V20, REG_P3, REG_V11, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> SignExtend32(Vector<long> value) => SignExtend32(value);


        ///  SignExtend8 : Sign-extend the low 8 bits

        /// <summary>
        /// svint16_t svextb[_s16]_m(svint16_t inactive, svbool_t pg, svint16_t op)
        ///   SXTB Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; SXTB Zresult.H, Pg/M, Zop.H
        /// svint16_t svextb[_s16]_x(svbool_t pg, svint16_t op)
        ///   SXTB Ztied.H, Pg/M, Ztied.H
        ///   MOVPRFX Zresult, Zop; SXTB Zresult.H, Pg/M, Zop.H
        /// svint16_t svextb[_s16]_z(svbool_t pg, svint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; SXTB Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  SXTB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> SignExtend8(Vector<short> value) => SignExtend8(value);

        /// <summary>
        /// svint32_t svextb[_s32]_m(svint32_t inactive, svbool_t pg, svint32_t op)
        ///   SXTB Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; SXTB Zresult.S, Pg/M, Zop.S
        /// svint32_t svextb[_s32]_x(svbool_t pg, svint32_t op)
        ///   SXTB Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; SXTB Zresult.S, Pg/M, Zop.S
        /// svint32_t svextb[_s32]_z(svbool_t pg, svint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; SXTB Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  SXTB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> SignExtend8(Vector<int> value) => SignExtend8(value);

        /// <summary>
        /// svint64_t svextb[_s64]_m(svint64_t inactive, svbool_t pg, svint64_t op)
        ///   SXTB Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; SXTB Zresult.D, Pg/M, Zop.D
        /// svint64_t svextb[_s64]_x(svbool_t pg, svint64_t op)
        ///   SXTB Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; SXTB Zresult.D, Pg/M, Zop.D
        /// svint64_t svextb[_s64]_z(svbool_t pg, svint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; SXTB Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  SXTB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_sxtb, EA_SCALABLE, REG_V22, REG_P1, REG_V9, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> SignExtend8(Vector<long> value) => SignExtend8(value);


        ///  SignExtendWideningLower : Unpack and extend low half

        /// <summary>
        /// svint16_t svunpklo[_s16](svint8_t op)
        ///   SUNPKLO Zresult.H, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  SUNPKLO <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_sunpklo, EA_SCALABLE, REG_V1, REG_V5, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<short> SignExtendWideningLower(Vector<sbyte> value) => SignExtendWideningLower(value);

        /// <summary>
        /// svint32_t svunpklo[_s32](svint16_t op)
        ///   SUNPKLO Zresult.S, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  SUNPKLO <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_sunpklo, EA_SCALABLE, REG_V1, REG_V5, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<int> SignExtendWideningLower(Vector<short> value) => SignExtendWideningLower(value);

        /// <summary>
        /// svint64_t svunpklo[_s64](svint32_t op)
        ///   SUNPKLO Zresult.D, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  SUNPKLO <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_sunpklo, EA_SCALABLE, REG_V1, REG_V5, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<long> SignExtendWideningLower(Vector<int> value) => SignExtendWideningLower(value);


        ///  SignExtendWideningUpper : Unpack and extend high half

        /// <summary>
        /// svint16_t svunpkhi[_s16](svint8_t op)
        ///   SUNPKHI Zresult.H, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  SUNPKHI <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_sunpkhi, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<short> SignExtendWideningUpper(Vector<sbyte> value) => SignExtendWideningUpper(value);

        /// <summary>
        /// svint32_t svunpkhi[_s32](svint16_t op)
        ///   SUNPKHI Zresult.S, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  SUNPKHI <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_sunpkhi, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<int> SignExtendWideningUpper(Vector<short> value) => SignExtendWideningUpper(value);

        /// <summary>
        /// svint64_t svunpkhi[_s64](svint32_t op)
        ///   SUNPKHI Zresult.D, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  SUNPKHI <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_sunpkhi, EA_SCALABLE, REG_V2, REG_V4, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<long> SignExtendWideningUpper(Vector<int> value) => SignExtendWideningUpper(value);


        ///  Splice : Splice two vectors under predicate control

        /// <summary>
        /// svint8_t svsplice[_s8](svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SPLICE Ztied1.B, Pg, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.B, Pg, Zresult.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<sbyte> Splice(Vector<sbyte> mask, Vector<sbyte> left, Vector<sbyte> right) => Splice(mask, left, right);

        /// <summary>
        /// svint16_t svsplice[_s16](svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SPLICE Ztied1.H, Pg, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.H, Pg, Zresult.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<short> Splice(Vector<short> mask, Vector<short> left, Vector<short> right) => Splice(mask, left, right);

        /// <summary>
        /// svint32_t svsplice[_s32](svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SPLICE Ztied1.S, Pg, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.S, Pg, Zresult.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<int> Splice(Vector<int> mask, Vector<int> left, Vector<int> right) => Splice(mask, left, right);

        /// <summary>
        /// svint64_t svsplice[_s64](svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SPLICE Ztied1.D, Pg, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.D, Pg, Zresult.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<long> Splice(Vector<long> mask, Vector<long> left, Vector<long> right) => Splice(mask, left, right);

        /// <summary>
        /// svuint8_t svsplice[_u8](svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   SPLICE Ztied1.B, Pg, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.B, Pg, Zresult.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<byte> Splice(Vector<byte> mask, Vector<byte> left, Vector<byte> right) => Splice(mask, left, right);

        /// <summary>
        /// svuint16_t svsplice[_u16](svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   SPLICE Ztied1.H, Pg, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.H, Pg, Zresult.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<ushort> Splice(Vector<ushort> mask, Vector<ushort> left, Vector<ushort> right) => Splice(mask, left, right);

        /// <summary>
        /// svuint32_t svsplice[_u32](svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   SPLICE Ztied1.S, Pg, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.S, Pg, Zresult.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<uint> Splice(Vector<uint> mask, Vector<uint> left, Vector<uint> right) => Splice(mask, left, right);

        /// <summary>
        /// svuint64_t svsplice[_u64](svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   SPLICE Ztied1.D, Pg, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.D, Pg, Zresult.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<ulong> Splice(Vector<ulong> mask, Vector<ulong> left, Vector<ulong> right) => Splice(mask, left, right);

        /// <summary>
        /// svfloat32_t svsplice[_f32](svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   SPLICE Ztied1.S, Pg, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.S, Pg, Zresult.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<float> Splice(Vector<float> mask, Vector<float> left, Vector<float> right) => Splice(mask, left, right);

        /// <summary>
        /// svfloat64_t svsplice[_f64](svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   SPLICE Ztied1.D, Pg, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SPLICE Zresult.D, Pg, Zresult.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_CV_3A  SPLICE <Zd>.<T>, <Pv>, {<Zn1>.<T>, <Zn2>.<T>}
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V0, REG_P0, REG_V30, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V3, REG_P7, REG_V27, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///    IF_SVE_CV_3B  SPLICE <Zdn>.<T>, <Pv>, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V1, REG_P1, REG_V29, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_splice, EA_SCALABLE, REG_V2, REG_P6, REG_V28, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<double> Splice(Vector<double> mask, Vector<double> left, Vector<double> right) => Splice(mask, left, right);


        ///  Sqrt : Square root

        /// <summary>
        /// svfloat32_t svsqrt[_f32]_m(svfloat32_t inactive, svbool_t pg, svfloat32_t op)
        ///   FSQRT Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; FSQRT Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svsqrt[_f32]_x(svbool_t pg, svfloat32_t op)
        ///   FSQRT Ztied.S, Pg/M, Ztied.S
        ///   MOVPRFX Zresult, Zop; FSQRT Zresult.S, Pg/M, Zop.S
        /// svfloat32_t svsqrt[_f32]_z(svbool_t pg, svfloat32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; FSQRT Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HR_3A  FSQRT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fsqrt, EA_SCALABLE, REG_V6, REG_P6, REG_V6, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Sqrt(Vector<float> value) => Sqrt(value);

        /// <summary>
        /// svfloat64_t svsqrt[_f64]_m(svfloat64_t inactive, svbool_t pg, svfloat64_t op)
        ///   FSQRT Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; FSQRT Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svsqrt[_f64]_x(svbool_t pg, svfloat64_t op)
        ///   FSQRT Ztied.D, Pg/M, Ztied.D
        ///   MOVPRFX Zresult, Zop; FSQRT Zresult.D, Pg/M, Zop.D
        /// svfloat64_t svsqrt[_f64]_z(svbool_t pg, svfloat64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; FSQRT Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HR_3A  FSQRT <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fsqrt, EA_SCALABLE, REG_V6, REG_P6, REG_V6, INS_OPTS_SCALABLE_S);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Sqrt(Vector<double> value) => Sqrt(value);


        ///  Store : Non-truncating store

        /// <summary>
        /// void svst1[_s8](svbool_t pg, int8_t *base, svint8_t data)
        ///   ST1B Zdata.B, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.B, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<sbyte> mask, sbyte* address, Vector<sbyte> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_s8](svbool_t pg, int8_t *base, svint8x2_t data)
        ///   ST2B {Zdata0.B, Zdata1.B}, Pg, [Xarray, Xindex]
        ///   ST2B {Zdata0.B, Zdata1.B}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2B {<Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, -16, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_JC_4A  ST2B {<Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void Store(Vector<sbyte> mask, sbyte* address, (Vector<sbyte> Value1, Vector<sbyte> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_s8](svbool_t pg, int8_t *base, svint8x3_t data)
        ///   ST3B {Zdata0.B - Zdata2.B}, Pg, [Xarray, Xindex]
        ///   ST3B {Zdata0.B - Zdata2.B}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3b, EA_SCALABLE, REG_V7, REG_P6, REG_R5, -24, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_JC_4A  ST3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3b, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_R4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void Store(Vector<sbyte> mask, sbyte* address, (Vector<sbyte> Value1, Vector<sbyte> Value2, Vector<sbyte> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_s8](svbool_t pg, int8_t *base, svint8x4_t data)
        ///   ST4B {Zdata0.B - Zdata3.B}, Pg, [Xarray, Xindex]
        ///   ST4B {Zdata0.B - Zdata3.B}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4b, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -32, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_JC_4A  ST4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4b, EA_SCALABLE, REG_V0, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void Store(Vector<sbyte> mask, sbyte* address, (Vector<sbyte> Value1, Vector<sbyte> Value2, Vector<sbyte> Value3, Vector<sbyte> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_s16](svbool_t pg, int16_t *base, svint16_t data)
        ///   ST1H Zdata.H, Pg, [Xarray, Xindex, LSL #1]
        ///   ST1H Zdata.H, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<short> mask, short* address, Vector<short> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_s16](svbool_t pg, int16_t *base, svint16x2_t data)
        ///   ST2H {Zdata0.H, Zdata1.H}, Pg, [Xarray, Xindex, LSL #1]
        ///   ST2H {Zdata0.H, Zdata1.H}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2H {<Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2h, EA_SCALABLE, REG_V6, REG_P7, REG_R8, -16, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_JC_4A  ST2H {<Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2h, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_R6, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<short> mask, short* address, (Vector<short> Value1, Vector<short> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_s16](svbool_t pg, int16_t *base, svint16x3_t data)
        ///   ST3H {Zdata0.H - Zdata2.H}, Pg, [Xarray, Xindex, LSL #1]
        ///   ST3H {Zdata0.H - Zdata2.H}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, -24, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_JC_4A  ST3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3h, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<short> mask, short* address, (Vector<short> Value1, Vector<short> Value2, Vector<short> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_s16](svbool_t pg, int16_t *base, svint16x4_t data)
        ///   ST4H {Zdata0.H - Zdata3.H}, Pg, [Xarray, Xindex, LSL #1]
        ///   ST4H {Zdata0.H - Zdata3.H}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4h, EA_SCALABLE, REG_V3, REG_P5, REG_R2, -32, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_JC_4A  ST4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4h, EA_SCALABLE, REG_V1, REG_P0, REG_R9, REG_R8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<short> mask, short* address, (Vector<short> Value1, Vector<short> Value2, Vector<short> Value3, Vector<short> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_s32](svbool_t pg, int32_t *base, svint32_t data)
        ///   ST1W Zdata.S, Pg, [Xarray, Xindex, LSL #2]
        ///   ST1W Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<int> mask, int* address, Vector<int> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_s32](svbool_t pg, int32_t *base, svint32x2_t data)
        ///   ST2W {Zdata0.S, Zdata1.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST2W {Zdata0.S, Zdata1.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2W {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2w, EA_SCALABLE, REG_V8, REG_P1, REG_R9, -16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST2W {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2w, EA_SCALABLE, REG_V0, REG_P2, REG_R8, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<int> mask, int* address, (Vector<int> Value1, Vector<int> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_s32](svbool_t pg, int32_t *base, svint32x3_t data)
        ///   ST3W {Zdata0.S - Zdata2.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST3W {Zdata0.S - Zdata2.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3w, EA_SCALABLE, REG_V1, REG_P3, REG_R8, -24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<int> mask, int* address, (Vector<int> Value1, Vector<int> Value2, Vector<int> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_s32](svbool_t pg, int32_t *base, svint32x4_t data)
        ///   ST4W {Zdata0.S - Zdata3.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST4W {Zdata0.S - Zdata3.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4w, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 28, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4w, EA_SCALABLE, REG_V31, REG_P1, REG_R5, 28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4w, EA_SCALABLE, REG_V0, REG_P1, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<int> mask, int* address, (Vector<int> Value1, Vector<int> Value2, Vector<int> Value3, Vector<int> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_s64](svbool_t pg, int64_t *base, svint64_t data)
        ///   ST1D Zdata.D, Pg, [Xarray, Xindex, LSL #3]
        ///   ST1D Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<long> mask, long* address, Vector<long> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_s64](svbool_t pg, int64_t *base, svint64x2_t data)
        ///   ST2D {Zdata0.D, Zdata1.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST2D {Zdata0.D, Zdata1.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2D {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2d, EA_SCALABLE, REG_V5, REG_P4, REG_R3, -16, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST2D {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2d, EA_SCALABLE, REG_V1, REG_P7, REG_R6, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<long> mask, long* address, (Vector<long> Value1, Vector<long> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_s64](svbool_t pg, int64_t *base, svint64x3_t data)
        ///   ST3D {Zdata0.D - Zdata2.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST3D {Zdata0.D - Zdata2.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3d, EA_SCALABLE, REG_V2, REG_P3, REG_R4, -24, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3d, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<long> mask, long* address, (Vector<long> Value1, Vector<long> Value2, Vector<long> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_s64](svbool_t pg, int64_t *base, svint64x4_t data)
        ///   ST4D {Zdata0.D - Zdata3.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST4D {Zdata0.D - Zdata3.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4d, EA_SCALABLE, REG_V2, REG_P0, REG_R1, -32, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4d, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<long> mask, long* address, (Vector<long> Value1, Vector<long> Value2, Vector<long> Value3, Vector<long> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_u8](svbool_t pg, uint8_t *base, svuint8_t data)
        ///   ST1B Zdata.B, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.B, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<byte> mask, byte* address, Vector<byte> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_u8](svbool_t pg, uint8_t *base, svuint8x2_t data)
        ///   ST2B {Zdata0.B, Zdata1.B}, Pg, [Xarray, Xindex]
        ///   ST2B {Zdata0.B, Zdata1.B}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2B {<Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, -16, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_JC_4A  ST2B {<Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2b, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void Store(Vector<byte> mask, byte* address, (Vector<byte> Value1, Vector<byte> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_u8](svbool_t pg, uint8_t *base, svuint8x3_t data)
        ///   ST3B {Zdata0.B - Zdata2.B}, Pg, [Xarray, Xindex]
        ///   ST3B {Zdata0.B - Zdata2.B}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3b, EA_SCALABLE, REG_V7, REG_P6, REG_R5, -24, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_JC_4A  ST3B {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3b, EA_SCALABLE, REG_V0, REG_P1, REG_R3, REG_R4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void Store(Vector<byte> mask, byte* address, (Vector<byte> Value1, Vector<byte> Value2, Vector<byte> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_u8](svbool_t pg, uint8_t *base, svuint8x4_t data)
        ///   ST4B {Zdata0.B - Zdata3.B}, Pg, [Xarray, Xindex]
        ///   ST4B {Zdata0.B - Zdata3.B}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4b, EA_SCALABLE, REG_V0, REG_P0, REG_R0, -32, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_JC_4A  ST4B {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4b, EA_SCALABLE, REG_V0, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void Store(Vector<byte> mask, byte* address, (Vector<byte> Value1, Vector<byte> Value2, Vector<byte> Value3, Vector<byte> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_u16](svbool_t pg, uint16_t *base, svuint16_t data)
        ///   ST1H Zdata.H, Pg, [Xarray, Xindex, LSL #1]
        ///   ST1H Zdata.H, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<ushort> mask, ushort* address, Vector<ushort> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_u16](svbool_t pg, uint16_t *base, svuint16x2_t data)
        ///   ST2H {Zdata0.H, Zdata1.H}, Pg, [Xarray, Xindex, LSL #1]
        ///   ST2H {Zdata0.H, Zdata1.H}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2H {<Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2h, EA_SCALABLE, REG_V6, REG_P7, REG_R8, -16, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_JC_4A  ST2H {<Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2h, EA_SCALABLE, REG_V2, REG_P3, REG_R5, REG_R6, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<ushort> mask, ushort* address, (Vector<ushort> Value1, Vector<ushort> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_u16](svbool_t pg, uint16_t *base, svuint16x3_t data)
        ///   ST3H {Zdata0.H - Zdata2.H}, Pg, [Xarray, Xindex, LSL #1]
        ///   ST3H {Zdata0.H - Zdata2.H}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, -24, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_JC_4A  ST3H {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3h, EA_SCALABLE, REG_V1, REG_P0, REG_R3, REG_R8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<ushort> mask, ushort* address, (Vector<ushort> Value1, Vector<ushort> Value2, Vector<ushort> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_u16](svbool_t pg, uint16_t *base, svuint16x4_t data)
        ///   ST4H {Zdata0.H - Zdata3.H}, Pg, [Xarray, Xindex, LSL #1]
        ///   ST4H {Zdata0.H - Zdata3.H}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4h, EA_SCALABLE, REG_V3, REG_P5, REG_R2, -32, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_JC_4A  ST4H {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4h, EA_SCALABLE, REG_V1, REG_P0, REG_R9, REG_R8, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<ushort> mask, ushort* address, (Vector<ushort> Value1, Vector<ushort> Value2, Vector<ushort> Value3, Vector<ushort> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_u32](svbool_t pg, uint32_t *base, svuint32_t data)
        ///   ST1W Zdata.S, Pg, [Xarray, Xindex, LSL #2]
        ///   ST1W Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<uint> mask, uint* address, Vector<uint> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_u32](svbool_t pg, uint32_t *base, svuint32x2_t data)
        ///   ST2W {Zdata0.S, Zdata1.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST2W {Zdata0.S, Zdata1.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2W {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2w, EA_SCALABLE, REG_V8, REG_P1, REG_R9, -16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST2W {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2w, EA_SCALABLE, REG_V0, REG_P2, REG_R8, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<uint> mask, uint* address, (Vector<uint> Value1, Vector<uint> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_u32](svbool_t pg, uint32_t *base, svuint32x3_t data)
        ///   ST3W {Zdata0.S - Zdata2.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST3W {Zdata0.S - Zdata2.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3w, EA_SCALABLE, REG_V1, REG_P3, REG_R8, -24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<uint> mask, uint* address, (Vector<uint> Value1, Vector<uint> Value2, Vector<uint> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_u32](svbool_t pg, uint32_t *base, svuint32x4_t data)
        ///   ST4W {Zdata0.S - Zdata3.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST4W {Zdata0.S - Zdata3.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4w, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 28, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4w, EA_SCALABLE, REG_V31, REG_P1, REG_R5, 28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4w, EA_SCALABLE, REG_V0, REG_P1, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<uint> mask, uint* address, (Vector<uint> Value1, Vector<uint> Value2, Vector<uint> Value3, Vector<uint> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_u64](svbool_t pg, uint64_t *base, svuint64_t data)
        ///   ST1D Zdata.D, Pg, [Xarray, Xindex, LSL #3]
        ///   ST1D Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<ulong> mask, ulong* address, Vector<ulong> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_u64](svbool_t pg, uint64_t *base, svuint64x2_t data)
        ///   ST2D {Zdata0.D, Zdata1.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST2D {Zdata0.D, Zdata1.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2D {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2d, EA_SCALABLE, REG_V5, REG_P4, REG_R3, -16, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST2D {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2d, EA_SCALABLE, REG_V1, REG_P7, REG_R6, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<ulong> mask, ulong* address, (Vector<ulong> Value1, Vector<ulong> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_u64](svbool_t pg, uint64_t *base, svuint64x3_t data)
        ///   ST3D {Zdata0.D - Zdata2.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST3D {Zdata0.D - Zdata2.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3d, EA_SCALABLE, REG_V2, REG_P3, REG_R4, -24, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3d, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<ulong> mask, ulong* address, (Vector<ulong> Value1, Vector<ulong> Value2, Vector<ulong> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_u64](svbool_t pg, uint64_t *base, svuint64x4_t data)
        ///   ST4D {Zdata0.D - Zdata3.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST4D {Zdata0.D - Zdata3.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4d, EA_SCALABLE, REG_V2, REG_P0, REG_R1, -32, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4d, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<ulong> mask, ulong* address, (Vector<ulong> Value1, Vector<ulong> Value2, Vector<ulong> Value3, Vector<ulong> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_f32](svbool_t pg, float32_t *base, svfloat32_t data)
        ///   ST1W Zdata.S, Pg, [Xarray, Xindex, LSL #2]
        ///   ST1W Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<float> mask, float* address, Vector<float> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_f32](svbool_t pg, float32_t *base, svfloat32x2_t data)
        ///   ST2W {Zdata0.S, Zdata1.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST2W {Zdata0.S, Zdata1.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2W {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2w, EA_SCALABLE, REG_V8, REG_P1, REG_R9, -16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST2W {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2w, EA_SCALABLE, REG_V0, REG_P2, REG_R8, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<float> mask, float* address, (Vector<float> Value1, Vector<float> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_f32](svbool_t pg, float32_t *base, svfloat32x3_t data)
        ///   ST3W {Zdata0.S - Zdata2.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST3W {Zdata0.S - Zdata2.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3w, EA_SCALABLE, REG_V1, REG_P3, REG_R8, -24, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST3W {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<float> mask, float* address, (Vector<float> Value1, Vector<float> Value2, Vector<float> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_f32](svbool_t pg, float32_t *base, svfloat32x4_t data)
        ///   ST4W {Zdata0.S - Zdata3.S}, Pg, [Xarray, Xindex, LSL #2]
        ///   ST4W {Zdata0.S - Zdata3.S}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4w, EA_SCALABLE, REG_V0, REG_P1, REG_R5, 28, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4w, EA_SCALABLE, REG_V31, REG_P1, REG_R5, 28, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_JC_4A  ST4W {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4w, EA_SCALABLE, REG_V0, REG_P1, REG_R4, REG_R5, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<float> mask, float* address, (Vector<float> Value1, Vector<float> Value2, Vector<float> Value3, Vector<float> Value4) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst1[_f64](svbool_t pg, float64_t *base, svfloat64_t data)
        ///   ST1D Zdata.D, Pg, [Xarray, Xindex, LSL #3]
        ///   ST1D Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JN_3C_D  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V2, REG_P1, REG_R0, 0, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JJ_4A  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P1, REG_R2, REG_V5, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JD_4C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V1, REG_P4, REG_R5, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JD_4C_A  ST1D {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P5, REG_R6, REG_R1, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V0, REG_P3, REG_R2, REG_V1, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_C  ST1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P4, REG_R5, REG_V6, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JL_3A  ST1D {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1d, EA_SCALABLE, REG_V3, REG_P7, REG_V4, 248, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void Store(Vector<double> mask, double* address, Vector<double> data) => Store(mask, address, data);

        /// <summary>
        /// void svst2[_f64](svbool_t pg, float64_t *base, svfloat64x2_t data)
        ///   ST2D {Zdata0.D, Zdata1.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST2D {Zdata0.D, Zdata1.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST2D {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st2d, EA_SCALABLE, REG_V5, REG_P4, REG_R3, -16, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST2D {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st2d, EA_SCALABLE, REG_V1, REG_P7, REG_R6, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<double> mask, double* address, (Vector<double> Value1, Vector<double> Value2) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst3[_f64](svbool_t pg, float64_t *base, svfloat64x3_t data)
        ///   ST3D {Zdata0.D - Zdata2.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST3D {Zdata0.D - Zdata2.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>{, #<imm>,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st3d, EA_SCALABLE, REG_V2, REG_P3, REG_R4, -24, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST3D {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>, <Xm>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st3d, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R6, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<double> mask, double* address, (Vector<double> Value1, Vector<double> Value2, Vector<double> Value3) data) => Store(mask, address, Value1,);

        /// <summary>
        /// void svst4[_f64](svbool_t pg, float64_t *base, svfloat64x4_t data)
        ///   ST4D {Zdata0.D - Zdata3.D}, Pg, [Xarray, Xindex, LSL #3]
        ///   ST4D {Zdata0.D - Zdata3.D}, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JO_3A  ST4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>{,
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st4d, EA_SCALABLE, REG_V2, REG_P0, REG_R1, -32, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JC_4A  ST4D {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>,
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st4d, EA_SCALABLE, REG_V5, REG_P2, REG_R1, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void Store(Vector<double> mask, double* address, (Vector<double> Value1, Vector<double> Value2, Vector<double> Value3, Vector<double> Value4) data) => Store(mask, address, Value1,);


        ///  StoreNarrowing : Truncate to 8 bits and store

        /// <summary>
        /// void svst1b[_s16](svbool_t pg, int8_t *base, svint16_t data)
        ///   ST1B Zdata.H, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.H, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<short> mask, sbyte* address, Vector<short> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1b[_s32](svbool_t pg, int8_t *base, svint32_t data)
        ///   ST1B Zdata.S, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<int> mask, sbyte* address, Vector<int> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1h[_s32](svbool_t pg, int16_t *base, svint32_t data)
        ///   ST1H Zdata.S, Pg, [Xarray, Xindex, LSL #1]
        ///   ST1H Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<int> mask, short* address, Vector<int> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1b[_s64](svbool_t pg, int8_t *base, svint64_t data)
        ///   ST1B Zdata.D, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<long> mask, sbyte* address, Vector<long> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1h[_s64](svbool_t pg, int16_t *base, svint64_t data)
        ///   ST1H Zdata.D, Pg, [Xarray, Xindex, LSL #1]
        ///   ST1H Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<long> mask, short* address, Vector<long> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1w[_s64](svbool_t pg, int32_t *base, svint64_t data)
        ///   ST1W Zdata.D, Pg, [Xarray, Xindex, LSL #2]
        ///   ST1W Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<long> mask, int* address, Vector<long> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1b[_u16](svbool_t pg, uint8_t *base, svuint16_t data)
        ///   ST1B Zdata.H, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.H, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<ushort> mask, byte* address, Vector<ushort> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1b[_u32](svbool_t pg, uint8_t *base, svuint32_t data)
        ///   ST1B Zdata.S, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<uint> mask, byte* address, Vector<uint> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1h[_u32](svbool_t pg, uint16_t *base, svuint32_t data)
        ///   ST1H Zdata.S, Pg, [Xarray, Xindex, LSL #1]
        ///   ST1H Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<uint> mask, ushort* address, Vector<uint> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1b[_u64](svbool_t pg, uint8_t *base, svuint64_t data)
        ///   ST1B Zdata.D, Pg, [Xarray, Xindex]
        ///   ST1B Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P1, REG_R2, REG_R0, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P5, REG_R6, REG_R2, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P5, REG_R7, REG_R4, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P0, REG_R1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4A  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V4, REG_P2, REG_R0, REG_V1, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JK_4A_B  ST1B {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V0, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1B {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 5, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 4, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 2, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V3, REG_P2, REG_R1, 0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JK_4B  ST1B {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1b, EA_SCALABLE, REG_V6, REG_P3, REG_R0, REG_V4, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1B {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1b, EA_SCALABLE, REG_V1, REG_P2, REG_V3, 31, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<ulong> mask, byte* address, Vector<ulong> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1h[_u64](svbool_t pg, uint16_t *base, svuint64_t data)
        ///   ST1H Zdata.D, Pg, [Xarray, Xindex, LSL #1]
        ///   ST1H Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JD_4A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P6, REG_R1, REG_R2, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_R4, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P2, REG_R4, REG_R0, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V3, REG_P1, REG_R5, REG_V4, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V2, REG_P3, REG_R1, REG_V4, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P5, REG_R1, REG_V3, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1H {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V7, REG_P5, REG_R4, REG_V1, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3A  ST1H {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 3, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V0, REG_P3, REG_R4, -2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JJ_4B  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1H {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1h, EA_SCALABLE, REG_V1, REG_P4, REG_R3, REG_V2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1H {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1h, EA_SCALABLE, REG_V5, REG_P3, REG_V2, 62, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<ulong> mask, ushort* address, Vector<ulong> data) => StoreNarrowing(mask, address, data);

        /// <summary>
        /// void svst1w[_u64](svbool_t pg, uint32_t *base, svuint64_t data)
        ///   ST1W Zdata.D, Pg, [Xarray, Xindex, LSL #2]
        ///   ST1W Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JN_3C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P4, REG_R5, 6, INS_OPTS_SCALABLE_Q);
        ///    IF_SVE_JD_4B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_R5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4A  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P3, REG_R1, REG_V2, INS_OPTS_SCALABLE_S_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_UXTW, INS_SCALABLE_OPTS_MOD_N);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P4, REG_R2, REG_V3, INS_OPTS_SCALABLE_D_SXTW, INS_SCALABLE_OPTS_MOD_N);
        ///    IF_SVE_JJ_4A_C  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V0, REG_P2, REG_R3, REG_V4, INS_OPTS_SCALABLE_D_SXTW);
        ///    IF_SVE_JJ_4A_D  ST1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_UXTW);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V1, REG_P2, REG_R3, REG_V2, INS_OPTS_SCALABLE_S_SXTW);
        ///    IF_SVE_JN_3B  ST1W {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 5, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R3, 1, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JD_4C  ST1W {<Zt>.Q }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P1, REG_R8, REG_R7, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V2, REG_P3, REG_R4, REG_V5, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        ///    IF_SVE_JJ_4B_E  ST1W {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_st1w, EA_SCALABLE, REG_V3, REG_P5, REG_R1, REG_V0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JI_3A_A  ST1W {<Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 0, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_st1w, EA_SCALABLE, REG_V5, REG_P4, REG_V1, 124, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe void StoreNarrowing(Vector<ulong> mask, uint* address, Vector<ulong> data) => StoreNarrowing(mask, address, data);


        ///  StoreNonTemporal : Non-truncating store, non-temporal

        /// <summary>
        /// void svstnt1[_s8](svbool_t pg, int8_t *base, svint8_t data)
        ///   STNT1B Zdata.B, Pg, [Xarray, Xindex]
        ///   STNT1B Zdata.B, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1B {<Zt>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IZ_4A  STNT1B {<Zt>.S }, <Pg>, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V0, REG_P2, REG_V3, REG_R4, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A_A  STNT1B {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V0, REG_P4, REG_V6, REG_R8, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V0, REG_P4, REG_V6, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1B {<Zt>.B }, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V6, REG_P5, REG_R4, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<sbyte> mask, sbyte* address, Vector<sbyte> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_s16](svbool_t pg, int16_t *base, svint16_t data)
        ///   STNT1H Zdata.H, Pg, [Xarray, Xindex, LSL #1]
        ///   STNT1H Zdata.H, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1H {<Zt>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1h, EA_SCALABLE, REG_V9, REG_P1, REG_R0, -5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IZ_4A  STNT1H {<Zt>.S }, <Pg>, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1h, EA_SCALABLE, REG_V2, REG_P7, REG_V6, REG_R5, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A_A  STNT1H {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1h, EA_SCALABLE, REG_V5, REG_P3, REG_V1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1H {<Zt>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<short> mask, short* address, Vector<short> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_s32](svbool_t pg, int32_t *base, svint32_t data)
        ///   STNT1W Zdata.S, Pg, [Xarray, Xindex, LSL #2]
        ///   STNT1W Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1W {<Zt>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1w, EA_SCALABLE, REG_V0, REG_P0, REG_R2, -7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A  STNT1W {<Zt>.S }, <Pg>, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V2, REG_R0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V2, REG_ZR, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A_A  STNT1W {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V3, REG_P1, REG_V2, REG_R0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V0, REG_P5, REG_R6, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<int> mask, int* address, Vector<int> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_s64](svbool_t pg, int64_t *base, svint64_t data)
        ///   STNT1D Zdata.D, Pg, [Xarray, Xindex, LSL #3]
        ///   STNT1D Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1d, EA_SCALABLE, REG_V8, REG_P7, REG_R6, 5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JA_4A  STNT1D {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V1, REG_P3, REG_V4, REG_R5, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V0, REG_P4, REG_V5, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V7, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<long> mask, long* address, Vector<long> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_u8](svbool_t pg, uint8_t *base, svuint8_t data)
        ///   STNT1B Zdata.B, Pg, [Xarray, Xindex]
        ///   STNT1B Zdata.B, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1B {<Zt>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1b, EA_SCALABLE, REG_V1, REG_P2, REG_R3, 4, INS_OPTS_SCALABLE_B);
        ///    IF_SVE_IZ_4A  STNT1B {<Zt>.S }, <Pg>, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V0, REG_P2, REG_V3, REG_R4, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A_A  STNT1B {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V0, REG_P4, REG_V6, REG_R8, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V0, REG_P4, REG_V6, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1B {<Zt>.B }, <Pg>, [<Xn|SP>, <Xm>]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1b, EA_SCALABLE, REG_V6, REG_P5, REG_R4, REG_R3, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<byte> mask, byte* address, Vector<byte> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_u16](svbool_t pg, uint16_t *base, svuint16_t data)
        ///   STNT1H Zdata.H, Pg, [Xarray, Xindex, LSL #1]
        ///   STNT1H Zdata.H, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1H {<Zt>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1h, EA_SCALABLE, REG_V9, REG_P1, REG_R0, -5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_IZ_4A  STNT1H {<Zt>.S }, <Pg>, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1h, EA_SCALABLE, REG_V2, REG_P7, REG_V6, REG_R5, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A_A  STNT1H {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1h, EA_SCALABLE, REG_V5, REG_P3, REG_V1, REG_R2, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1H {<Zt>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1h, EA_SCALABLE, REG_V0, REG_P1, REG_R2, REG_R3, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<ushort> mask, ushort* address, Vector<ushort> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_u32](svbool_t pg, uint32_t *base, svuint32_t data)
        ///   STNT1W Zdata.S, Pg, [Xarray, Xindex, LSL #2]
        ///   STNT1W Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1W {<Zt>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1w, EA_SCALABLE, REG_V0, REG_P0, REG_R2, -7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A  STNT1W {<Zt>.S }, <Pg>, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V2, REG_R0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V2, REG_ZR, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A_A  STNT1W {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V3, REG_P1, REG_V2, REG_R0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V0, REG_P5, REG_R6, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<uint> mask, uint* address, Vector<uint> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_u64](svbool_t pg, uint64_t *base, svuint64_t data)
        ///   STNT1D Zdata.D, Pg, [Xarray, Xindex, LSL #3]
        ///   STNT1D Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1d, EA_SCALABLE, REG_V8, REG_P7, REG_R6, 5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JA_4A  STNT1D {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V1, REG_P3, REG_V4, REG_R5, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V0, REG_P4, REG_V5, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V7, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<ulong> mask, ulong* address, Vector<ulong> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_f32](svbool_t pg, float32_t *base, svfloat32_t data)
        ///   STNT1W Zdata.S, Pg, [Xarray, Xindex, LSL #2]
        ///   STNT1W Zdata.S, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1W {<Zt>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1w, EA_SCALABLE, REG_V0, REG_P0, REG_R2, -7, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A  STNT1W {<Zt>.S }, <Pg>, [<Zn>.S{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V2, REG_R0, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V1, REG_P3, REG_V2, REG_ZR, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_IZ_4A_A  STNT1W {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V3, REG_P1, REG_V2, REG_R0, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1W {<Zt>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1w, EA_SCALABLE, REG_V0, REG_P5, REG_R6, REG_R7, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<float> mask, float* address, Vector<float> data) => StoreNonTemporal(mask, address, data);

        /// <summary>
        /// void svstnt1[_f64](svbool_t pg, float64_t *base, svfloat64_t data)
        ///   STNT1D Zdata.D, Pg, [Xarray, Xindex, LSL #3]
        ///   STNT1D Zdata.D, Pg, [Xbase, #0, MUL VL]
        ///
        /// codegenarm64test:
        ///    IF_SVE_JM_3A  STNT1D {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]
        ///        theEmitter->emitIns_R_R_R_I(INS_sve_stnt1d, EA_SCALABLE, REG_V8, REG_P7, REG_R6, 5, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JA_4A  STNT1D {<Zt>.D }, <Pg>, [<Zn>.D{, <Xm>}]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V1, REG_P3, REG_V4, REG_R5, INS_OPTS_SCALABLE_D);
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V0, REG_P4, REG_V5, REG_ZR, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_JB_4A  STNT1D {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_stnt1d, EA_SCALABLE, REG_V7, REG_P6, REG_R5, REG_R4, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_LSL_N);
        /// </summary>
        public static unsafe void StoreNonTemporal(Vector<double> mask, double* address, Vector<double> data) => StoreNonTemporal(mask, address, data);


        ///  Subtract : Subtract

        /// <summary>
        /// svint8_t svsub[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SUB Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t svsub[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   SUB Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   SUBR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   SUB Zresult.B, Zop1.B, Zop2.B
        /// svint8_t svsub[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; SUB Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; SUBR Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Subtract(Vector<sbyte> left, Vector<sbyte> right) => Subtract(left, right);

        /// <summary>
        /// svint16_t svsub[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SUB Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t svsub[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   SUB Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   SUBR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   SUB Zresult.H, Zop1.H, Zop2.H
        /// svint16_t svsub[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; SUB Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; SUBR Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Subtract(Vector<short> left, Vector<short> right) => Subtract(left, right);

        /// <summary>
        /// svint32_t svsub[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SUB Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t svsub[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   SUB Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   SUBR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   SUB Zresult.S, Zop1.S, Zop2.S
        /// svint32_t svsub[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; SUB Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; SUBR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Subtract(Vector<int> left, Vector<int> right) => Subtract(left, right);

        /// <summary>
        /// svint64_t svsub[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SUB Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t svsub[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   SUB Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   SUBR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   SUB Zresult.D, Zop1.D, Zop2.D
        /// svint64_t svsub[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; SUB Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; SUBR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Subtract(Vector<long> left, Vector<long> right) => Subtract(left, right);

        /// <summary>
        /// svuint8_t svsub[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   SUB Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t svsub[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   SUB Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   SUBR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   SUB Zresult.B, Zop1.B, Zop2.B
        /// svuint8_t svsub[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; SUB Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; SUBR Zresult.B, Pg/M, Zresult.B, Zop1.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Subtract(Vector<byte> left, Vector<byte> right) => Subtract(left, right);

        /// <summary>
        /// svuint16_t svsub[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   SUB Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t svsub[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   SUB Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   SUBR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   SUB Zresult.H, Zop1.H, Zop2.H
        /// svuint16_t svsub[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; SUB Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; SUBR Zresult.H, Pg/M, Zresult.H, Zop1.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Subtract(Vector<ushort> left, Vector<ushort> right) => Subtract(left, right);

        /// <summary>
        /// svuint32_t svsub[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   SUB Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t svsub[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   SUB Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   SUBR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   SUB Zresult.S, Zop1.S, Zop2.S
        /// svuint32_t svsub[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; SUB Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; SUBR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Subtract(Vector<uint> left, Vector<uint> right) => Subtract(left, right);

        /// <summary>
        /// svuint64_t svsub[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   SUB Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; SUB Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t svsub[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   SUB Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   SUBR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   SUB Zresult.D, Zop1.D, Zop2.D
        /// svuint64_t svsub[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; SUB Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; SUBR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AB_3A  SUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V15, REG_P7, REG_V29, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sub, EA_SCALABLE, REG_V19, REG_V7, REG_V13, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sub, EA_SCALABLE, REG_V3, 128, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Subtract(Vector<ulong> left, Vector<ulong> right) => Subtract(left, right);

        /// <summary>
        /// svfloat32_t svsub[_f32]_m(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FSUB Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FSUB Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svsub[_f32]_x(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   FSUB Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   FSUBR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   FSUB Zresult.S, Zop1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; FSUB Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svfloat32_t svsub[_f32]_z(svbool_t pg, svfloat32_t op1, svfloat32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; FSUB Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; FSUBR Zresult.S, Pg/M, Zresult.S, Zop1.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fsub, EA_SCALABLE, REG_V5, REG_P5, REG_V30, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fsub, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_HM_2A  FSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fsub, EA_SCALABLE, REG_V7, REG_P2, 0.5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fsub, EA_SCALABLE, REG_V7, REG_P2, 1.0, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<float> Subtract(Vector<float> left, Vector<float> right) => Subtract(left, right);

        /// <summary>
        /// svfloat64_t svsub[_f64]_m(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FSUB Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FSUB Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svsub[_f64]_x(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   FSUB Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   FSUBR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   FSUB Zresult.D, Zop1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; FSUB Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svfloat64_t svsub[_f64]_z(svbool_t pg, svfloat64_t op1, svfloat64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; FSUB Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; FSUBR Zresult.D, Pg/M, Zresult.D, Zop1.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HL_3A  FSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fsub, EA_SCALABLE, REG_V5, REG_P5, REG_V30, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_HK_3A  FSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_fsub, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_HM_2A  FSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>
        ///        theEmitter->emitIns_R_R_F(INS_sve_fsub, EA_SCALABLE, REG_V7, REG_P2, 0.5, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_F(INS_sve_fsub, EA_SCALABLE, REG_V7, REG_P2, 1.0, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<double> Subtract(Vector<double> left, Vector<double> right) => Subtract(left, right);



        ///  SubtractSaturate : Saturating subtract

        /// <summary>
        /// svint8_t svqsub[_s8](svint8_t op1, svint8_t op2)
        ///   SQSUB Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V29, REG_P0, REG_V24, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V7, REG_V0, REG_V31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqsub, EA_SCALABLE, REG_V2, 1, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<sbyte> SubtractSaturate(Vector<sbyte> left, Vector<sbyte> right) => SubtractSaturate(left, right);

        /// <summary>
        /// svint16_t svqsub[_s16](svint16_t op1, svint16_t op2)
        ///   SQSUB Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V29, REG_P0, REG_V24, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V7, REG_V0, REG_V31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqsub, EA_SCALABLE, REG_V2, 1, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<short> SubtractSaturate(Vector<short> left, Vector<short> right) => SubtractSaturate(left, right);

        /// <summary>
        /// svint32_t svqsub[_s32](svint32_t op1, svint32_t op2)
        ///   SQSUB Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V29, REG_P0, REG_V24, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V7, REG_V0, REG_V31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqsub, EA_SCALABLE, REG_V2, 1, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<int> SubtractSaturate(Vector<int> left, Vector<int> right) => SubtractSaturate(left, right);

        /// <summary>
        /// svint64_t svqsub[_s64](svint64_t op1, svint64_t op2)
        ///   SQSUB Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  SQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V29, REG_P0, REG_V24, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_AT_3A  SQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_sqsub, EA_SCALABLE, REG_V7, REG_V0, REG_V31, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  SQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_sqsub, EA_SCALABLE, REG_V2, 1, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<long> SubtractSaturate(Vector<long> left, Vector<long> right) => SubtractSaturate(left, right);

        /// <summary>
        /// svuint8_t svqsub[_u8](svuint8_t op1, svuint8_t op2)
        ///   UQSUB Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V1, REG_P4, REG_V28, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_AT_3A  UQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V31, REG_V31, REG_V31, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqsub, EA_SCALABLE, REG_V6, 255, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<byte> SubtractSaturate(Vector<byte> left, Vector<byte> right) => SubtractSaturate(left, right);

        /// <summary>
        /// svuint16_t svqsub[_u16](svuint16_t op1, svuint16_t op2)
        ///   UQSUB Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V1, REG_P4, REG_V28, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_AT_3A  UQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V31, REG_V31, REG_V31, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqsub, EA_SCALABLE, REG_V6, 255, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<ushort> SubtractSaturate(Vector<ushort> left, Vector<ushort> right) => SubtractSaturate(left, right);

        /// <summary>
        /// svuint32_t svqsub[_u32](svuint32_t op1, svuint32_t op2)
        ///   UQSUB Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V1, REG_P4, REG_V28, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_AT_3A  UQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V31, REG_V31, REG_V31, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqsub, EA_SCALABLE, REG_V6, 255, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<uint> SubtractSaturate(Vector<uint> left, Vector<uint> right) => SubtractSaturate(left, right);

        /// <summary>
        /// svuint64_t svqsub[_u64](svuint64_t op1, svuint64_t op2)
        ///   UQSUB Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_ET_3A  UQSUB <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V1, REG_P4, REG_V28, INS_OPTS_SCALABLE_D);
        ///    IF_SVE_AT_3A  UQSUB <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uqsub, EA_SCALABLE, REG_V31, REG_V31, REG_V31, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_EC_1A  UQSUB <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}
        ///        theEmitter->emitIns_R_I(INS_sve_uqsub, EA_SCALABLE, REG_V6, 255, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_SHIFT);
        /// </summary>
        public static unsafe Vector<ulong> SubtractSaturate(Vector<ulong> left, Vector<ulong> right) => SubtractSaturate(left, right);


        ///  TestAnyTrue : Test whether any active element is true

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<sbyte> leftMask, Vector<sbyte> rightMask) => TestAnyTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<short> leftMask, Vector<short> rightMask) => TestAnyTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<int> leftMask, Vector<int> rightMask) => TestAnyTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<long> leftMask, Vector<long> rightMask) => TestAnyTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<byte> leftMask, Vector<byte> rightMask) => TestAnyTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<ushort> leftMask, Vector<ushort> rightMask) => TestAnyTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<uint> leftMask, Vector<uint> rightMask) => TestAnyTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_any(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestAnyTrue(Vector<ulong> leftMask, Vector<ulong> rightMask) => TestAnyTrue(leftMask, rightMask);


        ///  TestFirstTrue : Test whether the first active element is true

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<sbyte> leftMask, Vector<sbyte> rightMask) => TestFirstTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<short> leftMask, Vector<short> rightMask) => TestFirstTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<int> leftMask, Vector<int> rightMask) => TestFirstTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<long> leftMask, Vector<long> rightMask) => TestFirstTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<byte> leftMask, Vector<byte> rightMask) => TestFirstTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<ushort> leftMask, Vector<ushort> rightMask) => TestFirstTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<uint> leftMask, Vector<uint> rightMask) => TestFirstTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_first(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestFirstTrue(Vector<ulong> leftMask, Vector<ulong> rightMask) => TestFirstTrue(leftMask, rightMask);


        ///  TestLastTrue : Test whether the last active element is true

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<sbyte> leftMask, Vector<sbyte> rightMask) => TestLastTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<short> leftMask, Vector<short> rightMask) => TestLastTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<int> leftMask, Vector<int> rightMask) => TestLastTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<long> leftMask, Vector<long> rightMask) => TestLastTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<byte> leftMask, Vector<byte> rightMask) => TestLastTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<ushort> leftMask, Vector<ushort> rightMask) => TestLastTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<uint> leftMask, Vector<uint> rightMask) => TestLastTrue(leftMask, rightMask);

        /// <summary>
        /// bool svptest_last(svbool_t pg, svbool_t op)
        ///   PTEST
        ///
        /// codegenarm64test:
        ///    IF_SVE_DI_2A  PTEST <Pg>, <Pn>.B
        ///        theEmitter->emitIns_R_R(INS_sve_ptest, EA_SCALABLE, REG_P2, REG_P14, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe bool TestLastTrue(Vector<ulong> leftMask, Vector<ulong> rightMask) => TestLastTrue(leftMask, rightMask);


        ///  TransposeEven : Interleave even elements from two inputs

        /// <summary>
        /// svint8_t svtrn1[_s8](svint8_t op1, svint8_t op2)
        ///   TRN1 Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<sbyte> TransposeEven(Vector<sbyte> left, Vector<sbyte> right) => TransposeEven(left, right);

        /// <summary>
        /// svint16_t svtrn1[_s16](svint16_t op1, svint16_t op2)
        ///   TRN1 Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<short> TransposeEven(Vector<short> left, Vector<short> right) => TransposeEven(left, right);

        /// <summary>
        /// svint32_t svtrn1[_s32](svint32_t op1, svint32_t op2)
        ///   TRN1 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<int> TransposeEven(Vector<int> left, Vector<int> right) => TransposeEven(left, right);

        /// <summary>
        /// svint64_t svtrn1[_s64](svint64_t op1, svint64_t op2)
        ///   TRN1 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<long> TransposeEven(Vector<long> left, Vector<long> right) => TransposeEven(left, right);

        /// <summary>
        /// svuint8_t svtrn1[_u8](svuint8_t op1, svuint8_t op2)
        ///   TRN1 Zresult.B, Zop1.B, Zop2.B
        /// svbool_t svtrn1_b8(svbool_t op1, svbool_t op2)
        ///   TRN1 Presult.B, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> TransposeEven(Vector<byte> left, Vector<byte> right) => TransposeEven(left, right);

        /// <summary>
        /// svuint16_t svtrn1[_u16](svuint16_t op1, svuint16_t op2)
        ///   TRN1 Zresult.H, Zop1.H, Zop2.H
        /// svbool_t svtrn1_b16(svbool_t op1, svbool_t op2)
        ///   TRN1 Presult.H, Pop1.H, Pop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ushort> TransposeEven(Vector<ushort> left, Vector<ushort> right) => TransposeEven(left, right);

        /// <summary>
        /// svuint32_t svtrn1[_u32](svuint32_t op1, svuint32_t op2)
        ///   TRN1 Zresult.S, Zop1.S, Zop2.S
        /// svbool_t svtrn1_b32(svbool_t op1, svbool_t op2)
        ///   TRN1 Presult.S, Pop1.S, Pop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<uint> TransposeEven(Vector<uint> left, Vector<uint> right) => TransposeEven(left, right);

        /// <summary>
        /// svuint64_t svtrn1[_u64](svuint64_t op1, svuint64_t op2)
        ///   TRN1 Zresult.D, Zop1.D, Zop2.D
        /// svbool_t svtrn1_b64(svbool_t op1, svbool_t op2)
        ///   TRN1 Presult.D, Pop1.D, Pop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ulong> TransposeEven(Vector<ulong> left, Vector<ulong> right) => TransposeEven(left, right);

        /// <summary>
        /// svfloat32_t svtrn1[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   TRN1 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<float> TransposeEven(Vector<float> left, Vector<float> right) => TransposeEven(left, right);

        /// <summary>
        /// svfloat64_t svtrn1[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   TRN1 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn1, EA_SCALABLE, REG_P1, REG_P3, REG_P4, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<double> TransposeEven(Vector<double> left, Vector<double> right) => TransposeEven(left, right);


        ///  TransposeOdd : Interleave odd elements from two inputs

        /// <summary>
        /// svint8_t svtrn2[_s8](svint8_t op1, svint8_t op2)
        ///   TRN2 Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<sbyte> TransposeOdd(Vector<sbyte> left, Vector<sbyte> right) => TransposeOdd(left, right);

        /// <summary>
        /// svint16_t svtrn2[_s16](svint16_t op1, svint16_t op2)
        ///   TRN2 Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<short> TransposeOdd(Vector<short> left, Vector<short> right) => TransposeOdd(left, right);

        /// <summary>
        /// svint32_t svtrn2[_s32](svint32_t op1, svint32_t op2)
        ///   TRN2 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<int> TransposeOdd(Vector<int> left, Vector<int> right) => TransposeOdd(left, right);

        /// <summary>
        /// svint64_t svtrn2[_s64](svint64_t op1, svint64_t op2)
        ///   TRN2 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<long> TransposeOdd(Vector<long> left, Vector<long> right) => TransposeOdd(left, right);

        /// <summary>
        /// svuint8_t svtrn2[_u8](svuint8_t op1, svuint8_t op2)
        ///   TRN2 Zresult.B, Zop1.B, Zop2.B
        /// svbool_t svtrn2_b8(svbool_t op1, svbool_t op2)
        ///   TRN2 Presult.B, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<byte> TransposeOdd(Vector<byte> left, Vector<byte> right) => TransposeOdd(left, right);

        /// <summary>
        /// svuint16_t svtrn2[_u16](svuint16_t op1, svuint16_t op2)
        ///   TRN2 Zresult.H, Zop1.H, Zop2.H
        /// svbool_t svtrn2_b16(svbool_t op1, svbool_t op2)
        ///   TRN2 Presult.H, Pop1.H, Pop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ushort> TransposeOdd(Vector<ushort> left, Vector<ushort> right) => TransposeOdd(left, right);

        /// <summary>
        /// svuint32_t svtrn2[_u32](svuint32_t op1, svuint32_t op2)
        ///   TRN2 Zresult.S, Zop1.S, Zop2.S
        /// svbool_t svtrn2_b32(svbool_t op1, svbool_t op2)
        ///   TRN2 Presult.S, Pop1.S, Pop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<uint> TransposeOdd(Vector<uint> left, Vector<uint> right) => TransposeOdd(left, right);

        /// <summary>
        /// svuint64_t svtrn2[_u64](svuint64_t op1, svuint64_t op2)
        ///   TRN2 Zresult.D, Zop1.D, Zop2.D
        /// svbool_t svtrn2_b64(svbool_t op1, svbool_t op2)
        ///   TRN2 Presult.D, Pop1.D, Pop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ulong> TransposeOdd(Vector<ulong> left, Vector<ulong> right) => TransposeOdd(left, right);

        /// <summary>
        /// svfloat32_t svtrn2[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   TRN2 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<float> TransposeOdd(Vector<float> left, Vector<float> right) => TransposeOdd(left, right);

        /// <summary>
        /// svfloat64_t svtrn2[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   TRN2 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  TRN2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  TRN2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  TRN2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_trn2, EA_SCALABLE, REG_P5, REG_P2, REG_P7, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<double> TransposeOdd(Vector<double> left, Vector<double> right) => TransposeOdd(left, right);


        ///  TrigonometricMultiplyAddCoefficient : Trigonometric multiply-add coefficient

        /// <summary>
        /// svfloat32_t svtmad[_f32](svfloat32_t op1, svfloat32_t op2, uint64_t imm3)
        ///   FTMAD Ztied1.S, Ztied1.S, Zop2.S, #imm3
        ///   MOVPRFX Zresult, Zop1; FTMAD Zresult.S, Zresult.S, Zop2.S, #imm3
        ///
        /// codegenarm64test:
        ///    IF_SVE_HN_2A  FTMAD <Zdn>.<T>, <Zdn>.<T>, <Zm>.<T>, #<imm>
        ///        theEmitter->emitIns_R_R_I(INS_sve_ftmad, EA_SCALABLE, REG_V0, REG_V2, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_ftmad, EA_SCALABLE, REG_V3, REG_V5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_ftmad, EA_SCALABLE, REG_V4, REG_V2, 7, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> TrigonometricMultiplyAddCoefficient(Vector<float> left, Vector<float> right, [ConstantExpected] byte control) => TrigonometricMultiplyAddCoefficient(left, right, control);

        /// <summary>
        /// svfloat64_t svtmad[_f64](svfloat64_t op1, svfloat64_t op2, uint64_t imm3)
        ///   FTMAD Ztied1.D, Ztied1.D, Zop2.D, #imm3
        ///   MOVPRFX Zresult, Zop1; FTMAD Zresult.D, Zresult.D, Zop2.D, #imm3
        ///
        /// codegenarm64test:
        ///    IF_SVE_HN_2A  FTMAD <Zdn>.<T>, <Zdn>.<T>, <Zm>.<T>, #<imm>
        ///        theEmitter->emitIns_R_R_I(INS_sve_ftmad, EA_SCALABLE, REG_V0, REG_V2, 0, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_I(INS_sve_ftmad, EA_SCALABLE, REG_V3, REG_V5, 1, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_I(INS_sve_ftmad, EA_SCALABLE, REG_V4, REG_V2, 7, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> TrigonometricMultiplyAddCoefficient(Vector<double> left, Vector<double> right, [ConstantExpected] byte control) => TrigonometricMultiplyAddCoefficient(left, right, control);


        ///  TrigonometricSelectCoefficient : Trigonometric select coefficient

        /// <summary>
        /// svfloat32_t svtssel[_f32](svfloat32_t op1, svuint32_t op2)
        ///   FTSSEL Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BK_3A  FTSSEL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_ftssel, EA_SCALABLE, REG_V17, REG_V16, REG_V15, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> TrigonometricSelectCoefficient(Vector<float> value, Vector<uint> selector) => TrigonometricSelectCoefficient(value, selector);

        /// <summary>
        /// svfloat64_t svtssel[_f64](svfloat64_t op1, svuint64_t op2)
        ///   FTSSEL Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BK_3A  FTSSEL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_ftssel, EA_SCALABLE, REG_V17, REG_V16, REG_V15, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> TrigonometricSelectCoefficient(Vector<double> value, Vector<ulong> selector) => TrigonometricSelectCoefficient(value, selector);


        ///  TrigonometricStartingValue : Trigonometric starting value

        /// <summary>
        /// svfloat32_t svtsmul[_f32](svfloat32_t op1, svuint32_t op2)
        ///   FTSMUL Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_HK_3A  FTSMUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_ftsmul, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<float> TrigonometricStartingValue(Vector<float> value, Vector<uint> sign) => TrigonometricStartingValue(value, sign);

        /// <summary>
        /// svfloat64_t svtsmul[_f64](svfloat64_t op1, svuint64_t op2)
        ///   FTSMUL Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_HK_3A  FTSMUL <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_ftsmul, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        /// </summary>
        public static unsafe Vector<double> TrigonometricStartingValue(Vector<double> value, Vector<ulong> sign) => TrigonometricStartingValue(value, sign);


        ///  UnzipEven : Concatenate even elements from two inputs

        /// <summary>
        /// svint8_t svuzp1[_s8](svint8_t op1, svint8_t op2)
        ///   UZP1 Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<sbyte> UnzipEven(Vector<sbyte> left, Vector<sbyte> right) => UnzipEven(left, right);

        /// <summary>
        /// svint16_t svuzp1[_s16](svint16_t op1, svint16_t op2)
        ///   UZP1 Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<short> UnzipEven(Vector<short> left, Vector<short> right) => UnzipEven(left, right);

        /// <summary>
        /// svint32_t svuzp1[_s32](svint32_t op1, svint32_t op2)
        ///   UZP1 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<int> UnzipEven(Vector<int> left, Vector<int> right) => UnzipEven(left, right);

        /// <summary>
        /// svint64_t svuzp1[_s64](svint64_t op1, svint64_t op2)
        ///   UZP1 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<long> UnzipEven(Vector<long> left, Vector<long> right) => UnzipEven(left, right);

        /// <summary>
        /// svuint8_t svuzp1[_u8](svuint8_t op1, svuint8_t op2)
        ///   UZP1 Zresult.B, Zop1.B, Zop2.B
        /// svbool_t svuzp1_b8(svbool_t op1, svbool_t op2)
        ///   UZP1 Presult.B, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<byte> UnzipEven(Vector<byte> left, Vector<byte> right) => UnzipEven(left, right);

        /// <summary>
        /// svuint16_t svuzp1[_u16](svuint16_t op1, svuint16_t op2)
        ///   UZP1 Zresult.H, Zop1.H, Zop2.H
        /// svbool_t svuzp1_b16(svbool_t op1, svbool_t op2)
        ///   UZP1 Presult.H, Pop1.H, Pop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<ushort> UnzipEven(Vector<ushort> left, Vector<ushort> right) => UnzipEven(left, right);

        /// <summary>
        /// svuint32_t svuzp1[_u32](svuint32_t op1, svuint32_t op2)
        ///   UZP1 Zresult.S, Zop1.S, Zop2.S
        /// svbool_t svuzp1_b32(svbool_t op1, svbool_t op2)
        ///   UZP1 Presult.S, Pop1.S, Pop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<uint> UnzipEven(Vector<uint> left, Vector<uint> right) => UnzipEven(left, right);

        /// <summary>
        /// svuint64_t svuzp1[_u64](svuint64_t op1, svuint64_t op2)
        ///   UZP1 Zresult.D, Zop1.D, Zop2.D
        /// svbool_t svuzp1_b64(svbool_t op1, svbool_t op2)
        ///   UZP1 Presult.D, Pop1.D, Pop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<ulong> UnzipEven(Vector<ulong> left, Vector<ulong> right) => UnzipEven(left, right);

        /// <summary>
        /// svfloat32_t svuzp1[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   UZP1 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<float> UnzipEven(Vector<float> left, Vector<float> right) => UnzipEven(left, right);

        /// <summary>
        /// svfloat64_t svuzp1[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   UZP1 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<double> UnzipEven(Vector<double> left, Vector<double> right) => UnzipEven(left, right);


        ///  UnzipOdd : Concatenate odd elements from two inputs

        /// <summary>
        /// svint8_t svuzp2[_s8](svint8_t op1, svint8_t op2)
        ///   UZP2 Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<sbyte> UnzipOdd(Vector<sbyte> left, Vector<sbyte> right) => UnzipOdd(left, right);

        /// <summary>
        /// svint16_t svuzp2[_s16](svint16_t op1, svint16_t op2)
        ///   UZP2 Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<short> UnzipOdd(Vector<short> left, Vector<short> right) => UnzipOdd(left, right);

        /// <summary>
        /// svint32_t svuzp2[_s32](svint32_t op1, svint32_t op2)
        ///   UZP2 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<int> UnzipOdd(Vector<int> left, Vector<int> right) => UnzipOdd(left, right);

        /// <summary>
        /// svint64_t svuzp2[_s64](svint64_t op1, svint64_t op2)
        ///   UZP2 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<long> UnzipOdd(Vector<long> left, Vector<long> right) => UnzipOdd(left, right);

        /// <summary>
        /// svuint8_t svuzp2[_u8](svuint8_t op1, svuint8_t op2)
        ///   UZP2 Zresult.B, Zop1.B, Zop2.B
        /// svbool_t svuzp2_b8(svbool_t op1, svbool_t op2)
        ///   UZP2 Presult.B, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<byte> UnzipOdd(Vector<byte> left, Vector<byte> right) => UnzipOdd(left, right);

        /// <summary>
        /// svuint16_t svuzp2[_u16](svuint16_t op1, svuint16_t op2)
        ///   UZP2 Zresult.H, Zop1.H, Zop2.H
        /// svbool_t svuzp2_b16(svbool_t op1, svbool_t op2)
        ///   UZP2 Presult.H, Pop1.H, Pop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> UnzipOdd(Vector<ushort> left, Vector<ushort> right) => UnzipOdd(left, right);

        /// <summary>
        /// svuint32_t svuzp2[_u32](svuint32_t op1, svuint32_t op2)
        ///   UZP2 Zresult.S, Zop1.S, Zop2.S
        /// svbool_t svuzp2_b32(svbool_t op1, svbool_t op2)
        ///   UZP2 Presult.S, Pop1.S, Pop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> UnzipOdd(Vector<uint> left, Vector<uint> right) => UnzipOdd(left, right);

        /// <summary>
        /// svuint64_t svuzp2[_u64](svuint64_t op1, svuint64_t op2)
        ///   UZP2 Zresult.D, Zop1.D, Zop2.D
        /// svbool_t svuzp2_b64(svbool_t op1, svbool_t op2)
        ///   UZP2 Presult.D, Pop1.D, Pop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> UnzipOdd(Vector<ulong> left, Vector<ulong> right) => UnzipOdd(left, right);

        /// <summary>
        /// svfloat32_t svuzp2[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   UZP2 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<float> UnzipOdd(Vector<float> left, Vector<float> right) => UnzipOdd(left, right);

        /// <summary>
        /// svfloat64_t svuzp2[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   UZP2 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  UZP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V18, REG_V19, REG_V20, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V21, REG_V22, REG_V23, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  UZP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  UZP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uzp2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<double> UnzipOdd(Vector<double> left, Vector<double> right) => UnzipOdd(left, right);


        ///  VectorTableLookup : Table lookup in single-vector table

        /// <summary>
        /// svint8_t svtbl[_s8](svint8_t data, svuint8_t indices)
        ///   TBL Zresult.B, Zdata.B, Zindices.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<sbyte> VectorTableLookup(Vector<sbyte> data, Vector<byte> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svint16_t svtbl[_s16](svint16_t data, svuint16_t indices)
        ///   TBL Zresult.H, Zdata.H, Zindices.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<short> VectorTableLookup(Vector<short> data, Vector<ushort> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svint32_t svtbl[_s32](svint32_t data, svuint32_t indices)
        ///   TBL Zresult.S, Zdata.S, Zindices.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<int> VectorTableLookup(Vector<int> data, Vector<uint> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svint64_t svtbl[_s64](svint64_t data, svuint64_t indices)
        ///   TBL Zresult.D, Zdata.D, Zindices.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<long> VectorTableLookup(Vector<long> data, Vector<ulong> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svuint8_t svtbl[_u8](svuint8_t data, svuint8_t indices)
        ///   TBL Zresult.B, Zdata.B, Zindices.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<byte> VectorTableLookup(Vector<byte> data, Vector<byte> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svuint16_t svtbl[_u16](svuint16_t data, svuint16_t indices)
        ///   TBL Zresult.H, Zdata.H, Zindices.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<ushort> VectorTableLookup(Vector<ushort> data, Vector<ushort> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svuint32_t svtbl[_u32](svuint32_t data, svuint32_t indices)
        ///   TBL Zresult.S, Zdata.S, Zindices.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<uint> VectorTableLookup(Vector<uint> data, Vector<uint> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svuint64_t svtbl[_u64](svuint64_t data, svuint64_t indices)
        ///   TBL Zresult.D, Zdata.D, Zindices.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<ulong> VectorTableLookup(Vector<ulong> data, Vector<ulong> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svfloat32_t svtbl[_f32](svfloat32_t data, svuint32_t indices)
        ///   TBL Zresult.S, Zdata.S, Zindices.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<float> VectorTableLookup(Vector<float> data, Vector<uint> indices) => VectorTableLookup(data, indices);

        /// <summary>
        /// svfloat64_t svtbl[_f64](svfloat64_t data, svuint64_t indices)
        ///   TBL Zresult.D, Zdata.D, Zindices.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BZ_3A  TBL <Zd>.<T>, {<Zn>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H);
        ///    IF_SVE_BZ_3A_A  TBL <Zd>.<T>, {<Zn1>.<T>, <Zn2>.<T>}, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V0, REG_V1, REG_V2, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V3, REG_V4, REG_V5, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        ///        theEmitter->emitIns_R_R_R(INS_sve_tbl, EA_SCALABLE, REG_V9, REG_V10, REG_V11, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_WITH_VECTOR_PAIR);
        /// </summary>
        public static unsafe Vector<double> VectorTableLookup(Vector<double> data, Vector<ulong> indices) => VectorTableLookup(data, indices);


        ///  Xor : Bitwise exclusive OR

        /// <summary>
        /// svint8_t sveor[_s8]_m(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   EOR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svint8_t sveor[_s8]_x(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   EOR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   EOR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svint8_t sveor[_s8]_z(svbool_t pg, svint8_t op1, svint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; EOR Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; EOR Zresult.B, Pg/M, Zresult.B, Zop1.B
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> Xor(Vector<sbyte> left, Vector<sbyte> right) => Xor(left, right);

        /// <summary>
        /// svint16_t sveor[_s16]_m(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   EOR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svint16_t sveor[_s16]_x(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   EOR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   EOR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svint16_t sveor[_s16]_z(svbool_t pg, svint16_t op1, svint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; EOR Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; EOR Zresult.H, Pg/M, Zresult.H, Zop1.H
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> Xor(Vector<short> left, Vector<short> right) => Xor(left, right);

        /// <summary>
        /// svint32_t sveor[_s32]_m(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   EOR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svint32_t sveor[_s32]_x(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   EOR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   EOR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svint32_t sveor[_s32]_z(svbool_t pg, svint32_t op1, svint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; EOR Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; EOR Zresult.S, Pg/M, Zresult.S, Zop1.S
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> Xor(Vector<int> left, Vector<int> right) => Xor(left, right);

        /// <summary>
        /// svint64_t sveor[_s64]_m(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   EOR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svint64_t sveor[_s64]_x(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   EOR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   EOR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svint64_t sveor[_s64]_z(svbool_t pg, svint64_t op1, svint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; EOR Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; EOR Zresult.D, Pg/M, Zresult.D, Zop1.D
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> Xor(Vector<long> left, Vector<long> right) => Xor(left, right);

        /// <summary>
        /// svuint8_t sveor[_u8]_m(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   EOR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.B, Pg/M, Zresult.B, Zop2.B
        /// svuint8_t sveor[_u8]_x(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   EOR Ztied1.B, Pg/M, Ztied1.B, Zop2.B
        ///   EOR Ztied2.B, Pg/M, Ztied2.B, Zop1.B
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svuint8_t sveor[_u8]_z(svbool_t pg, svuint8_t op1, svuint8_t op2)
        ///   MOVPRFX Zresult.B, Pg/Z, Zop1.B; EOR Zresult.B, Pg/M, Zresult.B, Zop2.B
        ///   MOVPRFX Zresult.B, Pg/Z, Zop2.B; EOR Zresult.B, Pg/M, Zresult.B, Zop1.B
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> Xor(Vector<byte> left, Vector<byte> right) => Xor(left, right);

        /// <summary>
        /// svuint16_t sveor[_u16]_m(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   EOR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.H, Pg/M, Zresult.H, Zop2.H
        /// svuint16_t sveor[_u16]_x(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   EOR Ztied1.H, Pg/M, Ztied1.H, Zop2.H
        ///   EOR Ztied2.H, Pg/M, Ztied2.H, Zop1.H
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svuint16_t sveor[_u16]_z(svbool_t pg, svuint16_t op1, svuint16_t op2)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop1.H; EOR Zresult.H, Pg/M, Zresult.H, Zop2.H
        ///   MOVPRFX Zresult.H, Pg/Z, Zop2.H; EOR Zresult.H, Pg/M, Zresult.H, Zop1.H
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> Xor(Vector<ushort> left, Vector<ushort> right) => Xor(left, right);

        /// <summary>
        /// svuint32_t sveor[_u32]_m(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   EOR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.S, Pg/M, Zresult.S, Zop2.S
        /// svuint32_t sveor[_u32]_x(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   EOR Ztied1.S, Pg/M, Ztied1.S, Zop2.S
        ///   EOR Ztied2.S, Pg/M, Ztied2.S, Zop1.S
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svuint32_t sveor[_u32]_z(svbool_t pg, svuint32_t op1, svuint32_t op2)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop1.S; EOR Zresult.S, Pg/M, Zresult.S, Zop2.S
        ///   MOVPRFX Zresult.S, Pg/Z, Zop2.S; EOR Zresult.S, Pg/M, Zresult.S, Zop1.S
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> Xor(Vector<uint> left, Vector<uint> right) => Xor(left, right);

        /// <summary>
        /// svuint64_t sveor[_u64]_m(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   EOR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   MOVPRFX Zresult, Zop1; EOR Zresult.D, Pg/M, Zresult.D, Zop2.D
        /// svuint64_t sveor[_u64]_x(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   EOR Ztied1.D, Pg/M, Ztied1.D, Zop2.D
        ///   EOR Ztied2.D, Pg/M, Ztied2.D, Zop1.D
        ///   EOR Zresult.D, Zop1.D, Zop2.D
        /// svuint64_t sveor[_u64]_z(svbool_t pg, svuint64_t op1, svuint64_t op2)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop1.D; EOR Zresult.D, Pg/M, Zresult.D, Zop2.D
        ///   MOVPRFX Zresult.D, Pg/Z, Zop2.D; EOR Zresult.D, Pg/M, Zresult.D, Zop1.D
        /// svbool_t sveor[_b]_z(svbool_t pg, svbool_t op1, svbool_t op2)
        ///   EOR Presult.B, Pg/Z, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AA_3A  EOR <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V14, REG_P5, REG_V16, INS_OPTS_SCALABLE_S);
        ///    IF_SVE_CZ_4A  CMPNE <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R_R(INS_sve_eor, EA_SCALABLE, REG_P8, REG_P15, REG_P11, REG_P7, INS_OPTS_SCALABLE_B); /* EOR <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B */
        ///    IF_SVE_AU_3A  EOR <Zd>.D, <Zn>.D, <Zm>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_eor, EA_SCALABLE, REG_V6, REG_V7, REG_V8, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> Xor(Vector<ulong> left, Vector<ulong> right) => Xor(left, right);


        ///  XorAcross : Bitwise exclusive OR reduction to scalar

        /// <summary>
        /// int8_t sveorv[_s8](svbool_t pg, svint8_t op)
        ///   EORV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<sbyte> XorAcross(Vector<sbyte> value) => XorAcross(value);

        /// <summary>
        /// int16_t sveorv[_s16](svbool_t pg, svint16_t op)
        ///   EORV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<short> XorAcross(Vector<short> value) => XorAcross(value);

        /// <summary>
        /// int32_t sveorv[_s32](svbool_t pg, svint32_t op)
        ///   EORV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<int> XorAcross(Vector<int> value) => XorAcross(value);

        /// <summary>
        /// int64_t sveorv[_s64](svbool_t pg, svint64_t op)
        ///   EORV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<long> XorAcross(Vector<long> value) => XorAcross(value);

        /// <summary>
        /// uint8_t sveorv[_u8](svbool_t pg, svuint8_t op)
        ///   EORV Bresult, Pg, Zop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<byte> XorAcross(Vector<byte> value) => XorAcross(value);

        /// <summary>
        /// uint16_t sveorv[_u16](svbool_t pg, svuint16_t op)
        ///   EORV Hresult, Pg, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> XorAcross(Vector<ushort> value) => XorAcross(value);

        /// <summary>
        /// uint32_t sveorv[_u32](svbool_t pg, svuint32_t op)
        ///   EORV Sresult, Pg, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> XorAcross(Vector<uint> value) => XorAcross(value);

        /// <summary>
        /// uint64_t sveorv[_u64](svbool_t pg, svuint64_t op)
        ///   EORV Dresult, Pg, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AF_3A  EORV <V><d>, <Pg>, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_eorv, EA_2BYTE, REG_V1, REG_P1, REG_V1, INS_OPTS_SCALABLE_H);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> XorAcross(Vector<ulong> value) => XorAcross(value);


        ///  ZeroExtend16 : Zero-extend the low 16 bits

        /// <summary>
        /// svuint32_t svexth[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   UXTH Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; UXTH Zresult.S, Pg/M, Zop.S
        /// svuint32_t svexth[_u32]_x(svbool_t pg, svuint32_t op)
        ///   UXTH Ztied.S, Pg/M, Ztied.S
        ///   AND Ztied.S, Ztied.S, #65535
        /// svuint32_t svexth[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; UXTH Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  UXTH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxth, EA_SCALABLE, REG_V18, REG_P5, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxth, EA_SCALABLE, REG_V18, REG_P5, REG_V13, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ZeroExtend16(Vector<uint> value) => ZeroExtend16(value);

        /// <summary>
        /// svuint64_t svexth[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   UXTH Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; UXTH Zresult.D, Pg/M, Zop.D
        /// svuint64_t svexth[_u64]_x(svbool_t pg, svuint64_t op)
        ///   UXTH Ztied.D, Pg/M, Ztied.D
        ///   AND Ztied.D, Ztied.D, #65535
        /// svuint64_t svexth[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; UXTH Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  UXTH <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxth, EA_SCALABLE, REG_V18, REG_P5, REG_V13, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxth, EA_SCALABLE, REG_V18, REG_P5, REG_V13, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ZeroExtend16(Vector<ulong> value) => ZeroExtend16(value);


        ///  ZeroExtend32 : Zero-extend the low 32 bits

        /// <summary>
        /// svuint64_t svextw[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   UXTW Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; UXTW Zresult.D, Pg/M, Zop.D
        /// svuint64_t svextw[_u64]_x(svbool_t pg, svuint64_t op)
        ///   UXTW Ztied.D, Pg/M, Ztied.D
        ///   AND Ztied.D, Ztied.D, #4294967295
        /// svuint64_t svextw[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; UXTW Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  UXTW <Zd>.D, <Pg>/M, <Zn>.D
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtw, EA_SCALABLE, REG_V17, REG_P6, REG_V14, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ZeroExtend32(Vector<ulong> value) => ZeroExtend32(value);


        ///  ZeroExtend8 : Zero-extend the low 8 bits

        /// <summary>
        /// svuint16_t svextb[_u16]_m(svuint16_t inactive, svbool_t pg, svuint16_t op)
        ///   UXTB Ztied.H, Pg/M, Zop.H
        ///   MOVPRFX Zresult, Zinactive; UXTB Zresult.H, Pg/M, Zop.H
        /// svuint16_t svextb[_u16]_x(svbool_t pg, svuint16_t op)
        ///   UXTB Ztied.H, Pg/M, Ztied.H
        ///   AND Ztied.H, Ztied.H, #255
        /// svuint16_t svextb[_u16]_z(svbool_t pg, svuint16_t op)
        ///   MOVPRFX Zresult.H, Pg/Z, Zop.H; UXTB Zresult.H, Pg/M, Zop.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  UXTB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ushort> ZeroExtend8(Vector<ushort> value) => ZeroExtend8(value);

        /// <summary>
        /// svuint32_t svextb[_u32]_m(svuint32_t inactive, svbool_t pg, svuint32_t op)
        ///   UXTB Ztied.S, Pg/M, Zop.S
        ///   MOVPRFX Zresult, Zinactive; UXTB Zresult.S, Pg/M, Zop.S
        /// svuint32_t svextb[_u32]_x(svbool_t pg, svuint32_t op)
        ///   UXTB Ztied.S, Pg/M, Ztied.S
        ///   AND Ztied.S, Ztied.S, #255
        /// svuint32_t svextb[_u32]_z(svbool_t pg, svuint32_t op)
        ///   MOVPRFX Zresult.S, Pg/Z, Zop.S; UXTB Zresult.S, Pg/M, Zop.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  UXTB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<uint> ZeroExtend8(Vector<uint> value) => ZeroExtend8(value);

        /// <summary>
        /// svuint64_t svextb[_u64]_m(svuint64_t inactive, svbool_t pg, svuint64_t op)
        ///   UXTB Ztied.D, Pg/M, Zop.D
        ///   MOVPRFX Zresult, Zinactive; UXTB Zresult.D, Pg/M, Zop.D
        /// svuint64_t svextb[_u64]_x(svbool_t pg, svuint64_t op)
        ///   UXTB Ztied.D, Pg/M, Ztied.D
        ///   AND Ztied.D, Ztied.D, #255
        /// svuint64_t svextb[_u64]_z(svbool_t pg, svuint64_t op)
        ///   MOVPRFX Zresult.D, Pg/Z, Zop.D; UXTB Zresult.D, Pg/M, Zop.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_AQ_3A  UXTB <Zd>.<T>, <Pg>/M, <Zn>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_H);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_S);
        ///        theEmitter->emitIns_R_R_R(INS_sve_uxtb, EA_SCALABLE, REG_V19, REG_P4, REG_V12, INS_OPTS_SCALABLE_D);
        ///
        /// Embedded arg1 mask predicate
        /// </summary>
        public static unsafe Vector<ulong> ZeroExtend8(Vector<ulong> value) => ZeroExtend8(value);


        ///  ZeroExtendWideningLower : Unpack and extend low half

        /// <summary>
        /// svuint16_t svunpklo[_u16](svuint8_t op)
        ///   UUNPKLO Zresult.H, Zop.B
        /// svbool_t svunpklo[_b](svbool_t op)
        ///   PUNPKLO Presult.H, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  UUNPKLO <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_uunpklo, EA_SCALABLE, REG_V8, REG_V6, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<ushort> ZeroExtendWideningLower(Vector<byte> value) => ZeroExtendWideningLower(value);

        /// <summary>
        /// svuint32_t svunpklo[_u32](svuint16_t op)
        ///   UUNPKLO Zresult.S, Zop.H
        /// svbool_t svunpklo[_b](svbool_t op)
        ///   PUNPKLO Presult.H, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  UUNPKLO <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_uunpklo, EA_SCALABLE, REG_V8, REG_V6, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<uint> ZeroExtendWideningLower(Vector<ushort> value) => ZeroExtendWideningLower(value);

        /// <summary>
        /// svuint64_t svunpklo[_u64](svuint32_t op)
        ///   UUNPKLO Zresult.D, Zop.S
        /// svbool_t svunpklo[_b](svbool_t op)
        ///   PUNPKLO Presult.H, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  UUNPKLO <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_uunpklo, EA_SCALABLE, REG_V8, REG_V6, INS_OPTS_SCALABLE_S);
        /// </summary>
        public static unsafe Vector<ulong> ZeroExtendWideningLower(Vector<uint> value) => ZeroExtendWideningLower(value);


        ///  ZeroExtendWideningUpper : Unpack and extend high half

        /// <summary>
        /// svuint16_t svunpkhi[_u16](svuint8_t op)
        ///   UUNPKHI Zresult.H, Zop.B
        /// svbool_t svunpkhi[_b](svbool_t op)
        ///   PUNPKHI Presult.H, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  UUNPKHI <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_uunpkhi, EA_SCALABLE, REG_V5, REG_V1, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ushort> ZeroExtendWideningUpper(Vector<byte> value) => ZeroExtendWideningUpper(value);

        /// <summary>
        /// svuint32_t svunpkhi[_u32](svuint16_t op)
        ///   UUNPKHI Zresult.S, Zop.H
        /// svbool_t svunpkhi[_b](svbool_t op)
        ///   PUNPKHI Presult.H, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  UUNPKHI <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_uunpkhi, EA_SCALABLE, REG_V5, REG_V1, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<uint> ZeroExtendWideningUpper(Vector<ushort> value) => ZeroExtendWideningUpper(value);

        /// <summary>
        /// svuint64_t svunpkhi[_u64](svuint32_t op)
        ///   UUNPKHI Zresult.D, Zop.S
        /// svbool_t svunpkhi[_b](svbool_t op)
        ///   PUNPKHI Presult.H, Pop.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_CH_2A  UUNPKHI <Zd>.<T>, <Zn>.<Tb>
        ///        theEmitter->emitIns_R_R(INS_sve_uunpkhi, EA_SCALABLE, REG_V5, REG_V1, INS_OPTS_SCALABLE_D);
        /// </summary>
        public static unsafe Vector<ulong> ZeroExtendWideningUpper(Vector<uint> value) => ZeroExtendWideningUpper(value);


        ///  ZipHigh : Interleave elements from high halves of two inputs

        /// <summary>
        /// svint8_t svzip2[_s8](svint8_t op1, svint8_t op2)
        ///   ZIP2 Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<sbyte> ZipHigh(Vector<sbyte> left, Vector<sbyte> right) => ZipHigh(left, right);

        /// <summary>
        /// svint16_t svzip2[_s16](svint16_t op1, svint16_t op2)
        ///   ZIP2 Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<short> ZipHigh(Vector<short> left, Vector<short> right) => ZipHigh(left, right);

        /// <summary>
        /// svint32_t svzip2[_s32](svint32_t op1, svint32_t op2)
        ///   ZIP2 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<int> ZipHigh(Vector<int> left, Vector<int> right) => ZipHigh(left, right);

        /// <summary>
        /// svint64_t svzip2[_s64](svint64_t op1, svint64_t op2)
        ///   ZIP2 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<long> ZipHigh(Vector<long> left, Vector<long> right) => ZipHigh(left, right);

        /// <summary>
        /// svuint8_t svzip2[_u8](svuint8_t op1, svuint8_t op2)
        ///   ZIP2 Zresult.B, Zop1.B, Zop2.B
        /// svbool_t svzip2_b8(svbool_t op1, svbool_t op2)
        ///   ZIP2 Presult.B, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<byte> ZipHigh(Vector<byte> left, Vector<byte> right) => ZipHigh(left, right);

        /// <summary>
        /// svuint16_t svzip2[_u16](svuint16_t op1, svuint16_t op2)
        ///   ZIP2 Zresult.H, Zop1.H, Zop2.H
        /// svbool_t svzip2_b16(svbool_t op1, svbool_t op2)
        ///   ZIP2 Presult.H, Pop1.H, Pop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ushort> ZipHigh(Vector<ushort> left, Vector<ushort> right) => ZipHigh(left, right);

        /// <summary>
        /// svuint32_t svzip2[_u32](svuint32_t op1, svuint32_t op2)
        ///   ZIP2 Zresult.S, Zop1.S, Zop2.S
        /// svbool_t svzip2_b32(svbool_t op1, svbool_t op2)
        ///   ZIP2 Presult.S, Pop1.S, Pop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<uint> ZipHigh(Vector<uint> left, Vector<uint> right) => ZipHigh(left, right);

        /// <summary>
        /// svuint64_t svzip2[_u64](svuint64_t op1, svuint64_t op2)
        ///   ZIP2 Zresult.D, Zop1.D, Zop2.D
        /// svbool_t svzip2_b64(svbool_t op1, svbool_t op2)
        ///   ZIP2 Presult.D, Pop1.D, Pop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<ulong> ZipHigh(Vector<ulong> left, Vector<ulong> right) => ZipHigh(left, right);

        /// <summary>
        /// svfloat32_t svzip2[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   ZIP2 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<float> ZipHigh(Vector<float> left, Vector<float> right) => ZipHigh(left, right);

        /// <summary>
        /// svfloat64_t svzip2[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   ZIP2 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V30, REG_V31, REG_V0, INS_OPTS_SCALABLE_S, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V1, REG_V2, REG_V3, INS_OPTS_SCALABLE_D, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_V15, REG_V16, REG_V17, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP2 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip2, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_H);
        /// </summary>
        public static unsafe Vector<double> ZipHigh(Vector<double> left, Vector<double> right) => ZipHigh(left, right);


        ///  ZipLow : Interleave elements from low halves of two inputs

        /// <summary>
        /// svint8_t svzip1[_s8](svint8_t op1, svint8_t op2)
        ///   ZIP1 Zresult.B, Zop1.B, Zop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<sbyte> ZipLow(Vector<sbyte> left, Vector<sbyte> right) => ZipLow(left, right);

        /// <summary>
        /// svint16_t svzip1[_s16](svint16_t op1, svint16_t op2)
        ///   ZIP1 Zresult.H, Zop1.H, Zop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<short> ZipLow(Vector<short> left, Vector<short> right) => ZipLow(left, right);

        /// <summary>
        /// svint32_t svzip1[_s32](svint32_t op1, svint32_t op2)
        ///   ZIP1 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<int> ZipLow(Vector<int> left, Vector<int> right) => ZipLow(left, right);

        /// <summary>
        /// svint64_t svzip1[_s64](svint64_t op1, svint64_t op2)
        ///   ZIP1 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<long> ZipLow(Vector<long> left, Vector<long> right) => ZipLow(left, right);

        /// <summary>
        /// svuint8_t svzip1[_u8](svuint8_t op1, svuint8_t op2)
        ///   ZIP1 Zresult.B, Zop1.B, Zop2.B
        /// svbool_t svzip1_b8(svbool_t op1, svbool_t op2)
        ///   ZIP1 Presult.B, Pop1.B, Pop2.B
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<byte> ZipLow(Vector<byte> left, Vector<byte> right) => ZipLow(left, right);

        /// <summary>
        /// svuint16_t svzip1[_u16](svuint16_t op1, svuint16_t op2)
        ///   ZIP1 Zresult.H, Zop1.H, Zop2.H
        /// svbool_t svzip1_b16(svbool_t op1, svbool_t op2)
        ///   ZIP1 Presult.H, Pop1.H, Pop2.H
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ushort> ZipLow(Vector<ushort> left, Vector<ushort> right) => ZipLow(left, right);

        /// <summary>
        /// svuint32_t svzip1[_u32](svuint32_t op1, svuint32_t op2)
        ///   ZIP1 Zresult.S, Zop1.S, Zop2.S
        /// svbool_t svzip1_b32(svbool_t op1, svbool_t op2)
        ///   ZIP1 Presult.S, Pop1.S, Pop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<uint> ZipLow(Vector<uint> left, Vector<uint> right) => ZipLow(left, right);

        /// <summary>
        /// svuint64_t svzip1[_u64](svuint64_t op1, svuint64_t op2)
        ///   ZIP1 Zresult.D, Zop1.D, Zop2.D
        /// svbool_t svzip1_b64(svbool_t op1, svbool_t op2)
        ///   ZIP1 Presult.D, Pop1.D, Pop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<ulong> ZipLow(Vector<ulong> left, Vector<ulong> right) => ZipLow(left, right);

        /// <summary>
        /// svfloat32_t svzip1[_f32](svfloat32_t op1, svfloat32_t op2)
        ///   ZIP1 Zresult.S, Zop1.S, Zop2.S
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<float> ZipLow(Vector<float> left, Vector<float> right) => ZipLow(left, right);

        /// <summary>
        /// svfloat64_t svzip1[_f64](svfloat64_t op1, svfloat64_t op2)
        ///   ZIP1 Zresult.D, Zop1.D, Zop2.D
        ///
        /// codegenarm64test:
        ///    IF_SVE_BR_3A  ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V24, REG_V25, REG_V26, INS_OPTS_SCALABLE_B, INS_SCALABLE_OPTS_UNPREDICATED);
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V27, REG_V28, REG_V29, INS_OPTS_SCALABLE_H, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_BR_3B  ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_V12, REG_V13, REG_V14, INS_OPTS_SCALABLE_Q, INS_SCALABLE_OPTS_UNPREDICATED);
        ///    IF_SVE_CI_3A  ZIP1 <Pd>.<T>, <Pn>.<T>, <Pm>.<T>
        ///        theEmitter->emitIns_R_R_R(INS_sve_zip1, EA_SCALABLE, REG_P0, REG_P0, REG_P0, INS_OPTS_SCALABLE_B);
        /// </summary>
        public static unsafe Vector<double> ZipLow(Vector<double> left, Vector<double> right) => ZipLow(left, right);

    }
}

