parameters:
  platform: ''
  dependsOn: []
  additionalMSBuildArgs: ''
  additionalRunArgs: ''
  crossBuild: false
  disableCrossgen: false
  container: ''
  packageDistroList: null
  skipTests: false
  archType: x64
  timeoutInMinutes: 120
  pool: ''
  crossrootfsDir: ''

jobs:
- template: base-job.yml
  parameters:
    ${{ insert }}: ${{ parameters }}

    # Do not attempt to clean workspace: the agent might not be able to remove the files because
    # they may be owned by "root" due to the way this job uses Docker. This job does its own cleanup
    # as a prepare step.
    workspace: ''

    # This job runs within several Docker containers, so Build.SourcesDirectory is not accurate.
    buildCommandSourcesDirectory: '/root/runtime/'

    buildVariables:
      # Preserve the NuGet authentication env vars into the Docker container.
      # The 'NuGetAuthenticate' build step may have set these.
      PreserveNuGetAuthDockerArgs: >-
        -e VSS_NUGET_URI_PREFIXES
        -e VSS_NUGET_ACCESSTOKEN

      ${{ if ne(parameters.container, '') }}:
        RunArguments: >-
          docker run --privileged --rm
          -v "$(Build.SourcesDirectory):/root/runtime"
          -w="/root/runtime"
          $(PreserveNuGetAuthDockerArgs)
          -e ROOTFS_DIR=${{ parameters.crossrootfsDir }}
          ${{ parameters.container }}

      ${{ if eq(parameters.name, 'FreeBSD_x64')}}:
        RunArguments: export DotNetBootstrapCliTarPath=/dotnet-sdk-freebsd-x64.tar &&

      ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
        BuildScript: ./eng/install-nuget-credprovider-then-build.sh --subsetCategory installer
        MSBuildScript: /root/runtime/eng/install-nuget-credprovider-then-msbuild.sh

      ${{ if not(and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'))) }}:
        BuildScript: ./installer.sh
        MSBuildScript: /root/runtime/eng/common/msbuild.sh

      CommonMSBuildArgs: >-
        /p:Configuration=$(_BuildConfig)
        /p:OfficialBuildId=$(Build.BuildNumber)
        /p:TargetArchitecture=${{ parameters.archType }}

      # Don't put additionalMSBuildArgs as the last line. It may or may not have extra args. If the
      # parameter is empty, AzDO replaces it with empty space without chomping the extra newline.
      # This causes a newline in the arg string that causes failure.
      BuildArguments: >-
        --restore --build --ci --test
        /p:CrossBuild=${{ parameters.crossBuild }}
        /p:DisableCrossgen=${{ parameters.disableCrossgen }}
        /p:PortableBuild=${{ parameters.portableBuild }}
        /p:SkipTests=${{ parameters.skipTests }}
        $(LiveOverridePathArgs)
        $(CommonMSBuildArgs)
        ${{ parameters.additionalMSBuildArgs }}
        /p:StripSymbols=true

      PublishArguments: >-
        /p:PortableBuild=${{ parameters.portableBuild }}
        $(CommonMSBuildArgs)
        ${{ parameters.additionalMSBuildArgs }}
        /bl:msbuild.publish.binlog

      # Tell the build to package up the bits from the portable build.
      PackagePortableBitsArgs: >-
        /p:PortableBuild=false
        /p:SharedFrameworkPublishDir=/root/sharedFrameworkPublish/
        /p:InstallerSourceOSPlatformConfig=linux-x64.$(_BuildConfig)

      DockerRunMSBuild: >-
        docker run
        -v $(Build.SourcesDirectory):/root/runtime
        -v $(Build.StagingDirectory)/sharedFrameworkPublish/:/root/sharedFrameworkPublish/
        -w=/root/runtime
        $(PreserveNuGetAuthDockerArgs)

      installersSubsetArg: --subset Installers

    prepareSteps:

    - ${{ if ne(parameters.container, '') }}:
      # Builds don't set user ID, so files might be owned by root and unable to be cleaned up by AzDO.
      # Clean up the build dirs ourselves in another Docker container to avoid failures.
      # Using hosted agents is tracked by https://github.com/dotnet/core-setup/issues/4997
      - script: |
          set -x
          docker run --rm \
            -v "$(Agent.BuildDirectory):/root/build" \
            -w /root/build \
            ${{ parameters.container }} \
            bash -c '
              rm -v -rf a b s'
          mkdir "$(Agent.BuildDirectory)/s"
        displayName: Clean up old artifacts owned by root

    buildSteps:

    # Build binary and nuget packages
    - script: |
        set -x
        df -h
        $(RunArguments) $(BuildScript) $(BuildArguments)
      displayName: Build

    # Only for glibc leg, here we produce RPMs and Debs
    - ${{ if eq(parameters.name, 'Linux_x64_glibc')}}:
      - task: CopyFiles@2
        displayName: 'Copy built Portable linux-x64 binaries to staging directory'
        inputs:
          SourceFolder: '$(Build.SourcesDirectory)/artifacts/obj/linux-x64.$(_BuildConfig)/sharedFrameworkPublish'
          TargetFolder: '$(Build.StagingDirectory)/sharedFrameworkPublish'

      - ${{ each packageBuild in parameters.packageDistroList }}:
        # This leg's RID matches the build image. Build its distro-dependent packages, as well as
        # the distro-independent installers. (There's no particular reason to build the distro-
        # independent installers on this leg, but we need to do it somewhere.)
        - template: steps/build-linux-package.yml
          parameters:
            buildTraversalBuildDependencies: true
            distroRid: ${{ packageBuild.imageRid }}
            image: ${{ packageBuild.image }}
            packageStepDescription: Runtime Deps, Runtime, Framework Packs installers
            subsetArg: $(installersSubsetArg)

        - ${{ each rid in packageBuild.rids }}:
          # Build distro-dependent packages.
          - template: steps/build-linux-package.yml
            parameters:
              distroRid: ${{ rid }}
              image: ${{ packageBuild.image }}
              outputRidArg: /p:OutputRid=${{ rid }}-${{ parameters.archType }}
              packageStepDescription: Runtime Deps installers
              packagingArgs: /p:BuildDistroIndependentInstallers=false
              subsetArg: $(installersSubsetArg)

    - ${{ if ne(parameters.container, '') }}:
      # Files may be owned by root because builds don't set user ID. Later build steps run 'find' in
      # the source tree, which fails due to permissions in the 'NetCore*-Int-Pool' queues. This step
      # prevents the failure by using chown to clean up our source tree.
      - script: |
          set -x
          docker run --rm \
            -v "$(Agent.BuildDirectory):/root/build" \
            -w /root/build \
            ${{ parameters.container }} \
            bash -c "chown -R $(id -u):$(id -g) *"
        displayName: Update file ownership from root to build agent account
        continueOnError: true
        condition: succeededOrFailed()
