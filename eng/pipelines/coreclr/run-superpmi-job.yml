parameters:
  steps: []                       # optional -- any additional steps that need to happen before pulling down the jitutils repo and sending the jitutils to helix (ie building your repo)
  variables: []                   # optional -- list of additional variables to send to the template
  buildConfig: ''                 # required -- build configuration
  archType: ''                    # required -- targeting CPU architecture
  osGroup: ''                     # required -- operating system for the job
  osSubgroup: ''                  # optional -- operating system subgroup
  continueOnError: 'false'        # optional -- determines whether to continue the build if the step errors
  dependsOn: ''                   # optional -- dependencies of the job
  runtimeType: 'coreclr'          # optional -- Sets the runtime as coreclr or mono
  codeGenType: 'JIT'              # optional -- Decides on the codegen technology if running on mono
  runKind: ''                     # required -- test category
  helixSource: ''                 # sources must start with pr/, official/, prodcon/, or agent/
  helixType: ''                   # required -- helix type
  helixTargetQueues: ''           # required -- helix target queue to run the job on
  creator: ''                     # required -- creator
  helixAccessToken: ''            # required -- access token to make Helix API requests; should be provided by the appropriate variable group
  workItemTimeout: 4:00           # optional -- work item timeout
  workItemDirectory: ''           # required -- work item directory
  correlationPayloadDirectory: '' # required -- correlation payload directory
  pythonScript: ''                # required -- python script to use
  pmiAssembliesSubDirectory: ''   # required -- path of directory on which SPMI needs to be run on
  outputSPMICollectionName: ''    # required -- name of the SPMI collection
  coreRootDir: ''                 # required -- path to coreRootDir
  mchFileLocation: ''             # required -- path to mchFileLocation
  mchFileTag: ''                  # required -- mch file tag to use

steps:

     # Run superpmi collection in helix
  - template: /eng/common/templates/steps/superpmi-send-to-helix.yml
    parameters:
      HelixSource: ${{ parameters.helixSource }}
      HelixType: ${{ parameters.helixType }}
      HelixPreCommands: ''
      HelixAccessToken: ${{ parameters.helixAccessToken }}
      HelixTargetQueues: ${{ parameters.helixTargetQueues }}
      Creator: ${{ parameters.creator }}
      WorkItemTimeout: ${{ parameters.workItemTimeout }}
      WorkItemDirectory: ${{ parameters.workItemDirectory }}
      CorrelationPayloadDirectory: ${{ parameters.correlationPayloadDirectory}}
      BuildConfig: ${{ parameters.buildConfig}}
      osGroup: ${{ parameters.osGroup }}
      PmiAssembliesSubDirectory: ${{ parameters.pmiAssembliesSubDirectory}}
      OutputSPMICollectionName: ${{ parameters.outputSPMICollectionName }}
      DisplayNamePrefix: ${{ format('Send job to Helix ({0})', parameters.outputSPMICollectionName) }}

  - task: PublishPipelineArtifact@1
    displayName: Publish SuperPMI collection
    inputs:
      targetPath: $(Build.SourcesDirectory)/artifacts/helixresults
      artifactName: 'SuperPMI_${{ parameters.outputSPMICollectionName}}_${{ parameters.osGroup}}${{ parameters.osSubgroup }}_${{ parameters.archType }}_${{ parameters.buildConfig}}_${{ parameters.runtimeType }}_${{ parameters.codeGenType }}'

  - script: ${{ parameters.pythonScript }} $(Build.SourcesDirectory)/src/coreclr/scripts/superpmi.py merge-mch -pattern ${{ parameters.mchFileLocation}}${{ parameters.outputSPMICollectionName}}.pmi*.mch  -output_mch_path ${{ parameters.mchFileLocation}}${{ parameters.outputSPMICollectionName}}.pmi.${{ parameters.mchFileTag }}.mch
    displayName: ${{ format('Merge {0} SuperPMI collections', parameters.outputSPMICollectionName) }}

    # For now, we won't upload merged collection as an artifact.

  - script: ${{ parameters.pythonScript }} $(Build.SourcesDirectory)/src/coreclr/scripts/superpmi.py upload -arch ${{ parameters.archType }} -build_type ${{ parameters.buildConfig}} -mch_files ${{ parameters.mchFileLocation}}${{ parameters.outputSPMICollectionName}}.pmi.${{ parameters.mchFileTag }}.mch -core_root ${{ parameters.coreRootDir }}
    displayName: Upload SuperPMI collection to Azure Storage
    env:
      CLRJIT_AZ_KEY: $(clrjit_key1) # secret key stored as variable in pipeline

  - task: PublishPipelineArtifact@1
    displayName: Publish Logs
    inputs:
      targetPath: $(Build.SourcesDirectory)/artifacts/log
      artifactName: 'SuperPMI_${{ parameters.outputSPMICollectionName}}_Logs_${{ parameters.osGroup}}${{ parameters.osSubgroup }}_${{ parameters.archType }}_${{ parameters.buildConfig}}_${{ parameters.runtimeType }}_${{ parameters.codeGenType }}'
    continueOnError: true
    condition: always()