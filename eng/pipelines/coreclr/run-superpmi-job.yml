parameters:
  steps: []                       # optional -- any additional steps that need to happen before pulling down the jitutils repo and sending the jitutils to helix (ie building your repo)
  variables: []                   # optional -- list of additional variables to send to the template
  buildConfig: ''                 # required -- build configuration
  archType: ''                    # required -- targeting CPU architecture
  osGroup: ''                     # required -- operating system for the job
  osSubgroup: ''                  # optional -- operating system subgroup
  continueOnError: 'false'        # optional -- determines whether to continue the build if the step errors
  dependsOn: ''                   # optional -- dependencies of the job
  runtimeType: 'coreclr'          # optional -- Sets the runtime as coreclr or mono
  codeGenType: 'JIT'              # optional -- Decides on the codegen technology if running on mono
  runKind: ''                     # required -- test category
  helixSource: ''                 # sources must start with pr/, official/, prodcon/, or agent/
  helixType: ''                   # required -- helix type
  helixTargetQueues: ''           # required -- helix target queue to run the job on
  creator: ''                     # required -- creator
  workItemTimeout: 4:00           # optional -- work item timeout
  workItemDirectory: ''           # required -- work item directory
  correlationPayloadDirectory: '' # required -- correlation payload directory
  pythonScript: ''                # required -- python script to use
  pmiAssembliesSubDirectory: ''   # required -- path of directory on which SPMI needs to be run on
  outputSPMICollectionName: ''    # required -- name of the SPMI collection
  coreRootDir: ''                 # required -- path to coreRootDir
  mchFileLocation: ''             # required -- path to mchFileLocation
  mchFileTag: ''                  # required -- mch file tag to use

  variables:
      HelixSource: ${{ parameters.helixSource }}
      HelixType: ${{ parameters.helixType }}
      HelixPreCommands: ''
      HelixAccessToken: ''
      HelixTargetQueues: ${{ parameters.helixTargetQueues }}
      Creator: ${{ parameters.creator }}
      WorkItemTimeout: ${{ parameters.workItemTimeout }}
      WorkItemDirectory: ${{ parameters.workItemDirectory }}
      CorrelationPayloadDirectory: ${{ parameters.correlationPayloadDirectory }}
      BuildConfig: ${{ parameters.buildConfig }}
      osGroup: ${{ parameters.osGroup }}
      osSubgroup: ${{ parameters.osSubgroup }}
      archType: ${{ parameters.archType }}
      PythonScript: ${{ parameters.pythonScript }}
      PmiAssembliesSubDirectory: ${{ parameters.pmiAssembliesSubDirectory }}
      OutputSPMICollectionName: ${{ parameters.outputSPMICollectionName }}
      Core_Root_Dir: ${{ parameters.coreRootDir }}
      MchFilesLocation: ${{ parameters.mchFileLocation }}
      MchFileTag: ${{ parameters.mchFileTag }}

     # Run superpmi collection in helix
    - template: /eng/common/templates/steps/superpmi-send-to-helix.yml
      parameters:
        HelixSource: $(HelixSource)
        HelixType: $(HelixType)
        HelixPreCommands: ''
        HelixAccessToken: ''
        HelixTargetQueues: $(HelixTargetQueues)
        Creator: $(Creator)
        WorkItemTimeout: $(WorkItemTimeout)
        WorkItemDirectory: $(WorkItemDirectory)
        CorrelationPayloadDirectory: $(CorrelationPayloadDirectory)
        BuildConfig: $(BuildConfig)
        osGroup: $(osGroup)
        PmiAssembliesSubDirectory: $(PmiAssembliesSubDirectory)
        OutputSPMICollectionName: $(OutputSPMICollectionName)

    - task: PublishPipelineArtifact@1
      displayName: Publish SuperPMI collection
      inputs:
        targetPath: $(Build.SourcesDirectory)/artifacts/helixresults
        artifactName: 'SuperPMI_$(OutputSPMICollectionName)_$(osGroup)$(osSubgroup)_$(archType)_$(buildConfig)_${{ parameters.runtimeType }}_${{ parameters.codeGenType }}'

    - script: $(PythonScript) $(Build.SourcesDirectory)/src/coreclr/scripts/superpmi.py merge-mch -pattern $(MchFilesLocation)$(OutputSPMICollectionName).pmi*.mch  -output_mch_path $(MchFilesLocation)$(OutputSPMICollectionName).pmi.$(MchFileTag).mch
      displayName: ${{ format('Merge {0} SuperPMI collections', parameters.outputSPMICollectionName) }}

    # For now, we won't upload merged collection as an artifact.

    - script: $(PythonScript) $(Build.SourcesDirectory)/src/coreclr/scripts/superpmi.py upload -arch $(archType) -build_type $(buildConfig) -mch_files $(MchFilesLocation)$(OutputSPMICollectionName).pmi.$(MchFileTag).mch -core_root $(Build.SourcesDirectory)/artifacts/bin/coreclr/$(osGroup).x64.$(buildConfigUpper)
      displayName: Upload SuperPMI collection to Azure Storage
      env:
        CLRJIT_AZ_KEY: $(clrjit_key1) # secret key stored as variable in pipeline

    - task: PublishPipelineArtifact@1
      displayName: Publish Logs
      inputs:
        targetPath: $(Build.SourcesDirectory)/artifacts/log
        artifactName: 'SuperPMI_$(OutputSPMICollectionName)_Logs_$(osGroup)$(osSubgroup)_$(archType)_$(buildConfig)_${{ parameters.runtimeType }}_${{ parameters.codeGenType }}'
      continueOnError: true
      condition: always()