parameters:
  buildConfig: ''
  osGroup: ''
  osSubgroup: ''
  archType: ''
  targetRid: ''
  framework: 'net8.0'
  isOfficialBuild: false
  liveRuntimeBuildConfig: ''
  runtimeFlavor: 'coreclr'
  runtimeDisplayName: 'coreclr'
  interpreter: ''
  timeoutInMinutes: 150
  pool: ''
  runtimeVariant: ''
  testScope: ''
  helixQueues: []
  dependOnEvaluatePaths: false
  condition: true
  shouldContinueOnError: false
  variables: {}
  # coreclrTestGroup: if empty, then a normal, default test run is created. If set, it indicates a set of
  # stress modes that each test will be run with. This is the same usage as 'testGroup' in
  # eng/pipelines/common/templates/runtimes/run-test-job.yml.
  coreclrTestGroup: ''
  SuperPmiCollect: false
  dependsOn: []

jobs:
  - template: /eng/pipelines/libraries/base-job.yml
    parameters:
      buildConfig: ${{ parameters.buildConfig }}
      osGroup:  ${{ parameters.osGroup }}
      osSubgroup:  ${{ parameters.osSubgroup }}
      archType:  ${{ parameters.archType }}
      crossBuild: ${{ parameters.crossBuild }}
      framework:  ${{ parameters.framework }}
      isOfficialBuild: ${{ parameters.isOfficialBuild }}
      liveRuntimeBuildConfig: ${{ parameters.liveRuntimeBuildConfig }}
      runtimeFlavor: ${{ parameters.runtimeFlavor }}
      runtimeVariant: ${{ parameters.runtimeVariant }}
      timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
      container: ${{ parameters.container }}
      condition: ${{ parameters.condition }}
      testScope: ${{ parameters.testScope }}
      runTests: true
      ${{ if ne(parameters.liveRuntimeBuildConfig, '') }}:
        displayName: ${{ format('Test Run {0} {1}', parameters.liveRuntimeBuildConfig, parameters.runtimeDisplayName) }}
        name: ${{ format('test_run_{0}_{1}', parameters.liveRuntimeBuildConfig, parameters.runtimeDisplayName) }}
      ${{ if eq(parameters.liveRuntimeBuildConfig, '') }}:
        displayName: 'Test Run'
        name: test_run
      ${{ if eq(parameters.interpreter, 'true') }}:
        testDisplayName: ${{ parameters.runtimeFlavor }}_interpreter_${{ parameters.liveRuntimeBuildConfig }}

      # To run the tests we just send to helix and wait, use ubuntu hosted pools for faster providing and to not back up our build pools
      pool: ${{ parameters.pool }}

      dependOnEvaluatePaths: ${{ parameters.dependOnEvaluatePaths }}
      dependsOn:
      - ${{ if ne(parameters.dependsOn[0], '') }}:
        - ${{ parameters.dependsOn }}
      - ${{ if eq(parameters.dependsOn[0], '') }}:
        - ${{ if notIn(parameters.framework, 'allConfigurations', 'net48') }}:
          - ${{ format('libraries_build_{0}{1}_{2}_{3}', parameters.osGroup, parameters.osSubgroup, parameters.archType, parameters.buildConfig) }}
        - ${{ if ne(parameters.liveRuntimeBuildConfig, '') }}:
          - ${{ format('{0}_{1}_product_build_{2}{3}_{4}_{5}', parameters.runtimeFlavor, parameters.runtimeVariant, parameters.osGroup, parameters.osSubgroup, parameters.archType, parameters.liveRuntimeBuildConfig) }}
      # SuperPMI collection needs to run mcs.exe on the AzDO machine. Assume that's an x64 machine, and download an x64 product build if needed.
      - ${{ if and(eq(parameters.SuperPmiCollect, true), ne(parameters.archType, 'x64')) }}:
          - ${{ format('{0}_{1}_product_build_{2}{3}_{4}_{5}', 'coreclr', '', parameters.osGroup, parameters.osSubgroup, 'x64', parameters.liveRuntimeBuildConfig) }}

      variables:
        # Convenience variables
        - name: buildConfig
          value: ${{ parameters.buildConfig }}
        - name: archType
          value: ${{ parameters.archType }}
        - name: osGroup
          value: ${{ parameters.osGroup }}
        - name: osSubgroup
          value: ${{ parameters.osSubgroup }}
        - name: buildConfigUpper
          ${{ if eq(parameters.buildConfig, 'debug') }}:
            value: 'Debug'
          ${{ if eq(parameters.buildConfig, 'release') }}:
            value: 'Release'
          ${{ if eq(parameters.buildConfig, 'checked') }}:
            value: 'Checked'

        - librariesTestsArtifactName: ${{ format('libraries_test_assets_{0}{1}_{2}_{3}', parameters.osGroup, parameters.osSubgroup, parameters.archType, parameters.buildConfig) }}
        - _archiveTestsParameter: /p:ArchiveTests=true

        # Variables used for SuperPMI collection
        - name: CollectionType
          value: ''
        - name: CollectionName
          value: ''
        - name: _runtimeX64DownloadPath
          value: ''
        # superpmi.py 'merge-mch' needs to be able to find the mcs tool. Point SuperPmiMcsPath at the downloaded CoreCLR binaries. For non-x64 targets, download an x64
        # build and point at that. Pass this to superpmi.py as the '-core_root' argument. It's not actually a "Core_Root" directory, but all it needs is to find mcs.
        - name: SuperPmiMcsPath
          value: $(_runtimeDownloadPath)
        - ${{ if eq(parameters.SuperPmiCollect, true) }}:
          - MchFileTag: '${{ parameters.osGroup }}.${{ parameters.archType }}.${{ parameters.buildConfig }}'
          - name: CollectionType
            value: 'run'
          - name: CollectionName
            value: 'libraries_tests'
          - ${{ if ne(parameters.archType, 'x64') }}:
            - name: _runtimeX64DownloadPath
              value: '$(Build.SourcesDirectory)/artifacts/transport/${{ parameters.runtimeFlavor }}.x64'
            - name: SuperPmiMcsPath
              value: $(_runtimeX64DownloadPath)
          - ${{ if eq(parameters.osGroup, 'windows') }}:
            - name: PythonScript
              value: 'py -3'
            - name: PipScript
              value: 'py -3 -m pip'
            - name: MchFilesLocation
              value: '$(Build.SourcesDirectory)\artifacts\helixresults\'
            - name: MergedMchFileLocation
              value: '$(Build.SourcesDirectory)\artifacts\spmi_collection\'
            - name: SpmiLogsLocation
              value: '$(Build.SourcesDirectory)\artifacts\spmi_logs\'
          - ${{ if ne(parameters.osGroup, 'windows') }}:
            - name: PythonScript
              value: 'python3'
            - name: PipScript
              value: 'pip3'
            - name: MchFilesLocation
              value: '$(Build.SourcesDirectory)/artifacts/helixresults/'
            - name: MergedMchFileLocation
              value: '$(Build.SourcesDirectory)/artifacts/spmi_collection/'
            - name: SpmiLogsLocation
              value: '$(Build.SourcesDirectory)/artifacts/spmi_logs/'

        - ${{ parameters.variables }}

      steps:
        - template: /eng/pipelines/common/download-artifact-step.yml
          parameters:
            displayName: Build Assets
            cleanUnpackFolder: false
            artifactName: $(librariesBuildArtifactName)
            artifactFileName: $(librariesBuildArtifactName)$(archiveExtension)
            unpackFolder: $(Build.SourcesDirectory)/artifacts

        - template: /eng/pipelines/common/download-artifact-step.yml
          parameters:
            displayName: Test Assets
            cleanUnpackFolder: false
            artifactName: $(librariesTestsArtifactName)
            artifactFileName: $(librariesTestsArtifactName)$(archiveExtension)
            unpackFolder: $(Build.SourcesDirectory)/artifacts

        # SuperPMI collection: Download x64 coreclr if running on non-x64 configuration (needed for mcs.exe)
        - ${{ if and(eq(parameters.SuperPmiCollect, true), ne(parameters.archType, 'x64')) }}:
          - template: /eng/pipelines/common/download-artifact-step.yml
            parameters:
              unpackFolder: $(_runtimeX64DownloadPath)
              artifactFileName: 'CoreCLRProduct___$(osGroup)$(osSubgroup)_x64_${{ parameters.liveRuntimeBuildConfig }}$(archiveExtension)'
              artifactName: 'CoreCLRProduct___$(osGroup)$(osSubgroup)_x64_${{ parameters.liveRuntimeBuildConfig }}'
              displayName: 'CoreCLR product build (x64)'

        - ${{ if in(parameters.osGroup, 'osx', 'maccatalyst', 'ios', 'iossimulator', 'tvos', 'tvossimulator') }}:
          - script: $(Build.SourcesDirectory)/eng/install-native-dependencies.sh ${{ parameters.osGroup }}
            displayName: Install Build Dependencies

        - ${{ if ne(parameters.liveRuntimeBuildConfig, '') }}:
          - script: $(_buildScript)
                    -subset host.native+libs.pretest
                    $(_buildArguments)
                    /p:RuntimeFlavor=${{ parameters.runtimeFlavor }}
                    /bl:$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/overrideRuntimeFromLiveDrop.binlog
            displayName: Prepare TestHost with runtime $(runtimeFlavorName)

        - template: /eng/pipelines/libraries/helix.yml
          parameters:
            runtimeFlavor: ${{ parameters.runtimeFlavor }}
            osGroup: ${{ parameters.osGroup }}
            targetRid: ${{ parameters.targetRid }}
            archType: ${{ parameters.archType }}
            buildConfig: ${{ parameters.buildConfig }}
            helixQueues: ${{ parameters.helixQueues }}
            testScope: ${{ parameters.testScope }}
            interpreter: ${{ parameters.interpreter }}
            shouldContinueOnError: ${{ parameters.shouldContinueOnError }}
            creator: dotnet-bot
            testRunNamePrefixSuffix: $(_testRunNamePrefixSuffix)
            SuperPmiCollect: ${{ parameters.SuperPmiCollect }}
            SuperPmiCollectionType: $(CollectionType)
            SuperPmiCollectionName: $(CollectionName)

            # coreclrTestGroup: The following mappings of 'coreclrTestGroup' to 'scenarios' is copied from
            # eng/pipelines/common/templates/runtimes/run-test-job.yml (with 'testGroup' replaced by 'coreclrTestGroup'
            # for clarity), and should remain in sync. This is only a subset; only the testGroups that are
            # used to test the libraries have been added here. More could be added if we decided to test the
            # libraries with more stress modes. The scenario tags are interpreted by
            # src\tests\Common\testenvironment.proj.
            #
            # The one difference here compared to eng/pipelines/common/templates/runtimes/run-test-job.yml is
            # that 'jitstress' contains 'no_tiered_compilation'. The 'normal' (default) test mode
            # is run in a regular CI job, so there is no need to duplicate it here. So, add 'no_tiered_compilation'
            # to the 'jitstress' job instead of adding a new job just for 'no_tiered_compilation'.

            # src/libraries/sendtohelix.proj processes one scenario per parallel MSBuild invocation. Each invocation only
            # creates Helix work items and them waits for their completion on the remote Helix machines, so is not
            # computationally intensive. We want Helix to be provided with all the possible work items in up front,
            # so can do as much work in parallel as possible. Thus, increase the amount of allowed MSBuild parallelism
            # to at least the maximum number of scenarios to be processed in a coreclrTestGroup. If there is no
            # coreclrTestGroup then there is only one scenario (the default scenario), so don't change the MSBuild argument.
            ${{ if ne(parameters.coreclrTestGroup, '') }}:
              extraHelixArguments: $(_extraHelixArguments) /maxcpucount:10
            ${{ else }}:
              extraHelixArguments: $(_extraHelixArguments)

            ${{ if in(parameters.coreclrTestGroup, 'superpmi_collection') }}:
              scenarios:
              - normal
              - no_tiered_compilation
            ${{ if in(parameters.coreclrTestGroup, 'jitstress') }}:
              scenarios:
              - no_tiered_compilation
              - jitminopts
              - jitstress1
              - jitstress1_tiered
              - jitstress2
              - jitstress2_tiered
              - zapdisable
              - tailcallstress
            ${{ if in(parameters.coreclrTestGroup, 'jitstress-random') }}:
              scenarios:
              - jitstress_random_1
              - jitstress_random_2
            ${{ if in(parameters.coreclrTestGroup, 'jitstressregs' ) }}:
              scenarios:
              - jitstressregs1
              - jitstressregs2
              - jitstressregs3
              - jitstressregs4
              - jitstressregs8
              - jitstressregs0x10
              - jitstressregs0x80
              - jitstressregs0x1000
              - jitstressregs0x2000
            ${{ if in(parameters.coreclrTestGroup, 'jitstress2-jitstressregs') }}:
              scenarios:
              - jitstress2_jitstressregs1
              - jitstress2_jitstressregs2
              - jitstress2_jitstressregs3
              - jitstress2_jitstressregs4
              - jitstress2_jitstressregs8
              - jitstress2_jitstressregs0x10
              - jitstress2_jitstressregs0x80
              - jitstress2_jitstressregs0x1000
              - jitstress2_jitstressregs0x2000
            ${{ if in(parameters.coreclrTestGroup, 'gcstress0x3-gcstress0xc') }}:
              scenarios:
              # Disable gcstress0x3 for now; it causes lots of test timeouts. Investigate this after
              # gcstress0xc runs are clean. Tracking issue: https://github.com/dotnet/runtime/issues/38903.
              # - gcstress0x3
              - gcstress0xc
            ${{ if in(parameters.coreclrTestGroup, 'gcstress-extra') }}:
              scenarios:
              - heapverify1
              - gcstress0xc_zapdisable
              - gcstress0xc_zapdisable_jitstress2
              - gcstress0xc_zapdisable_heapverify1
              - gcstress0xc_jitstress1
              - gcstress0xc_jitstress2
              - gcstress0xc_jitminopts_heapverify1
            ${{ if in(parameters.coreclrTestGroup, 'pgo') }}:
              ${{ if and(eq(parameters.osGroup, 'windows'), eq(parameters.archType, 'arm64')) }}:
                scenarios:
                - defaultpgo
              ${{ else }}:
                scenarios:
                - defaultpgo
                - fullpgo
                - fullpgo_methodprofiling
                - fullpgo_random_gdv
                - fullpgo_random_gdv_methodprofiling_only
                - fullpgo_random_gdv_edge
                - jitosr_stress
                - jitosr_stress_random
                - syntheticpgo
                - syntheticpgo_blend

        ########################################################################################################
        #
        # Finalize SuperPMI collection: (1) merge all MCH files generated by all Helix jobs, (2) upload MCH file to Azure Storage, (3) upload log files
        # Note that all these steps are "condition: always()" because we want to upload as much of the collection
        # as possible, even if there were test failures.
        #
        ########################################################################################################

        - ${{ if eq(parameters.SuperPmiCollect, true) }}:

          # Create required directories for merged mch collection and superpmi logs
          - ${{ if ne(parameters.osGroup, 'windows') }}:
            - script: |
                mkdir -p $(MergedMchFileLocation)
                mkdir -p $(SpmiLogsLocation)
              displayName: 'Create SuperPMI directories $(MergedMchFileLocation), $(SpmiLogsLocation)'
              condition: always()
          - ${{ if eq(parameters.osGroup, 'windows') }}:
            - script: |
                mkdir $(MergedMchFileLocation)
                mkdir $(SpmiLogsLocation)
              displayName: 'Create SuperPMI directories $(MergedMchFileLocation), $(SpmiLogsLocation)'
              condition: always()

          - script: $(PythonScript) $(Build.SourcesDirectory)/src/coreclr/scripts/superpmi.py merge-mch -log_level DEBUG -pattern $(MchFilesLocation)$(CollectionName).$(CollectionType)*.mch -output_mch_path $(MergedMchFileLocation)$(CollectionName).$(CollectionType).$(MchFileTag).mch -core_root $(SuperPmiMcsPath)
            displayName: 'Merge $(CollectionName)-$(CollectionType) SuperPMI collections'
            condition: always()

          - template: /eng/pipelines/common/upload-artifact-step.yml
            parameters:
              rootFolder: $(MergedMchFileLocation)
              includeRootFolder: false
              archiveType: $(archiveType)
              tarCompression: $(tarCompression)
              archiveExtension: $(archiveExtension)
              artifactName: 'SuperPMI_Collection_$(CollectionName)_$(CollectionType)_$(osGroup)$(osSubgroup)_$(archType)_$(buildConfig)'
              displayName: 'Upload artifacts SuperPMI $(CollectionName)-$(CollectionType) collection'
              condition: always()

          # Add authenticated pip feed
          - task: PipAuthenticate@1
            displayName: 'Pip Authenticate'
            inputs:
              artifactFeeds: public/dotnet-public-pypi
              onlyAddExtraIndex: false
            condition: always()

          # Ensure the Python azure-storage-blob package is installed before doing the upload.
          - script: $(PipScript) install --user --upgrade pip && $(PipScript) install --user azure.storage.blob==12.5.0 --force-reinstall
            displayName: Upgrade Pip to latest and install azure-storage-blob Python package
            condition: always()

          - script: $(PythonScript) $(Build.SourcesDirectory)/src/coreclr/scripts/superpmi.py upload -log_level DEBUG -arch $(archType) -build_type $(buildConfig) -mch_files $(MergedMchFileLocation)$(CollectionName).$(CollectionType).$(MchFileTag).mch -core_root $(Build.SourcesDirectory)/artifacts/bin/coreclr/$(osGroup).x64.$(buildConfigUpper)
            displayName: 'Upload SuperPMI $(CollectionName)-$(CollectionType) collection to Azure Storage'
            condition: always()
            env:
              CLRJIT_AZ_KEY: $(clrjit_key1) # secret key stored as variable in pipeline

          - task: CopyFiles@2
            displayName: Copying superpmi.log of all partitions
            inputs:
              sourceFolder: '$(MchFilesLocation)'
              contents: '**/$(CollectionName).$(CollectionType)*.log'
              targetFolder: '$(SpmiLogsLocation)'
            condition: always()

          - task: PublishPipelineArtifact@1
            displayName: Publish SuperPMI logs
            inputs:
              targetPath: $(SpmiLogsLocation)
              artifactName: 'SuperPMI_Logs_$(CollectionName)_$(CollectionType)_$(osGroup)$(osSubgroup)_$(archType)_$(buildConfig)'
            condition: always()

        ########################################################################################################
        #
        # End of SuperPMI processing
        #
        ########################################################################################################
