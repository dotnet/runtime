<Project TreatAsLocalProperty="ArchiveTests">
  <PropertyGroup>
    <_UseWasmSymbolicator Condition="'$(TestTrimming)' != 'true'">true</_UseWasmSymbolicator>
  </PropertyGroup>

  <Import Project="tests.wasm.targets" />
  <!-- We need to set this in order to get extensibility on xunit category traits and other arguments we pass down to xunit via MSBuild properties -->
  <PropertyGroup>
    <IsBrowserWasmProject Condition="'$(IsBrowserWasmProject)' == ''">true</IsBrowserWasmProject>
    <WasmEnableHotReload>false</WasmEnableHotReload>
    <CompressionEnabled>false</CompressionEnabled>
    <DisableBuildCompression>true</DisableBuildCompression>
    <PublishTrimmed>false</PublishTrimmed>
    <PublishTrimmed Condition="'$(RunAOTCompilation)' == 'true' or '$(TestTrimming)' == 'true'">true</PublishTrimmed>
    <_WasmInTreeDefaults>false</_WasmInTreeDefaults>

    <ResolveWasmOutputsDependsOn>
      $(ResolveWasmOutputsDependsOn);
      WasmTriggerPublishApp;
      ReadWasmNativeAssetsFromFileSystem;
      UpdateWasmNativeAssetOriginalItemSpec
    </ResolveWasmOutputsDependsOn>
    <ResolveWasmOutputsDependsOn Condition="'$(RuntimeFlavor)' == 'CoreCLR'">
      $(ResolveWasmOutputsDependsOn);
      AddTestRunnersToReferenceCopyLocalPaths
    </ResolveWasmOutputsDependsOn>

    <!-- set this when provisioning emsdk on CI -->
    <EMSDK_PATH Condition="'$(EMSDK_PATH)' == '' and '$(ContinuousIntegrationBuild)' == 'true' and '$(MonoProjectRoot)' != ''">$([MSBuild]::NormalizeDirectory($(BrowserProjectRoot), 'emsdk'))</EMSDK_PATH>

    <WasmEmitSymbolMap Condition="'$(WasmEmitSymbolMap)' == ''">true</WasmEmitSymbolMap>

    <_WasmMainJSFileName Condition="'$(WasmMainJSPath)' != ''">$([System.IO.Path]::GetFileName('$(WasmMainJSPath)'))</_WasmMainJSFileName>
    <_WasmStrictVersionMatch Condition="'$(ContinuousIntegrationBuild)' == 'true'">true</_WasmStrictVersionMatch>
    <WasmIgnoreNet6WorkloadInstallErrors Condition="'$(WasmIgnoreNet6WorkloadInstallErrors)' == ''">true</WasmIgnoreNet6WorkloadInstallErrors>
    <WasmIgnoreNet6WorkloadInstallErrors Condition="'$(WasmIgnoreNet6WorkloadInstallErrors)' != 'true'">false</WasmIgnoreNet6WorkloadInstallErrors>
    <!--<InstallWorkloadUsingArtifactsDependsOn>_GetWorkloadsToInstall;$(InstallWorkloadUsingArtifactsDependsOn)</InstallWorkloadUsingArtifactsDependsOn>-->
    <!-- '/.dockerenv' - is to check if this is running in a codespace -->
    <InstallChromeForTests Condition="'$(InstallChromeForTests)' == '' and
                                        ('$(ContinuousIntegrationBuild)' != 'true' or Exists('/.dockerenv')) and
                                        '$(Scenario)' == 'WasmTestOnChrome'">true</InstallChromeForTests>
    <InstallFirefoxForTests Condition="'$(InstallFirefoxForTests)' == '' and
                                        ('$(ContinuousIntegrationBuild)' != 'true' or Exists('/.dockerenv')) and
                                        '$(Scenario)' == 'WasmTestOnFirefox'">true</InstallFirefoxForTests>
    <InstallV8ForTests Condition="'$(InstallV8ForTests)' == '' and
                                        ('$(ContinuousIntegrationBuild)' == 'true' or Exists('/.dockerenv')) and
                                        ($([MSBuild]::IsOSPlatform('windows')) or $([MSBuild]::IsOSPlatform('linux')))"
                                    >true</InstallV8ForTests>

    <_BundleAOTTestWasmAppForHelixDependsOn>$(_BundleAOTTestWasmAppForHelixDependsOn);PrepareForWasmBuildApp;_PrepareForAOTOnHelix</_BundleAOTTestWasmAppForHelixDependsOn>
    <UseSystemResourceKeys Condition="'$(UseSystemResourceKeys)' == ''">false</UseSystemResourceKeys>
    <EventSourceSupport Condition="'$(EventSourceSupport)' == ''">true</EventSourceSupport>
    <NullabilityInfoContextSupport Condition="'$(NullabilityInfoContextSupport)' == ''">true</NullabilityInfoContextSupport>
  </PropertyGroup>

  <ItemGroup>
    <Content Include="$(MonoProjectRoot)browser\test-main.js" Link="wwwroot\test-main.js" CopyToOutputDirectory="PreserveNewest" Condition="'$(IsFunctionalTest)' != 'true'" />
    <Content Include="$(MonoProjectRoot)browser\test-index.html" Link="wwwroot\index.html" CopyToOutputDirectory="PreserveNewest" Condition="'$(IsFunctionalTest)' != 'true'" />
  </ItemGroup>

  <!-- We expect WASM users to indicate they would like to have bigger download size by adding WasmIncludeFullIcuData, -->
  <!-- by default we make their icu small by sharding. -->
  <!-- Trimming test InvariantGlobalizationFalse requires full ICU data. -->
  <!-- ToDo: edit after https://github.com/dotnet/runtime/issues/82819 is merged -->
  <PropertyGroup Condition="'$(TestTrimming)' == 'true'">
    <WasmIncludeFullIcuData>true</WasmIncludeFullIcuData>
  </PropertyGroup>

  <PropertyGroup>
    <InvariantGlobalization Condition="'$(InvariantGlobalization)' == ''">false</InvariantGlobalization>
    <BlazorWebAssemblyLoadAllGlobalizationData Condition="'$(InvariantGlobalization)' == 'false' and '$(WasmIncludeFullIcuData)' == 'true'">true</BlazorWebAssemblyLoadAllGlobalizationData>
  </PropertyGroup>

  <!-- On CI this is installed as part of pretest, but it should still be installed
       for WBT, and debugger tests -->
  <Import Project="$(MSBuildThisFileDirectory)wasm-provisioning.targets"
          Condition="'$(ContinuousIntegrationBuild)' != 'true' or '$(IsBrowserWasmProject)' != 'true'" />

  <PropertyGroup>
    <_WasmChromePathForTests Condition="'$(CHROME_PATH_FOR_TESTS)' != ''">$(CHROME_PATH_FOR_TESTS)</_WasmChromePathForTests>
    <_WasmChromePathForTests Condition="'$(_WasmChromePathForTests)' == '' and '$(InstallChromeForTests)' == 'true'">$(ChromeBinaryPath)</_WasmChromePathForTests>

    <_WasmFirefoxPathForTests Condition="'$(FIREFOX_PATH_FOR_TESTS)' != ''">$(FIREFOX_PATH_FOR_TESTS)</_WasmFirefoxPathForTests>
    <_WasmFirefoxPathForTests Condition="'$(_WasmFirefoxPathForTests)' == '' and '$(InstallFirefoxForTests)' == 'true'">$(FirefoxBinaryPath)</_WasmFirefoxPathForTests>

    <_WasmJSEnginePathForTests Condition="'$(V8_PATH_FOR_TESTS)' != ''">$(V8_PATH_FOR_TESTS)</_WasmJSEnginePathForTests>
    <_WasmJSEnginePathForTests Condition="'$(_WasmJSEnginePathForTests)' == '' and '$(InstallV8ForTests)' == 'true'">$(V8BinaryPath)</_WasmJSEnginePathForTests>
  </PropertyGroup>

  <!--
    This is running during compile time and therefore $(Scenario) is empty, unless the specific project sets it.
    Any settings in the project file could be replaced on Helix.
    See also eng\testing\WasmRunnerTemplate.sh
    -->
  <ItemGroup>
    <SetScriptCommands Condition="'$(Scenario)' != '' and '$(ContinuousIntegrationBuild)' != 'true'" Include="$(EnvVarCommand) &quot;SCENARIO=$(Scenario)&quot;" />
    <SetScriptCommands Condition="'$(JSEngine)' != ''" Include="$(EnvVarCommand) &quot;JS_ENGINE=--engine^=$(JSEngine)&quot;" />
    <SetScriptCommands Condition="'$(JSEngineArgs)' != ''" Include="$(EnvVarCommand) &quot;JS_ENGINE_ARGS=$(JSEngineArgs)&quot;" />
    <SetScriptCommands Condition="'$(_WasmMainJSFileName)' != ''" Include="$(EnvVarCommand) &quot;MAIN_JS=--js-file^=$(_WasmMainJSFileName)&quot;" />
    <!-- Workaround for https://github.com/dotnet/runtime/issues/74328 -->
    <SetScriptCommands Condition="'$(BuildAOTTestsOnHelix)' == 'true'" Include="$(EnvVarCommand) DOTNET_CLI_DO_NOT_USE_MSBUILD_SERVER=1" />
  </ItemGroup>
  <ItemGroup Condition="'$(OS)' != 'Windows_NT'">
    <SetScriptCommands Condition="'$(_WasmJSEnginePathForTests)' != ''" Include="$(EnvVarCommand) V8_PATH_FOR_TESTS=${V8_PATH_FOR_TESTS:=$(_WasmJSEnginePathForTests)}" />
  </ItemGroup>

  <PropertyGroup>
    <_AppArgs Condition="'$(IsFunctionalTest)' != 'true' and '$(Scenario)' != 'BuildWasmApps' and '$(WasmMainAssemblyFileName)' == ''">--run WasmTestRunner.dll $(AssemblyName).dll</_AppArgs>
    <_AppArgs Condition="'$(IsFunctionalTest)' != 'true' and '$(WasmMainAssemblyFileName)' != ''">--run $(WasmMainAssemblyFileName)</_AppArgs>
    <_AppArgs Condition="'$(IsFunctionalTest)' == 'true'">--run $(AssemblyName).dll</_AppArgs>

    <_AppArgs Condition="'$(WasmTestAppArgs)' != ''">$(_AppArgs) $(WasmTestAppArgs)</_AppArgs>

    <WasmXHarnessMonoArgs Condition="'$(XunitShowProgress)' == 'true'">$(WasmXHarnessMonoArgs) --setenv=XHARNESS_LOG_TEST_START=true</WasmXHarnessMonoArgs>
    <!-- help unit test with PlatformDetection.IsThreadingSupported via IsBrowserThreadingSupported env variable -->
    <WasmXHarnessMonoArgs Condition="'$(WasmEnableThreads)' == 'true'">$(WasmXHarnessMonoArgs) --setenv=IsBrowserThreadingSupported=true</WasmXHarnessMonoArgs>
    <WasmXHarnessMaxParallelThreads Condition="'$(WasmEnableThreads)' == 'true' and '$(WasmXHarnessMaxParallelThreads)' == ''">8</WasmXHarnessMaxParallelThreads>
  </PropertyGroup>

  <PropertyGroup Condition="'$(RunScriptCommand)' == ''">
    <_XHarnessArgs Condition="'$(OS)' != 'Windows_NT'">wasm $XHARNESS_COMMAND --app=. --output-directory=$XHARNESS_OUT</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(OS)' == 'Windows_NT'">wasm %XHARNESS_COMMAND% --app=. --output-directory=%XHARNESS_OUT%</_XHarnessArgs>

    <_XHarnessArgs Condition="'$(IsFunctionalTest)' == 'true'"     >$(_XHarnessArgs) --expected-exit-code=$(ExpectedExitCode)</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(WasmXHarnessArgs)' != ''"         >$(_XHarnessArgs) $(WasmXHarnessArgs)</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(WasmEnableThreads)' == 'true' and '$(_XHarnessArgs.Contains(&quot;--web-server-use-cop&quot;)' != 'true'">$(_XHarnessArgs) --web-server-use-cop</_XHarnessArgs>
    <_XHarnessArgs                                                 >$(_XHarnessArgs) -s dotnet.native.js.symbols</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(_UseWasmSymbolicator)' == 'true'" >$(_XHarnessArgs) --symbol-patterns wasm-symbol-patterns.txt</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(_UseWasmSymbolicator)' == 'true'" >$(_XHarnessArgs) --symbolicator WasmSymbolicator.dll,Microsoft.WebAssembly.Internal.SymbolicatorWrapperForXHarness</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(_WasmChromePathForTests)' != ''" >$(_XHarnessArgs) &quot;--browser-path=$(_WasmChromePathForTests)&quot;</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(_WasmFirefoxPathForTests)' != ''" >$(_XHarnessArgs) &quot;--browser-path=$(_WasmFirefoxPathForTests)&quot;</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(WasmXHarnessTestsTimeout)' != ''" >$(_XHarnessArgs) &quot;--timeout=$(WasmXHarnessTestsTimeout)&quot;</_XHarnessArgs>
    <_XHarnessArgs Condition="'$(WasmXHarnessVerbosity)' != ''"    >$(_XHarnessArgs) --verbosity=$(WasmXHarnessVerbosity)</_XHarnessArgs><!-- Trace, Debug, Information (default), Warning, Error, Critical -->
    <_XHarnessArgs Condition="'$(WasmXHarnessArgsCli)' != ''"      >$(_XHarnessArgs) $(WasmXHarnessArgsCli)</_XHarnessArgs>

    <_AppArgs Condition="'$(WasmEnableThreads)' == 'true'">$(_AppArgs) -threads</_AppArgs>
    <_AppArgs Condition="'$(WasmXHarnessMaxParallelThreads)' != ''">$(_AppArgs) -parallelThreads $(WasmXHarnessMaxParallelThreads)</_AppArgs>
    <!-- There are two flavors of WasmXHarnessArgs and WasmXHarnessMonoArgs, one is MSBuild property and the other is environment variable -->
    <RunScriptCommand Condition="'$(OS)' != 'Windows_NT'">$HARNESS_RUNNER $(_XHarnessArgs) %24XHARNESS_ARGS %24WasmXHarnessArgs -- $(WasmXHarnessMonoArgs) %24WasmXHarnessMonoArgs $(_AppArgs) %24WasmTestAppArgs</RunScriptCommand>
    <RunScriptCommand Condition="'$(OS)' == 'Windows_NT'">%HARNESS_RUNNER% $(_XHarnessArgs) %XHARNESS_ARGS% %WasmXHarnessArgs%  -- $(WasmXHarnessMonoArgs) %WasmXHarnessMonoArgs% $(_AppArgs) %WasmTestAppArgs%</RunScriptCommand>
  </PropertyGroup>

  <PropertyGroup Condition="'$(BuildAOTTestsOnHelix)' == 'true'">
    <_AOTBuildCommand Condition="'$(BrowserHost)' != 'windows'">_buildAOTFunc publish/ProxyProjectForAOTOnHelix.proj $XHARNESS_OUT/AOTBuild.binlog</_AOTBuildCommand>
    <_AOTBuildCommand Condition="'$(BrowserHost)' == 'windows'">dotnet msbuild publish/ProxyProjectForAOTOnHelix.proj /bl:%XHARNESS_OUT%/AOTBuild.binlog</_AOTBuildCommand>

    <!-- running aot-helix tests locally, so we can test with the same project file as CI -->
    <_AOTBuildCommand Condition="'$(ContinuousIntegrationBuild)' != 'true'">$(_AOTBuildCommand) /p:RuntimeSrcDir=$(RepoRoot) /p:RuntimeConfig=$(Configuration) /p:TasksConfiguration=$(TasksConfiguration)</_AOTBuildCommand>

    <_AOTBuildCommand>$(_AOTBuildCommand) /p:RunAOTCompilation=$(RunAOTCompilation)</_AOTBuildCommand>
    <_AOTBuildCommand>$(_AOTBuildCommand) $(_ShellCommandSeparator) cd wasm_build/AppBundle</_AOTBuildCommand>

    <RunScriptCommand Condition="'$(RunScriptCommand)' == ''">$(_AOTBuildCommand)</RunScriptCommand>
    <RunScriptCommand Condition="'$(RunScriptCommand)' != ''">$(_AOTBuildCommand) $(_ShellCommandSeparator) $(RunScriptCommand)</RunScriptCommand>
  </PropertyGroup>

  <Import Project="$(BrowserProjectRoot)build\WasmApp.InTree.props"
          Condition="'$(BuildAOTTestsOn)' == 'local' and '$(IsWasmProject)' != 'false'" />
  <Import Project="$(BrowserProjectRoot)build\WasmApp.InTree.targets"
          Condition="'$(BuildAOTTestsOn)' == 'local' and '$(IsWasmProject)' != 'false'" />

  <PropertyGroup Condition="'$(BuildAOTTestsOnHelix)' == 'true'">
    <!-- wasm targets are not imported at all, in this case, because we run the wasm build on helix -->
  </PropertyGroup>

  <PropertyGroup Condition="'$(IsWasmProject)' == 'true' and '$(BuildAOTTestsOnHelix)' != 'true'">
    <WasmBuildOnlyAfterPublish>true</WasmBuildOnlyAfterPublish>

    <!-- wasm's publish targets will trigger publish, so we shouldn't do that -->
    <PublishTestAsSelfContainedDependsOn />
    <WasmNestedPublishAppDependsOn>PrepareForWasmBuildApp;$(WasmNestedPublishAppDependsOn)</WasmNestedPublishAppDependsOn>
  </PropertyGroup>

  <Target Name="UpdateWasmNativeAssetOriginalItemSpec">
    <ItemGroup>
      <!-- WasmNativeAsset OriginalItemSpec points to the .csproj it was built for, whereas we expect it to point to the file itself later in WasmSDK -->
      <WasmNativeAsset Update="@(WasmNativeAsset)">
        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
      </WasmNativeAsset>
    </ItemGroup>
  </Target>

  <Target Name="AddTestRunnersToReferenceCopyLocalPaths"
          AfterTargets=""
          Condition="'$(TestFramework)' == 'xunit'">
    <ItemGroup>
      <_runnerFilesToBuild Include="$(WasmTestRunnerDir)*" />

      <!-- Remove runner files that already exist in ReferenceCopyLocalPaths to avoid double Building -->
      <_resolvedFilesToBuildToFileName Include="@(ReferenceCopyLocalPaths -> '%(FileName)%(Extension)')" />

      <_runnerFilesToBuildToFileName Include="@(_runnerFilesToBuild -> '%(FileName)%(Extension)')">
        <OriginalIdentity>%(Identity)</OriginalIdentity>
      </_runnerFilesToBuildToFileName>
      <_runnerFilesToBuildToFileName Remove="@(_resolvedFilesToBuildToFileName)" />

      <ReferenceCopyLocalPaths Include="@(_runnerFilesToBuildToFileName -> '%(OriginalIdentity)')" RelativePath="%(FileName)%(Extension)" CopyToOutputDirectory="PreserveNewest" CopyToPublishDirectory="PreserveNewest" PostprocessAssembly="true" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="Microsoft.WebAssembly.Build.Tasks.LinkContentToWwwroot" AssemblyFile="$(WasmBuildTasksAssemblyPath)" Condition="'$(TestTrimming)' != 'true'" />

  <Target Name="LinkContentToWwwroot" BeforeTargets="ResolveProjectStaticWebAssets" Condition="'$(TargetOS)' == 'browser' and '$(WasmBuildingForNestedPublish)' != 'true' and '$(TestTrimming)' != 'true'">
    <!-- StaticWebAssetsSDK expects all "files accessible from web" to be in wwwroot folder -->
    <!-- Here we are adding Link/TargetPath for all Content items and adding them to WasmFilesToIncludeInFileSystem -->
    <LinkContentToWwwroot Content="@(Content)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
      <Output TaskParameter="WasmFilesToIncludeInFileSystem" ItemName="WasmFilesToIncludeInFileSystem" />
      <Output TaskParameter="ContentOut" ItemName="_LinkedContent" />
    </LinkContentToWwwroot>
    <ItemGroup>
      <Content Remove="@(_LinkedContent)" />
      <Content Include="@(_LinkedContent)" />
    </ItemGroup>
  </Target>

  <Target Name="LinkPublishContentToWwwroot" BeforeTargets="ComputeWasmVfs" DependsOnTargets="GetCopyToOutputDirectoryItems" Condition="'$(TargetOS)' == 'browser' and '$(WasmBuildingForNestedPublish)' != 'true' and '$(TestTrimming)' != 'true'">
    <!-- StaticWebAssetsSDK doesn't have support for adding generated files during publish as "files accessible from web" -->
    <!-- Here we are adding Link/TargetPath for various files generated during publish, adding them to WasmFilesToIncludeInFileSystem and defining them as StaticWebAsset with StaticWebAssetEndpoint -->
    <ItemGroup>
      <_WasmFilesForVfs Include="$(PublishDir)%(WasmFilesToIncludeFromPublishDir.Identity)"
        TargetPath="%(WasmFilesToIncludeFromPublishDir.TargetDir)/%(WasmFilesToIncludeFromPublishDir.Identity)"
        CopyToOutputDirectory="PreserveNewest"
        Condition="'%(WasmFilesToIncludeFromPublishDir.Identity)' != '' and '%(WasmFilesToIncludeFromPublishDir.TargetDir)' != ''" />
      <_WasmFilesForVfs Include="$(PublishDir)%(WasmFilesToIncludeFromPublishDir.Identity)"
        TargetPath="%(WasmFilesToIncludeFromPublishDir.Identity)"
        CopyToOutputDirectory="PreserveNewest"
        Condition="'%(WasmFilesToIncludeFromPublishDir.Identity)' != '' and '%(WasmFilesToIncludeFromPublishDir.TargetDir)' == ''" />

      <_WasmFilesForVfs Include="@(AllItemsFullPathWithTargetPath)" Condition="$([System.String]::new('%(AllItemsFullPathWithTargetPath.Identity)').EndsWith('.dmeta'))" />
      <_WasmFilesForVfs Include="@(AllItemsFullPathWithTargetPath)" Condition="$([System.String]::new('%(AllItemsFullPathWithTargetPath.Identity)').EndsWith('.dil'))" />
      <_WasmFilesForVfs Include="@(AllItemsFullPathWithTargetPath)" Condition="$([System.String]::new('%(AllItemsFullPathWithTargetPath.Identity)').EndsWith('.dpdb'))" />
      <_WasmFilesForVfs Include="@(_WasmBuildAssetCandidates)" Condition="'%(_WasmBuildAssetCandidates.BuildReference)' == 'true' and $([System.String]::new('%(_WasmBuildAssetCandidates.Identity)').EndsWith('.dll')) and !$([System.String]::new('%(_WasmBuildAssetCandidates.Identity)').EndsWith('.resources.dll'))" />
    </ItemGroup>

    <ItemGroup Condition="'$(IncludeSatelliteAssembliesInVFS)' == 'true' and '$(BuildAOTTestsOnHelix)' != 'true'">
      <_SatelliteAssemblies Include="$(PublishDir)*\*.resources.dll" />
      <_SatelliteAssemblies CultureName="$([System.IO.Directory]::GetParent('%(Identity)').Name)" />
      <_SatelliteAssemblies TargetPath="%(CultureName)\%(FileName)%(Extension)" />

      <_WasmFilesForVfs Include="@(_SatelliteAssemblies)" />
    </ItemGroup>
    <ItemGroup>
      <_WasmFilesForVfs CopyToOutputDirectory="PreserveNewest" />
    </ItemGroup>

    <LinkContentToWwwroot Content="@(_WasmFilesForVfs->Distinct())" MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
      <Output TaskParameter="WasmFilesToIncludeInFileSystem" ItemName="WasmFilesToIncludeInFileSystem" />
      <Output TaskParameter="ContentOut" ItemName="_WasmFilesForVfsLinked" />
    </LinkContentToWwwroot>

    <DefineStaticWebAssets
      CandidateAssets="@(_WasmFilesForVfsLinked->Distinct())"
      FingerprintCandidates="$(StaticWebAssetsFingerprintContent)"
      FingerprintPatterns="@(StaticWebAssetFingerprintPattern)"
      RelativePathPattern="wwwroot/**"
      SourceType="Discovered"
      SourceId="$(PackageId)"
      ContentRoot="$(MSBuildProjectDirectory)\wwwroot\"
      BasePath="$(StaticWebAssetBasePath)"
      AssetMergeSource="$(StaticWebAssetMergeTarget)"
      CacheManifestPath="$(_ResolveProjectStaticWebAssetsCachePath)">
        <Output TaskParameter="Assets" ItemName="StaticWebAsset" />
        <Output TaskParameter="Assets" ItemName="_CurrentProjectStaticWebAsset" />
    </DefineStaticWebAssets>

    <DefineStaticWebAssetEndpoints
      CandidateAssets="@(_CurrentProjectStaticWebAsset)"
      ContentTypeMappings="@(StaticWebAssetContentTypeMapping)"
    >
      <Output TaskParameter="Endpoints" ItemName="StaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
  </Target>

  <!-- In RuntimeTests we don't have RuntimePack, instead search for files on disk -->
  <Target Name="ReadWasmNativeAssetsFromFileSystem" DependsOnTargets="_InitializeCommonProperties" Condition="'$(WasmBuildingForNestedPublish)' == 'true' and '@(ResolvedRuntimePack->Count())' == '0'">
    <PropertyGroup>
      <_HasDotnetWasm Condition="'%(WasmNativeAsset.FileName)%(WasmNativeAsset.Extension)' == 'dotnet.native.wasm'">true</_HasDotnetWasm>
      <_HasDotnetJsWorker Condition="'%(WasmNativeAsset.FileName)%(WasmNativeAsset.Extension)' == 'dotnet.native.worker.mjs'">true</_HasDotnetJsWorker>
      <_HasDotnetJsSymbols Condition="'%(WasmNativeAsset.FileName)%(WasmNativeAsset.Extension)' == 'dotnet.native.js.symbols'">true</_HasDotnetJsSymbols>
      <_HasDotnetNativeJs Condition="'%(WasmNativeAsset.FileName)%(WasmNativeAsset.Extension)' == 'dotnet.native.js'">true</_HasDotnetNativeJs>
      <_WasmIcuDataFileName Condition="'$(WasmIcuDataFileName)' != '' and Exists('$(WasmIcuDataFileName)')">$(WasmIcuDataFileName)</_WasmIcuDataFileName>
      <_WasmIcuDataFileName Condition="'$(WasmIcuDataFileName)' != '' and !Exists('$(WasmIcuDataFileName)')">$(MicrosoftNetCoreAppRuntimePackRidNativeDir)$(WasmIcuDataFileName)</_WasmIcuDataFileName>
    </PropertyGroup>

    <ItemGroup>
      <!-- If dotnet.{wasm,js} weren't added already (eg. AOT can add them), then add the default ones -->
      <!-- A similar logic is in ComputeWasmBuildAssets and ComputeWasmPublishAssets -->
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.js" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.runtime.js" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.diagnostics.js" Condition="'$(EnableDiagnostics)' == 'true'" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.native.wasm" Condition="'$(_HasDotnetWasm)' != 'true'" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.native.js" Condition="'$(_HasDotnetNativeJs)' != 'true'" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.native.worker.mjs" Condition="'$(_HasDotnetJsWorker)' != 'true' and Exists('$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.native.worker.mjs')" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.native.js.symbols"
                       Condition="'$(WasmEmitSymbolMap)' == 'true' and
                                  '$(_HasDotnetJsSymbols)' != 'true' and
                                  Exists('$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.native.js.symbols')" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.js.map"
                       Condition="'$(WasmEmitSourceMap)' != 'false'" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.runtime.js.map"
                       Condition="'$(WasmEmitSourceMap)' != 'false'" />
      <WasmNativeAsset Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)dotnet.diagnostics.js.map"
                       Condition="'$(WasmEmitSourceMap)' != 'false' and '$(EnableDiagnostics)' == 'true'" />
    </ItemGroup>

    <ItemGroup Condition="'$(InvariantGlobalization)' != 'true'">
      <_IcuAvailableDataFiles Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)icudt_*" Exclude="$(_WasmIcuDataFileName)"/>
      <WasmIcuDataFileNames Condition="'$(WasmIncludeFullIcuData)' == 'true'" Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)icudt.dat"/>
      <WasmIcuDataFileNames Condition="'$(WasmIncludeFullIcuData)' != 'true' and '$(_WasmIcuDataFileName)' == ''" Include="@(_IcuAvailableDataFiles)"/>
      <WasmIcuDataFileNames Condition="'$(WasmIncludeFullIcuData)' != 'true' and '$(_WasmIcuDataFileName)' != ''" Include="$(_WasmIcuDataFileName)"/>
      <WasmNativeAsset Include="@(WasmIcuDataFileNames)"/>
    </ItemGroup>
  </Target>

  <Target Name="PrepareForWasmBuildApp">
    <PropertyGroup>
      <WasmAppDir>$(BundleDir)</WasmAppDir>
      <WasmMainAssemblyFileName Condition="'$(WasmMainAssemblyFileName)' == ''">WasmTestRunner.dll</WasmMainAssemblyFileName>
      <WasmMainJSPath Condition="'$(WasmMainJSPath)' == ''">$(MonoProjectRoot)\browser\test-main.js</WasmMainJSPath>
      <WasmMainJSFileName>$([System.IO.Path]::GetFileName('$(WasmMainJSPath)'))</WasmMainJSFileName>
      <WasmGenerateRunV8Script>true</WasmGenerateRunV8Script>
    </PropertyGroup>

    <ItemGroup>
      <WasmAssembliesToBundle Include="$(PublishDir)\**\*.dll" Condition="'$(BuildAOTTestsOnHelix)' == 'true'" />
      <WasmAssembliesToBundle Condition="'%(WasmAssembliesToBundle.FileName)' == 'WasmSymbolicator'" AOT_InternalForceToInterpret="true" />
    </ItemGroup>

    <ForceMSBuildGC />
  </Target>

  <Target Name="_PrepareForAOTOnHelix">
    <PropertyGroup Condition="'$(IsHighAotMemoryUsageTest)' == 'true' and '$(ContinuousIntegrationBuild)' == 'true'">
      <DisableParallelEmccCompile Condition="'$(DisableParallelEmccCompile)' == ''">true</DisableParallelEmccCompile>
      <EmccLinkOptimizationFlag Condition="'$(EmccLinkOptimizationFlag)' == ''">-O2</EmccLinkOptimizationFlag>
    </PropertyGroup>

    <PropertyGroup>
      <EmccLinkOptimizationFlag Condition="'$(EmccLinkOptimizationFlag)' == ''">-O2 -Wl,-O0 -Wl,--lto-O0</EmccLinkOptimizationFlag>
    </PropertyGroup>

    <ItemGroup>
      <BundleFiles Include="$(WasmMainJSPath)" TargetDir="publish" />

      <_WasmPropertyNames Include="DisableParallelEmccCompile" />
      <_WasmPropertyNames Include="EmccCompileOptimizationFlag" />
      <_WasmPropertyNames Include="EmccLinkOptimizationFlag" />
      <_WasmPropertyNames Include="WasmIncludeFullIcuData" />
      <_WasmPropertyNames Include="WasmIcuDataFileName" />
    </ItemGroup>
  </Target>

  <Target Name="_WasmAddToRunScript" BeforeTargets="GenerateRunScript">
    <!-- Combine optional alias on all NodeNpmModule and trim separator where alias is empty -->
    <ItemGroup>
      <_NodeNpmModuleString Include="%(NodeNpmModule.Identity):%(NodeNpmModule.Alias)" />
      <_NodeNpmModuleStringTrimmed Include="@(_NodeNpmModuleString->Trim(':'))" />
    </ItemGroup>
    <PropertyGroup>
      <Scenario Condition="'$(Scenario)' == ''">WasmTestOnV8</Scenario>
      <NodeNpmModuleString>@(_NodeNpmModuleStringTrimmed, ',')</NodeNpmModuleString>
    </PropertyGroup>

    <Error Condition="'$(Scenario)' != 'WasmTestOnV8' and 
                      '$(Scenario)' != 'WasmTestOnChrome' and 
                      '$(Scenario)' != 'WasmTestOnFirefox' and 
                      '$(Scenario)' != 'BuildWasmApps'" 
                      Text="Only supported scenarios are WasmTestOnV8, WasmTestOnChrome, WasmTestOnFirefox and BuildWasmApps at the moment. It was $(Scenario)." />

    <!-- Restore NPM packages -->
    <ItemGroup>
      <SetScriptCommands Condition="'$(InstallChromeForTests)' == 'true' and '$(ChromeDriverBinaryPath)' != ''" Include="$(EnvVarCommand) PREPEND_PATH=$([System.IO.Path]::GetDirectoryName($(ChromeDriverBinaryPath)))" />
      <SetScriptCommands Condition="'$(InstallFirefoxForTests)' == 'true' and '$(GeckoDriverBinaryPath)' != ''" Include="$(EnvVarCommand) PREPEND_PATH=$([System.IO.Path]::GetDirectoryName($(GeckoDriverBinaryPath)))" />
      <SetScriptCommands Condition="'$(IsBrowserWasmProject)' == 'true'" Include="$(EnvVarCommand) RuntimeIdentifier=browser-wasm" />
    </ItemGroup>
  </Target>
</Project>
