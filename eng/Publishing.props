<Project>
  <PropertyGroup>
    <ProducesDotNetReleaseShippingAssets>true</ProducesDotNetReleaseShippingAssets>
    <!-- This avoids creating VS.*.symbols.nupkg packages that are identical to the original package. -->
    <AutoGenerateSymbolPackages>false</AutoGenerateSymbolPackages>

    <!--
      By default, we don't use the default artifacts settings for publishing (only for signing).
      Every job will publish their RID-specific packages.
      For non-RID-specific packages, we have various rules:

      - A job can specify EnableDefaultArtifacts=true as a global property to publish all packages it produces.
        We have specific jobs that produce RID-agnostic packages or packages for multiple RIDs set this property.
      - For some target RIDs, we also include specific RID-agnostic packages.

      VMR jobs control whether or not a vertical has EnableDefaultArtifacts set to true or false in DotNetBuild.props.

      Packages that do not meet the above rules are added with Vertical visibility in the VMR and excluded in non-VMR builds.
    -->
    <EnableDefaultArtifacts Condition="'$(DotNetBuildOrchestrator)' != 'true'">false</EnableDefaultArtifacts>
  </PropertyGroup>

  <!--
    Filter out the RID-specific (Runtime) nupkgs for this RID.
    Every job will publish their RID-specific packages.
    For non-RID-specific packages, we have various rules:

    - A job can specify PublishAllPackages=true as a global property to publish all packages it produces.
      We have specific jobs that produce RID-agnostic packages or packages for multiple RIDs set this property.
    - For some target RIDs, we also include specific RID-agnostic packages.
  -->
  <Choose>
    <When Condition="'$(EnableDefaultArtifacts)' != 'true'">
      <ItemGroup>
        <ThisRidPackages Include="$(ArtifactsPackagesDir)**\*.$(PackageRID).*.nupkg" />
        <OtherPackages Include="$(ArtifactsPackagesDir)**\*.nupkg" Exclude="@(RidSpecificPackages)" />

        <PackagesToPublishFromThisJob Include="@(ThisRidPackages)" />
      </ItemGroup>

      <ItemGroup Condition="'$(PackageRID)' == 'ios-arm64'">
        <PackagesToPublishFromThisJob
          Include="$(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.iOS.Sample.Mono.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.LibraryBuilder.Sdk.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.MonoAOTCompiler.Task.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.MonoTargets.Sdk.*.nupkg" />
      </ItemGroup>
      <ItemGroup Condition="'$(PackageRID)' == 'android-arm64'">
        <PackagesToPublishFromThisJob
          Include="$(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.Android.Sample.Mono.*.nupkg" />
      </ItemGroup>
      <ItemGroup Condition="'$(PackageRID)' == 'wasi-wasm'">
        <PackagesToPublishFromThisJob
          Include="$(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.*.nupkg" />
      </ItemGroup>
      <ItemGroup Condition="'$(PackageRID)' == 'browser-wasm' and '$(WasmEnableThreads)' != 'true'">
        <PackagesToPublishFromThisJob
          Include="$(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.wasm.Sample.Mono.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.WorkloadTesting.Internal.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NETCore.BrowserDebugHost.Transport.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.WebAssembly.Sdk.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Runtime.WebAssembly.Templates.net10.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Sdk.WebAssembly.Pack.*.nupkg;
                  $(ArtifactsPackagesDir)**\Microsoft.NET.Workload.Mono.ToolChain.*.nupkg" />
      </ItemGroup>
      <ItemGroup Condition="$(PackageRID.StartsWith('win-'))">
        <PackagesToPublishFromThisJob
          Include="$(ArtifactsPackagesDir)**\VS.Redist.Common.NetCore.*.nupkg" />
      </ItemGroup>

      <ItemGroup>
        <PackagesToSkipFromThisJob Include="$(ArtifactsPackagesDir)**\*.nupkg" Exclude="@(PackagesToPublishFromThisJob)" />
        <!--
          In non-VMR builds, we can skip publishing RID-agnostic packages entirely when we're not the lane that is supposed to publish them.
          In VMR builds, we need to publish them for upstack jobs to consume.
        -->
        <Artifact Include="@(PackagesToPublishFromThisJob)"
                  IsShipping="$([System.String]::Copy('%(RecursiveDir)').StartsWith('Shipping'))"
                  Kind="Package" />

        <Artifact Include="@(PackagesToSkipFromThisJob)"
                  IsShipping="false"
                  Visibility="Vertical"
                  Kind="Package"
                  Condition="'$(DotNetBuildOrchestrator)' == 'true'" />
      </ItemGroup>
    </When>
    <Otherwise>
      <!--
        Mark host-RID-targeting assets as Vertical visibility when building in the VMR
      -->
      <ItemGroup Condition="'$(DotNetBuildOrchestrator)' == 'true' and '$(OutputRID)' != '$(NETCoreSdkRuntimeIdentifier)'">
        <Artifact Update="$(ArtifactsPackagesDir)**\runtime.$(NETCoreSdkRuntimeIdentifier).Microsoft.NETCore.ILAsm.*.nupkg"
                  Visibility="Vertical"
                  IsShipping="false" />
        <Artifact Update="$(ArtifactsPackagesDir)**\runtime.$(NETCoreSdkRuntimeIdentifier).Microsoft.NETCore.ILDAsm.*.nupkg"
                  Visibility="Vertical"
                  IsShipping="false" />
        <Artifact Update="$(ArtifactsPackagesDir)**\Microsoft.NETCore.App.Crossgen2.$(NETCoreSdkRuntimeIdentifier).*.nupkg"
                  Visibility="Vertical"
                  IsShipping="false" />
        <Artifact Update="$(ArtifactsPackagesDir)**\runtime.$(NETCoreSDKRuntimeIdentifier).Microsoft.DotNet.ILCompiler.*.nupkg"
                  Visibility="Vertical"
                  IsShipping="false" />
      </ItemGroup>
    </Otherwise>
  </Choose>

  <Target Name="GetNonStableProductVersion">
    <!-- Retrieve the non-stable runtime pack product version.
         Don't stabilize the package version in order to retrieve the VersionSuffix. -->
    <MSBuild Projects="$(RepoRoot)src/installer/pkg/sfx/Microsoft.NETCore.App/Microsoft.NETCore.App.Runtime.CoreCLR.sfxproj"
             Targets="ReturnProductVersion"
             Properties="IsShipping=false;
                         Crossgen2SdkOverridePropsPath=;
                         Crossgen2SdkOverrideTargetsPath=">
      <Output TaskParameter="TargetOutputs" PropertyName="NonStableProductVersion" />
    </MSBuild>
  </Target>

  <!--
    Only generate the productVersion.txt and runtime-productVersion.txt files when we're building
    either the full VMR repo or not building in the VMR infrastructure.
    This ensures that we don't produce these files in the "Repo source build" builds,
    but we do produce them in both the VMR and the runtime official build.
  -->
  <PropertyGroup Condition="'$(DotNetBuildOrchestrator)' == 'true'">
    <ShouldGenerateProductVersionFiles Condition="'$(PackageRID)' == 'win-x64' and ('$(DotNetBuildPass)' == '' or '$(DotNetBuildPass)' == '1')">true</ShouldGenerateProductVersionFiles>
    <ShouldGenerateProductVersionFiles Condition="'$(DotNetBuildSourceOnly)' == 'true'">true</ShouldGenerateProductVersionFiles>
  </PropertyGroup>

  <Target Name="GenerateProductVersionFiles"
          DependsOnTargets="GetNonStableProductVersion"
          BeforeTargets="PublishToAzureDevOpsArtifacts"
          Condition="'$(ShouldGenerateProductVersionFiles)' == 'true'">
    <!-- Retrieve the runtime pack product version. -->
    <MSBuild Projects="$(RepoRoot)src/installer/pkg/sfx/Microsoft.NETCore.App/Microsoft.NETCore.App.Runtime.CoreCLR.sfxproj"
             Targets="ReturnProductVersion"
             Properties="Crossgen2SdkOverridePropsPath=;
                         Crossgen2SdkOverrideTargetsPath=">
      <Output TaskParameter="TargetOutputs" PropertyName="ProductVersionForVersionsFile" />
    </MSBuild>

    <ItemGroup>
      <ProductVersionFile Include="$(ArtifactsShippingPackagesDir)productVersion.txt" />
      <ProductVersionFile Include="$(ArtifactsShippingPackagesDir)runtime-productVersion.txt" />
    </ItemGroup>

    <!-- Generate productVersion.txt file containing the product version. -->
    <WriteLinesToFile File="%(ProductVersionFile.Identity)"
                      Lines="$(ProductVersionForVersionsFile)"
                      Overwrite="true"
                      Encoding="ASCII" />

    <ItemGroup>
      <Artifact Include="@(ProductVersionFile)"
                RelativeBlobPath="Runtime/$(NonStableProductVersion)/%(Filename)%(Extension)" />
    </ItemGroup>
  </Target>

  <Target Name="AddRelativeBlobPathToInstallerArtifacts"
          DependsOnTargets="GetNonStableProductVersion"
          BeforeTargets="PublishToAzureDevOpsArtifacts"
          AfterTargets="GenerateChecksumsFromArtifacts">
    <ItemGroup>
      <Artifact Condition="'%(Artifact.PublishFlatContainer)' == 'true' and '%(Artifact.RelativeBlobPath)' == ''"
                RelativeBlobPath="Runtime/$(NonStableProductVersion)/%(Artifact.SubBlobFolder)%(Filename)%(Extension)" />
    </ItemGroup>
  </Target>
</Project>
