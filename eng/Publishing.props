<Project>

  <PropertyGroup>
    <ProducesDotNetReleaseShippingAssets>true</ProducesDotNetReleaseShippingAssets>
    <!-- This avoids creating VS.*.symbols.nupkg packages that are identical to the original package. -->
    <AutoGenerateSymbolPackages>false</AutoGenerateSymbolPackages>
    <!-- Set PlatformName to TargetArchitecture to create unique build manifest files. -->
    <PlatformName Condition="'$(TargetArchitecture)' != ''">$(TargetArchitecture)</PlatformName>
  </PropertyGroup>

  <!--
    Mark assets as Vertical visibility when building in the VMR
  -->
  <ItemGroup Condition="'$(DotNetBuildOrchestrator)' == 'true'">
    <Artifact Condition="'$(OutputRID)' != '$(NETCoreSdkRuntimeIdentifier)'"
              Update="$(ArtifactsPackagesDir)**\runtime.$(NETCoreSdkRuntimeIdentifier).Microsoft.NETCore.ILAsm.*.nupkg"
              Visibility="Vertical"
              IsShipping="false" />
    <Artifact Condition="'$(OutputRID)' != '$(NETCoreSdkRuntimeIdentifier)'"
              Update="$(ArtifactsPackagesDir)**\runtime.$(NETCoreSdkRuntimeIdentifier).Microsoft.NETCore.ILDAsm.*.nupkg"
              Visibility="Vertical"
              IsShipping="false" />
    <Artifact Condition="'$(RuntimeFlavor)' != 'Mono' and '$(OutputRID)' != '$(NETCoreSdkRuntimeIdentifier)'"
              Update="$(ArtifactsPackagesDir)**\Microsoft.NETCore.App.Crossgen2.$(NETCoreSdkRuntimeIdentifier).*.nupkg"
              Visibility="Vertical"
              IsShipping="false" />
    <Artifact Condition="'$(RuntimeFlavor)' != 'Mono' and '$(OutputRID)' != '$(NETCoreSdkRuntimeIdentifier)'"
              Update="$(ArtifactsPackagesDir)**\runtime.$(NETCoreSDKRuntimeIdentifier).Microsoft.DotNet.ILCompiler.*.nupkg"
              Visibility="Vertical"
              IsShipping="false" />
  </ItemGroup>

  <!-- Default to publishing only RID-specific assets -->
  <ItemGroup>
    <!--
      Filter out the RID-specific (Runtime) nupkgs and RID-agnostic nupkgs. RID-specific packages
      are published from every job. RID-agnostic nupkgs are built with the same ID/version by
      every job, so one specific job's outputs must be picked to sign and publish.
    -->
    <RidSpecificPackages
      Include="
        $(ArtifactsPackagesDir)**\Microsoft.*.Runtime.*.nupkg;
        $(ArtifactsPackagesDir)**\Microsoft.*.App.Host.*.nupkg;
        $(ArtifactsPackagesDir)**\Microsoft.*.App.Crossgen2.*.nupkg;
        $(ArtifactsPackagesDir)**\VS.Redist.Common.*.nupkg
        $(ArtifactsPackagesDir)**\runtime.*.nupkg"
      Exclude="
        $(ArtifactsPackagesDir)**\runtime.native.*.nupkg
        $(ArtifactsPackagesDir)**\*.Transport.*.nupkg" /> 
    <RidAgnosticPackages Include="$(ArtifactsPackagesDir)\**\*.nupkg" Exclude="@(RidSpecificPackages)" />
    <!--
      In non-VMR builds, we can skip publishing RID-agnostic packages entirely when we're not the lane that is supposed to publish them.
      In VMR builds, we need to publish them for upstack jobs to consume.
    -->
    <Artifact Update="@(RidAgnosticPackages)" SkipPublish="true" Condition="'$(DotNetBuildOrchestrator)' != 'true' and '$(PublishRidAgnosticPackages)' != 'true'" />
    <Artifact Update="@(RidAgnosticPackages)" Visibility="Vertical" Condition="'$(DotNetBuildOrchestrator)' == 'true' and '$(PublishRidAgnosticPackages)' != 'true'" />

    <!--
    TODO: Some packages aren't produced in the windows_x64 jobs. In particular, packages matching the following patterns:
      - Microsoft.NET.Workload.Mono.Toolchain.*Manifest-*
      - Microsoft.NET.Sdk.WebAssembly.Pack.*

    We need to determine where to ship these from and how to specify it in the official build.

    Additionally, some packages matching the above RID-specific patterns aren't actually RID-specific and need to be deduplicated:
      - Microsoft.NET.Runtime.*.Sample.Mono
      - Microsoft.NET.Runtime.LibraryBuilder.Sdk
      - Microsoft.NET.Runtime.MonoAOTCompiler.Task
      - Microsoft.NET.Runtime.MonoTargets.Sdk
      - Microsoft.NET.Runtime.WebAssembly.Sdk
      - Microsoft.NET.Runtime.WebAssembly.Templates.net10
      - Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk
      - Microsoft.NET.Runtime.WorkloadTesting.Internal
     -->
  </ItemGroup>

  <!-- Set the subpath of workloads zip files -->
  <ItemGroup>
    <Artifact Update="$(ArtifactsPackagesDir)**\Workload.VSDrop.*.zip" SubBlobFolder="workloads" />
  </ItemGroup>

  <Target Name="GetNonStableProductVersion">
    <!-- Retrieve the non-stable runtime pack product version.
         Don't stabilize the package version in order to retrieve the VersionSuffix. -->
    <MSBuild Projects="$(RepoRoot)src/installer/pkg/sfx/Microsoft.NETCore.App/Microsoft.NETCore.App.Runtime.CoreCLR.sfxproj"
             Targets="ReturnProductVersion"
             Properties="IsShipping=false;
                         Crossgen2SdkOverridePropsPath=;
                         Crossgen2SdkOverrideTargetsPath=">
      <Output TaskParameter="TargetOutputs" PropertyName="NonStableProductVersion" />
    </MSBuild>
  </Target>

  <!--
    Only generate the productVersion.txt and runtime-productVersion.txt files when we're building
    either the full VMR repo or not building in the VMR infrastructure.
    This ensures that we don't produce these files in the "Repo source build" builds,
    but we do produce them in both the VMR and the runtime official build.
  -->
  <PropertyGroup>
    <ShouldGenerateProductVersionFiles Condition="'$(DotNetBuildOrchestrator)' == 'true'">true</ShouldGenerateProductVersionFiles>
  </PropertyGroup>

  <Target Name="GenerateProductVersionFiles"
          DependsOnTargets="GetNonStableProductVersion"
          BeforeTargets="PublishToAzureDevOpsArtifacts"
          Condition="'$(ShouldGenerateProductVersionFiles)' == 'true'">
    <!-- Retrieve the runtime pack product version. -->
    <MSBuild Projects="$(RepoRoot)src/installer/pkg/sfx/Microsoft.NETCore.App/Microsoft.NETCore.App.Runtime.CoreCLR.sfxproj"
             Targets="ReturnProductVersion"
             Properties="Crossgen2SdkOverridePropsPath=;
                         Crossgen2SdkOverrideTargetsPath=">
      <Output TaskParameter="TargetOutputs" PropertyName="ProductVersionForVersionsFile" />
    </MSBuild>

    <ItemGroup>
      <ProductVersionFile Include="$(ArtifactsShippingPackagesDir)productVersion.txt" />
      <ProductVersionFile Include="$(ArtifactsShippingPackagesDir)runtime-productVersion.txt" />
    </ItemGroup>

    <!-- Generate productVersion.txt file containing the product version. -->
    <WriteLinesToFile File="%(ProductVersionFile.Identity)"
                      Lines="$(ProductVersionForVersionsFile)"
                      Overwrite="true"
                      Encoding="ASCII" />

    <ItemGroup>
      <Artifact Include="@(ProductVersionFile)"
                RelativeBlobPath="Runtime/$(NonStableProductVersion)/%(Filename)%(Extension)" />
    </ItemGroup>
  </Target>

  <Target Name="AddRelativeBlobPathToInstallerArtifacts"
          DependsOnTargets="GetNonStableProductVersion"
          BeforeTargets="PublishToAzureDevOpsArtifacts"
          AfterTargets="GenerateChecksumsFromArtifacts">
    <ItemGroup>
      <Artifact Condition="'%(Artifact.PublishFlatContainer)' == 'true' and '%(Artifact.RelativeBlobPath)' == ''"
                RelativeBlobPath="Runtime/$(NonStableProductVersion)/%(Artifact.SubBlobFolder)%(Filename)%(Extension)" />
    </ItemGroup>
  </Target>
</Project>
