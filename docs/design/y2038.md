# Y2038 support in .NET 9 linux arm32

During the development of .NET 9, Ubuntu 24.04 was released as the first Ubuntu version to enable 64-bit time_t by default for linux arm32. We [discovered](https://github.com/dotnet/runtime/issues/101444) this when our linux arm32 builds started hitting openssl-related errors on Ubuntu 24.04. This document describes our approach to Y2038 support.

### Summary

.NET 9 linux arm32 requires glibc 2.35 and uses 64-bit `time_t` by default. This works on systems with 32-bit `time_t` as long as we don't need to represent times larger than 32 bits. We detect whether openssl uses 32-bit `time_t`, and fail predictably if the time being represented on the .NET side does not fit in 32 bits.

### Y2038 in linux

Y2038 support at the [kernel](https://lwn.net/Articles/643234/) layer includes new versions of syscalls that use 64-bit versions of time_t. Userspace programs that use 32-bit time_t continue to work with this kernel.

The next layer up is [glibc](https://sourceware.org/glibc/wiki/Y2038ProofnessDesign), which got Y2038 support in version 2.34. Like the kernel, glibc took a backwards-compatible approach. For every existing API symbol that used 32-bit time, glibc added a new 64-bit equivalent. The glibc headers provide a define `__TIME_BITS` that determines which versions of the time-related symbols are referenced at compile-time. For example, a call to glibc's `mktime` becomes a call to `__mktime64` when built with `__TIME_BITS==64`.

However, the backwards compatibility ends with glibc. Linux distributions took on the project of building the remaining distribution-provided userspace libraries and applications with `__TIME_BITS=64`, introducing an ABI break at the boundary of any library with public surface that referenced `time_t`.

[Ubuntu](https://discourse.ubuntu.com/t/ubuntu-24-04-lts-noble-numbat-release-notes/39890#year-2038-support-for-the-armhf-architecture-5) made this change in 24.04, and [Debian](https://wiki.debian.org/ReleaseGoals/64bit-time) 13 is planned to be the first Debian release with 64-bit time.

[musl](https://musl.libc.org/time64.html) version 1.2.0 got 64-bit time_t support, which was adopted in [Alpine](https://wiki.alpinelinux.org/wiki/Release_Notes_for_Alpine_3.13.0) 3.13.

### .NET builds

.NET official builds are produced by building the product on a dedicated set of build images. The images run Azure Linux 3.0 with a modern cross-compilation toolchain, and also include a root filesystem of an old linux distribution that provides an old version of glibc (or musl libc), which determines the libc compatibility of our builds.

In .NET 8, we [support](https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md#libc-compatibility) glibc 2.23 andc musl 1.2.2, by building the product with a root filesystem from Ubuntu 16.04 and Alpine 3.13, respectively.

### .NET Y2038 support

.NET 8 already [supports](https://github.com/dotnet/runtime/pull/51099) 64-bit time on musl linux, and on architectures other than arm. This just leaves the glibc-based arm32 linux build.

#### glibc

Because our build already [defined](https://github.com/dotnet/runtime/pull/100461) `_TIME_BITS=64`, the main change we had to make was to [update](https://github.com/dotnet/dotnet-buildtools-prereqs-docker/pull/1037) the Ubuntu version of our rootfs to one that had a glibc with `_TIME_BITS` support. By targeting Ubuntu 22.04, .NET would be built with 64-bit `time_t`, allowing `DateTime.UtcNow` to [work](https://github.com/dotnet/runtime/issues/96460) correctly past Y2038.

With this change, glibc-based .NET 9 (on linux arm) is only [supported](https://github.com/dotnet/core/blob/main/release-notes/9.0/supported-os.md) on distributions with at least glibc 2.35 (from Ubuntu 22.04).

#### openssl

Notice that we require a 64-bit time compatible glibc, _but_ the rest of the userspace may still be built with 32-bit time. This causes further problems when .NET interacts with other userspace libraries, in particular openssl. An initial analysis [identified](https://github.com/dotnet/runtime/issues/101444) a couple of spots where .NET was passing `time_t` values (now 64-bit, with the aforementioned change) into openssl functions. Before Ubuntu 24.04 and Debian 13, this meant we would be passing 64-bit values into functions that expected 32-bit values.

One of the callsites passes the `time_t` by value, and another passes it as a pointer. We realized that little-endianness on arm meant we could safely pass a 64-bit value as a pointer, and have the receiving function interpret the low 32 bits as a 32-bit time_t value. However, passing the `time_t` by value hit an [ABI](github.com/ARM-software/abi-aa/blob/main/aapcs32/aapcs32.rst) requirement which essentially meant that it could be passed in registers r0:r1 or r2:r3, but not r1:r2:

>  C.3 | If the argument requires double-word alignment (8-byte), the NCRN is rounded up to the next even register number.


It turns out that the by-value callsite was already passing another value in r0, so the 32-bit build of openssl was expecting to be passed a 32-bit `time_t` in r1, while our 64-bit `time_t` was being passed in r2:r3. At first we considered using a clever ABI hack to pass _both_ the lower 32 bits in r1, and the full 64-bit `time_t` value in r2:r3. This would have solved the problem, at least until we tried to represent a time that didn't fit into 32 bits.

However, we decided that we also wanted to be resilient to the Y2038 problem even when running on systems with 32-bit `time_t`, at least as far as that was reasonably possible in .NET. It's likely that other libraries will fail in unexpected ways in this case, but we had a goal of not contributing to the problem in .NET.

This meant we needed to fail predictably when working with times that did not fit in 32 bits and running on a system where openssl was using 32-bit `time_t`. We needed to consider the behavior of the two [callsites](https://github.com/dotnet/runtime/issues/101444#issuecomment-2077632497):

- One was passing a time to openssl's `X509_VERIFY_PARAM_set_time` for the purpose of validating a certificate chain.
- Another was calling `X509_cmp_time` to compare the current time with a time returned from an OCSP response, as part of getting the expiry time.

We didn't want to cause a potential security hole by clamping a larger-than-32-bit time to `INT_MAX` or `INT_MIN`, as that might (for example) cause openssl to accept a certificate chain valid during the Y2038 rollover, well past Y2038 (as it would internally be comparing an `ASN1_GENERALIZEDTIME` that does not have the Y2038 problem with a 32-bit time).

We solved this by calling a simple openssl function, `OPENSSL_gmtime`, that takes a pointer to a `time_t` and returns a broken-down time in the form of a `tm` struct. For this call we use the ABI trick that allows passing a 64-bit `time_t` as a pointer, and we examine the broken-down time to see whether it represents the full 64-bit value (indicating that openssl is using 64-bit `time_t`), or just the lower 32 bits.

[Here](https://github.com/dotnet/runtime/pull/102410/files#diff-592e31e5115ea6d3235bc9a81ee765635da398589f1bd51d7d66bfbca814f1b6R236-R251S) is the interesting bit of code:

```c
    // This value will represent a time in year 2038 if 64-bit time is used,
    // or 1901 if the lower 32 bits are interpreted as a 32-bit time_t value.
    time_t timeVal = (time_t)INT_MAX + 1;
    struct tm tmVal = { 0 };

    // Detect whether openssl is using 32-bit or 64-bit time_t.
    // If it uses 32-bit time_t, little-endianness means that the pointer
    // will be interpreted as a pointer to the lower 32 bits of timeVal.
    // tm_year is the number of years since 1900.
    if (!OPENSSL_gmtime(&timeVal, &tmVal) || (tmVal.tm_year != 138 && tmVal.tm_year != 1))
    {
        fprintf(stderr, "Cannot determine the time_t size used by libssl\n");
        abort();
    }

    g_libSslUses32BitTime = (tmVal.tm_year == 1);
```

Then at the other callsites, we just check if our value is larger than 32 bits, and fail early if it is, or do the right thing for the 32-bit version of openssl if not. For [example](https://github.com/dotnet/runtime/pull/102410/files#diff-b144366bd4c3520d0793a1b06c10c5efb57f85f6bb68a1a9073f8dd0f1a0efa5R968-R976):

```c
    if (g_libSslUses32BitTime)
    {
        if (verifyTime > INT_MAX || verifyTime < INT_MIN)
        {
            return 0;
        }

        // Cast to a signature that takes a 32-bit value for the time.
        ((void (*)(X509_VERIFY_PARAM*, int32_t))(void*)(X509_VERIFY_PARAM_set_time))(verifyParams, (int32_t)verifyTime);
        return 1;
    }
```

This cast is ensuring that the 32-bit value gets passed in r1, instead of r2:r3 that would normally be used by the ABI when compiling with `_TIME_BITS=64`.


With that, we support running on 64-bit `time_t` compatible glibc, along with either 32-bit or 64-bit `time_t` openssl, at least until we hit a time that does not fit into 32 bits.

