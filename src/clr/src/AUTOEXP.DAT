;---------------------------------------------------------------
; This comment block added by the CLR dev team.
;
; This is a custom autoexp.dat that causes VS2005 to nicely
; pretty-print common CLR data types (MethodDesc, EEClass, etc.)
; in the debugger watch window. For example, instead of
; seeing
;
;     pString     {...}         
;
; you will see the more useful
;
;     pString     {0x<addr> "Hello" }
;
;
;
;
; To use this file, replace the autoexp.dat file in your VS
; installation with this one. This file is normally found under
; this path:
;
;    C:\Program Files\Microsoft Visual Studio 8\Common7\Packages\Debugger
;
; If you have your own custom rules that you don't want messed
; up or you're just healthily paranoid, you can cut and paste
; the CLR-specific section only. The section begins with
;
;   ;---- [BEGIN] CLR-specific autoexps ---------------------------
;
; and ends with
;
;   ;---- [END] CLR-specific autoexps ---------------------------
;
; Note that this *must* go into the [AutoExpand] section of the file.
; Don't just append to the end of the file or the debugger won't
; see it.
;
; 
;
;---------------------------------------------------------------








;---------------------------------------------------------------
; AutoExp.Dat - templates for automatically expanding data
; Licensed to the .NET Foundation under one or more agreements.
; The .NET Foundation licenses this file to you under the MIT license.
; See the LICENSE file in the project root for more information.
;---------------------------------------------------------------
;
; While debugging, Data Tips and items in the Watch and Variable
; windows are automatically expanded to show their most important
; elements. The expansion follows the format given by the rules
; in this file. You can add rules for your types or change the
; predefined rules.
;
; For good examples, read the rules in this file.
;
; To find what the debugger considers the type of a variable to
; be, add it to the Watch window and look at the Type column.
;
; An AutoExpand rule is a line with the name of a type, an equals 
; sign, and text with replaceable parts in angle brackets. The 
; part in angle brackets names a member of the type and an 
; optional Watch format specifier.
;
; AutoExpand rules use the following syntax. The equals sign (=), 
; angle brackets (<>), and comma are taken literally. Square
; brackets ([]) indicate optional items.
;
; type=[text]<member[,format]>...
;
; type      Name of the type (may be followed by <*> for template
;           types such as the ATL types listed below).
;
; text      Any text.Usually the name of the member to display, 
;           or a shorthand name for the member.
;
; member    Name of a member to display.
;
; format    Watch format specifier. One of the following:
;
;   Letter  Description                 Sample         Display
;   ------  --------------------------  ------------   -------------
;   d,i     Signed decimal integer      0xF000F065,d   -268373915
;   u       Unsigned decimal integer    0x0065,u       101
;   o       Unsigned octal integer      0xF065,o       0170145
;   x,X     Hexadecimal integer         61541,X        0X0000F065
;   l,h     long or short prefix for    00406042,hx    0x0c22
;             d, i, u, o, x, X
;   f       Signed floating-point       3./2.,f        1.500000
;   e       Signed scientific-notation  3./2.,e        1.500000e+000
;   g       Shorter of e and f          3./2.,g        1.5
;   c       Single character            0x0065,c       'e'
;   s       Zero-terminated string      pVar,s         "Hello world"
;   su      Unicode string              pVar,su        "Hello world"
;
; For details of other format specifiers see Help under:
; "format specifiers/watch variable"
;
; The special format <,t> specifies the name of the most-derived 
; type of the object. This is especially useful with pointers or
; references to a base class.
;
; If there is no rule for a class, the base classes are checked for
; a matching rule.
;
; There are some special entries allowed in the AutoExpand section:
; $BUILTIN is used to display more complex types that need to do more
; than just show a member variable or two.
; $ADDIN allows external DLLs to be added to display even more complex
; types via the EE Add-in API. The first argument is the DLL name, the
; second argument is the name of the export from the DLL to use. For 
; further information on this API see the sample called EEAddIn.
;
; WARNING: if hexadecimal mode is on in the watch window, all numbers here are
; evaluated in hex, e.g. 42 becomes 0x42

[AutoExpand]

;---- [BEGIN] CLR-specific autoexps ---------------------------
; 


PEFile=<m_pDebugName,su>
Module=<m_file->m_pDebugName, su>
Assembly=<m_pManifestFile->m_pDebugName,su>
ClassLoader=<m_pAssembly->m_pManifestFile->m_pDebugName,su>
AssemblySpec=<m_pAssemblyName,s> v<m_context.usMajorVersion,d>.<m_context.usMinorVersion,d>.<m_context.usBuildNumber,d>.<m_context.usRevisionNumber,d> <m_CodeInfo.m_pszCodeBase,su>

TypeHandle=<m_asMT->m_pEEClass->m_szDebugClassName,s>
ParamTypeDesc=<m_TemplateMT->m_pEEClass->m_szDebugClassName, s>


EEClass=<m_szDebugClassName,s>
MethodTable=<m_pEEClass->m_szDebugClassName,s>
MethodDesc=<m_pszDebugClassName,s>::<m_pszDebugMethodName,s> 
ReflectMethod=<pMethod->m_pszDebugClassName,s>::<pMethod->m_pszDebugMethodName,s> 
FieldDesc=<m_pMTOfEnclosingClass->m_pEEClass->m_szDebugClassName,s>::<m_debugName,s>

Thread=<m_ThreadId,x>

BaseObject=<m_pMethTab->m_pEEClass->m_szDebugClassName,s>
Object=<m_pMethTab->m_pEEClass->m_szDebugClassName,s>
StringObject=<m_Characters>
OBJECTREF= <m_asObj->m_pMethTab->m_pEEClass->m_szDebugClassName,s>
REF<StringObject>=<m_asString->m_Characters>
REF<*>= <m_asObj->m_pMethTab->m_pEEClass->m_szDebugClassName,s>

; SStrings are annoying because their internal buffer can be in either
; unicode or ansi depending on the code path. Thus, this rule attempts
; to print it both ways. We will do the ascii attempt first as it's
; less likely to produce verbose garbage (usually, it'll print just the
; first character.)
;
; So the typical output you'll see is...
;
;   {"A"/"ABCD"}              ; sbuffer is using unicode representation
;   {"ABCD"/"<square boxes>"} ; sbuffer was using ansi representation
;
; The rule below also kicks in as desired for StackSString and InlineSString.

SString =<m_buffer, s>|<m_buffer, su>


HolderBase<*>=<m_value>

NATIVE_BINDER_SPACE::IEntry=<_tag,su>
HolderBase<NATIVE_BINDER_SPACE::IEntry *>=<m_value> <m_value->_tag,su>
HolderBase<NATIVE_BINDER_SPACE::CILEntry *>=<m_value> <m_value->_tag,su>
HolderBase<NATIVE_BINDER_SPACE::CNgenEntry *>=<m_value> <m_value->_tag,su>

NATIVE_BINDER_SPACE::CILEntryBind=<_pILEntry->_tag,su>
HolderBase<NATIVE_BINDER_SPACE::CILEntryBind *>=<m_value> <m_value->_pILEntry->_tag,su>

NATIVE_BINDER_SPACE::CNgenEntryBind=<_pNgenEntry->_tag,su>
HolderBase<NATIVE_BINDER_SPACE::CNgenEntryBind *>=<m_value> <m_value->_pNgenEntry->_tag,su>

NATIVE_BINDER_SPACE::CDependencyEntry=<_pEntry->_tag,su>
HolderBase<NATIVE_BINDER_SPACE::CDependencyEntry *>=<m_value> <m_value->_pEntry->_tag,su>

CAssemblyName=<_rProp._rProp[3].asStr>
HolderBase<CAssemblyName *>=<m_value->_rProp._rProp[3].asStr>
HolderBase<IAssemblyName *>=<m_pAutoExpVisibleValue->_asCAssemblyName->_rProp._rProp[3].asStr>

BindResult=<m_tag,su>
HolderBase<BindResult *>=<m_value->m_tag,su>
HolderBase<IBindResult *>=<m_pAutoExpVisibleValue->_asBindResult->m_tag,su>

AssemblyLocation=<m_pwzAssemblyPath>
HolderBase<AssemblyLocation *>=<m_value->m_pwzAssemblyPath>
HolderBase<IAssemblyLocation *>=<m_pAutoExpVisibleValue->_asAssemblyLocation->m_pwzAssemblyPath>


;---- [END] CLR-specific autoexps ---------------------------






; from windef.h
tagPOINT =x=<x> y=<y>
tagRECT =top=<top> bottom=<bottom> left=<left> right=<right>

; from winuser.h
tagMSG =msg=<message,x> wp=<wParam,x> lp=<lParam,x>

; intrinsics
__m64 =<m64_i64,x>
__m128=$BUILTIN(M128)
__m128i=$BUILTIN(M128I)
__m128d=$BUILTIN(M128D)

; from afxwin.h
CDC =hDC=<m_hDC> attrib=<m_hAttribDC>
CPaintDC =<,t> hWnd=<m_hWnd>
CPoint =x=<x> y=<y>
CRect =top=<top> bottom=<bottom> left=<left> right=<right>
CSize =cx=<cx> cy=<cy>
CWnd =<,t> hWnd=<m_hWnd>
CWinApp =<,t> <m_pszAppName,s>
CWinThread =<,t> h=<m_hThread> proc=<m_pfnThreadProc>

; from afxcoll.h
CPtrList =cnt=<m_nCount>

; from afxstat_.h
CProcessLocalObject =<,t>
CThreadLocalObject =<,t>

; from afx.h
CArchiveException =cause=<m_cause>
CFile =hFile=<m_hFile> name=<m_strFileName.m_pchData,s>
CFileException =cause=<m_cause> OS Error=m_lOsError
CMemFile =pos=<m_nPosition> size=<m_nFileSize>
CObject =<,t>
CRuntimeClass =<m_lpszClassName,s>
CStdioFile =FILE*=<m_pStream> name=<m_strFilename.m_pchData,s>
CTimeSpan =time=<m_time>
CTime =time=<m_time>

; from afxcoll.h
CByteArray =count=<m_nCount>
CStringList =count=<m_nCount>
; same for all CXXXArray classes
; same for CXXXList
; same for CMapXXToXX

; various string classes from MFC & ATL

_com_error=<m_hresult,hr>
_bstr_t=<m_Data->m_wstr,su> (<m_Data->m_RefCount,u>)
_com_ptr_t<*>=<m_pInterface>
_LARGE_INTEGER=<QuadPart>
_ULARGE_INTEGER=<QuadPart>
ATL::CComPtr<*>=<p>

ATL::CComQIPtr<*>=<p>

tagVARIANT=$BUILTIN(VARIANT)
VARIANT=$BUILTIN(VARIANT)
_GUID=$BUILTIN(GUID)

; see EEAddIn sample for how to use these
;_SYSTEMTIME=$ADDIN(EEAddIn.dll,AddIn_SystemTime)
;_FILETIME=$ADDIN(EEAddIn.dll,AddIn_FileTime)

std::binder1st<*>= op=<op> value=<value>
std::binder2nd<*>= op=<op> value=<value>
std::less<*>=lessthan
std::greater<*>=greaterthan

[Visualizer]
; This section contains visualizers for STL and ATL containers
; DO NOT MODIFY



ATL::CStringT<char,*>|CSimpleStringT<char,*>|ATL::CSimpleStringT<char,*>{
	preview([$c.m_pszData,s])
        stringview([$c.m_pszData,sb])
}

ATL::CStringT<wchar_t,*>|CSimpleStringT<wchar_t,*>|ATL::CSimpleStringT<wchar_t,*>|ATL::CStringT<unsigned short,*>|CSimpleStringT<unsigned short,*>|ATL::CSimpleStringT<unsigned short,*>{
	preview([$c.m_pszData,su])
        stringview([$c.m_pszData,sub])
}

ATL::CComBSTR{
	preview([$c.m_str,su])
        stringview([$c.m_str,sub])
}


;------------------------------------------------------------------------------
;  std::vector<bool,*> specialization
;------------------------------------------------------------------------------

std::vector<bool,*>{
	children
	(
		#array
		(
			expr : ($c._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)), 
			size : ($c._Mysize)
		)  : (bool)($e & 1)
	)
		
    preview
    ( 
            #( 
				"[", 
				$e._Mysize , 
				"](", 
				#array
				(
					expr : ($c._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)), 
					size : ($c._Mysize)
				)  : (bool)($e & 1), ")")
	)		
}

std::vector<bool,*>::iterator|std::vector<bool,*>::const_iterator|std::_Vb_iterator<*>|std::_Vb_const_iterator<*>{
	preview
	(
		#( 
			(bool) (((*$e._Myptr) >> $e._Myoff) & 1)   
		)
	)
	
	children
	(
		#( 
			ptr: (bool) (((*$e._Myptr) >> $e._Myoff) & 1)   
		)
	)

	
}


;------------------------------------------------------------------------------
;  std::vector
;------------------------------------------------------------------------------
std::vector<*>{
	children
	(
	    #array
	    (
			expr :	($c._Myfirst)[$i],  
			size :	$c._Mylast-$c._Myfirst
		)
	)
	
    preview
    ( 
        #( 
			"[", 
            $e._Mylast - $e._Myfirst , 
            "](", 
            
            #array
            (
				expr : 	($c._Myfirst)[$i],  
				size : 	$c._Mylast-$c._Myfirst
			), 
			")"
		)
	)
	

}

std::_Vector_iterator<*>|std::_Vector_const_iterator<*>{
	preview 
	(
		#(*$e._Myptr)
	)
	
	children
	(
		#(ptr: *$e._Myptr)
	)
}



;------------------------------------------------------------------------------
;  std::string/basic_string
;------------------------------------------------------------------------------

std::basic_string<char,*>{
	preview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			[$e._Bx._Buf,s]
		)
		#else
		(
			[$e._Bx._Ptr,s]
		)
	)
	
	stringview
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			[$e._Bx._Buf,sb]
		)
		#else
		(
			[$e._Bx._Ptr,sb]
		)
	)
	
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)	
	)	

}

std::basic_string<unsigned short,*>|std::basic_string<wchar_t,*>{
	preview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,su] )
		#else ( [$e._Bx._Ptr,su] )
	)
	
	stringview
	( 
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sub] )
		#else ( [$e._Bx._Ptr,sub] )
	)
	
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)	
	)	
}

std::basic_string<*>::iterator|std::basic_string<*>::const_iterator|std::_String_iterator<*>|std::_String_const_iterator<*>{
	preview
	( 
		#( $e._Myptr ) 
	)

	children
	( 
		#( ptr: $e._Myptr ) 
	)
}

std::pair<*>{
	preview
	(
		#( 
			"(", 
			$e.first, 
			",", 
			$e.second , 
			")"
		)
	)
}

;------------------------------------------------------------------------------
;  std::auto_ptr
;------------------------------------------------------------------------------

std::auto_ptr<*>{
	preview
	( 
		#(	"auto_ptr ",
			(*(($T1 *)$c._Myptr))
		 )
	)
	children
	( 
		#( 
			ptr: (*(($T1 *)$c._Myptr)) 
		)
	)
}

;------------------------------------------------------------------------------
;  std::map
;------------------------------------------------------------------------------

std::map<*>{
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
		    skip : $c._Myhead, 
		    size : $c._Mysize, 
		    left : _Left, 
		    right : _Right
		) : $e._Myval
	)
		     
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 

			#tree
			(
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				size : $c._Mysize, 
				left : _Left, 
				right : _Right
			) : $e._Myval,
			
			")"
		)
	)		     
}

;------------------------------------------------------------------------------
;  std::multi_map
;------------------------------------------------------------------------------

std::multimap<*>{
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
		    skip : $c._Myhead, 
		    size : $c._Mysize, 
		    left : _Left, 
		    right : _Right
		) : $e._Myval
	)
		     
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
			
			#tree
			(	
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				size : $c._Mysize, 
				left : _Left, 
				right : _Right
			) : $e._Myval,
			
			")"
		)
	)		     
}


;------------------------------------------------------------------------------
;  std::list
;------------------------------------------------------------------------------

std::list<*>{

	children
	(
		#list
		(
			head : $c._Myhead->_Next, 
		    size : $c._Mysize, 
		    next : _Next
		) : $e._Myval
	)
		          
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
		  
			#list
			(
				head : $c._Myhead->_Next, 
				size : $c._Mysize, 
				next : _Next
			) : $e._Myval,
		 
			")"
		)
	)			      
}

std::list<*>::iterator|std::list<*>::const_iterator|std::list<*>::_Iterator<1>|std::list<*>::_Const_iterator<1>{
	preview
	(
		#($e._Ptr->_Myval)
	)
	
	children
	(
		#(ptr: $e._Ptr->_Myval)
	)

}


;------------------------------------------------------------------------------
;  std::bitset  <bitset>
;------------------------------------------------------------------------------

std::bitset<*>{       
	preview
	(
		#(
		"[",
			$c.digits,
		"](",
		#array
		(	
			expr : 	($c._Array[$i / $c._Bitsperword] >> ($i % $c._Bitsperword)),  
			size : 	$c.digits
		) : [($e & 1),d],
		")"
		)
	)
	children
	(
		#array
		(	
			expr : 	($c._Array[$i / $c._Bitsperword] >> ($i % $c._Bitsperword)),  
			size : 	$c.digits
		) : (bool)($e & 1))
}

std::bitset<*>::reference{
    preview
    (
		#(
			"bitset[", $e._Mypos, "] = ", 
			(bool)(($e._Pbitset->_Array[$i / _Bitsperword] >> ($e._Mypos % _Bitsperword)) & 1) 
		)
    )
}

;------------------------------------------------------------------------------
;  std::deque
;------------------------------------------------------------------------------

std::deque<*>{
	children
	(
		#array
		(
			expr : $c._Map[ (($i + $c._Myoff) / $c._EEN_DS) % $c._Mapsize][($i + $c._Myoff) % $c._EEN_DS],  
			size : $c._Mysize
		)
	)

	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
		  
			#array
			(
				expr : $c._Map[ (($i + $c._Myoff) / $c._EEN_DS) % $c._Mapsize][($i + $c._Myoff) % $c._EEN_DS],  
				size : $c._Mysize
			),
		 
			")"
		)
	)		       
}

std::deque<*,*>::iterator|std::_Deque_iterator<*,*,*>|std::_Deque_const_iterator<*,*,*>{
   preview
   (
	   #if( $e._Myoff >= ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mysize)
	   (
	   		#("<end>")
	   )
	   #else(
			#(
				"deque[", 
				$e._Myoff - ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff, 
				"] = ",
				((std::deque<$T1,$T2 > *)$c._Mycont)->_Map[ (($c._Myoff) / ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mapsize][$c._Myoff % ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS] 
			)
		)
	)
	children
	(
	   #if( ((std::deque<$T1,$T2 > *)$c._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mysize > $e._Myoff) 
	   (
			#(
				ptr: ((std::deque<$T1,$T2 > *)$c._Mycont)->_Map[ ($c._Myoff / ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c._Mycont)->_Mapsize][$c._Myoff % ((std::deque<$T1,$T2 > *)$c._Mycont)->_EEN_DS] 
			)
		)
	)
}

;------------------------------------------------------------------------------
;  std::queue
;------------------------------------------------------------------------------

std::queue<*>{
	children
	(
		#array
		(
			expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
			size : $c.c._Mysize
		)
	)
		   
 preview
	(
		#(
			"[", 
			$e.c._Mysize, 
			"](", 
		  
			#array
			(
				expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
				size : $c.c._Mysize
			),
		 
			")"
		)
	)			   
}


;------------------------------------------------------------------------------
;  std::priority_queue
;------------------------------------------------------------------------------

std::priority_queue<*>{
	preview
	( 
		$e.c 
	)
}

;------------------------------------------------------------------------------
;  std::set
;------------------------------------------------------------------------------

std::set<*>{
    preview
    ( 
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #tree
            (
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c._Mysize
			) : $e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
			skip : $c._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c._Mysize
		) : $e._Myval
	)
}

;------------------------------------------------------------------------------
;  std::multi_set
;------------------------------------------------------------------------------

std::multiset<*>{
    preview
    (
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #tree
            (
				head : $c._Myhead->_Parent, 
				skip : $c._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c._Mysize
			) : $e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c._Myhead->_Parent, 
			skip : $c._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c._Mysize
		) : $e._Myval
	)
}


;------------------------------------------------------------------------------
;  std::_Tree (shared my map/multimap/set/multiset)
;------------------------------------------------------------------------------

std::_Tree<*>::iterator|std::_Tree<*>::const_iterator{
	preview
	(
		#($e._Ptr->_Myval)
	)
	
	children
	(
		#(ptr: $e._Ptr->_Myval)
	)

	
}


;------------------------------------------------------------------------------
;  std::stack
;------------------------------------------------------------------------------

std::stack<*>{
	children
	(
		#array
		(
			expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
			size : $c.c._Mysize
		)
	)
           
    preview
    (
		#( 
			"[", 
            $e.c._Mysize , 
            "](", 
            
            #array
            (
				expr : $c.c._Map[ (($i + $c.c._Myoff) / $c.c._EEN_DS) % $c.c._Mapsize][($i + $c.c._Myoff) % $c.c._EEN_DS],  
				size : $c.c._Mysize
			), 
			
			")"
		)
	)           
}

;------------------------------------------------------------------------------
;  stdext::hash_map
;  stdext::hash_multimap
;  stdext::hash_set
;  stdext::hash_multiset
;------------------------------------------------------------------------------

stdext::hash_map<*>|stdext::hash_multimap<*>|stdext::hash_set<*>|stdext::hash_multiset<*>{
	
	preview
	(
		#(
			"[", 
			$e._List._Mysize, 
			"](", 
		 
			#list
			(
				head : $c._List._Myhead->_Next, 
          	    size : $c._List._Mysize,
				next : _Next
			) : $e._Myval,
			
			")"
		)
	)	

	children
	(
    
		#list
		(
			head : $c._List._Myhead->_Next, 
			size : $c._List._Mysize, 
			next : _Next
		) : $e._Myval
	)
}

;------------------------------------------------------------------------------
;  std::complex
;------------------------------------------------------------------------------

std::complex<*>{
	children
	(
		#(
			real: $e._Val[0],
			imaginary: $e._Val[1]
		)
	)
	preview
	(
		#if($e._Val[1] != 0)
		(										
			#if ($e._Val[0] != 0)				
			(									; Real and Imaginary components 
				#if ($e._Val[1] >= 0)
				(
					#($e._Val[0],"+i*", $e._Val[1])
				)
				#else
				(
					#($e._Val[0],"-i*", -$e._Val[1])							  
				)
			)
			#else
			(									; Purely imaginary
				#if ($e._Val[1] >= 0.0)
				(
					#("i*", $e._Val[1])
				)
				#else
				(
					#("-i*", -$e._Val[1])						
				)
			)
		)
		#else
		(										; Purely real
			$e._Val[0]		
		)
	)
}

;------------------------------------------------------------------------------
;  std::valarray
;------------------------------------------------------------------------------

std::valarray<*>{
    preview
    ( 
		#( 
			"[", 
            $e._Mysize , 
            "](", 
            
            #array
            (
				expr : 	($c._Myptr)[$i],  
				size : 	$c._Mysize
			), 
			
			")"
		)
	)
	
	children
	(
		#array
		(
			expr :	($c._Myptr)[$i],  
			size :	$c._Mysize
		)
	)
}

;------------------------------------------------------------------------------
;  PROPVARIANT
;------------------------------------------------------------------------------

; Visualizers for VT_VECTOR C arrays
tagCAC|tagCAUB|tagCAI|tagCAUI|tagCAL|tagCAUL|tagCAFLT|tagCADBL|tagCACY|tagCADATE|tagCABSTR|tagCABSTRBLOB|tagCABOOL|tagCASCODE|tagCAPROPVARIANT|tagCAH|tagCAUH|tagCALPSTR|tagCALPWSTR|tagCAFILETIME|tagCACLIPDATA|tagCACLSID{
	preview(
		#( 
			"[", 
            $e.cElems , 
            "](", 
            
            #array
            (
				expr : 	($c.pElems)[$i],  
				size : 	$c.cElems
			), 			
			")"
		)
	)

	children
	(
		#array
		(
			expr :	($c.pElems)[$i],  
			size :	$c.cElems
		)
	)	
	
}

; Visualizers for SAFE ARRAY
tagSAFEARRAY|SAFEARRAY{
	preview(		
			#if ($c.fFeatures & 0x0080)		; FADF_HAVEVARTYPE 
			(
				;
				;	Switch on the variant type field - which is stored 4 bytes
				;	before the beginning of the SAFEARRAY type
				;
				#switch( ((unsigned *)&($c))[-1] )						
					#case 0x2							; VT_I2 | VT_ARRAY
					(
						#(
							"safearray of I2 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x3							; VT_I4 | VT_ARRAY
					(
						#(
							"safearray of I4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x4							; VT_R4 | VT_ARRAY
					(
						#(
							"safearray of R4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((float *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x5							; VT_R8 | VT_ARRAY
					(
						#(
							"safearray of R8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((double *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x6							; VT_CY | VT_ARRAY
					(
						#(
							"safearray of CY = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CY *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)
					
					#case 0x7							; VT_DATE | VT_ARRAY
					(
						#(
							"safearray of DATE = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((DATE *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x8							; VT_BSTR | VT_ARRAY
					(
						#(
							"safearray of BSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((wchar_t **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	

					#case 0xa							; VT_ERROR | VT_ARRAY
					(
						#(
							"safearray of ERROR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((long *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)
					
					#case 0xb							; VT_BOOL | VT_ARRAY
					(
						#(
							"safearray of BOOL = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0xc							; VT_VARIANT | VT_ARRAY
					(
						#(
							"safearray of VARIANT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((tagVARIANT *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x10							; VT_I1 | VT_ARRAY
					(
						#(
							"safearray of I1 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed char *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x11							; VT_UI1 | VT_ARRAY
					(
						#(
							"safearray of UI1 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned char *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)		
					
					#case 0x12							; VT_UI2 | VT_ARRAY
					(
						#(
							"safearray of UI2 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned short *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x13							; VT_UI4 | VT_ARRAY
					(
						#(
							"safearray of UI4 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x14							; VT_I8 | VT_ARRAY
					(
						#(
							"safearray of I8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((signed __int64 *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x15							; VT_UI8 | VT_ARRAY
					(
						#(
							"safearray of UI8 = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned __int64 *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x16							; VT_INT | VT_ARRAY
					(
						#(
							"safearray of INT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((int *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)																																																																																
					
					#case 0x17							; VT_UINT | VT_ARRAY
					(
						#(
							"safearray of UINT = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((unsigned *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x1e							; VT_LPSTR | VT_ARRAY
					(
						#(
							"safearray of LPSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((char **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	

					#case 0x1f							; VT_LPWSTR | VT_ARRAY
					(
						#(
							"safearray of LPWSTR = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((wchar_t **)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x40							; VT_FILETIME | VT_ARRAY
					(
						#(
							"safearray of FILETIME = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((FILETIME *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x47							; VT_CLIPDATA | VT_ARRAY
					(
						#(
							"safearray of CLIPDATA = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CLIPDATA *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)	
					
					#case 0x48							; VT_CLSID | VT_ARRAY
					(
						#(
							"safearray of CLSID = [",	
																
							; output the rank array
							#array(	expr: $c.rgsabound[$i].cElements, size: $c.cDims),		
							
							"](", 
							
							; output the data elements
							#array( 
									expr: ((CLSID *)$c.pvData)[$i], 
									size: $c.rgsabound[$r].cElements, 
									rank: $c.cDims, 
									base: $c.rgsabound[$r].lLbound 
								  ), 
							")"
						)
					)																															
			)
			#elif ($c.fFeatures & 0x0100)		; FADF_BSTR 
			(
				#("safearray of BSTR = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((wchar_t * *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
			#elif ($c.fFeatures & 0x0200)		; FADF_UNKNOWN
			(
				#("safearray of IUnknown* = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((IUnknown *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)	
			#elif ($c.fFeatures & 0x0400)		; FADF_DISPATCH
			(
				#("safearray of IDispatch* = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((IDispatch*)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
			#elif ($c.fFeatures & 0x0800)		; FADF_VARIANT
			(
				#("safearray of VARIANT = ",#array(expr: $c.rgsabound[$i].cElements, size: $c.cDims) : #("[",$e,"]"), "(", #array(expr: ((tagVARIANT *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound ), ")")
			)
	)
	children(
		#(									;[actual members]: [$c,!],
			#if ($c.fFeatures & 0x0080)		; FADF_HAVEVARTYPE 
			(
				#switch( ((unsigned *)&($c))[-1] )	; for some reason the VT field is before the SAFEARRAY struct
					#case 2							; VT_I2|VT_ARRAY
					( 
						#array(
								expr: ((signed short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)				
					
					#case 3							; VT_I4|VT_ARRAY
					( 
						#array(
								expr: ((signed int   *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 4							; VT_R4|VT_ARRAY
					( 
						#array(
								expr: ((float *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements,
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 5							; VT_R8|VT_ARRAY
					( 
						#array(
								expr: ((double  *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)		
							
					#case 0x10						; VT_I1|VT_ARRAY
					( 
						#array(
								expr: ((signed char *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)	
								
					#case 0x11						; VT_UI1|VT_ARRAY
					( 
						#array(
								expr: ((unsigned char *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							  )
					)		
							
					#case 0x12						; VT_UI2|VT_ARRAY
					( 
						#array(
								expr: ((unsigned short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound 
							   )
					)		
							
					#case 0x13						; VT_UI4|VT_ARRAY
					( 
						#array(
								expr: ((unsigned int *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							   )	
					)
								
					#case 0x14						; VT_I8|VT_ARRAY
					( 
						#array(
								expr: ((signed __int64 *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							   )				
					)							 
					#case 0x15						; VT_UI8|VT_ARRAY
					( 
						#array(
								expr: ((unsigned __int64 *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 0x1e						; VT_LPSTR|VT_ARRAY
					( 
						#array(
								expr: ((char * *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x1f						; VT_LPWSTR|VT_ARRAY
					( 
						#array(
								expr: ((wchar_t **)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )		
					)
					
					#case 0xc						; VT_VARIANT|VT_ARRAY
					( 
						#array(
								expr: ((tagVARIANT *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					
					)
					
					#case 0xb						; VT_BOOL|VT_ARRAY
					(					
						#array(
								expr: ((short *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0xa						; VT_ERROR|VT_ARRAY
					( 
						#array(
								expr: ((long *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 6							; VT_CY|VT_ARRAY
					( 
						#array(
								expr: ((CY *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 7							; VT_DATE|VT_ARRAY
					( 
						#array(
								expr: ((DATE *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x40						; VT_FILETIME|VT_ARRAY
					( 
						#array(
								expr: ((FILETIME *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )		
					)
					
					#case 0x48						; VT_CLSID|VT_ARRAY
					( 
						#array(
								expr: ((CLSID *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x47						; VT_CF|VT_ARRAY
					( 
						#array(
								expr: ((CLIPDATA *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 8							; VT_BSTR|VT_ARRAY
					( 
						#array(
								expr: ((wchar_t * *)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )			
					)
					
					#case 0x16						; VT_INT|VT_ARRAY
					( 
						#array(
								expr: ((int *)$c.pvData)[$i],
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )				
					)
					
					#case 0x17						; VT_UINT|VT_ARRAY		
					( 
						#array(
								expr: ((unsigned int*)$c.pvData)[$i], 
								size: $c.rgsabound[$r].cElements, 
								rank: $c.cDims, 
								base: $c.rgsabound[$r].lLbound
							  )	
					)			
					
					#default
					(
						#([actual members]: [$e,!])
					)
					#except
					(
						#([actual members]: [$e,!])
					)
			)
			#elif ($c.fFeatures & 0x0100)		; FADF_BSTR 
			(
				#array(expr: ((wchar_t * *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
			#elif ($c.fFeatures & 0x0200)		; FADF_UNKNOWN
			(
				#array(expr: ((IUnknown *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)	
			#elif ($c.fFeatures & 0x0400)		; FADF_DISPATCH
			(
				#array(expr: ((IDispatch *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
			#elif ($c.fFeatures & 0x0800)		; FADF_VARIANT
			(
				#array(expr: ((tagVARIANT *)$c.pvData)[$i], size: $c.rgsabound[$r].cElements, rank: $c.cDims, base: $c.rgsabound[$r].lLbound )	
			)
		)
	)
}

tagPROPVARIANT|tagVARIANT|PROPVARIANT|VARIANT{
	preview(
			#switch ($e.vt)
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;      Base Types                                          ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0 ( #("Empty") )										; VT_EMPTY
				#case 1 ( #("NULL") )										; VT_NULL
				#case 2 ( #("I2 = ", $e.iVal) )								; VT_I2
				#case 3 ( #("I4 = ", $e.lVal) )								; VT_I4
				#case 4 ( #("R4 = ", $e.fltVal) )							; VT_R4
				#case 5 ( #("R8 = ", $e.dblVal) )							; VT_R8
				#case 6 ( #("CY = ", $e.cyVal) )							; VT_CY
				#case 7 ( #("DATE =  ", $e.date) )							; VT_DATE
				#case 8 ( #("BSTR = ", $e.bstrVal) )						; VT_BSTR
				#case 9 ( #("DISPATCH =  ", $e.pdispVal) )					; VT_DISPATCH
				#case 10 ( #("ERROR =  ", $e.scode) )						; VT_ERROR
				#case 0xB ( #("BOOL =  ", $e.boolVal) )						; VT_BOOL
				#case 0xC ( #("VARIANT ") )									; VT_VARIANT
				#case 0xD ( #("UNKNOWN =  ", $e.punkVal) )					; VT_UNKNOWN
				#case 0xE ( #("DECIMAL = ", $e.hVal) )						; VT_DECIMAL
				#case 0x10 ( #("I1 =  ", $e.cVal) )							; VT_I1
				#case 0x11 ( #("UI1 =  ", $e.bVal) )							; VT_UI1
				#case 0x12 ( #("UI2 =  ", $e.uiVal) )							; VT_UI2
				#case 0x13 ( #("UI4 =  ", $e.ulVal) )							; VT_UI4
				#case 0x14 ( #("I8 =  ", $e.hVal) )							; VT_I8
				#case 0x15 ( #("UI8 =  ", $e.uhVal) )							; VT_UI8
				#case 0x16 ( #("INT =  ", $e.intVal) )						; VT_INT
				#case 0x17 ( #("UINT = ", $e.uintVal) )						; VT_UINT
				#case 0x18 ( #("VOID ") )										; VT_VOID
				#case 0x19 ( #("HRESULT ") )									; VT_HRESULT
				#case 0x1A ( #("PTR ") )										; VT_PTR
				#case 0x1B ( #("SAFEARRAY ") )								; VT_SAFEARRAY
				#case 0x1C ( #("CARRAY ") )									; VT_CARRAY
				#case 0x1D ( #("USERDEFINED ") )								; VT_USERDEFINED
				#case 0x1E ( #("LPSTR =  ", $e.pszVal) )						; VT_LPSTR
				#case 0x1F ( #("LPWSTR =  ", $e.pwszVal) )					; VT_LPWSTR
				#case 0x24 ( #("RECORD  ") )									; VT_RECORD
				#case 0x26 ( #("UINT_PTR ") )									; VT_UINT_PTR
				#case 0x40 ( #("FILETIME =  ", $e.filetime) )					; VT_FILETIME
				#case 0x42 ( #("STREAM =  ", $e.pStream) )					; VT_STREAM
				#case 0x43 ( #("STORAGE = ", $e.pStorage) )					; VT_STORAGE
				#case 0x44 ( #("STREAMED_OBJECT =  ", $e.pStream) )			; VT_STREAMED_OBJECT
				#case 0x45 ( #("STORED_OBJECT =  ", $e.pStorage) )			; VT_STORED_OBJECT
				#case 0x46 ( #("BLOB_OBJECT = ", $e.blob ) )					; VT_BLOB_OBJECT
				#case 0x47 ( #("CF =  ", $e.pclipdata) )						; VT_CF
				#case 0x48 ( #("CLSID = ", $e.puuid) )						; VT_CLSID
				#case 0x49 ( #("VERSIONED_STREAM = ", $e.pVersionedStream) )	; VT_VERSIONED_STREAM
				
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Vector types                                           ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x1002 ( #("vector of I2 = ", $e.cai) )					; VT_I2|VT_VECTOR
				#case 0x1003 ( #("vector of I4 = ", $e.cal) )					; VT_I4|VT_VECTOR
				#case 0x1004 ( #("vector of R4 = ", $e.caflt) )				; VT_R4|VT_VECTOR
				#case 0x1005 ( #("vector of R8 = ", $e.cadbl) )				; VT_R8|VT_VECTOR
				#case 0x1010 ( #("vector of I1 =  ", $e.cac) )				; VT_I1|VT_VECTOR
				#case 0x1011 ( #("vector of UI1 =  ", $e.caub) )				; VT_UI1|VT_VECTOR
				#case 0x1012 ( #("vector of UI2 =  ", $e.caui) )				; VT_UI2|VT_VECTOR
				#case 0x1013 ( #("vector of UI4 =  ", $e.caul) )				; VT_UI4|VT_VECTOR
				#case 0x1014 ( #("vector of I8 =  ", $e.cah) )				; VT_I8|VT_VECTOR
				#case 0x1015 ( #("vector of UI8 =  ", $e.cauh) )				; VT_UI8|VT_VECTOR
				#case 0x101E ( #("vector of LPSTR =  ", $e.calpstr) )			; VT_LPSTR|VT_VECTOR
				#case 0x101F ( #("vector of LPWSTR =  ", $e.calpwstr) )		; VT_LPWSTR|VT_VECTOR
				#case 0x100C ( #("vector of VARIANT ", $e.capropvar) )		; VT_VARIANT|VT_VECTOR
				#case 0x100B ( #("vector of BOOL =  ", $e.cabool) )		    ; VT_BOOL|VT_VECTOR
				#case 0x100A ( #("vector of ERROR =  ", $e.cascode) )			; VT_ERROR|VT_VECTOR
				#case 0x1006 ( #("vector of CY = ", $e.cacy) )				; VT_CY|VT_VECTOR
				#case 0x1007 ( #("vector of DATE =  ", $e.cadate) )			; VT_DATE|VT_VECTOR
				#case 0x1040 ( #("vector of FILETIME =  ", $e.cafiletime) )	; VT_FILETIME|VT_VECTOR
				#case 0x1048 ( #("vector of CLSID = ", $e.cauuid) )			; VT_CLSID|VT_VECTOR
				#case 0x1047 ( #("vector of CF =  ", $e.caclipdata) )			; VT_CF|VT_VECTOR
				#case 0x1008 ( #("vector of BSTR = ", $e.cabstr) )			; VT_BSTR|VT_VECTOR
		
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Byref Types                                            ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x4016 ( #("byref of INT =  ", $e.pintVal) )				; VT_INT|VT_BYREF
				#case 0x4017 ( #("byref of UINT = ", $e.puintVal) )				; VT_UINT|VT_BYREF
				#case 0x4002 ( #("byref of I2 = ", $e.piVal) )					; VT_I2|VT_BYREF
				#case 0x4003 ( #("byref of I4 = ", $e.plVal) )					; VT_I4|VT_BYREF
				#case 0x4004 ( #("byref of R4 = ", $e.pfltVal) )					; VT_R4|VT_BYREF
				#case 0x4005 ( #("byref of R8 = ", $e.pdblVal) )					; VT_R8|VT_BYREF
				#case 0x4010 ( #("byref of I1 =  ", $e.pcVal) )					; VT_I1|VT_BYREF
				#case 0x4011 ( #("byref of UI1 =  ", $e.pbVal) )					; VT_UI1|VT_BYREF
				#case 0x4012 ( #("byref of UI2 =  ", $e.puiVal) )				; VT_UI2|VT_BYREF
				#case 0x4013 ( #("byref of UI4 =  ", $e.pulVal) )				; VT_UI4|VT_BYREF
				#case 0x400C ( #("byref of VARIANT ", $e.pvarVal) )				; VT_VARIANT|VT_BYREF
				#case 0x400B ( #("byref of BOOL =  ", $e.pboolVal) )				; VT_BOOL|VT_BYREF
				#case 0x400A ( #("byref of ERROR =  ", $e.pscode) )				; VT_ERROR|VT_BYREF
				#case 0x4006 ( #("byref of CY = ", $e.pcyVal) )					; VT_CY|VT_BYREF
				#case 0x4007 ( #("byref of DATE =  ", $e.pdate) )				; VT_DATE|VT_BYREF
				#case 0x4008 ( #("byref of BSTR = ", $e.pbstrVal) )				; VT_BSTR|VT_BYREF
				#case 0x400E ( #("byref of DECIMAL = ", $e.pdecVal) )			; VT_DECIMAL|VT_BYREF
				#case 0x400D ( #("byref of UNKNOWN =  ", $e.ppunkVal) )			; VT_UNKNOWN|VT_BYREF
				#case 0x4009 ( #("byref of DISPATCH =  ", $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
				#case 0x6000 ( #("byref of ARRAY =  ", $e.pparray) )				; VT_ARRAY|VT_BYREF
							
				#default 
				( 
					#if ($e.vt & 0x2000)
					(
						$e.parray
					)
					#else
					(
						#("Unknown vt type = ", $e.vt) 
					)
				)
	)
	
	
	children(
			#(vt: $e.vt, 
			#switch ($e.vt)
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;      Base Types                                          ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x2 ( #(I2  : $e.iVal) )								; VT_I2
				#case 0x3 ( #(I4  : $e.lVal) )								; VT_I4
				#case 0x4 ( #(R4  : $e.fltVal) )								; VT_R4
				#case 0x5 ( #(R8  : $e.dblVal) )								; VT_R8
				#case 0x6 ( #(CY  : $e.cyVal) )								; VT_CY
				#case 0x7 ( #(DATE   : $e.date) )								; VT_DATE
				#case 0x8 ( #(BSTR  : $e.bstrVal) )							; VT_BSTR
				#case 0x9 ( #(DISPATCH   : $e.pdispVal) )						; VT_DISPATCH
				#case 0xA ( #(ERROR   : $e.scode) )							; VT_ERROR
				#case 0xB ( #(BOOL   : $e.boolVal) )							; VT_BOOL
				#case 0xD ( #(UNKNOWN   : $e.punkVal) )						; VT_UNKNOWN
				#case 0xE ( #(DECIMAL  : $e.hVal) )							; VT_DECIMAL
				#case 0x10 ( #(I1   : $e.cVal) )								; VT_I1
				#case 0x11 ( #(UI1   : $e.bVal) )								; VT_UI1
				#case 0x12 ( #(UI2   : $e.uiVal) )							; VT_UI2
				#case 0x13 ( #(UI4   : $e.ulVal) )							; VT_UI4
				#case 0x14 ( #(I8   : $e.hVal) )								; VT_I8
				#case 0x15 ( #(UI8   : $e.uhVal) )							; VT_UI8
				#case 0x16 ( #(INT   : $e.intVal) )							; VT_INT
				#case 0x17 ( #(UINT  : $e.uintVal) )							; VT_UINT
				#case 0x1E ( #(LPSTR   : $e.pszVal) )							; VT_LPSTR
				#case 0x1F ( #(LPWSTR   : $e.pwszVal) )						; VT_LPWSTR
				#case 0x40 ( #(FILETIME   : $e.filetime) )					; VT_FILETIME
				#case 0x42 ( #(STREAM   : $e.pStream) )						; VT_STREAM
				#case 0x43 ( #(STORAGE  : $e.pStorage) )						; VT_STORAGE
				#case 0x44 ( #(STREAMED_OBJECT   : $e.pStream) )				; VT_STREAMED_OBJECT
				#case 0x45 ( #(STORED_OBJECT   : $e.pStorage) )				; VT_STORED_OBJECT
				#case 0x46 ( #(BLOB_OBJECT  : $e.blob ) )						; VT_BLOB_OBJECT
				#case 0x47 ( #(CF   : $e.pclipdata) )							; VT_CF
				#case 0x48 ( #(CLSID  : $e.puuid) )							; VT_CLSID
				#case 0x49 ( #(VERSIONED_STREAM  : $e.pVersionedStream) )		; VT_VERSIONED_STREAM
				
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Vector types                                           ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x1002 ( #(vector of I2  : $e.cai) )					; VT_I2|VT_VECTOR
				#case 0x1003 ( #(vector of I4  : $e.cal) )					; VT_I4|VT_VECTOR
				#case 0x1004 ( #(vector of R4  : $e.caflt) )					; VT_R4|VT_VECTOR
				#case 0x1005 ( #(vector of R8  : $e.cadbl) )					; VT_R8|VT_VECTOR
				#case 0x1010 ( #(vector of I1   : $e.cac) )					; VT_I1|VT_VECTOR
				#case 0x1011 ( #(vector of UI1   : $e.caub) )					; VT_UI1|VT_VECTOR
				#case 0x1012 ( #(vector of UI2   : $e.caui) )					; VT_UI2|VT_VECTOR
				#case 0x1013 ( #(vector of UI4   : $e.caul) )					; VT_UI4|VT_VECTOR
				#case 0x1014 ( #(vector of I8   : $e.cah) )					; VT_I8|VT_VECTOR
				#case 0x1015 ( #(vector of UI8   : $e.cauh) )					; VT_UI8|VT_VECTOR
				#case 0x101E ( #(vector of LPSTR   : $e.calpstr) )			; VT_LPSTR|VT_VECTOR
				#case 0x101F ( #(vector of LPWSTR   : $e.calpwstr) )			; VT_LPWSTR|VT_VECTOR
				#case 0x100C ( #(vector of VARIANT : $e.capropvar) )			; VT_VARIANT|VT_VECTOR
				#case 0x100B ( #(vector of BOOL   : $e.cabool) )				; VT_BOOL|VT_VECTOR
				#case 0x100A ( #(vector of ERROR   : $e.cascode) )			; VT_ERROR|VT_VECTOR
				#case 0x1006 ( #(vector of CY  : $e.cacy) )					; VT_CY|VT_VECTOR
				#case 0x1007 ( #(vector of DATE   : $e.cadate) )				; VT_DATE|VT_VECTOR
				#case 0x1040 ( #(vector of FILETIME   : $e.cafiletime) )		; VT_FILETIME|VT_VECTOR
				#case 0x1048 ( #(vector of CLSID  : $e.cauuid) )				; VT_CLSID|VT_VECTOR
				#case 0x1047 ( #(vector of CF   : $e.caclipdata) )			; VT_CF|VT_VECTOR
				#case 0x1008 ( #(vector of BSTR  : $e.cabstr) )				; VT_BSTR|VT_VECTOR

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;   Byref Types                                            ;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				#case 0x4016 ( #(byref of INT   : $e.pintVal) )				; VT_INT|VT_BYREF
				#case 0x4017 ( #(byref of UINT  : $e.puintVal) )				; VT_UINT|VT_BYREF
				#case 0x4002 ( #(byref of I2  : $e.piVal) )					; VT_I2|VT_BYREF
				#case 0x4003 ( #(byref of I4  : $e.plVal) )					; VT_I4|VT_BYREF
				#case 0x4004 ( #(byref of R4  : $e.pfltVal) )				; VT_R4|VT_BYREF
				#case 0x4005 ( #(byref of R8  : $e.pdblVal) )				; VT_R8|VT_BYREF
				#case 0x4010 ( #(byref of I1   : $e.pcVal) )					; VT_I1|VT_BYREF
				#case 0x4011 ( #(byref of UI1   : $e.pbVal) )				; VT_UI1|VT_BYREF
				#case 0x4012 ( #(byref of UI2   : $e.puiVal) )				; VT_UI2|VT_BYREF
				#case 0x4013 ( #(byref of UI4   : $e.pulVal) )				; VT_UI4|VT_BYREF
				#case 0x400C ( #(byref of VARIANT : $e.pvarVal) )			; VT_VARIANT|VT_BYREF
				#case 0x400B ( #(byref of BOOL   : $e.pboolVal) )			; VT_BOOL|VT_BYREF
				#case 0x400A ( #(byref of ERROR   : $e.pscode) )				; VT_ERROR|VT_BYREF
				#case 0x4006 ( #(byref of CY  : $e.pcyVal) )					; VT_CY|VT_BYREF
				#case 0x4007 ( #(byref of DATE   : $e.pdate) )				; VT_DATE|VT_BYREF
				#case 0x4008 ( #(byref of BSTR  : $e.pbstrVal) )				; VT_BSTR|VT_BYREF
				#case 0x400E ( #(byref of DECIMAL  : $e.pdecVal) )			; VT_DECIMAL|VT_BYREF
				#case 0x400D ( #(byref of UNKNOWN   : $e.ppunkVal) )			; VT_UNKNOWN|VT_BYREF
				#case 0x4009 ( #(byref of DISPATCH   : $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
				#case 0x6000 ( #(byref of ARRAY   : $e.pparray) )			; VT_ARRAY|VT_BYREF
				
				; the following are either empty or invalid vt values for a variant
				; #case 0 ( #(Empty :) )										; VT_EMPTY
				; #case 0x1 ( #(NULL :) )										; VT_NULL
				; #case 0xC ( #(VARIANT :) )									; VT_VARIANT
				; #case 0x18 ( #(VOID :) )										; VT_VOID
				; #case 0x19 ( #(HRESULT :) )									; VT_HRESULT
				; #case 0x1A ( #(PTR :) )										; VT_PTR
				; #case 0x1B ( #(SAFEARRAY :) )									; VT_SAFEARRAY
				; #case 0x1C ( #(CARRAY :) )									; VT_CARRAY
				; #case 0x1D ( #(USERDEFINED :) )								; VT_USERDEFINED
				; #case 0x24 ( #(RECORD  :) )									; VT_RECORD
				; #case 0x26 ( #(UINT_PTR :) )									; VT_UINT_PTR
							
				#default 
				( 
					#if ($e.vt & 0x2000 )
					(
						#(safearray: $e.parray)
					)
					#else
					(
						#(
							[raw members]: [$e,!]	; unformatted data members
						)
					)
				)							
				#except 
				( 
					#(
						[raw members]: [$e,!]	; unformatted data members
					)
				)							
	))
}

; This section lets you define your own errors for the HRESULT display.
; You need to list the error code in unsigned decimal, followed by the message.
; Changes will take effect the next time you redisplay the variable.
[hresult]
;1234=my custom error code



