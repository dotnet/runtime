//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//

/******************************************************************

DO NOT MODIFY. AUTOGENERATED FILE.
This file is generated using the logic from <root>/src/inc/genXplatLttng.pl

******************************************************************/


#define TRACEPOINT_DEFINE
#define TRACEPOINT_PROBE_DYNAMIC_LINKAGE
#include "lttng/tpdotnetruntime.h"
extern "C" BOOL  EventXplatEnabledGCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCStart(
                  const unsigned int Count,
                  const unsigned int Reason
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCStart()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCStart,
        Count,
        Reason
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCStart_V1(
                  const unsigned int Count,
                  const unsigned int Depth,
                  const unsigned int Reason,
                  const unsigned int Type,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCStart_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCStart_V1,
        Count,
        Depth,
        Reason,
        Type,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCStart_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCStart_V2(
                  const unsigned int Count,
                  const unsigned int Depth,
                  const unsigned int Reason,
                  const unsigned int Type,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ClientSequenceNumber
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCStart_V2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCStart_V2,
        Count,
        Depth,
        Reason,
        Type,
        ClrInstanceID,
        ClientSequenceNumber
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCEnd(
                  const unsigned int Count,
                  const unsigned short Depth
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCEnd()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCEnd,
        Count,
        Depth
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCEnd_V1(
                  const unsigned int Count,
                  const unsigned int Depth,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCEnd_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCEnd_V1,
        Count,
        Depth,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCRestartEEEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCRestartEEEnd(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCRestartEEEnd()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        GCRestartEEEnd
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCRestartEEEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCRestartEEEnd_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCRestartEEEnd_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCRestartEEEnd_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCHeapStats(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCHeapStats(
                  const unsigned __int64 GenerationSize0,
                  const unsigned __int64 TotalPromotedSize0,
                  const unsigned __int64 GenerationSize1,
                  const unsigned __int64 TotalPromotedSize1,
                  const unsigned __int64 GenerationSize2,
                  const unsigned __int64 TotalPromotedSize2,
                  const unsigned __int64 GenerationSize3,
                  const unsigned __int64 TotalPromotedSize3,
                  const unsigned __int64 FinalizationPromotedSize,
                  const unsigned __int64 FinalizationPromotedCount,
                  const unsigned int PinnedObjectCount,
                  const unsigned int SinkBlockCount,
                  const unsigned int GCHandleCount
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCHeapStats()){ return ERROR_SUCCESS;};

                                                    
     tracepoint(
        DotNETRuntime,
        GCHeapStats,
        GenerationSize0,
        TotalPromotedSize0,
        GenerationSize1,
        TotalPromotedSize1,
        GenerationSize2,
        TotalPromotedSize2,
        GenerationSize3,
        TotalPromotedSize3,
        FinalizationPromotedSize,
        FinalizationPromotedCount
        );

     tracepoint(
        DotNETRuntime,
        GCHeapStats_1,
        PinnedObjectCount,
        SinkBlockCount,
        GCHandleCount
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCHeapStats_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCHeapStats_V1(
                  const unsigned __int64 GenerationSize0,
                  const unsigned __int64 TotalPromotedSize0,
                  const unsigned __int64 GenerationSize1,
                  const unsigned __int64 TotalPromotedSize1,
                  const unsigned __int64 GenerationSize2,
                  const unsigned __int64 TotalPromotedSize2,
                  const unsigned __int64 GenerationSize3,
                  const unsigned __int64 TotalPromotedSize3,
                  const unsigned __int64 FinalizationPromotedSize,
                  const unsigned __int64 FinalizationPromotedCount,
                  const unsigned int PinnedObjectCount,
                  const unsigned int SinkBlockCount,
                  const unsigned int GCHandleCount,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCHeapStats_V1()){ return ERROR_SUCCESS;};

                                                    
     tracepoint(
        DotNETRuntime,
        GCHeapStats_V1,
        GenerationSize0,
        TotalPromotedSize0,
        GenerationSize1,
        TotalPromotedSize1,
        GenerationSize2,
        TotalPromotedSize2,
        GenerationSize3,
        TotalPromotedSize3,
        FinalizationPromotedSize,
        FinalizationPromotedCount
        );

     tracepoint(
        DotNETRuntime,
        GCHeapStats_V1_1,
        PinnedObjectCount,
        SinkBlockCount,
        GCHandleCount,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCCreateSegment(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCCreateSegment(
                  const unsigned __int64 Address,
                  const unsigned __int64 Size,
                  const unsigned int Type
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCCreateSegment()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCCreateSegment,
        Address,
        Size,
        Type
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCCreateSegment_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCCreateSegment_V1(
                  const unsigned __int64 Address,
                  const unsigned __int64 Size,
                  const unsigned int Type,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCCreateSegment_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCCreateSegment_V1,
        Address,
        Size,
        Type,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCFreeSegment(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCFreeSegment(
                  const unsigned __int64 Address
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCFreeSegment()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCFreeSegment,
        Address
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCFreeSegment_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCFreeSegment_V1(
                  const unsigned __int64 Address,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCFreeSegment_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCFreeSegment_V1,
        Address,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCRestartEEBegin(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCRestartEEBegin(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCRestartEEBegin()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        GCRestartEEBegin
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCRestartEEBegin_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCRestartEEBegin_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCRestartEEBegin_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCRestartEEBegin_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCSuspendEEEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCSuspendEEEnd(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCSuspendEEEnd()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        GCSuspendEEEnd
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCSuspendEEEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCSuspendEEEnd_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCSuspendEEEnd_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCSuspendEEEnd_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCSuspendEEBegin(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCSuspendEEBegin(
                  const unsigned short Reason
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCSuspendEEBegin()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCSuspendEEBegin,
        Reason
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCSuspendEEBegin_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCSuspendEEBegin_V1(
                  const unsigned int Reason,
                  const unsigned int Count,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCSuspendEEBegin_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCSuspendEEBegin_V1,
        Reason,
        Count,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCAllocationTick(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCAllocationTick(
                  const unsigned int AllocationAmount,
                  const unsigned int AllocationKind
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCAllocationTick()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCAllocationTick,
        AllocationAmount,
        AllocationKind
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCAllocationTick_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCAllocationTick_V1(
                  const unsigned int AllocationAmount,
                  const unsigned int AllocationKind,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCAllocationTick_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCAllocationTick_V1,
        AllocationAmount,
        AllocationKind,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCAllocationTick_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCAllocationTick_V2(
                  const unsigned int AllocationAmount,
                  const unsigned int AllocationKind,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 AllocationAmount64,
                  const void* TypeID,
                  PCWSTR TypeName,
                  const unsigned int HeapIndex
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCAllocationTick_V2()){ return ERROR_SUCCESS;};
    INT TypeName_path_size = -1;
    INT TypeName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, TypeName, -1, NULL, 0, NULL, NULL );
    CHAR* TypeName_full_name=NULL;

    TypeName_full_name = (CHAR*)malloc(TypeName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(TypeName_full_name != NULL);
    if(TypeName_full_name == NULL){goto LExit;}

    TypeName_path_size = WideCharToMultiByte( CP_ACP, 0, TypeName, -1, TypeName_full_name, TypeName_full_name_path_size, NULL, NULL );
    _ASSERTE(TypeName_path_size == TypeName_full_name_path_size );
    if( TypeName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        GCAllocationTick_V2,
        AllocationAmount,
        AllocationKind,
        ClrInstanceID,
        AllocationAmount64,
        (const size_t) TypeID,
        TypeName_full_name,
        HeapIndex
        );

        Error = ERROR_SUCCESS;
LExit:
        if (TypeName_full_name != NULL) {free(TypeName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledGCAllocationTick_V3(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCAllocationTick_V3(
                  const unsigned int AllocationAmount,
                  const unsigned int AllocationKind,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 AllocationAmount64,
                  const void* TypeID,
                  PCWSTR TypeName,
                  const unsigned int HeapIndex,
                  const void* Address
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCAllocationTick_V3()){ return ERROR_SUCCESS;};
    INT TypeName_path_size = -1;
    INT TypeName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, TypeName, -1, NULL, 0, NULL, NULL );
    CHAR* TypeName_full_name=NULL;

    TypeName_full_name = (CHAR*)malloc(TypeName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(TypeName_full_name != NULL);
    if(TypeName_full_name == NULL){goto LExit;}

    TypeName_path_size = WideCharToMultiByte( CP_ACP, 0, TypeName, -1, TypeName_full_name, TypeName_full_name_path_size, NULL, NULL );
    _ASSERTE(TypeName_path_size == TypeName_full_name_path_size );
    if( TypeName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        GCAllocationTick_V3,
        AllocationAmount,
        AllocationKind,
        ClrInstanceID,
        AllocationAmount64,
        (const size_t) TypeID,
        TypeName_full_name,
        HeapIndex,
        (const size_t) Address
        );

        Error = ERROR_SUCCESS;
LExit:
        if (TypeName_full_name != NULL) {free(TypeName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledGCCreateConcurrentThread(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCCreateConcurrentThread(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCCreateConcurrentThread()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        GCCreateConcurrentThread
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCCreateConcurrentThread_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCCreateConcurrentThread_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCCreateConcurrentThread_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCCreateConcurrentThread_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCTerminateConcurrentThread(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCTerminateConcurrentThread(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCTerminateConcurrentThread()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        GCTerminateConcurrentThread
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCTerminateConcurrentThread_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCTerminateConcurrentThread_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCTerminateConcurrentThread_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCTerminateConcurrentThread_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCFinalizersEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCFinalizersEnd(
                  const unsigned int Count
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCFinalizersEnd()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCFinalizersEnd,
        Count
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCFinalizersEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCFinalizersEnd_V1(
                  const unsigned int Count,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCFinalizersEnd_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCFinalizersEnd_V1,
        Count,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCFinalizersBegin(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCFinalizersBegin(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCFinalizersBegin()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        GCFinalizersBegin
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCFinalizersBegin_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCFinalizersBegin_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCFinalizersBegin_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCFinalizersBegin_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledBulkType(){ return TRUE;}
extern "C" ULONG  FireEtXplatBulkType(
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg2_Struct_Len_,
                  const void* Arg2_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledBulkType()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        BulkType,
        Count,
        ClrInstanceID,
        Arg2_Struct_Len_,
        (const int*) Arg2_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkRootEdge(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkRootEdge(
                  const unsigned int Index,
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg3_Struct_Len_,
                  const void* Arg3_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkRootEdge()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkRootEdge,
        Index,
        Count,
        ClrInstanceID,
        Arg3_Struct_Len_,
        (const int*) Arg3_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkRootConditionalWeakTableElementEdge(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkRootConditionalWeakTableElementEdge(
                  const unsigned int Index,
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg3_Struct_Len_,
                  const void* Arg3_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkRootConditionalWeakTableElementEdge()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkRootConditionalWeakTableElementEdge,
        Index,
        Count,
        ClrInstanceID,
        Arg3_Struct_Len_,
        (const int*) Arg3_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkNode(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkNode(
                  const unsigned int Index,
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg3_Struct_Len_,
                  const void* Arg3_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkNode()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkNode,
        Index,
        Count,
        ClrInstanceID,
        Arg3_Struct_Len_,
        (const int*) Arg3_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkEdge(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkEdge(
                  const unsigned int Index,
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg3_Struct_Len_,
                  const void* Arg3_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkEdge()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkEdge,
        Index,
        Count,
        ClrInstanceID,
        Arg3_Struct_Len_,
        (const int*) Arg3_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCSampledObjectAllocationHigh(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCSampledObjectAllocationHigh(
                  const void* Address,
                  const void* TypeID,
                  const unsigned int ObjectCountForTypeSample,
                  const unsigned __int64 TotalSizeForTypeSample,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCSampledObjectAllocationHigh()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCSampledObjectAllocationHigh,
        (const size_t) Address,
        (const size_t) TypeID,
        ObjectCountForTypeSample,
        TotalSizeForTypeSample,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkSurvivingObjectRanges(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkSurvivingObjectRanges(
                  const unsigned int Index,
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg3_Struct_Len_,
                  const void* Arg3_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkSurvivingObjectRanges()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkSurvivingObjectRanges,
        Index,
        Count,
        ClrInstanceID,
        Arg3_Struct_Len_,
        (const int*) Arg3_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkMovedObjectRanges(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkMovedObjectRanges(
                  const unsigned int Index,
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg3_Struct_Len_,
                  const void* Arg3_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkMovedObjectRanges()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkMovedObjectRanges,
        Index,
        Count,
        ClrInstanceID,
        Arg3_Struct_Len_,
        (const int*) Arg3_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCGenerationRange(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCGenerationRange(
                  const unsigned char Generation,
                  const void* RangeStart,
                  const unsigned __int64 RangeUsedLength,
                  const unsigned __int64 RangeReservedLength,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCGenerationRange()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCGenerationRange,
        Generation,
        (const size_t) RangeStart,
        RangeUsedLength,
        RangeReservedLength,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCMarkStackRoots(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCMarkStackRoots(
                  const unsigned int HeapNum,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCMarkStackRoots()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCMarkStackRoots,
        HeapNum,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCMarkFinalizeQueueRoots(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCMarkFinalizeQueueRoots(
                  const unsigned int HeapNum,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCMarkFinalizeQueueRoots()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCMarkFinalizeQueueRoots,
        HeapNum,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCMarkHandles(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCMarkHandles(
                  const unsigned int HeapNum,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCMarkHandles()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCMarkHandles,
        HeapNum,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCMarkOlderGenerationRoots(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCMarkOlderGenerationRoots(
                  const unsigned int HeapNum,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCMarkOlderGenerationRoots()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCMarkOlderGenerationRoots,
        HeapNum,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledFinalizeObject(){ return TRUE;}
extern "C" ULONG  FireEtXplatFinalizeObject(
                  const void* TypeID,
                  const void* ObjectID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledFinalizeObject()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        FinalizeObject,
        (const size_t) TypeID,
        (const size_t) ObjectID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledSetGCHandle(){ return TRUE;}
extern "C" ULONG  FireEtXplatSetGCHandle(
                  const void* HandleID,
                  const void* ObjectID,
                  const unsigned int Kind,
                  const unsigned int Generation,
                  const unsigned __int64 AppDomainID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledSetGCHandle()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        SetGCHandle,
        (const size_t) HandleID,
        (const size_t) ObjectID,
        Kind,
        Generation,
        AppDomainID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDestroyGCHandle(){ return TRUE;}
extern "C" ULONG  FireEtXplatDestroyGCHandle(
                  const void* HandleID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDestroyGCHandle()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        DestroyGCHandle,
        (const size_t) HandleID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCSampledObjectAllocationLow(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCSampledObjectAllocationLow(
                  const void* Address,
                  const void* TypeID,
                  const unsigned int ObjectCountForTypeSample,
                  const unsigned __int64 TotalSizeForTypeSample,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCSampledObjectAllocationLow()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCSampledObjectAllocationLow,
        (const size_t) Address,
        (const size_t) TypeID,
        ObjectCountForTypeSample,
        TotalSizeForTypeSample,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledPinObjectAtGCTime(){ return TRUE;}
extern "C" ULONG  FireEtXplatPinObjectAtGCTime(
                  const void* HandleID,
                  const void* ObjectID,
                  const unsigned __int64 ObjectSize,
                  PCWSTR TypeName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledPinObjectAtGCTime()){ return ERROR_SUCCESS;};
    INT TypeName_path_size = -1;
    INT TypeName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, TypeName, -1, NULL, 0, NULL, NULL );
    CHAR* TypeName_full_name=NULL;

    TypeName_full_name = (CHAR*)malloc(TypeName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(TypeName_full_name != NULL);
    if(TypeName_full_name == NULL){goto LExit;}

    TypeName_path_size = WideCharToMultiByte( CP_ACP, 0, TypeName, -1, TypeName_full_name, TypeName_full_name_path_size, NULL, NULL );
    _ASSERTE(TypeName_path_size == TypeName_full_name_path_size );
    if( TypeName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        PinObjectAtGCTime,
        (const size_t) HandleID,
        (const size_t) ObjectID,
        ObjectSize,
        TypeName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (TypeName_full_name != NULL) {free(TypeName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledGCTriggered(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCTriggered(
                  const unsigned int Reason,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCTriggered()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCTriggered,
        Reason,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkRootCCW(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkRootCCW(
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg2_Struct_Len_,
                  const void* Arg2_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkRootCCW()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkRootCCW,
        Count,
        ClrInstanceID,
        Arg2_Struct_Len_,
        (const int*) Arg2_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkRCW(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkRCW(
                  const unsigned int Count,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg2_Struct_Len_,
                  const void* Arg2_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkRCW()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkRCW,
        Count,
        ClrInstanceID,
        Arg2_Struct_Len_,
        (const int*) Arg2_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCBulkRootStaticVar(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCBulkRootStaticVar(
                  const unsigned int Count,
                  const unsigned __int64 AppDomainID,
                  const unsigned short ClrInstanceID,
                  const ULONG Arg3_Struct_Len_,
                  const void* Arg3_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCBulkRootStaticVar()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCBulkRootStaticVar,
        Count,
        AppDomainID,
        ClrInstanceID,
        Arg3_Struct_Len_,
        (const int*) Arg3_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledWorkerThreadCreate(){ return TRUE;}
extern "C" ULONG  FireEtXplatWorkerThreadCreate(
                  const unsigned int WorkerThreadCount,
                  const unsigned int RetiredWorkerThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledWorkerThreadCreate()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        WorkerThreadCreate,
        WorkerThreadCount,
        RetiredWorkerThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledWorkerThreadTerminate(){ return TRUE;}
extern "C" ULONG  FireEtXplatWorkerThreadTerminate(
                  const unsigned int WorkerThreadCount,
                  const unsigned int RetiredWorkerThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledWorkerThreadTerminate()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        WorkerThreadTerminate,
        WorkerThreadCount,
        RetiredWorkerThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledWorkerThreadRetire(){ return TRUE;}
extern "C" ULONG  FireEtXplatWorkerThreadRetire(
                  const unsigned int WorkerThreadCount,
                  const unsigned int RetiredWorkerThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledWorkerThreadRetire()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        WorkerThreadRetire,
        WorkerThreadCount,
        RetiredWorkerThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledWorkerThreadUnretire(){ return TRUE;}
extern "C" ULONG  FireEtXplatWorkerThreadUnretire(
                  const unsigned int WorkerThreadCount,
                  const unsigned int RetiredWorkerThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledWorkerThreadUnretire()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        WorkerThreadUnretire,
        WorkerThreadCount,
        RetiredWorkerThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadCreate(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadCreate(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadCreate()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadCreate,
        IOThreadCount,
        RetiredIOThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadCreate_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadCreate_V1(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadCreate_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadCreate_V1,
        IOThreadCount,
        RetiredIOThreads,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadTerminate(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadTerminate(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadTerminate()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadTerminate,
        IOThreadCount,
        RetiredIOThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadTerminate_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadTerminate_V1(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadTerminate_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadTerminate_V1,
        IOThreadCount,
        RetiredIOThreads,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadRetire(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadRetire(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadRetire()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadRetire,
        IOThreadCount,
        RetiredIOThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadRetire_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadRetire_V1(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadRetire_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadRetire_V1,
        IOThreadCount,
        RetiredIOThreads,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadUnretire(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadUnretire(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadUnretire()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadUnretire,
        IOThreadCount,
        RetiredIOThreads
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledIOThreadUnretire_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatIOThreadUnretire_V1(
                  const unsigned int IOThreadCount,
                  const unsigned int RetiredIOThreads,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIOThreadUnretire_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IOThreadUnretire_V1,
        IOThreadCount,
        RetiredIOThreads,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadpoolSuspensionSuspendThread(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadpoolSuspensionSuspendThread(
                  const unsigned int ClrThreadID,
                  const unsigned int CpuUtilization
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadpoolSuspensionSuspendThread()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadpoolSuspensionSuspendThread,
        ClrThreadID,
        CpuUtilization
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadpoolSuspensionResumeThread(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadpoolSuspensionResumeThread(
                  const unsigned int ClrThreadID,
                  const unsigned int CpuUtilization
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadpoolSuspensionResumeThread()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadpoolSuspensionResumeThread,
        ClrThreadID,
        CpuUtilization
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadStart(
                  const unsigned int ActiveWorkerThreadCount,
                  const unsigned int RetiredWorkerThreadCount,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadStart()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadStart,
        ActiveWorkerThreadCount,
        RetiredWorkerThreadCount,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadStop(
                  const unsigned int ActiveWorkerThreadCount,
                  const unsigned int RetiredWorkerThreadCount,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadStop()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadStop,
        ActiveWorkerThreadCount,
        RetiredWorkerThreadCount,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadRetirementStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadRetirementStart(
                  const unsigned int ActiveWorkerThreadCount,
                  const unsigned int RetiredWorkerThreadCount,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadRetirementStart()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadRetirementStart,
        ActiveWorkerThreadCount,
        RetiredWorkerThreadCount,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadRetirementStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadRetirementStop(
                  const unsigned int ActiveWorkerThreadCount,
                  const unsigned int RetiredWorkerThreadCount,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadRetirementStop()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadRetirementStop,
        ActiveWorkerThreadCount,
        RetiredWorkerThreadCount,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadAdjustmentSample(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadAdjustmentSample(
                  const double Throughput,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadAdjustmentSample()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadAdjustmentSample,
        Throughput,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadAdjustmentAdjustment(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadAdjustmentAdjustment(
                  const double AverageThroughput,
                  const unsigned int NewWorkerThreadCount,
                  const unsigned int Reason,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadAdjustmentAdjustment()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadAdjustmentAdjustment,
        AverageThroughput,
        NewWorkerThreadCount,
        Reason,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadAdjustmentStats(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadAdjustmentStats(
                  const double Duration,
                  const double Throughput,
                  const double ThreadWave,
                  const double ThroughputWave,
                  const double ThroughputErrorEstimate,
                  const double AverageThroughputErrorEstimate,
                  const double ThroughputRatio,
                  const double Confidence,
                  const double NewControlSetting,
                  const unsigned short NewThreadWaveMagnitude,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadAdjustmentStats()){ return ERROR_SUCCESS;};

                                                    
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadAdjustmentStats,
        Duration,
        Throughput,
        ThreadWave,
        ThroughputWave,
        ThroughputErrorEstimate,
        AverageThroughputErrorEstimate,
        ThroughputRatio,
        Confidence,
        NewControlSetting,
        NewThreadWaveMagnitude
        );

     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadAdjustmentStats_1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkerThreadWait(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkerThreadWait(
                  const unsigned int ActiveWorkerThreadCount,
                  const unsigned int RetiredWorkerThreadCount,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkerThreadWait()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkerThreadWait,
        ActiveWorkerThreadCount,
        RetiredWorkerThreadCount,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolWorkingThreadCount(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolWorkingThreadCount(
                  const unsigned int Count,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolWorkingThreadCount()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolWorkingThreadCount,
        Count,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolEnqueue(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolEnqueue(
                  const void* WorkID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolEnqueue()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolEnqueue,
        (const size_t) WorkID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolDequeue(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolDequeue(
                  const void* WorkID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolDequeue()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolDequeue,
        (const size_t) WorkID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolIOEnqueue(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolIOEnqueue(
                  const void* NativeOverlapped,
                  const void* Overlapped,
                  const BOOL MultiDequeues,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolIOEnqueue()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolIOEnqueue,
        (const size_t) NativeOverlapped,
        (const size_t) Overlapped,
        MultiDequeues,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolIODequeue(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolIODequeue(
                  const void* NativeOverlapped,
                  const void* Overlapped,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolIODequeue()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolIODequeue,
        (const size_t) NativeOverlapped,
        (const size_t) Overlapped,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadPoolIOPack(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadPoolIOPack(
                  const void* NativeOverlapped,
                  const void* Overlapped,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadPoolIOPack()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadPoolIOPack,
        (const size_t) NativeOverlapped,
        (const size_t) Overlapped,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadCreating(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadCreating(
                  const void* ID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadCreating()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadCreating,
        (const size_t) ID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadRunning(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadRunning(
                  const void* ID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadRunning()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadRunning,
        (const size_t) ID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionThrown(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionThrown(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionThrown()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        ExceptionThrown
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionThrown_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionThrown_V1(
                  PCWSTR ExceptionType,
                  PCWSTR ExceptionMessage,
                  const void* ExceptionEIP,
                  const unsigned int ExceptionHRESULT,
                  const unsigned short ExceptionFlags,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionThrown_V1()){ return ERROR_SUCCESS;};
    INT ExceptionType_path_size = -1;
    INT ExceptionType_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ExceptionType, -1, NULL, 0, NULL, NULL );
    CHAR* ExceptionType_full_name=NULL;
    INT ExceptionMessage_path_size = -1;
    INT ExceptionMessage_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ExceptionMessage, -1, NULL, 0, NULL, NULL );
    CHAR* ExceptionMessage_full_name=NULL;

    ExceptionType_full_name = (CHAR*)malloc(ExceptionType_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ExceptionType_full_name != NULL);
    if(ExceptionType_full_name == NULL){goto LExit;}

    ExceptionType_path_size = WideCharToMultiByte( CP_ACP, 0, ExceptionType, -1, ExceptionType_full_name, ExceptionType_full_name_path_size, NULL, NULL );
    _ASSERTE(ExceptionType_path_size == ExceptionType_full_name_path_size );
    if( ExceptionType_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ExceptionMessage_full_name = (CHAR*)malloc(ExceptionMessage_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ExceptionMessage_full_name != NULL);
    if(ExceptionMessage_full_name == NULL){goto LExit;}

    ExceptionMessage_path_size = WideCharToMultiByte( CP_ACP, 0, ExceptionMessage, -1, ExceptionMessage_full_name, ExceptionMessage_full_name_path_size, NULL, NULL );
    _ASSERTE(ExceptionMessage_path_size == ExceptionMessage_full_name_path_size );
    if( ExceptionMessage_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ExceptionThrown_V1,
        ExceptionType_full_name,
        ExceptionMessage_full_name,
        (const size_t) ExceptionEIP,
        ExceptionHRESULT,
        ExceptionFlags,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ExceptionMessage_full_name != NULL) {free(ExceptionMessage_full_name);}
        if (ExceptionType_full_name != NULL) {free(ExceptionType_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionCatchStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionCatchStart(
                  const unsigned __int64 EntryEIP,
                  const unsigned __int64 MethodID,
                  PCWSTR MethodName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionCatchStart()){ return ERROR_SUCCESS;};
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;

    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ExceptionCatchStart,
        EntryEIP,
        MethodID,
        MethodName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionCatchStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionCatchStop(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionCatchStop()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        ExceptionCatchStop
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionFinallyStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionFinallyStart(
                  const unsigned __int64 EntryEIP,
                  const unsigned __int64 MethodID,
                  PCWSTR MethodName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionFinallyStart()){ return ERROR_SUCCESS;};
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;

    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ExceptionFinallyStart,
        EntryEIP,
        MethodID,
        MethodName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionFinallyStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionFinallyStop(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionFinallyStop()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        ExceptionFinallyStop
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionFilterStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionFilterStart(
                  const unsigned __int64 EntryEIP,
                  const unsigned __int64 MethodID,
                  PCWSTR MethodName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionFilterStart()){ return ERROR_SUCCESS;};
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;

    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ExceptionFilterStart,
        EntryEIP,
        MethodID,
        MethodName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionFilterStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionFilterStop(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionFilterStop()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        ExceptionFilterStop
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledExceptionThrownStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatExceptionThrownStop(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledExceptionThrownStop()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        ExceptionThrownStop
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledContention(){ return TRUE;}
extern "C" ULONG  FireEtXplatContention(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledContention()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        Contention
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledContentionStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatContentionStart_V1(
                  const unsigned char ContentionFlags,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledContentionStart_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ContentionStart_V1,
        ContentionFlags,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledContentionStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatContentionStop(
                  const unsigned char ContentionFlags,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledContentionStop()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ContentionStop,
        ContentionFlags,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledCLRStackWalk(){ return TRUE;}
extern "C" ULONG  FireEtXplatCLRStackWalk(
                  const unsigned short ClrInstanceID,
                  const unsigned char Reserved1,
                  const unsigned char Reserved2,
                  const unsigned int FrameCount,
                  const void** Stack
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledCLRStackWalk()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        CLRStackWalk,
        ClrInstanceID,
        Reserved1,
        Reserved2,
        FrameCount,
        (const size_t*) Stack
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainMemAllocated(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainMemAllocated(
                  const unsigned __int64 AppDomainID,
                  const unsigned __int64 Allocated,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainMemAllocated()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        AppDomainMemAllocated,
        AppDomainID,
        Allocated,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainMemSurvived(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainMemSurvived(
                  const unsigned __int64 AppDomainID,
                  const unsigned __int64 Survived,
                  const unsigned __int64 ProcessSurvived,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainMemSurvived()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        AppDomainMemSurvived,
        AppDomainID,
        Survived,
        ProcessSurvived,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadCreated(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadCreated(
                  const unsigned __int64 ManagedThreadID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int Flags,
                  const unsigned int ManagedThreadIndex,
                  const unsigned int OSThreadID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadCreated()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadCreated,
        ManagedThreadID,
        AppDomainID,
        Flags,
        ManagedThreadIndex,
        OSThreadID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadTerminated(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadTerminated(
                  const unsigned __int64 ManagedThreadID,
                  const unsigned __int64 AppDomainID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadTerminated()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadTerminated,
        ManagedThreadID,
        AppDomainID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadDomainEnter(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadDomainEnter(
                  const unsigned __int64 ManagedThreadID,
                  const unsigned __int64 AppDomainID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadDomainEnter()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ThreadDomainEnter,
        ManagedThreadID,
        AppDomainID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledILStubGenerated(){ return TRUE;}
extern "C" ULONG  FireEtXplatILStubGenerated(
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 StubMethodID,
                  const unsigned int StubFlags,
                  const unsigned int ManagedInteropMethodToken,
                  PCWSTR ManagedInteropMethodNamespace,
                  PCWSTR ManagedInteropMethodName,
                  PCWSTR ManagedInteropMethodSignature,
                  PCWSTR NativeMethodSignature,
                  PCWSTR StubMethodSignature,
                  PCWSTR StubMethodILCode
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledILStubGenerated()){ return ERROR_SUCCESS;};
    INT ManagedInteropMethodNamespace_path_size = -1;
    INT ManagedInteropMethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedInteropMethodNamespace_full_name=NULL;
    INT ManagedInteropMethodName_path_size = -1;
    INT ManagedInteropMethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodName, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedInteropMethodName_full_name=NULL;
    INT ManagedInteropMethodSignature_path_size = -1;
    INT ManagedInteropMethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedInteropMethodSignature_full_name=NULL;
    INT NativeMethodSignature_path_size = -1;
    INT NativeMethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, NativeMethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* NativeMethodSignature_full_name=NULL;
    INT StubMethodSignature_path_size = -1;
    INT StubMethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, StubMethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* StubMethodSignature_full_name=NULL;
    INT StubMethodILCode_path_size = -1;
    INT StubMethodILCode_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, StubMethodILCode, -1, NULL, 0, NULL, NULL );
    CHAR* StubMethodILCode_full_name=NULL;

    ManagedInteropMethodNamespace_full_name = (CHAR*)malloc(ManagedInteropMethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedInteropMethodNamespace_full_name != NULL);
    if(ManagedInteropMethodNamespace_full_name == NULL){goto LExit;}

    ManagedInteropMethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodNamespace, -1, ManagedInteropMethodNamespace_full_name, ManagedInteropMethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedInteropMethodNamespace_path_size == ManagedInteropMethodNamespace_full_name_path_size );
    if( ManagedInteropMethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedInteropMethodName_full_name = (CHAR*)malloc(ManagedInteropMethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedInteropMethodName_full_name != NULL);
    if(ManagedInteropMethodName_full_name == NULL){goto LExit;}

    ManagedInteropMethodName_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodName, -1, ManagedInteropMethodName_full_name, ManagedInteropMethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedInteropMethodName_path_size == ManagedInteropMethodName_full_name_path_size );
    if( ManagedInteropMethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedInteropMethodSignature_full_name = (CHAR*)malloc(ManagedInteropMethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedInteropMethodSignature_full_name != NULL);
    if(ManagedInteropMethodSignature_full_name == NULL){goto LExit;}

    ManagedInteropMethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodSignature, -1, ManagedInteropMethodSignature_full_name, ManagedInteropMethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedInteropMethodSignature_path_size == ManagedInteropMethodSignature_full_name_path_size );
    if( ManagedInteropMethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    NativeMethodSignature_full_name = (CHAR*)malloc(NativeMethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(NativeMethodSignature_full_name != NULL);
    if(NativeMethodSignature_full_name == NULL){goto LExit;}

    NativeMethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, NativeMethodSignature, -1, NativeMethodSignature_full_name, NativeMethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(NativeMethodSignature_path_size == NativeMethodSignature_full_name_path_size );
    if( NativeMethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    StubMethodSignature_full_name = (CHAR*)malloc(StubMethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(StubMethodSignature_full_name != NULL);
    if(StubMethodSignature_full_name == NULL){goto LExit;}

    StubMethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, StubMethodSignature, -1, StubMethodSignature_full_name, StubMethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(StubMethodSignature_path_size == StubMethodSignature_full_name_path_size );
    if( StubMethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    StubMethodILCode_full_name = (CHAR*)malloc(StubMethodILCode_full_name_path_size*sizeof(CHAR));
    _ASSERTE(StubMethodILCode_full_name != NULL);
    if(StubMethodILCode_full_name == NULL){goto LExit;}

    StubMethodILCode_path_size = WideCharToMultiByte( CP_ACP, 0, StubMethodILCode, -1, StubMethodILCode_full_name, StubMethodILCode_full_name_path_size, NULL, NULL );
    _ASSERTE(StubMethodILCode_path_size == StubMethodILCode_full_name_path_size );
    if( StubMethodILCode_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        ILStubGenerated,
        ClrInstanceID,
        ModuleID,
        StubMethodID,
        StubFlags,
        ManagedInteropMethodToken,
        ManagedInteropMethodNamespace_full_name,
        ManagedInteropMethodName_full_name,
        ManagedInteropMethodSignature_full_name,
        NativeMethodSignature_full_name,
        StubMethodSignature_full_name
        );

     tracepoint(
        DotNETRuntime,
        ILStubGenerated_1,
        StubMethodILCode_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (StubMethodILCode_full_name != NULL) {free(StubMethodILCode_full_name);}
        if (StubMethodSignature_full_name != NULL) {free(StubMethodSignature_full_name);}
        if (NativeMethodSignature_full_name != NULL) {free(NativeMethodSignature_full_name);}
        if (ManagedInteropMethodSignature_full_name != NULL) {free(ManagedInteropMethodSignature_full_name);}
        if (ManagedInteropMethodName_full_name != NULL) {free(ManagedInteropMethodName_full_name);}
        if (ManagedInteropMethodNamespace_full_name != NULL) {free(ManagedInteropMethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledILStubCacheHit(){ return TRUE;}
extern "C" ULONG  FireEtXplatILStubCacheHit(
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 StubMethodID,
                  const unsigned int ManagedInteropMethodToken,
                  PCWSTR ManagedInteropMethodNamespace,
                  PCWSTR ManagedInteropMethodName,
                  PCWSTR ManagedInteropMethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledILStubCacheHit()){ return ERROR_SUCCESS;};
    INT ManagedInteropMethodNamespace_path_size = -1;
    INT ManagedInteropMethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedInteropMethodNamespace_full_name=NULL;
    INT ManagedInteropMethodName_path_size = -1;
    INT ManagedInteropMethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodName, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedInteropMethodName_full_name=NULL;
    INT ManagedInteropMethodSignature_path_size = -1;
    INT ManagedInteropMethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedInteropMethodSignature_full_name=NULL;

    ManagedInteropMethodNamespace_full_name = (CHAR*)malloc(ManagedInteropMethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedInteropMethodNamespace_full_name != NULL);
    if(ManagedInteropMethodNamespace_full_name == NULL){goto LExit;}

    ManagedInteropMethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodNamespace, -1, ManagedInteropMethodNamespace_full_name, ManagedInteropMethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedInteropMethodNamespace_path_size == ManagedInteropMethodNamespace_full_name_path_size );
    if( ManagedInteropMethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedInteropMethodName_full_name = (CHAR*)malloc(ManagedInteropMethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedInteropMethodName_full_name != NULL);
    if(ManagedInteropMethodName_full_name == NULL){goto LExit;}

    ManagedInteropMethodName_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodName, -1, ManagedInteropMethodName_full_name, ManagedInteropMethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedInteropMethodName_path_size == ManagedInteropMethodName_full_name_path_size );
    if( ManagedInteropMethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedInteropMethodSignature_full_name = (CHAR*)malloc(ManagedInteropMethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedInteropMethodSignature_full_name != NULL);
    if(ManagedInteropMethodSignature_full_name == NULL){goto LExit;}

    ManagedInteropMethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedInteropMethodSignature, -1, ManagedInteropMethodSignature_full_name, ManagedInteropMethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedInteropMethodSignature_path_size == ManagedInteropMethodSignature_full_name_path_size );
    if( ManagedInteropMethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ILStubCacheHit,
        ClrInstanceID,
        ModuleID,
        StubMethodID,
        ManagedInteropMethodToken,
        ManagedInteropMethodNamespace_full_name,
        ManagedInteropMethodName_full_name,
        ManagedInteropMethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ManagedInteropMethodSignature_full_name != NULL) {free(ManagedInteropMethodSignature_full_name);}
        if (ManagedInteropMethodName_full_name != NULL) {free(ManagedInteropMethodName_full_name);}
        if (ManagedInteropMethodNamespace_full_name != NULL) {free(ManagedInteropMethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledDCStartCompleteV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCStartCompleteV2(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCStartCompleteV2()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        DCStartCompleteV2
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCEndCompleteV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCEndCompleteV2(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCEndCompleteV2()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        DCEndCompleteV2
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStartV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStartV2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStartV2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodDCStartV2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEndV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEndV2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEndV2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodDCEndV2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStartVerboseV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStartVerboseV2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStartVerboseV2()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodDCStartVerboseV2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEndVerboseV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEndVerboseV2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEndVerboseV2()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodDCEndVerboseV2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodLoad(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodLoad(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodLoad()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodLoad,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodLoad_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodLoad_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodLoad_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodLoad_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodLoad_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodLoad_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodLoad_V2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodLoad_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID,
        ReJITID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodUnload(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodUnload(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodUnload()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodUnload,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodUnload_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodUnload_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodUnload_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodUnload_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodUnload_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodUnload_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodUnload_V2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodUnload_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID,
        ReJITID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodLoadVerbose(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodLoadVerbose(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodLoadVerbose()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodLoadVerbose,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodLoadVerbose_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodLoadVerbose_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodLoadVerbose_V1()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodLoadVerbose_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodLoadVerbose_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodLoadVerbose_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodLoadVerbose_V2()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        MethodLoadVerbose_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

     tracepoint(
        DotNETRuntime,
        MethodLoadVerbose_V2_1,
        ReJITID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodUnloadVerbose(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodUnloadVerbose(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodUnloadVerbose()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodUnloadVerbose,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodUnloadVerbose_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodUnloadVerbose_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodUnloadVerbose_V1()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodUnloadVerbose_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodUnloadVerbose_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodUnloadVerbose_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodUnloadVerbose_V2()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        MethodUnloadVerbose_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

     tracepoint(
        DotNETRuntime,
        MethodUnloadVerbose_V2_1,
        ReJITID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodJittingStarted(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodJittingStarted(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned int MethodToken,
                  const unsigned int MethodILSize,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodJittingStarted()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodJittingStarted,
        MethodID,
        ModuleID,
        MethodToken,
        MethodILSize,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodJittingStarted_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodJittingStarted_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned int MethodToken,
                  const unsigned int MethodILSize,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodJittingStarted_V1()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodJittingStarted_V1,
        MethodID,
        ModuleID,
        MethodToken,
        MethodILSize,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodJitInliningSucceeded(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodJitInliningSucceeded(
                  PCWSTR MethodBeingCompiledNamespace,
                  PCWSTR MethodBeingCompiledName,
                  PCWSTR MethodBeingCompiledNameSignature,
                  PCWSTR InlinerNamespace,
                  PCWSTR InlinerName,
                  PCWSTR InlinerNameSignature,
                  PCWSTR InlineeNamespace,
                  PCWSTR InlineeName,
                  PCWSTR InlineeNameSignature,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodJitInliningSucceeded()){ return ERROR_SUCCESS;};
    INT MethodBeingCompiledNamespace_path_size = -1;
    INT MethodBeingCompiledNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNamespace_full_name=NULL;
    INT MethodBeingCompiledName_path_size = -1;
    INT MethodBeingCompiledName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledName_full_name=NULL;
    INT MethodBeingCompiledNameSignature_path_size = -1;
    INT MethodBeingCompiledNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNameSignature_full_name=NULL;
    INT InlinerNamespace_path_size = -1;
    INT InlinerNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* InlinerNamespace_full_name=NULL;
    INT InlinerName_path_size = -1;
    INT InlinerName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerName, -1, NULL, 0, NULL, NULL );
    CHAR* InlinerName_full_name=NULL;
    INT InlinerNameSignature_path_size = -1;
    INT InlinerNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* InlinerNameSignature_full_name=NULL;
    INT InlineeNamespace_path_size = -1;
    INT InlineeNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* InlineeNamespace_full_name=NULL;
    INT InlineeName_path_size = -1;
    INT InlineeName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeName, -1, NULL, 0, NULL, NULL );
    CHAR* InlineeName_full_name=NULL;
    INT InlineeNameSignature_path_size = -1;
    INT InlineeNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* InlineeNameSignature_full_name=NULL;

    MethodBeingCompiledNamespace_full_name = (CHAR*)malloc(MethodBeingCompiledNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNamespace_full_name != NULL);
    if(MethodBeingCompiledNamespace_full_name == NULL){goto LExit;}

    MethodBeingCompiledNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, MethodBeingCompiledNamespace_full_name, MethodBeingCompiledNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNamespace_path_size == MethodBeingCompiledNamespace_full_name_path_size );
    if( MethodBeingCompiledNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledName_full_name = (CHAR*)malloc(MethodBeingCompiledName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledName_full_name != NULL);
    if(MethodBeingCompiledName_full_name == NULL){goto LExit;}

    MethodBeingCompiledName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, MethodBeingCompiledName_full_name, MethodBeingCompiledName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledName_path_size == MethodBeingCompiledName_full_name_path_size );
    if( MethodBeingCompiledName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledNameSignature_full_name = (CHAR*)malloc(MethodBeingCompiledNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNameSignature_full_name != NULL);
    if(MethodBeingCompiledNameSignature_full_name == NULL){goto LExit;}

    MethodBeingCompiledNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, MethodBeingCompiledNameSignature_full_name, MethodBeingCompiledNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNameSignature_path_size == MethodBeingCompiledNameSignature_full_name_path_size );
    if( MethodBeingCompiledNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlinerNamespace_full_name = (CHAR*)malloc(InlinerNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlinerNamespace_full_name != NULL);
    if(InlinerNamespace_full_name == NULL){goto LExit;}

    InlinerNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNamespace, -1, InlinerNamespace_full_name, InlinerNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(InlinerNamespace_path_size == InlinerNamespace_full_name_path_size );
    if( InlinerNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlinerName_full_name = (CHAR*)malloc(InlinerName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlinerName_full_name != NULL);
    if(InlinerName_full_name == NULL){goto LExit;}

    InlinerName_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerName, -1, InlinerName_full_name, InlinerName_full_name_path_size, NULL, NULL );
    _ASSERTE(InlinerName_path_size == InlinerName_full_name_path_size );
    if( InlinerName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlinerNameSignature_full_name = (CHAR*)malloc(InlinerNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlinerNameSignature_full_name != NULL);
    if(InlinerNameSignature_full_name == NULL){goto LExit;}

    InlinerNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNameSignature, -1, InlinerNameSignature_full_name, InlinerNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(InlinerNameSignature_path_size == InlinerNameSignature_full_name_path_size );
    if( InlinerNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlineeNamespace_full_name = (CHAR*)malloc(InlineeNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlineeNamespace_full_name != NULL);
    if(InlineeNamespace_full_name == NULL){goto LExit;}

    InlineeNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNamespace, -1, InlineeNamespace_full_name, InlineeNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(InlineeNamespace_path_size == InlineeNamespace_full_name_path_size );
    if( InlineeNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlineeName_full_name = (CHAR*)malloc(InlineeName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlineeName_full_name != NULL);
    if(InlineeName_full_name == NULL){goto LExit;}

    InlineeName_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeName, -1, InlineeName_full_name, InlineeName_full_name_path_size, NULL, NULL );
    _ASSERTE(InlineeName_path_size == InlineeName_full_name_path_size );
    if( InlineeName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlineeNameSignature_full_name = (CHAR*)malloc(InlineeNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlineeNameSignature_full_name != NULL);
    if(InlineeNameSignature_full_name == NULL){goto LExit;}

    InlineeNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNameSignature, -1, InlineeNameSignature_full_name, InlineeNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(InlineeNameSignature_path_size == InlineeNameSignature_full_name_path_size );
    if( InlineeNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        MethodJitInliningSucceeded,
        MethodBeingCompiledNamespace_full_name,
        MethodBeingCompiledName_full_name,
        MethodBeingCompiledNameSignature_full_name,
        InlinerNamespace_full_name,
        InlinerName_full_name,
        InlinerNameSignature_full_name,
        InlineeNamespace_full_name,
        InlineeName_full_name,
        InlineeNameSignature_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (InlineeNameSignature_full_name != NULL) {free(InlineeNameSignature_full_name);}
        if (InlineeName_full_name != NULL) {free(InlineeName_full_name);}
        if (InlineeNamespace_full_name != NULL) {free(InlineeNamespace_full_name);}
        if (InlinerNameSignature_full_name != NULL) {free(InlinerNameSignature_full_name);}
        if (InlinerName_full_name != NULL) {free(InlinerName_full_name);}
        if (InlinerNamespace_full_name != NULL) {free(InlinerNamespace_full_name);}
        if (MethodBeingCompiledNameSignature_full_name != NULL) {free(MethodBeingCompiledNameSignature_full_name);}
        if (MethodBeingCompiledName_full_name != NULL) {free(MethodBeingCompiledName_full_name);}
        if (MethodBeingCompiledNamespace_full_name != NULL) {free(MethodBeingCompiledNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodJitInliningFailed(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodJitInliningFailed(
                  PCWSTR MethodBeingCompiledNamespace,
                  PCWSTR MethodBeingCompiledName,
                  PCWSTR MethodBeingCompiledNameSignature,
                  PCWSTR InlinerNamespace,
                  PCWSTR InlinerName,
                  PCWSTR InlinerNameSignature,
                  PCWSTR InlineeNamespace,
                  PCWSTR InlineeName,
                  PCWSTR InlineeNameSignature,
                  const BOOL FailAlways,
                  LPCSTR FailReason,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodJitInliningFailed()){ return ERROR_SUCCESS;};
    INT MethodBeingCompiledNamespace_path_size = -1;
    INT MethodBeingCompiledNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNamespace_full_name=NULL;
    INT MethodBeingCompiledName_path_size = -1;
    INT MethodBeingCompiledName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledName_full_name=NULL;
    INT MethodBeingCompiledNameSignature_path_size = -1;
    INT MethodBeingCompiledNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNameSignature_full_name=NULL;
    INT InlinerNamespace_path_size = -1;
    INT InlinerNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* InlinerNamespace_full_name=NULL;
    INT InlinerName_path_size = -1;
    INT InlinerName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerName, -1, NULL, 0, NULL, NULL );
    CHAR* InlinerName_full_name=NULL;
    INT InlinerNameSignature_path_size = -1;
    INT InlinerNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* InlinerNameSignature_full_name=NULL;
    INT InlineeNamespace_path_size = -1;
    INT InlineeNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* InlineeNamespace_full_name=NULL;
    INT InlineeName_path_size = -1;
    INT InlineeName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeName, -1, NULL, 0, NULL, NULL );
    CHAR* InlineeName_full_name=NULL;
    INT InlineeNameSignature_path_size = -1;
    INT InlineeNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* InlineeNameSignature_full_name=NULL;

    MethodBeingCompiledNamespace_full_name = (CHAR*)malloc(MethodBeingCompiledNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNamespace_full_name != NULL);
    if(MethodBeingCompiledNamespace_full_name == NULL){goto LExit;}

    MethodBeingCompiledNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, MethodBeingCompiledNamespace_full_name, MethodBeingCompiledNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNamespace_path_size == MethodBeingCompiledNamespace_full_name_path_size );
    if( MethodBeingCompiledNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledName_full_name = (CHAR*)malloc(MethodBeingCompiledName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledName_full_name != NULL);
    if(MethodBeingCompiledName_full_name == NULL){goto LExit;}

    MethodBeingCompiledName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, MethodBeingCompiledName_full_name, MethodBeingCompiledName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledName_path_size == MethodBeingCompiledName_full_name_path_size );
    if( MethodBeingCompiledName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledNameSignature_full_name = (CHAR*)malloc(MethodBeingCompiledNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNameSignature_full_name != NULL);
    if(MethodBeingCompiledNameSignature_full_name == NULL){goto LExit;}

    MethodBeingCompiledNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, MethodBeingCompiledNameSignature_full_name, MethodBeingCompiledNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNameSignature_path_size == MethodBeingCompiledNameSignature_full_name_path_size );
    if( MethodBeingCompiledNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlinerNamespace_full_name = (CHAR*)malloc(InlinerNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlinerNamespace_full_name != NULL);
    if(InlinerNamespace_full_name == NULL){goto LExit;}

    InlinerNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNamespace, -1, InlinerNamespace_full_name, InlinerNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(InlinerNamespace_path_size == InlinerNamespace_full_name_path_size );
    if( InlinerNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlinerName_full_name = (CHAR*)malloc(InlinerName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlinerName_full_name != NULL);
    if(InlinerName_full_name == NULL){goto LExit;}

    InlinerName_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerName, -1, InlinerName_full_name, InlinerName_full_name_path_size, NULL, NULL );
    _ASSERTE(InlinerName_path_size == InlinerName_full_name_path_size );
    if( InlinerName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlinerNameSignature_full_name = (CHAR*)malloc(InlinerNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlinerNameSignature_full_name != NULL);
    if(InlinerNameSignature_full_name == NULL){goto LExit;}

    InlinerNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, InlinerNameSignature, -1, InlinerNameSignature_full_name, InlinerNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(InlinerNameSignature_path_size == InlinerNameSignature_full_name_path_size );
    if( InlinerNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlineeNamespace_full_name = (CHAR*)malloc(InlineeNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlineeNamespace_full_name != NULL);
    if(InlineeNamespace_full_name == NULL){goto LExit;}

    InlineeNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNamespace, -1, InlineeNamespace_full_name, InlineeNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(InlineeNamespace_path_size == InlineeNamespace_full_name_path_size );
    if( InlineeNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlineeName_full_name = (CHAR*)malloc(InlineeName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlineeName_full_name != NULL);
    if(InlineeName_full_name == NULL){goto LExit;}

    InlineeName_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeName, -1, InlineeName_full_name, InlineeName_full_name_path_size, NULL, NULL );
    _ASSERTE(InlineeName_path_size == InlineeName_full_name_path_size );
    if( InlineeName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    InlineeNameSignature_full_name = (CHAR*)malloc(InlineeNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(InlineeNameSignature_full_name != NULL);
    if(InlineeNameSignature_full_name == NULL){goto LExit;}

    InlineeNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, InlineeNameSignature, -1, InlineeNameSignature_full_name, InlineeNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(InlineeNameSignature_path_size == InlineeNameSignature_full_name_path_size );
    if( InlineeNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        MethodJitInliningFailed,
        MethodBeingCompiledNamespace_full_name,
        MethodBeingCompiledName_full_name,
        MethodBeingCompiledNameSignature_full_name,
        InlinerNamespace_full_name,
        InlinerName_full_name,
        InlinerNameSignature_full_name,
        InlineeNamespace_full_name,
        InlineeName_full_name,
        InlineeNameSignature_full_name,
        FailAlways
        );

     tracepoint(
        DotNETRuntime,
        MethodJitInliningFailed_1,
        FailReason,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (InlineeNameSignature_full_name != NULL) {free(InlineeNameSignature_full_name);}
        if (InlineeName_full_name != NULL) {free(InlineeName_full_name);}
        if (InlineeNamespace_full_name != NULL) {free(InlineeNamespace_full_name);}
        if (InlinerNameSignature_full_name != NULL) {free(InlinerNameSignature_full_name);}
        if (InlinerName_full_name != NULL) {free(InlinerName_full_name);}
        if (InlinerNamespace_full_name != NULL) {free(InlinerNamespace_full_name);}
        if (MethodBeingCompiledNameSignature_full_name != NULL) {free(MethodBeingCompiledNameSignature_full_name);}
        if (MethodBeingCompiledName_full_name != NULL) {free(MethodBeingCompiledName_full_name);}
        if (MethodBeingCompiledNamespace_full_name != NULL) {free(MethodBeingCompiledNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodJitTailCallSucceeded(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodJitTailCallSucceeded(
                  PCWSTR MethodBeingCompiledNamespace,
                  PCWSTR MethodBeingCompiledName,
                  PCWSTR MethodBeingCompiledNameSignature,
                  PCWSTR CallerNamespace,
                  PCWSTR CallerName,
                  PCWSTR CallerNameSignature,
                  PCWSTR CalleeNamespace,
                  PCWSTR CalleeName,
                  PCWSTR CalleeNameSignature,
                  const BOOL TailPrefix,
                  const unsigned int TailCallType,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodJitTailCallSucceeded()){ return ERROR_SUCCESS;};
    INT MethodBeingCompiledNamespace_path_size = -1;
    INT MethodBeingCompiledNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNamespace_full_name=NULL;
    INT MethodBeingCompiledName_path_size = -1;
    INT MethodBeingCompiledName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledName_full_name=NULL;
    INT MethodBeingCompiledNameSignature_path_size = -1;
    INT MethodBeingCompiledNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNameSignature_full_name=NULL;
    INT CallerNamespace_path_size = -1;
    INT CallerNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* CallerNamespace_full_name=NULL;
    INT CallerName_path_size = -1;
    INT CallerName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CallerName, -1, NULL, 0, NULL, NULL );
    CHAR* CallerName_full_name=NULL;
    INT CallerNameSignature_path_size = -1;
    INT CallerNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* CallerNameSignature_full_name=NULL;
    INT CalleeNamespace_path_size = -1;
    INT CalleeNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* CalleeNamespace_full_name=NULL;
    INT CalleeName_path_size = -1;
    INT CalleeName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeName, -1, NULL, 0, NULL, NULL );
    CHAR* CalleeName_full_name=NULL;
    INT CalleeNameSignature_path_size = -1;
    INT CalleeNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* CalleeNameSignature_full_name=NULL;

    MethodBeingCompiledNamespace_full_name = (CHAR*)malloc(MethodBeingCompiledNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNamespace_full_name != NULL);
    if(MethodBeingCompiledNamespace_full_name == NULL){goto LExit;}

    MethodBeingCompiledNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, MethodBeingCompiledNamespace_full_name, MethodBeingCompiledNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNamespace_path_size == MethodBeingCompiledNamespace_full_name_path_size );
    if( MethodBeingCompiledNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledName_full_name = (CHAR*)malloc(MethodBeingCompiledName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledName_full_name != NULL);
    if(MethodBeingCompiledName_full_name == NULL){goto LExit;}

    MethodBeingCompiledName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, MethodBeingCompiledName_full_name, MethodBeingCompiledName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledName_path_size == MethodBeingCompiledName_full_name_path_size );
    if( MethodBeingCompiledName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledNameSignature_full_name = (CHAR*)malloc(MethodBeingCompiledNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNameSignature_full_name != NULL);
    if(MethodBeingCompiledNameSignature_full_name == NULL){goto LExit;}

    MethodBeingCompiledNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, MethodBeingCompiledNameSignature_full_name, MethodBeingCompiledNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNameSignature_path_size == MethodBeingCompiledNameSignature_full_name_path_size );
    if( MethodBeingCompiledNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CallerNamespace_full_name = (CHAR*)malloc(CallerNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CallerNamespace_full_name != NULL);
    if(CallerNamespace_full_name == NULL){goto LExit;}

    CallerNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNamespace, -1, CallerNamespace_full_name, CallerNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(CallerNamespace_path_size == CallerNamespace_full_name_path_size );
    if( CallerNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CallerName_full_name = (CHAR*)malloc(CallerName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CallerName_full_name != NULL);
    if(CallerName_full_name == NULL){goto LExit;}

    CallerName_path_size = WideCharToMultiByte( CP_ACP, 0, CallerName, -1, CallerName_full_name, CallerName_full_name_path_size, NULL, NULL );
    _ASSERTE(CallerName_path_size == CallerName_full_name_path_size );
    if( CallerName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CallerNameSignature_full_name = (CHAR*)malloc(CallerNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CallerNameSignature_full_name != NULL);
    if(CallerNameSignature_full_name == NULL){goto LExit;}

    CallerNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNameSignature, -1, CallerNameSignature_full_name, CallerNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(CallerNameSignature_path_size == CallerNameSignature_full_name_path_size );
    if( CallerNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CalleeNamespace_full_name = (CHAR*)malloc(CalleeNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CalleeNamespace_full_name != NULL);
    if(CalleeNamespace_full_name == NULL){goto LExit;}

    CalleeNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNamespace, -1, CalleeNamespace_full_name, CalleeNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(CalleeNamespace_path_size == CalleeNamespace_full_name_path_size );
    if( CalleeNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CalleeName_full_name = (CHAR*)malloc(CalleeName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CalleeName_full_name != NULL);
    if(CalleeName_full_name == NULL){goto LExit;}

    CalleeName_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeName, -1, CalleeName_full_name, CalleeName_full_name_path_size, NULL, NULL );
    _ASSERTE(CalleeName_path_size == CalleeName_full_name_path_size );
    if( CalleeName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CalleeNameSignature_full_name = (CHAR*)malloc(CalleeNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CalleeNameSignature_full_name != NULL);
    if(CalleeNameSignature_full_name == NULL){goto LExit;}

    CalleeNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNameSignature, -1, CalleeNameSignature_full_name, CalleeNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(CalleeNameSignature_path_size == CalleeNameSignature_full_name_path_size );
    if( CalleeNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        MethodJitTailCallSucceeded,
        MethodBeingCompiledNamespace_full_name,
        MethodBeingCompiledName_full_name,
        MethodBeingCompiledNameSignature_full_name,
        CallerNamespace_full_name,
        CallerName_full_name,
        CallerNameSignature_full_name,
        CalleeNamespace_full_name,
        CalleeName_full_name,
        CalleeNameSignature_full_name,
        TailPrefix
        );

     tracepoint(
        DotNETRuntime,
        MethodJitTailCallSucceeded_1,
        TailCallType,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (CalleeNameSignature_full_name != NULL) {free(CalleeNameSignature_full_name);}
        if (CalleeName_full_name != NULL) {free(CalleeName_full_name);}
        if (CalleeNamespace_full_name != NULL) {free(CalleeNamespace_full_name);}
        if (CallerNameSignature_full_name != NULL) {free(CallerNameSignature_full_name);}
        if (CallerName_full_name != NULL) {free(CallerName_full_name);}
        if (CallerNamespace_full_name != NULL) {free(CallerNamespace_full_name);}
        if (MethodBeingCompiledNameSignature_full_name != NULL) {free(MethodBeingCompiledNameSignature_full_name);}
        if (MethodBeingCompiledName_full_name != NULL) {free(MethodBeingCompiledName_full_name);}
        if (MethodBeingCompiledNamespace_full_name != NULL) {free(MethodBeingCompiledNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodJitTailCallFailed(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodJitTailCallFailed(
                  PCWSTR MethodBeingCompiledNamespace,
                  PCWSTR MethodBeingCompiledName,
                  PCWSTR MethodBeingCompiledNameSignature,
                  PCWSTR CallerNamespace,
                  PCWSTR CallerName,
                  PCWSTR CallerNameSignature,
                  PCWSTR CalleeNamespace,
                  PCWSTR CalleeName,
                  PCWSTR CalleeNameSignature,
                  const BOOL TailPrefix,
                  LPCSTR FailReason,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodJitTailCallFailed()){ return ERROR_SUCCESS;};
    INT MethodBeingCompiledNamespace_path_size = -1;
    INT MethodBeingCompiledNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNamespace_full_name=NULL;
    INT MethodBeingCompiledName_path_size = -1;
    INT MethodBeingCompiledName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledName_full_name=NULL;
    INT MethodBeingCompiledNameSignature_path_size = -1;
    INT MethodBeingCompiledNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodBeingCompiledNameSignature_full_name=NULL;
    INT CallerNamespace_path_size = -1;
    INT CallerNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* CallerNamespace_full_name=NULL;
    INT CallerName_path_size = -1;
    INT CallerName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CallerName, -1, NULL, 0, NULL, NULL );
    CHAR* CallerName_full_name=NULL;
    INT CallerNameSignature_path_size = -1;
    INT CallerNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* CallerNameSignature_full_name=NULL;
    INT CalleeNamespace_path_size = -1;
    INT CalleeNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* CalleeNamespace_full_name=NULL;
    INT CalleeName_path_size = -1;
    INT CalleeName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeName, -1, NULL, 0, NULL, NULL );
    CHAR* CalleeName_full_name=NULL;
    INT CalleeNameSignature_path_size = -1;
    INT CalleeNameSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNameSignature, -1, NULL, 0, NULL, NULL );
    CHAR* CalleeNameSignature_full_name=NULL;

    MethodBeingCompiledNamespace_full_name = (CHAR*)malloc(MethodBeingCompiledNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNamespace_full_name != NULL);
    if(MethodBeingCompiledNamespace_full_name == NULL){goto LExit;}

    MethodBeingCompiledNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNamespace, -1, MethodBeingCompiledNamespace_full_name, MethodBeingCompiledNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNamespace_path_size == MethodBeingCompiledNamespace_full_name_path_size );
    if( MethodBeingCompiledNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledName_full_name = (CHAR*)malloc(MethodBeingCompiledName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledName_full_name != NULL);
    if(MethodBeingCompiledName_full_name == NULL){goto LExit;}

    MethodBeingCompiledName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledName, -1, MethodBeingCompiledName_full_name, MethodBeingCompiledName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledName_path_size == MethodBeingCompiledName_full_name_path_size );
    if( MethodBeingCompiledName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodBeingCompiledNameSignature_full_name = (CHAR*)malloc(MethodBeingCompiledNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodBeingCompiledNameSignature_full_name != NULL);
    if(MethodBeingCompiledNameSignature_full_name == NULL){goto LExit;}

    MethodBeingCompiledNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodBeingCompiledNameSignature, -1, MethodBeingCompiledNameSignature_full_name, MethodBeingCompiledNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodBeingCompiledNameSignature_path_size == MethodBeingCompiledNameSignature_full_name_path_size );
    if( MethodBeingCompiledNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CallerNamespace_full_name = (CHAR*)malloc(CallerNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CallerNamespace_full_name != NULL);
    if(CallerNamespace_full_name == NULL){goto LExit;}

    CallerNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNamespace, -1, CallerNamespace_full_name, CallerNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(CallerNamespace_path_size == CallerNamespace_full_name_path_size );
    if( CallerNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CallerName_full_name = (CHAR*)malloc(CallerName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CallerName_full_name != NULL);
    if(CallerName_full_name == NULL){goto LExit;}

    CallerName_path_size = WideCharToMultiByte( CP_ACP, 0, CallerName, -1, CallerName_full_name, CallerName_full_name_path_size, NULL, NULL );
    _ASSERTE(CallerName_path_size == CallerName_full_name_path_size );
    if( CallerName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CallerNameSignature_full_name = (CHAR*)malloc(CallerNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CallerNameSignature_full_name != NULL);
    if(CallerNameSignature_full_name == NULL){goto LExit;}

    CallerNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, CallerNameSignature, -1, CallerNameSignature_full_name, CallerNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(CallerNameSignature_path_size == CallerNameSignature_full_name_path_size );
    if( CallerNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CalleeNamespace_full_name = (CHAR*)malloc(CalleeNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CalleeNamespace_full_name != NULL);
    if(CalleeNamespace_full_name == NULL){goto LExit;}

    CalleeNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNamespace, -1, CalleeNamespace_full_name, CalleeNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(CalleeNamespace_path_size == CalleeNamespace_full_name_path_size );
    if( CalleeNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CalleeName_full_name = (CHAR*)malloc(CalleeName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CalleeName_full_name != NULL);
    if(CalleeName_full_name == NULL){goto LExit;}

    CalleeName_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeName, -1, CalleeName_full_name, CalleeName_full_name_path_size, NULL, NULL );
    _ASSERTE(CalleeName_path_size == CalleeName_full_name_path_size );
    if( CalleeName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    CalleeNameSignature_full_name = (CHAR*)malloc(CalleeNameSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CalleeNameSignature_full_name != NULL);
    if(CalleeNameSignature_full_name == NULL){goto LExit;}

    CalleeNameSignature_path_size = WideCharToMultiByte( CP_ACP, 0, CalleeNameSignature, -1, CalleeNameSignature_full_name, CalleeNameSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(CalleeNameSignature_path_size == CalleeNameSignature_full_name_path_size );
    if( CalleeNameSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        MethodJitTailCallFailed,
        MethodBeingCompiledNamespace_full_name,
        MethodBeingCompiledName_full_name,
        MethodBeingCompiledNameSignature_full_name,
        CallerNamespace_full_name,
        CallerName_full_name,
        CallerNameSignature_full_name,
        CalleeNamespace_full_name,
        CalleeName_full_name,
        CalleeNameSignature_full_name,
        TailPrefix
        );

     tracepoint(
        DotNETRuntime,
        MethodJitTailCallFailed_1,
        FailReason,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (CalleeNameSignature_full_name != NULL) {free(CalleeNameSignature_full_name);}
        if (CalleeName_full_name != NULL) {free(CalleeName_full_name);}
        if (CalleeNamespace_full_name != NULL) {free(CalleeNamespace_full_name);}
        if (CallerNameSignature_full_name != NULL) {free(CallerNameSignature_full_name);}
        if (CallerName_full_name != NULL) {free(CallerName_full_name);}
        if (CallerNamespace_full_name != NULL) {free(CallerNamespace_full_name);}
        if (MethodBeingCompiledNameSignature_full_name != NULL) {free(MethodBeingCompiledNameSignature_full_name);}
        if (MethodBeingCompiledName_full_name != NULL) {free(MethodBeingCompiledName_full_name);}
        if (MethodBeingCompiledNamespace_full_name != NULL) {free(MethodBeingCompiledNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodILToNativeMap(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodILToNativeMap(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ReJITID,
                  const unsigned char MethodExtent,
                  const unsigned short CountOfMapEntries,
                  const unsigned int* ILOffsets,
                  const unsigned int* NativeOffsets,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodILToNativeMap()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        MethodILToNativeMap,
        MethodID,
        ReJITID,
        MethodExtent,
        CountOfMapEntries,
        (const unsigned int*) ILOffsets,
        (const unsigned int*) NativeOffsets,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCStartV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCStartV2(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCStartV2()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ModuleDCStartV2,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCEndV2(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCEndV2(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCEndV2()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ModuleDCEndV2,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledDomainModuleLoad(){ return TRUE;}
extern "C" ULONG  FireEtXplatDomainModuleLoad(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDomainModuleLoad()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        DomainModuleLoad,
        ModuleID,
        AssemblyID,
        AppDomainID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledDomainModuleLoad_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatDomainModuleLoad_V1(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDomainModuleLoad_V1()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        DomainModuleLoad_V1,
        ModuleID,
        AssemblyID,
        AppDomainID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleLoad(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleLoad(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleLoad()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ModuleLoad,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleLoad_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleLoad_V1(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleLoad_V1()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ModuleLoad_V1,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleLoad_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleLoad_V2(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID,
                  const GUID* ManagedPdbSignature,
                  const unsigned int ManagedPdbAge,
                  PCWSTR ManagedPdbBuildPath,
                  const GUID* NativePdbSignature,
                  const unsigned int NativePdbAge,
                  PCWSTR NativePdbBuildPath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleLoad_V2()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;
    INT ManagedPdbBuildPath_path_size = -1;
    INT ManagedPdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedPdbBuildPath_full_name=NULL;
    INT NativePdbBuildPath_path_size = -1;
    INT NativePdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* NativePdbBuildPath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedPdbBuildPath_full_name = (CHAR*)malloc(ManagedPdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedPdbBuildPath_full_name != NULL);
    if(ManagedPdbBuildPath_full_name == NULL){goto LExit;}

    ManagedPdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, ManagedPdbBuildPath_full_name, ManagedPdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedPdbBuildPath_path_size == ManagedPdbBuildPath_full_name_path_size );
    if( ManagedPdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    NativePdbBuildPath_full_name = (CHAR*)malloc(NativePdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(NativePdbBuildPath_full_name != NULL);
    if(NativePdbBuildPath_full_name == NULL){goto LExit;}

    NativePdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NativePdbBuildPath_full_name, NativePdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(NativePdbBuildPath_path_size == NativePdbBuildPath_full_name_path_size );
    if( NativePdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        ModuleLoad_V2,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID,
        (const int*) ManagedPdbSignature,
        ManagedPdbAge,
        ManagedPdbBuildPath_full_name
        );

     tracepoint(
        DotNETRuntime,
        ModuleLoad_V2_1,
        (const int*) NativePdbSignature,
        NativePdbAge,
        NativePdbBuildPath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (NativePdbBuildPath_full_name != NULL) {free(NativePdbBuildPath_full_name);}
        if (ManagedPdbBuildPath_full_name != NULL) {free(ManagedPdbBuildPath_full_name);}
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleUnload(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleUnload(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleUnload()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ModuleUnload,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleUnload_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleUnload_V1(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleUnload_V1()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        ModuleUnload_V1,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleUnload_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleUnload_V2(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID,
                  const GUID* ManagedPdbSignature,
                  const unsigned int ManagedPdbAge,
                  PCWSTR ManagedPdbBuildPath,
                  const GUID* NativePdbSignature,
                  const unsigned int NativePdbAge,
                  PCWSTR NativePdbBuildPath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleUnload_V2()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;
    INT ManagedPdbBuildPath_path_size = -1;
    INT ManagedPdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedPdbBuildPath_full_name=NULL;
    INT NativePdbBuildPath_path_size = -1;
    INT NativePdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* NativePdbBuildPath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedPdbBuildPath_full_name = (CHAR*)malloc(ManagedPdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedPdbBuildPath_full_name != NULL);
    if(ManagedPdbBuildPath_full_name == NULL){goto LExit;}

    ManagedPdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, ManagedPdbBuildPath_full_name, ManagedPdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedPdbBuildPath_path_size == ManagedPdbBuildPath_full_name_path_size );
    if( ManagedPdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    NativePdbBuildPath_full_name = (CHAR*)malloc(NativePdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(NativePdbBuildPath_full_name != NULL);
    if(NativePdbBuildPath_full_name == NULL){goto LExit;}

    NativePdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NativePdbBuildPath_full_name, NativePdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(NativePdbBuildPath_path_size == NativePdbBuildPath_full_name_path_size );
    if( NativePdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        ModuleUnload_V2,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID,
        (const int*) ManagedPdbSignature,
        ManagedPdbAge,
        ManagedPdbBuildPath_full_name
        );

     tracepoint(
        DotNETRuntime,
        ModuleUnload_V2_1,
        (const int*) NativePdbSignature,
        NativePdbAge,
        NativePdbBuildPath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (NativePdbBuildPath_full_name != NULL) {free(NativePdbBuildPath_full_name);}
        if (ManagedPdbBuildPath_full_name != NULL) {free(ManagedPdbBuildPath_full_name);}
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyLoad(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyLoad(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyLoad()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AssemblyLoad,
        AssemblyID,
        AppDomainID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyLoad_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyLoad_V1(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned __int64 BindingID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyLoad_V1()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AssemblyLoad_V1,
        AssemblyID,
        AppDomainID,
        BindingID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyUnload(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyUnload(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyUnload()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AssemblyUnload,
        AssemblyID,
        AppDomainID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyUnload_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyUnload_V1(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned __int64 BindingID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyUnload_V1()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AssemblyUnload_V1,
        AssemblyID,
        AppDomainID,
        BindingID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainLoad(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainLoad(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainLoad()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AppDomainLoad,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainLoad_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainLoad_V1(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName,
                  const unsigned int AppDomainIndex,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainLoad_V1()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AppDomainLoad_V1,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name,
        AppDomainIndex,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainUnload(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainUnload(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainUnload()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AppDomainUnload,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainUnload_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainUnload_V1(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName,
                  const unsigned int AppDomainIndex,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainUnload_V1()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AppDomainUnload_V1,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name,
        AppDomainIndex,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleRangeLoad(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleRangeLoad(
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ModuleID,
                  const unsigned int RangeBegin,
                  const unsigned int RangeSize,
                  const unsigned char RangeType
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleRangeLoad()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        ModuleRangeLoad,
        ClrInstanceID,
        ModuleID,
        RangeBegin,
        RangeSize,
        RangeType
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledStrongNameVerificationStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatStrongNameVerificationStart(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR FullyQualifiedAssemblyName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledStrongNameVerificationStart()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        StrongNameVerificationStart,
        VerificationFlags,
        ErrorCode,
        FullyQualifiedAssemblyName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledStrongNameVerificationStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatStrongNameVerificationStart_V1(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR FullyQualifiedAssemblyName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledStrongNameVerificationStart_V1()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        StrongNameVerificationStart_V1,
        VerificationFlags,
        ErrorCode,
        FullyQualifiedAssemblyName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledStrongNameVerificationStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatStrongNameVerificationStop(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR FullyQualifiedAssemblyName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledStrongNameVerificationStop()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        StrongNameVerificationStop,
        VerificationFlags,
        ErrorCode,
        FullyQualifiedAssemblyName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledStrongNameVerificationStop_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatStrongNameVerificationStop_V1(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR FullyQualifiedAssemblyName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledStrongNameVerificationStop_V1()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        StrongNameVerificationStop_V1,
        VerificationFlags,
        ErrorCode,
        FullyQualifiedAssemblyName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAuthenticodeVerificationStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatAuthenticodeVerificationStart(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR ModulePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAuthenticodeVerificationStart()){ return ERROR_SUCCESS;};
    INT ModulePath_path_size = -1;
    INT ModulePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModulePath_full_name=NULL;

    ModulePath_full_name = (CHAR*)malloc(ModulePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModulePath_full_name != NULL);
    if(ModulePath_full_name == NULL){goto LExit;}

    ModulePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, ModulePath_full_name, ModulePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModulePath_path_size == ModulePath_full_name_path_size );
    if( ModulePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AuthenticodeVerificationStart,
        VerificationFlags,
        ErrorCode,
        ModulePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModulePath_full_name != NULL) {free(ModulePath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAuthenticodeVerificationStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAuthenticodeVerificationStart_V1(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR ModulePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAuthenticodeVerificationStart_V1()){ return ERROR_SUCCESS;};
    INT ModulePath_path_size = -1;
    INT ModulePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModulePath_full_name=NULL;

    ModulePath_full_name = (CHAR*)malloc(ModulePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModulePath_full_name != NULL);
    if(ModulePath_full_name == NULL){goto LExit;}

    ModulePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, ModulePath_full_name, ModulePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModulePath_path_size == ModulePath_full_name_path_size );
    if( ModulePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AuthenticodeVerificationStart_V1,
        VerificationFlags,
        ErrorCode,
        ModulePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModulePath_full_name != NULL) {free(ModulePath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAuthenticodeVerificationStop(){ return TRUE;}
extern "C" ULONG  FireEtXplatAuthenticodeVerificationStop(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR ModulePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAuthenticodeVerificationStop()){ return ERROR_SUCCESS;};
    INT ModulePath_path_size = -1;
    INT ModulePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModulePath_full_name=NULL;

    ModulePath_full_name = (CHAR*)malloc(ModulePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModulePath_full_name != NULL);
    if(ModulePath_full_name == NULL){goto LExit;}

    ModulePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, ModulePath_full_name, ModulePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModulePath_path_size == ModulePath_full_name_path_size );
    if( ModulePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AuthenticodeVerificationStop,
        VerificationFlags,
        ErrorCode,
        ModulePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModulePath_full_name != NULL) {free(ModulePath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAuthenticodeVerificationStop_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAuthenticodeVerificationStop_V1(
                  const unsigned int VerificationFlags,
                  const unsigned int ErrorCode,
                  PCWSTR ModulePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAuthenticodeVerificationStop_V1()){ return ERROR_SUCCESS;};
    INT ModulePath_path_size = -1;
    INT ModulePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModulePath_full_name=NULL;

    ModulePath_full_name = (CHAR*)malloc(ModulePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModulePath_full_name != NULL);
    if(ModulePath_full_name == NULL){goto LExit;}

    ModulePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModulePath, -1, ModulePath_full_name, ModulePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModulePath_path_size == ModulePath_full_name_path_size );
    if( ModulePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        AuthenticodeVerificationStop_V1,
        VerificationFlags,
        ErrorCode,
        ModulePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModulePath_full_name != NULL) {free(ModulePath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledRuntimeInformationStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatRuntimeInformationStart(
                  const unsigned short ClrInstanceID,
                  const unsigned short Sku,
                  const unsigned short BclMajorVersion,
                  const unsigned short BclMinorVersion,
                  const unsigned short BclBuildNumber,
                  const unsigned short BclQfeNumber,
                  const unsigned short VMMajorVersion,
                  const unsigned short VMMinorVersion,
                  const unsigned short VMBuildNumber,
                  const unsigned short VMQfeNumber,
                  const unsigned int StartupFlags,
                  const unsigned char StartupMode,
                  PCWSTR CommandLine,
                  const GUID* ComObjectGuid,
                  PCWSTR RuntimeDllPath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledRuntimeInformationStart()){ return ERROR_SUCCESS;};
    INT CommandLine_path_size = -1;
    INT CommandLine_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CommandLine, -1, NULL, 0, NULL, NULL );
    CHAR* CommandLine_full_name=NULL;
    INT RuntimeDllPath_path_size = -1;
    INT RuntimeDllPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, RuntimeDllPath, -1, NULL, 0, NULL, NULL );
    CHAR* RuntimeDllPath_full_name=NULL;

    CommandLine_full_name = (CHAR*)malloc(CommandLine_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CommandLine_full_name != NULL);
    if(CommandLine_full_name == NULL){goto LExit;}

    CommandLine_path_size = WideCharToMultiByte( CP_ACP, 0, CommandLine, -1, CommandLine_full_name, CommandLine_full_name_path_size, NULL, NULL );
    _ASSERTE(CommandLine_path_size == CommandLine_full_name_path_size );
    if( CommandLine_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    RuntimeDllPath_full_name = (CHAR*)malloc(RuntimeDllPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(RuntimeDllPath_full_name != NULL);
    if(RuntimeDllPath_full_name == NULL){goto LExit;}

    RuntimeDllPath_path_size = WideCharToMultiByte( CP_ACP, 0, RuntimeDllPath, -1, RuntimeDllPath_full_name, RuntimeDllPath_full_name_path_size, NULL, NULL );
    _ASSERTE(RuntimeDllPath_path_size == RuntimeDllPath_full_name_path_size );
    if( RuntimeDllPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntime,
        RuntimeInformationStart,
        ClrInstanceID,
        Sku,
        BclMajorVersion,
        BclMinorVersion,
        BclBuildNumber,
        BclQfeNumber,
        VMMajorVersion,
        VMMinorVersion,
        VMBuildNumber,
        VMQfeNumber
        );

     tracepoint(
        DotNETRuntime,
        RuntimeInformationStart_1,
        StartupFlags,
        StartupMode,
        CommandLine_full_name,
        (const int*) ComObjectGuid,
        RuntimeDllPath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (RuntimeDllPath_full_name != NULL) {free(RuntimeDllPath_full_name);}
        if (CommandLine_full_name != NULL) {free(CommandLine_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledIncreaseMemoryPressure(){ return TRUE;}
extern "C" ULONG  FireEtXplatIncreaseMemoryPressure(
                  const unsigned __int64 BytesAllocated,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledIncreaseMemoryPressure()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        IncreaseMemoryPressure,
        BytesAllocated,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDecreaseMemoryPressure(){ return TRUE;}
extern "C" ULONG  FireEtXplatDecreaseMemoryPressure(
                  const unsigned __int64 BytesFreed,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDecreaseMemoryPressure()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        DecreaseMemoryPressure,
        BytesFreed,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCMarkWithType(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCMarkWithType(
                  const unsigned int HeapNum,
                  const unsigned short ClrInstanceID,
                  const unsigned int Type,
                  const unsigned __int64 Bytes
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCMarkWithType()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCMarkWithType,
        HeapNum,
        ClrInstanceID,
        Type,
        Bytes
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCJoin_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCJoin_V2(
                  const unsigned int Heap,
                  const unsigned int JoinTime,
                  const unsigned int JoinType,
                  const unsigned short ClrInstanceID,
                  const unsigned int JoinID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCJoin_V2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCJoin_V2,
        Heap,
        JoinTime,
        JoinType,
        ClrInstanceID,
        JoinID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCPerHeapHistory_V3(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCPerHeapHistory_V3(
                  const unsigned short ClrInstanceID,
                  const void* FreeListAllocated,
                  const void* FreeListRejected,
                  const void* EndOfSegAllocated,
                  const void* CondemnedAllocated,
                  const void* PinnedAllocated,
                  const void* PinnedAllocatedAdvance,
                  const unsigned int RunningFreeListEfficiency,
                  const unsigned int CondemnReasons0,
                  const unsigned int CondemnReasons1,
                  const unsigned int CompactMechanisms,
                  const unsigned int ExpandMechanisms,
                  const unsigned int HeapIndex,
                  const void* ExtraGen0Commit,
                  const unsigned int Count,
                  const ULONG Arg15_Struct_Len_,
                  const void* Arg15_Struct_Pointer_
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCPerHeapHistory_V3()){ return ERROR_SUCCESS;};

                                                    
     tracepoint(
        DotNETRuntime,
        GCPerHeapHistory_V3,
        ClrInstanceID,
        (const size_t) FreeListAllocated,
        (const size_t) FreeListRejected,
        (const size_t) EndOfSegAllocated,
        (const size_t) CondemnedAllocated,
        (const size_t) PinnedAllocated,
        (const size_t) PinnedAllocatedAdvance,
        RunningFreeListEfficiency,
        CondemnReasons0,
        CondemnReasons1
        );

     tracepoint(
        DotNETRuntime,
        GCPerHeapHistory_V3_1,
        CompactMechanisms,
        ExpandMechanisms,
        HeapIndex,
        (const size_t) ExtraGen0Commit,
        Count,
        Arg15_Struct_Len_,
        (const int*) Arg15_Struct_Pointer_
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledGCGlobalHeapHistory_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatGCGlobalHeapHistory_V2(
                  const unsigned __int64 FinalYoungestDesired,
                  const signed int NumHeaps,
                  const unsigned int CondemnedGeneration,
                  const unsigned int Gen0ReductionCount,
                  const unsigned int Reason,
                  const unsigned int GlobalMechanisms,
                  const unsigned short ClrInstanceID,
                  const unsigned int PauseMode,
                  const unsigned int MemoryPressure
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledGCGlobalHeapHistory_V2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        GCGlobalHeapHistory_V2,
        FinalYoungestDesired,
        NumHeaps,
        CondemnedGeneration,
        Gen0ReductionCount,
        Reason,
        GlobalMechanisms,
        ClrInstanceID,
        PauseMode,
        MemoryPressure
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDebugIPCEventStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatDebugIPCEventStart(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDebugIPCEventStart()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        DebugIPCEventStart
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDebugIPCEventEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatDebugIPCEventEnd(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDebugIPCEventEnd()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        DebugIPCEventEnd
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDebugExceptionProcessingStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatDebugExceptionProcessingStart(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDebugExceptionProcessingStart()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        DebugExceptionProcessingStart
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDebugExceptionProcessingEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatDebugExceptionProcessingEnd(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDebugExceptionProcessingEnd()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntime,
        DebugExceptionProcessingEnd
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledCodeSymbols(){ return TRUE;}
extern "C" ULONG  FireEtXplatCodeSymbols(
                  const unsigned __int64 ModuleId,
                  const unsigned short TotalChunks,
                  const unsigned short ChunkNumber,
                  const unsigned int ChunkLength,
                  const BYTE* Chunk,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledCodeSymbols()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntime,
        CodeSymbols,
        ModuleId,
        TotalChunks,
        ChunkNumber,
        ChunkLength,
        (const BYTE*) Chunk,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledEventSource(){ return TRUE;}
extern "C" ULONG  FireEtXplatEventSource(
                  const signed int EventID,
                  PCWSTR EventName,
                  PCWSTR EventSourceName,
                  PCWSTR Payload
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledEventSource()){ return ERROR_SUCCESS;};
    INT EventName_path_size = -1;
    INT EventName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, EventName, -1, NULL, 0, NULL, NULL );
    CHAR* EventName_full_name=NULL;
    INT EventSourceName_path_size = -1;
    INT EventSourceName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, EventSourceName, -1, NULL, 0, NULL, NULL );
    CHAR* EventSourceName_full_name=NULL;
    INT Payload_path_size = -1;
    INT Payload_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, Payload, -1, NULL, 0, NULL, NULL );
    CHAR* Payload_full_name=NULL;

    EventName_full_name = (CHAR*)malloc(EventName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(EventName_full_name != NULL);
    if(EventName_full_name == NULL){goto LExit;}

    EventName_path_size = WideCharToMultiByte( CP_ACP, 0, EventName, -1, EventName_full_name, EventName_full_name_path_size, NULL, NULL );
    _ASSERTE(EventName_path_size == EventName_full_name_path_size );
    if( EventName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    EventSourceName_full_name = (CHAR*)malloc(EventSourceName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(EventSourceName_full_name != NULL);
    if(EventSourceName_full_name == NULL){goto LExit;}

    EventSourceName_path_size = WideCharToMultiByte( CP_ACP, 0, EventSourceName, -1, EventSourceName_full_name, EventSourceName_full_name_path_size, NULL, NULL );
    _ASSERTE(EventSourceName_path_size == EventSourceName_full_name_path_size );
    if( EventSourceName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    Payload_full_name = (CHAR*)malloc(Payload_full_name_path_size*sizeof(CHAR));
    _ASSERTE(Payload_full_name != NULL);
    if(Payload_full_name == NULL){goto LExit;}

    Payload_path_size = WideCharToMultiByte( CP_ACP, 0, Payload, -1, Payload_full_name, Payload_full_name_path_size, NULL, NULL );
    _ASSERTE(Payload_path_size == Payload_full_name_path_size );
    if( Payload_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntime,
        EventSource,
        EventID,
        EventName_full_name,
        EventSourceName_full_name,
        Payload_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (Payload_full_name != NULL) {free(Payload_full_name);}
        if (EventSourceName_full_name != NULL) {free(EventSourceName_full_name);}
        if (EventName_full_name != NULL) {free(EventName_full_name);}

return Error;
}
