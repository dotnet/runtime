//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//

/******************************************************************

DO NOT MODIFY. AUTOGENERATED FILE.
This file is generated using the logic from <root>/src/inc/genXplatLttng.pl

******************************************************************/


#define TRACEPOINT_DEFINE
#define TRACEPOINT_PROBE_DYNAMIC_LINKAGE
#include "lttng/tpdotnetruntimerundown.h"
extern "C" BOOL  EventXplatEnabledCLRStackWalkDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatCLRStackWalkDCStart(
                  const unsigned short ClrInstanceID,
                  const unsigned char Reserved1,
                  const unsigned char Reserved2,
                  const unsigned int FrameCount,
                  const void** Stack
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledCLRStackWalkDCStart()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        CLRStackWalkDCStart,
        ClrInstanceID,
        Reserved1,
        Reserved2,
        FrameCount,
        (const size_t*) Stack
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStart(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStart()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStart,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStart_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStart_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStart_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStart_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStart_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStart_V2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStart_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID,
        ReJITID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEnd(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEnd()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEnd,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEnd_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEnd_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEnd_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEnd_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEnd_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEnd_V2()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEnd_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        ClrInstanceID,
        ReJITID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStartVerbose(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStartVerbose(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStartVerbose()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStartVerbose,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStartVerbose_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStartVerbose_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStartVerbose_V1()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStartVerbose_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStartVerbose_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStartVerbose_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStartVerbose_V2()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStartVerbose_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStartVerbose_V2_1,
        ReJITID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEndVerbose(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEndVerbose(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEndVerbose()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEndVerbose,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEndVerbose_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEndVerbose_V1(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEndVerbose_V1()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEndVerbose_V1,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEndVerbose_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEndVerbose_V2(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 MethodStartAddress,
                  const unsigned int MethodSize,
                  const unsigned int MethodToken,
                  const unsigned int MethodFlags,
                  PCWSTR MethodNamespace,
                  PCWSTR MethodName,
                  PCWSTR MethodSignature,
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ReJITID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEndVerbose_V2()){ return ERROR_SUCCESS;};
    INT MethodNamespace_path_size = -1;
    INT MethodNamespace_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, NULL, 0, NULL, NULL );
    CHAR* MethodNamespace_full_name=NULL;
    INT MethodName_path_size = -1;
    INT MethodName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, NULL, 0, NULL, NULL );
    CHAR* MethodName_full_name=NULL;
    INT MethodSignature_path_size = -1;
    INT MethodSignature_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, NULL, 0, NULL, NULL );
    CHAR* MethodSignature_full_name=NULL;

    MethodNamespace_full_name = (CHAR*)malloc(MethodNamespace_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodNamespace_full_name != NULL);
    if(MethodNamespace_full_name == NULL){goto LExit;}

    MethodNamespace_path_size = WideCharToMultiByte( CP_ACP, 0, MethodNamespace, -1, MethodNamespace_full_name, MethodNamespace_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodNamespace_path_size == MethodNamespace_full_name_path_size );
    if( MethodNamespace_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodName_full_name = (CHAR*)malloc(MethodName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodName_full_name != NULL);
    if(MethodName_full_name == NULL){goto LExit;}

    MethodName_path_size = WideCharToMultiByte( CP_ACP, 0, MethodName, -1, MethodName_full_name, MethodName_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodName_path_size == MethodName_full_name_path_size );
    if( MethodName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    MethodSignature_full_name = (CHAR*)malloc(MethodSignature_full_name_path_size*sizeof(CHAR));
    _ASSERTE(MethodSignature_full_name != NULL);
    if(MethodSignature_full_name == NULL){goto LExit;}

    MethodSignature_path_size = WideCharToMultiByte( CP_ACP, 0, MethodSignature, -1, MethodSignature_full_name, MethodSignature_full_name_path_size, NULL, NULL );
    _ASSERTE(MethodSignature_path_size == MethodSignature_full_name_path_size );
    if( MethodSignature_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEndVerbose_V2,
        MethodID,
        ModuleID,
        MethodStartAddress,
        MethodSize,
        MethodToken,
        MethodFlags,
        MethodNamespace_full_name,
        MethodName_full_name,
        MethodSignature_full_name,
        ClrInstanceID
        );

     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEndVerbose_V2_1,
        ReJITID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (MethodSignature_full_name != NULL) {free(MethodSignature_full_name);}
        if (MethodName_full_name != NULL) {free(MethodName_full_name);}
        if (MethodNamespace_full_name != NULL) {free(MethodNamespace_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledDCStartComplete(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCStartComplete(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCStartComplete()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntimeRundown,
        DCStartComplete
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCStartComplete_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCStartComplete_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCStartComplete_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        DCStartComplete_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCEndComplete(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCEndComplete(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCEndComplete()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntimeRundown,
        DCEndComplete
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCEndComplete_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCEndComplete_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCEndComplete_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        DCEndComplete_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCStartInit(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCStartInit(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCStartInit()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntimeRundown,
        DCStartInit
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCStartInit_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCStartInit_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCStartInit_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        DCStartInit_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCEndInit(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCEndInit(
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCEndInit()){ return ERROR_SUCCESS;};
                                
     tracepoint(
        DotNETRuntimeRundown,
        DCEndInit
     );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDCEndInit_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatDCEndInit_V1(
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDCEndInit_V1()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        DCEndInit_V1,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCStartILToNativeMap(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCStartILToNativeMap(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ReJITID,
                  const unsigned char MethodExtent,
                  const unsigned short CountOfMapEntries,
                  const unsigned int* ILOffsets,
                  const unsigned int* NativeOffsets,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCStartILToNativeMap()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCStartILToNativeMap,
        MethodID,
        ReJITID,
        MethodExtent,
        CountOfMapEntries,
        (const unsigned int*) ILOffsets,
        (const unsigned int*) NativeOffsets,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledMethodDCEndILToNativeMap(){ return TRUE;}
extern "C" ULONG  FireEtXplatMethodDCEndILToNativeMap(
                  const unsigned __int64 MethodID,
                  const unsigned __int64 ReJITID,
                  const unsigned char MethodExtent,
                  const unsigned short CountOfMapEntries,
                  const unsigned int* ILOffsets,
                  const unsigned int* NativeOffsets,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledMethodDCEndILToNativeMap()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        MethodDCEndILToNativeMap,
        MethodID,
        ReJITID,
        MethodExtent,
        CountOfMapEntries,
        (const unsigned int*) ILOffsets,
        (const unsigned int*) NativeOffsets,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledDomainModuleDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatDomainModuleDCStart(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDomainModuleDCStart()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        DomainModuleDCStart,
        ModuleID,
        AssemblyID,
        AppDomainID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledDomainModuleDCStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatDomainModuleDCStart_V1(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDomainModuleDCStart_V1()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        DomainModuleDCStart_V1,
        ModuleID,
        AssemblyID,
        AppDomainID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledDomainModuleDCEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatDomainModuleDCEnd(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDomainModuleDCEnd()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        DomainModuleDCEnd,
        ModuleID,
        AssemblyID,
        AppDomainID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledDomainModuleDCEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatDomainModuleDCEnd_V1(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledDomainModuleDCEnd_V1()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        DomainModuleDCEnd_V1,
        ModuleID,
        AssemblyID,
        AppDomainID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCStart(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCStart()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCStart,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCStart_V1(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCStart_V1()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCStart_V1,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCStart_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCStart_V2(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID,
                  const GUID* ManagedPdbSignature,
                  const unsigned int ManagedPdbAge,
                  PCWSTR ManagedPdbBuildPath,
                  const GUID* NativePdbSignature,
                  const unsigned int NativePdbAge,
                  PCWSTR NativePdbBuildPath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCStart_V2()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;
    INT ManagedPdbBuildPath_path_size = -1;
    INT ManagedPdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedPdbBuildPath_full_name=NULL;
    INT NativePdbBuildPath_path_size = -1;
    INT NativePdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* NativePdbBuildPath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedPdbBuildPath_full_name = (CHAR*)malloc(ManagedPdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedPdbBuildPath_full_name != NULL);
    if(ManagedPdbBuildPath_full_name == NULL){goto LExit;}

    ManagedPdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, ManagedPdbBuildPath_full_name, ManagedPdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedPdbBuildPath_path_size == ManagedPdbBuildPath_full_name_path_size );
    if( ManagedPdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    NativePdbBuildPath_full_name = (CHAR*)malloc(NativePdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(NativePdbBuildPath_full_name != NULL);
    if(NativePdbBuildPath_full_name == NULL){goto LExit;}

    NativePdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NativePdbBuildPath_full_name, NativePdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(NativePdbBuildPath_path_size == NativePdbBuildPath_full_name_path_size );
    if( NativePdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCStart_V2,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID,
        (const int*) ManagedPdbSignature,
        ManagedPdbAge,
        ManagedPdbBuildPath_full_name
        );

     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCStart_V2_1,
        (const int*) NativePdbSignature,
        NativePdbAge,
        NativePdbBuildPath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (NativePdbBuildPath_full_name != NULL) {free(NativePdbBuildPath_full_name);}
        if (ManagedPdbBuildPath_full_name != NULL) {free(ManagedPdbBuildPath_full_name);}
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCEnd(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCEnd()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCEnd,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCEnd_V1(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCEnd_V1()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCEnd_V1,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleDCEnd_V2(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleDCEnd_V2(
                  const unsigned __int64 ModuleID,
                  const unsigned __int64 AssemblyID,
                  const unsigned int ModuleFlags,
                  const unsigned int Reserved1,
                  PCWSTR ModuleILPath,
                  PCWSTR ModuleNativePath,
                  const unsigned short ClrInstanceID,
                  const GUID* ManagedPdbSignature,
                  const unsigned int ManagedPdbAge,
                  PCWSTR ManagedPdbBuildPath,
                  const GUID* NativePdbSignature,
                  const unsigned int NativePdbAge,
                  PCWSTR NativePdbBuildPath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleDCEnd_V2()){ return ERROR_SUCCESS;};
    INT ModuleILPath_path_size = -1;
    INT ModuleILPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleILPath_full_name=NULL;
    INT ModuleNativePath_path_size = -1;
    INT ModuleNativePath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, NULL, 0, NULL, NULL );
    CHAR* ModuleNativePath_full_name=NULL;
    INT ManagedPdbBuildPath_path_size = -1;
    INT ManagedPdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* ManagedPdbBuildPath_full_name=NULL;
    INT NativePdbBuildPath_path_size = -1;
    INT NativePdbBuildPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NULL, 0, NULL, NULL );
    CHAR* NativePdbBuildPath_full_name=NULL;

    ModuleILPath_full_name = (CHAR*)malloc(ModuleILPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleILPath_full_name != NULL);
    if(ModuleILPath_full_name == NULL){goto LExit;}

    ModuleILPath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleILPath, -1, ModuleILPath_full_name, ModuleILPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleILPath_path_size == ModuleILPath_full_name_path_size );
    if( ModuleILPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ModuleNativePath_full_name = (CHAR*)malloc(ModuleNativePath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ModuleNativePath_full_name != NULL);
    if(ModuleNativePath_full_name == NULL){goto LExit;}

    ModuleNativePath_path_size = WideCharToMultiByte( CP_ACP, 0, ModuleNativePath, -1, ModuleNativePath_full_name, ModuleNativePath_full_name_path_size, NULL, NULL );
    _ASSERTE(ModuleNativePath_path_size == ModuleNativePath_full_name_path_size );
    if( ModuleNativePath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    ManagedPdbBuildPath_full_name = (CHAR*)malloc(ManagedPdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(ManagedPdbBuildPath_full_name != NULL);
    if(ManagedPdbBuildPath_full_name == NULL){goto LExit;}

    ManagedPdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, ManagedPdbBuildPath, -1, ManagedPdbBuildPath_full_name, ManagedPdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(ManagedPdbBuildPath_path_size == ManagedPdbBuildPath_full_name_path_size );
    if( ManagedPdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    NativePdbBuildPath_full_name = (CHAR*)malloc(NativePdbBuildPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(NativePdbBuildPath_full_name != NULL);
    if(NativePdbBuildPath_full_name == NULL){goto LExit;}

    NativePdbBuildPath_path_size = WideCharToMultiByte( CP_ACP, 0, NativePdbBuildPath, -1, NativePdbBuildPath_full_name, NativePdbBuildPath_full_name_path_size, NULL, NULL );
    _ASSERTE(NativePdbBuildPath_path_size == NativePdbBuildPath_full_name_path_size );
    if( NativePdbBuildPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCEnd_V2,
        ModuleID,
        AssemblyID,
        ModuleFlags,
        Reserved1,
        ModuleILPath_full_name,
        ModuleNativePath_full_name,
        ClrInstanceID,
        (const int*) ManagedPdbSignature,
        ManagedPdbAge,
        ManagedPdbBuildPath_full_name
        );

     tracepoint(
        DotNETRuntimeRundown,
        ModuleDCEnd_V2_1,
        (const int*) NativePdbSignature,
        NativePdbAge,
        NativePdbBuildPath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (NativePdbBuildPath_full_name != NULL) {free(NativePdbBuildPath_full_name);}
        if (ManagedPdbBuildPath_full_name != NULL) {free(ManagedPdbBuildPath_full_name);}
        if (ModuleNativePath_full_name != NULL) {free(ModuleNativePath_full_name);}
        if (ModuleILPath_full_name != NULL) {free(ModuleILPath_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyDCStart(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyDCStart()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AssemblyDCStart,
        AssemblyID,
        AppDomainID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyDCStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyDCStart_V1(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned __int64 BindingID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyDCStart_V1()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AssemblyDCStart_V1,
        AssemblyID,
        AppDomainID,
        BindingID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyDCEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyDCEnd(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyDCEnd()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AssemblyDCEnd,
        AssemblyID,
        AppDomainID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAssemblyDCEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAssemblyDCEnd_V1(
                  const unsigned __int64 AssemblyID,
                  const unsigned __int64 AppDomainID,
                  const unsigned __int64 BindingID,
                  const unsigned int AssemblyFlags,
                  PCWSTR FullyQualifiedAssemblyName,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAssemblyDCEnd_V1()){ return ERROR_SUCCESS;};
    INT FullyQualifiedAssemblyName_path_size = -1;
    INT FullyQualifiedAssemblyName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, NULL, 0, NULL, NULL );
    CHAR* FullyQualifiedAssemblyName_full_name=NULL;

    FullyQualifiedAssemblyName_full_name = (CHAR*)malloc(FullyQualifiedAssemblyName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(FullyQualifiedAssemblyName_full_name != NULL);
    if(FullyQualifiedAssemblyName_full_name == NULL){goto LExit;}

    FullyQualifiedAssemblyName_path_size = WideCharToMultiByte( CP_ACP, 0, FullyQualifiedAssemblyName, -1, FullyQualifiedAssemblyName_full_name, FullyQualifiedAssemblyName_full_name_path_size, NULL, NULL );
    _ASSERTE(FullyQualifiedAssemblyName_path_size == FullyQualifiedAssemblyName_full_name_path_size );
    if( FullyQualifiedAssemblyName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AssemblyDCEnd_V1,
        AssemblyID,
        AppDomainID,
        BindingID,
        AssemblyFlags,
        FullyQualifiedAssemblyName_full_name,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (FullyQualifiedAssemblyName_full_name != NULL) {free(FullyQualifiedAssemblyName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainDCStart(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainDCStart()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AppDomainDCStart,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainDCStart_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainDCStart_V1(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName,
                  const unsigned int AppDomainIndex,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainDCStart_V1()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AppDomainDCStart_V1,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name,
        AppDomainIndex,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainDCEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainDCEnd(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainDCEnd()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AppDomainDCEnd,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledAppDomainDCEnd_V1(){ return TRUE;}
extern "C" ULONG  FireEtXplatAppDomainDCEnd_V1(
                  const unsigned __int64 AppDomainID,
                  const unsigned int AppDomainFlags,
                  PCWSTR AppDomainName,
                  const unsigned int AppDomainIndex,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledAppDomainDCEnd_V1()){ return ERROR_SUCCESS;};
    INT AppDomainName_path_size = -1;
    INT AppDomainName_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, NULL, 0, NULL, NULL );
    CHAR* AppDomainName_full_name=NULL;

    AppDomainName_full_name = (CHAR*)malloc(AppDomainName_full_name_path_size*sizeof(CHAR));
    _ASSERTE(AppDomainName_full_name != NULL);
    if(AppDomainName_full_name == NULL){goto LExit;}

    AppDomainName_path_size = WideCharToMultiByte( CP_ACP, 0, AppDomainName, -1, AppDomainName_full_name, AppDomainName_full_name_path_size, NULL, NULL );
    _ASSERTE(AppDomainName_path_size == AppDomainName_full_name_path_size );
    if( AppDomainName_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                
     tracepoint(
        DotNETRuntimeRundown,
        AppDomainDCEnd_V1,
        AppDomainID,
        AppDomainFlags,
        AppDomainName_full_name,
        AppDomainIndex,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;
LExit:
        if (AppDomainName_full_name != NULL) {free(AppDomainName_full_name);}

return Error;
}
extern "C" BOOL  EventXplatEnabledThreadDC(){ return TRUE;}
extern "C" ULONG  FireEtXplatThreadDC(
                  const unsigned __int64 ManagedThreadID,
                  const unsigned __int64 AppDomainID,
                  const unsigned int Flags,
                  const unsigned int ManagedThreadIndex,
                  const unsigned int OSThreadID,
                  const unsigned short ClrInstanceID
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledThreadDC()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        ThreadDC,
        ManagedThreadID,
        AppDomainID,
        Flags,
        ManagedThreadIndex,
        OSThreadID,
        ClrInstanceID
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleRangeDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleRangeDCStart(
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ModuleID,
                  const unsigned int RangeBegin,
                  const unsigned int RangeSize,
                  const unsigned char RangeType
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleRangeDCStart()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        ModuleRangeDCStart,
        ClrInstanceID,
        ModuleID,
        RangeBegin,
        RangeSize,
        RangeType
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledModuleRangeDCEnd(){ return TRUE;}
extern "C" ULONG  FireEtXplatModuleRangeDCEnd(
                  const unsigned short ClrInstanceID,
                  const unsigned __int64 ModuleID,
                  const unsigned int RangeBegin,
                  const unsigned int RangeSize,
                  const unsigned char RangeType
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledModuleRangeDCEnd()){ return ERROR_SUCCESS;};

                                
     tracepoint(
        DotNETRuntimeRundown,
        ModuleRangeDCEnd,
        ClrInstanceID,
        ModuleID,
        RangeBegin,
        RangeSize,
        RangeType
        );

        Error = ERROR_SUCCESS;

return Error;
}
extern "C" BOOL  EventXplatEnabledRuntimeInformationDCStart(){ return TRUE;}
extern "C" ULONG  FireEtXplatRuntimeInformationDCStart(
                  const unsigned short ClrInstanceID,
                  const unsigned short Sku,
                  const unsigned short BclMajorVersion,
                  const unsigned short BclMinorVersion,
                  const unsigned short BclBuildNumber,
                  const unsigned short BclQfeNumber,
                  const unsigned short VMMajorVersion,
                  const unsigned short VMMinorVersion,
                  const unsigned short VMBuildNumber,
                  const unsigned short VMQfeNumber,
                  const unsigned int StartupFlags,
                  const unsigned char StartupMode,
                  PCWSTR CommandLine,
                  const GUID* ComObjectGuid,
                  PCWSTR RuntimeDllPath
)
{
  ULONG Error = ERROR_WRITE_FAULT;
    if (!EventXplatEnabledRuntimeInformationDCStart()){ return ERROR_SUCCESS;};
    INT CommandLine_path_size = -1;
    INT CommandLine_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, CommandLine, -1, NULL, 0, NULL, NULL );
    CHAR* CommandLine_full_name=NULL;
    INT RuntimeDllPath_path_size = -1;
    INT RuntimeDllPath_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, RuntimeDllPath, -1, NULL, 0, NULL, NULL );
    CHAR* RuntimeDllPath_full_name=NULL;

    CommandLine_full_name = (CHAR*)malloc(CommandLine_full_name_path_size*sizeof(CHAR));
    _ASSERTE(CommandLine_full_name != NULL);
    if(CommandLine_full_name == NULL){goto LExit;}

    CommandLine_path_size = WideCharToMultiByte( CP_ACP, 0, CommandLine, -1, CommandLine_full_name, CommandLine_full_name_path_size, NULL, NULL );
    _ASSERTE(CommandLine_path_size == CommandLine_full_name_path_size );
    if( CommandLine_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
    RuntimeDllPath_full_name = (CHAR*)malloc(RuntimeDllPath_full_name_path_size*sizeof(CHAR));
    _ASSERTE(RuntimeDllPath_full_name != NULL);
    if(RuntimeDllPath_full_name == NULL){goto LExit;}

    RuntimeDllPath_path_size = WideCharToMultiByte( CP_ACP, 0, RuntimeDllPath, -1, RuntimeDllPath_full_name, RuntimeDllPath_full_name_path_size, NULL, NULL );
    _ASSERTE(RuntimeDllPath_path_size == RuntimeDllPath_full_name_path_size );
    if( RuntimeDllPath_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
                                                    
     tracepoint(
        DotNETRuntimeRundown,
        RuntimeInformationDCStart,
        ClrInstanceID,
        Sku,
        BclMajorVersion,
        BclMinorVersion,
        BclBuildNumber,
        BclQfeNumber,
        VMMajorVersion,
        VMMinorVersion,
        VMBuildNumber,
        VMQfeNumber
        );

     tracepoint(
        DotNETRuntimeRundown,
        RuntimeInformationDCStart_1,
        StartupFlags,
        StartupMode,
        CommandLine_full_name,
        (const int*) ComObjectGuid,
        RuntimeDllPath_full_name
        );

        Error = ERROR_SUCCESS;
LExit:
        if (RuntimeDllPath_full_name != NULL) {free(RuntimeDllPath_full_name);}
        if (CommandLine_full_name != NULL) {free(CommandLine_full_name);}

return Error;
}
