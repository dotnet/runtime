//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information. 
//

// Packer
// 
// Lives on debugger right-side
// 
// Note that this file is generated by ndp\clr\src\Debug\tools\BuildDDMarshal\.  
// Changes should be made to output\DDPack_template.h in that directory.
// 


#ifndef _DD_PACK_H_
#define _DD_PACK_H_

#ifdef FEATURE_DBGIPC_TRANSPORT_DI

    class WriteBuffer;
    class ReadBuffer;

    // Flow is:
    // RS --> DDPack --> byte streams --> DDUnpack --> Real IDacDbiInterface

    // PAck up DD interface to a byte-sream.
    class DDMarshal : public IDacDbiInterface
    {
    public:
        /*
        DDMarshal(IDacDbiInterface * pReal, DDUnpack * pUnpack)
        {
            m_pReal = pReal;
            m_pUnpack = pUnpack;
        }
        // Used for trivial wrappers where we can't marshal yet.
        IDacDbiInterface * m_pReal;

        // The unpacker that gets called on the other side.
        DDUnpack * m_pUnpack;

        */

        DDMarshal(CordbProcess * pProcess)
        {
            m_pProcess = pProcess;
            m_sLock.Init("DDMarshal Lock", RSLock::cLockFlat, RSLock::LL_DD_MARSHAL_LOCK);
        }

        ~DDMarshal()
        {
            m_sLock.Destroy();
        }

        HRESULT Init();

        DbgTransportTarget *  m_pProxy;
        DbgTransportSession * m_pTransport;
        CordbProcess *        m_pProcess;
        RSLock                m_sLock;

        // Each DD interface boils down to calling Send.
        void SendDDMessage(WriteBuffer * pSend, ReadBuffer * pResult);

        
        // Sig without '=0' at end;
        // virtual BOOL IsAssemblyFullyTrusted(VMPTR_DomainAssembly vmDomainAssembly, T* myRef, MyStruct * pStruct);
//
// Signature definitions
//
virtual HRESULT CheckDbiVersion(const DbiVersion * pVersion);

virtual void GetLocalInterfaceHashAndTimestamp(DWORD & hash1, DWORD & hash2, DWORD & hash3, DWORD & hash4, DWORD & timestamp1, DWORD & timestamp2);

virtual void GetRemoteInterfaceHashAndTimestamp(DWORD & hash1, DWORD & hash2, DWORD & hash3, DWORD & hash4, DWORD & timestamp1, DWORD & timestamp2);

virtual HRESULT FlushCache();

virtual void DacSetTargetConsistencyChecks(bool fEnableAsserts);

virtual void Destroy();

virtual BOOL IsLeftSideInitialized();

virtual VMPTR_AppDomain GetAppDomainFromId(ULONG appdomainId);

virtual ULONG GetAppDomainId(VMPTR_AppDomain vmAppDomain);

virtual VMPTR_OBJECTHANDLE GetAppDomainObject(VMPTR_AppDomain vmAppDomain);

virtual BOOL IsDefaultDomain(VMPTR_AppDomain vmAppDomain);

virtual void GetAssemblyFromDomainAssembly(VMPTR_DomainAssembly vmDomainAssembly, VMPTR_Assembly * vmAssembly);

virtual BOOL IsAssemblyFullyTrusted(VMPTR_DomainAssembly vmDomainAssembly);

virtual void GetAppDomainFullName(VMPTR_AppDomain vmAppDomain, IStringHolder * pStrName);

virtual void GetModuleSimpleName(VMPTR_Module vmModule, IStringHolder * pStrFilename);

virtual BOOL GetAssemblyPath(VMPTR_Assembly vmAssembly, IStringHolder * pStrFilename);

virtual void ResolveTypeReference(const TypeRefData * pTypeRefInfo, TypeRefData * pTargetRefInfo);

virtual BOOL GetModulePath(VMPTR_Module vmModule, IStringHolder * pStrFilename);

virtual BOOL GetModuleNGenPath(VMPTR_Module vmModule, IStringHolder * pStrFilename);

virtual void GetMetadata(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer);

virtual void GetSymbolsBuffer(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer, IDacDbiInterface::SymbolFormat * pSymbolFormat);

virtual void GetModuleData(VMPTR_Module vmModule, ModuleInfo * pData);

virtual void GetDomainFileData(VMPTR_DomainFile vmDomainFile, DomainFileInfo * pData);

virtual void GetModuleForDomainFile(VMPTR_DomainFile vmDomainFile, VMPTR_Module * pModule);

virtual IDacDbiInterface::AddressType GetAddressType(CORDB_ADDRESS address);

virtual BOOL IsTransitionStub(CORDB_ADDRESS address);

virtual void GetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL * pfAllowJITOpts, BOOL * pfEnableEnC);

virtual HRESULT SetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL fAllowJitOpts, BOOL fEnableEnC);

virtual void EnumerateAppDomains(IDacDbiInterface::FP_APPDOMAIN_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual void EnumerateAssembliesInAppDomain(VMPTR_AppDomain vmAppDomain, IDacDbiInterface::FP_ASSEMBLY_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual void EnumerateModulesInAssembly(VMPTR_DomainAssembly vmAssembly, IDacDbiInterface::FP_MODULE_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual void RequestSyncAtEvent();

virtual void MarkDebuggerAttachPending();

virtual void MarkDebuggerAttached(BOOL fAttached);

virtual void Hijack(VMPTR_Thread vmThread, ULONG32 dwThreadId, const EXCEPTION_RECORD * pRecord, T_CONTEXT * pOriginalContext, ULONG32 cbSizeContext, EHijackReason::EHijackReason reason, void * pUserData, CORDB_ADDRESS * pRemoteContextAddr);

virtual void EnumerateConnections(IDacDbiInterface::FP_CONNECTION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual void EnumerateThreads(IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual bool IsThreadMarkedDead(VMPTR_Thread vmThread);

virtual HANDLE GetThreadHandle(VMPTR_Thread vmThread);

virtual VMPTR_OBJECTHANDLE GetThreadObject(VMPTR_Thread vmThread);

virtual void SetDebugState(VMPTR_Thread vmThread, CorDebugThreadState debugState);

virtual BOOL HasUnhandledException(VMPTR_Thread vmThread);

virtual CorDebugUserState GetUserState(VMPTR_Thread vmThread);

virtual CONNID GetConnectionID(VMPTR_Thread vmThread);

virtual TASKID GetTaskID(VMPTR_Thread vmThread);

virtual DWORD TryGetVolatileOSThreadID(VMPTR_Thread vmThread);

virtual DWORD GetUniqueThreadID(VMPTR_Thread vmThread);

virtual VMPTR_OBJECTHANDLE GetCurrentException(VMPTR_Thread vmThread);

virtual VMPTR_OBJECTHANDLE GetCurrentCustomDebuggerNotification(VMPTR_Thread vmThread);

virtual VMPTR_AppDomain GetCurrentAppDomain(VMPTR_Thread vmThread);

virtual VMPTR_DomainAssembly ResolveAssembly(VMPTR_DomainFile vmScope, mdToken tkAssemblyRef);

virtual void GetNativeCodeSequencePointsAndVarInfo(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS startAddress, BOOL fCodeAvailabe, NativeVarData * pNativeVarData, SequencePoints * pSequencePoints);

virtual VMPTR_CONTEXT GetManagedStoppedContext(VMPTR_Thread vmThread);

virtual void CreateStackWalk(VMPTR_Thread vmThread, DT_CONTEXT * pInternalContextBuffer, StackWalkHandle * ppSFIHandle);

virtual void DeleteStackWalk(StackWalkHandle ppSFIHandle);

virtual void GetStackWalkCurrentContext(StackWalkHandle pSFIHandle, DT_CONTEXT * pContext);

virtual void SetStackWalkCurrentContext(VMPTR_Thread vmThread, StackWalkHandle pSFIHandle, CorDebugSetContextFlag flag, DT_CONTEXT * pContext);

virtual BOOL UnwindStackWalkFrame(StackWalkHandle pSFIHandle);

virtual HRESULT CheckContext(VMPTR_Thread vmThread, const DT_CONTEXT * pContext);

virtual IDacDbiInterface::FrameType GetStackWalkCurrentFrameInfo(StackWalkHandle pSFIHandle, DebuggerIPCE_STRData * pFrameData);

virtual ULONG32 GetCountOfInternalFrames(VMPTR_Thread vmThread);

virtual void EnumerateInternalFrames(VMPTR_Thread vmThread, IDacDbiInterface::FP_INTERNAL_FRAME_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual BOOL IsMatchingParentFrame(FramePointer fpToCheck, FramePointer fpParent);

virtual ULONG32 GetStackParameterSize(CORDB_ADDRESS controlPC);

virtual FramePointer GetFramePointer(StackWalkHandle pSFIHandle);

virtual BOOL IsLeafFrame(VMPTR_Thread vmThread, const DT_CONTEXT * pContext);

virtual void GetContext(VMPTR_Thread vmThread, DT_CONTEXT * pContextBuffer);

virtual void ConvertContextToDebuggerRegDisplay(const DT_CONTEXT * pInContext, DebuggerREGDISPLAY * pOutDRD, BOOL fActive);

virtual IDacDbiInterface::DynamicMethodType IsILStubOrLCGMethod(VMPTR_MethodDesc vmMethodDesc);

virtual TargetBuffer GetVarArgSig(CORDB_ADDRESS VASigCookieAddr, CORDB_ADDRESS * pArgBase);

virtual BOOL RequiresAlign8(VMPTR_TypeHandle thExact);

virtual GENERICS_TYPE_TOKEN ResolveExactGenericArgsToken(DWORD dwExactGenericArgsTokenIndex, GENERICS_TYPE_TOKEN rawToken);

virtual void GetILCodeAndSig(VMPTR_DomainFile vmDomainFile, mdToken functionToken, TargetBuffer * pCodeInfo, mdToken * pLocalSigToken);

virtual void GetNativeCodeInfo(VMPTR_DomainFile vmDomainFile, mdToken functionToken, NativeCodeFunctionData * pCodeInfo);

virtual void GetNativeCodeInfoForAddr(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS hotCodeStartAddr, NativeCodeFunctionData * pCodeInfo);

virtual void GetClassInfo(VMPTR_AppDomain vmAppDomain, VMPTR_Module vmModule, mdTypeDef metadataToken, VMPTR_TypeHandle thExact, VMPTR_TypeHandle thApprox, ClassInfo * pData);

virtual void GetInstantiationFieldInfo(VMPTR_DomainFile vmDomainFile, mdTypeDef metadataToken, VMPTR_TypeHandle vmThExact, VMPTR_TypeHandle vmThApprox, DacDbiArrayList<FieldData> * pFieldList, SIZE_T * pObjectSize);

virtual void TypeHandleToExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, DebuggerIPCE_ExpandedTypeData * pTypeInfo);

virtual void GetObjectExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, CORDB_ADDRESS addr, DebuggerIPCE_ExpandedTypeData * pTypeInfo);

virtual void GetObjectExpandedTypeInfoFromID(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, COR_TYPEID id, DebuggerIPCE_ExpandedTypeData * pTypeInfo);

virtual VMPTR_TypeHandle GetApproxTypeHandle(TypeInfoList * pTypeData);

virtual HRESULT GetExactTypeHandle(DebuggerIPCE_ExpandedTypeData * pTypeData, ArgInfoList * pArgInfo, VMPTR_TypeHandle & vmTypeHandle);

virtual void GetMethodDescParams(VMPTR_AppDomain vmAppDomain, VMPTR_MethodDesc vmMethodDesc, GENERICS_TYPE_TOKEN genericsToken, UINT32 * pcGenericClassTypeParams, TypeParamsList * pGenericTypeParams);

virtual CORDB_ADDRESS GetThreadOrContextStaticAddress(VMPTR_FieldDesc vmField, VMPTR_Thread vmRuntimeThread);

virtual CORDB_ADDRESS GetCollectibleTypeStaticAddress(VMPTR_FieldDesc vmField, VMPTR_AppDomain vmAppDomain);

virtual void GetEnCHangingFieldInfo(const EnCHangingFieldInfo * pEnCFieldInfo, FieldData * pFieldData, BOOL * pfStatic);

virtual void GetTypeHandleParams(VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, TypeParamsList * pParams);

virtual void GetSimpleType(VMPTR_AppDomain vmAppDomain, CorElementType simpleType, mdTypeDef * pMetadataToken, VMPTR_Module * pVmModule, VMPTR_DomainFile * pVmDomainFile);

virtual BOOL IsExceptionObject(VMPTR_Object vmObject);

virtual void GetStackFramesFromException(VMPTR_Object vmObject, DacDbiArrayList<DacExceptionCallStackData> & dacStackFrames);

virtual BOOL IsRcw(VMPTR_Object vmObject);

virtual void GetRcwCachedInterfaceTypes(VMPTR_Object vmObject, VMPTR_AppDomain vmAppDomain, BOOL bIInspectableOnly, DacDbiArrayList<DebuggerIPCE_ExpandedTypeData> * pDacInterfaces);

virtual void GetRcwCachedInterfacePointers(VMPTR_Object vmObject, BOOL bIInspectableOnly, DacDbiArrayList<CORDB_ADDRESS> * pDacItfPtrs);

virtual void GetCachedWinRTTypesForIIDs(VMPTR_AppDomain vmAppDomain, DacDbiArrayList<GUID> & iids, DacDbiArrayList<DebuggerIPCE_ExpandedTypeData> * pTypes);

virtual void GetCachedWinRTTypes(VMPTR_AppDomain vmAppDomain, DacDbiArrayList<GUID> * piids, DacDbiArrayList<DebuggerIPCE_ExpandedTypeData> * pTypes);

virtual void GetTypedByRefInfo(CORDB_ADDRESS pTypedByRef, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData);

virtual void GetStringData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData);

virtual void GetArrayData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData);

virtual void GetBasicObjectInfo(CORDB_ADDRESS objectAddress, CorElementType type, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData);

virtual void TestCrst(VMPTR_Crst vmCrst);

virtual void TestRWLock(VMPTR_SimpleRWLock vmRWLock);

virtual CORDB_ADDRESS GetDebuggerControlBlockAddress();

virtual VMPTR_Object GetObjectFromRefPtr(CORDB_ADDRESS ptr);

virtual VMPTR_Object GetObject(CORDB_ADDRESS ptr);

virtual HRESULT EnableNGENPolicy(CorDebugNGENPolicy ePolicy);

virtual VMPTR_OBJECTHANDLE GetVmObjectHandle(CORDB_ADDRESS handleAddress);

virtual BOOL IsVmObjectHandleValid(VMPTR_OBJECTHANDLE vmHandle);

virtual HRESULT IsWinRTModule(VMPTR_Module vmModule, BOOL & isWinRT);

virtual ULONG GetAppDomainIdFromVmObjectHandle(VMPTR_OBJECTHANDLE vmHandle);

virtual CORDB_ADDRESS GetHandleAddressFromVmHandle(VMPTR_OBJECTHANDLE vmHandle);

virtual TargetBuffer GetObjectContents(VMPTR_Object obj);

virtual void EnumerateBlockingObjects(VMPTR_Thread vmThread, IDacDbiInterface::FP_BLOCKINGOBJECT_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual MonitorLockInfo GetThreadOwningMonitorLock(VMPTR_Object vmObject);

virtual void EnumerateMonitorEventWaitList(VMPTR_Object vmObject, IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData);

virtual CLR_DEBUGGING_PROCESS_FLAGS GetAttachStateFlags();

virtual bool GetMetaDataFileInfoFromPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwImageSize, bool & isNGEN, IStringHolder * pStrFilename);

virtual bool GetILImageInfoFromNgenPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwSize, IStringHolder * pStrFilename);

virtual bool IsThreadSuspendedOrHijacked(VMPTR_Thread vmThread);

virtual bool AreGCStructuresValid();

virtual HRESULT CreateHeapWalk(HeapWalkHandle * pHandle);

virtual void DeleteHeapWalk(HeapWalkHandle handle);

virtual HRESULT WalkHeap(HeapWalkHandle handle, ULONG count, COR_HEAPOBJECT * objects, ULONG * pFetched);

virtual HRESULT GetHeapSegments(DacDbiArrayList<COR_SEGMENT> * pSegments);

virtual bool IsValidObject(CORDB_ADDRESS obj);

virtual bool GetAppDomainForObject(CORDB_ADDRESS obj, VMPTR_AppDomain * pApp, VMPTR_Module * pModule, VMPTR_DomainFile * pDomainFile);

virtual HRESULT CreateRefWalk(RefWalkHandle * pHandle, BOOL walkStacks, BOOL walkFQ, UINT32 handleWalkMask);

virtual void DeleteRefWalk(RefWalkHandle handle);

virtual HRESULT WalkRefs(RefWalkHandle handle, ULONG count, DacGcReference * refs, ULONG * pFetched);

virtual HRESULT GetTypeID(CORDB_ADDRESS obj, COR_TYPEID * pType);

virtual HRESULT GetObjectFields(COR_TYPEID id, ULONG32 celt, COR_FIELD * layout, ULONG32 * pceltFetched);

virtual HRESULT GetTypeLayout(COR_TYPEID id, COR_TYPE_LAYOUT * pLayout);

virtual HRESULT GetArrayLayout(COR_TYPEID id, COR_ARRAY_LAYOUT * pLayout);

virtual void GetGCHeapInformation(COR_HEAPINFO * pHeapInfo);

        

    };

#endif //FEATURE_DBGIPC_TRANSPORT_DI


#endif // _DD_PACK_H_

// end of file
