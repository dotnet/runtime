// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace System.Text.Json.Serialization.Metadata
{
    // Recognizing types emitted by the F# compiler requires consuming APIs from the FSharp.Core runtime library.
    // Every F# application ships with a copy of FSharp.Core, however it is not available statically to System.Text.Json.
    // The following class uses reflection to access the relevant APIs required to detect the various F# types we are looking to support.

    /// <summary>
    /// The various categories of F# types that System.Text.Json supports.
    /// </summary>
    internal enum FSharpKind
    {
        Unrecognized, Option, List, Set, Map, Record
    }

    /// <summary>
    /// Proxy class used to access FSharp.Core metadata and reflection APIs that are not statically available to System.Text.Json.
    /// </summary>
    internal sealed class FSharpCoreReflectionProxy
    {
        public const string FSharpCoreUnreferencedCodeMessage = "Uses Reflection to access FSharp.Core components, which requires unreferenced code.";

        private static object s_lockObj = new object();
        private static FSharpCoreReflectionProxy? s_singletonInstance;

        // Every type generated by the F# compiler is annotated with the CompilationMappingAttribute
        // containing all relevant metadata required to determine its kind:
        // https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-compilationmappingattribute.html#SourceConstructFlags
        private const string CompilationMappingAttributeTypeName = "Microsoft.FSharp.Core.CompilationMappingAttribute";
        private readonly Type _compilationMappingAttributeType;
        private readonly MethodInfo? _sourceConstructFlagsGetter;

        private readonly Type? _fsharpOptionType;
        private readonly Type? _fsharpListType;
        private readonly Type? _fsharpSetType;
        private readonly Type? _fsharpMapType;

        private readonly MethodInfo? _fsharpListCtor;
        private readonly MethodInfo? _fsharpSetCtor;
        private readonly MethodInfo? _fsharpMapCtor;

        /// <summary>
        /// Checks if the provided System.Type instance is emitted by the F# compiler.
        /// If true, also initializes the proxy singleton for future by other F# types.
        /// </summary>
        public static bool IsFSharpType(Type type)
        {
            if (s_singletonInstance is null)
            {
                if (GetFSharpCoreAssembly(type) is Assembly fsharpCoreAssembly)
                {
                    // Type is F# type, initialize the singleton instance.
                    lock (s_lockObj)
                    {
                        s_singletonInstance ??= new FSharpCoreReflectionProxy(fsharpCoreAssembly);
                    }

                    return true;
                }

                return false;
            }

            return s_singletonInstance.GetFSharpCompilationMappingAttribute(type) is not null;
        }

        /// <summary>
        /// Gets the singleton proxy instance; prerequires a successful IsFSharpType call for proxy initialization.
        /// </summary>
        public static FSharpCoreReflectionProxy Instance
        {
            get
            {
                Debug.Assert(s_singletonInstance is not null, "should be initialized via a successful IsFSharpType call.");
                return s_singletonInstance;
            }
        }

        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The public methods are marked RequiresUnreferencedCode.")]
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern", Justification = "The public methods are marked RequiresUnreferencedCode.")]
        private FSharpCoreReflectionProxy(Assembly fsharpCoreAssembly)
        {
            Debug.Assert(fsharpCoreAssembly.GetName().Name == "FSharp.Core");

            Type compilationMappingAttributeType = fsharpCoreAssembly.GetType(CompilationMappingAttributeTypeName)!;
            _sourceConstructFlagsGetter = compilationMappingAttributeType.GetMethod("get_SourceConstructFlags", BindingFlags.Public | BindingFlags.Instance);
            _compilationMappingAttributeType = compilationMappingAttributeType;

            _fsharpOptionType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Core.FSharpOption`1");
            _fsharpListType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpList`1");
            _fsharpSetType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpSet`1");
            _fsharpMapType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpMap`2");

            _fsharpListCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.ListModule")?.GetMethod("OfSeq", BindingFlags.Public | BindingFlags.Static);
            _fsharpSetCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.SetModule")?.GetMethod("OfSeq", BindingFlags.Public | BindingFlags.Static);
            _fsharpMapCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.MapModule")?.GetMethod("OfSeq", BindingFlags.Public | BindingFlags.Static);
        }

        [RequiresUnreferencedCode(FSharpCoreUnreferencedCodeMessage)]
        public FSharpKind DetectFSharpKind(Type type)
        {
            Attribute? compilationMappingAttribute = GetFSharpCompilationMappingAttribute(type);

            if (compilationMappingAttribute is null)
            {
                return FSharpKind.Unrecognized;
            }

            if (type.IsGenericType)
            {
                Type genericType = type.GetGenericTypeDefinition();
                if (genericType == _fsharpOptionType) return FSharpKind.Option;
                if (genericType == _fsharpListType) return FSharpKind.List;
                if (genericType == _fsharpSetType) return FSharpKind.Set;
                if (genericType == _fsharpMapType) return FSharpKind.Map;
            }

            return (GetSourceConstructFlags(compilationMappingAttribute) & SourceConstructFlags.KindMask) switch
            {
                SourceConstructFlags.RecordType => FSharpKind.Record,
                _ => FSharpKind.Unrecognized
            };
        }

        [RequiresUnreferencedCode(FSharpCoreUnreferencedCodeMessage)]
        public Func<TFSharpOption, T> CreateFSharpOptionValueGetter<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, T>()
        {
            Debug.Assert(typeof(TFSharpOption).GetGenericTypeDefinition() == _fsharpOptionType!);
            MethodInfo valueGetter = EnsureMemberExists(typeof(TFSharpOption).GetMethod("get_Value", BindingFlags.Public | BindingFlags.Instance), "Option.Value");
            return CreateDelegate<Func<TFSharpOption, T>>(valueGetter);
        }

        [RequiresUnreferencedCode(FSharpCoreUnreferencedCodeMessage)]
        public Func<T, TFSharpOption> CreateFSharpOptionConstructor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, T>()
        {
            Debug.Assert(typeof(TFSharpOption).GetGenericTypeDefinition() == _fsharpOptionType!);
            MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpOption).GetMethod("Some", BindingFlags.Public | BindingFlags.Static), "Option.Some");
            return CreateDelegate<Func<T, TFSharpOption>>(methodInfo);
        }

        [RequiresUnreferencedCode(FSharpCoreUnreferencedCodeMessage)]
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2060:MakeGenericMethod", Justification = "The public methods are marked RequiresUnreferencedCode.")]
        public Func<IEnumerable<T>, TFSharpList> CreateFSharpListConstructor<TFSharpList, T>()
        {
            Debug.Assert(typeof(TFSharpList).GetGenericTypeDefinition() == _fsharpListType!);
            return CreateDelegate<Func<IEnumerable<T>, TFSharpList>>(EnsureMemberExists(_fsharpListCtor, "List.ofSeq").MakeGenericMethod(typeof(T)));
        }

        [RequiresUnreferencedCode(FSharpCoreUnreferencedCodeMessage)]
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2060:MakeGenericMethod", Justification = "The public methods are marked RequiresUnreferencedCode.")]
        public Func<IEnumerable<T>, TFSharpSet> CreateFSharpSetConstructor<TFSharpSet, T>()
        {
            Debug.Assert(typeof(TFSharpSet).GetGenericTypeDefinition() == _fsharpSetType!);
            return CreateDelegate<Func<IEnumerable<T>, TFSharpSet>>(EnsureMemberExists(_fsharpSetCtor, "Set.ofSeq").MakeGenericMethod(typeof(T)));
        }

        [RequiresUnreferencedCode(FSharpCoreUnreferencedCodeMessage)]
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2060:MakeGenericMethod", Justification = "The public methods are marked RequiresUnreferencedCode.")]
        public Func<IEnumerable<Tuple<TKey, TValue>>, TFSharpMap> CreateFSharpMapConstructor<TFSharpMap, TKey, TValue>()
        {
            Debug.Assert(typeof(TFSharpMap).GetGenericTypeDefinition() == _fsharpMapType!);
            return CreateDelegate<Func<IEnumerable<Tuple<TKey, TValue>>, TFSharpMap>>(EnsureMemberExists(_fsharpMapCtor, "Map.ofSeq").MakeGenericMethod(typeof(TKey), typeof(TValue)));
        }

        private Attribute? GetFSharpCompilationMappingAttribute(Type type)
            => type.GetCustomAttribute(_compilationMappingAttributeType, inherit: true);

        private SourceConstructFlags GetSourceConstructFlags(Attribute compilationMappingAttribute)
            => _sourceConstructFlagsGetter is null ? SourceConstructFlags.None : (SourceConstructFlags)_sourceConstructFlagsGetter.Invoke(compilationMappingAttribute, null)!;

        // If the provided type is generated by the F# compiler, returns the runtime FSharp.Core assembly.
        private static Assembly? GetFSharpCoreAssembly(Type type)
        {
            foreach (Attribute attr in type.GetCustomAttributes(inherit: true))
            {
                Type attributeType = attr.GetType();
                if (attributeType.FullName == CompilationMappingAttributeTypeName)
                {
                    return attributeType.Assembly;
                }
            }

            return null;
        }

        private static TDelegate CreateDelegate<TDelegate>(MethodInfo methodInfo) where TDelegate : Delegate
            => (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), methodInfo, throwOnBindFailure: true)!;

        private TMemberInfo EnsureMemberExists<TMemberInfo>(TMemberInfo? memberInfo, string memberName) where TMemberInfo : MemberInfo
        {
            if (memberInfo is null)
            {
                ThrowHelper.ThrowMissingMemberException_MissingFSharpCoreMember(memberName);
            }

            return memberInfo;
        }

        // Replicates the F# source construct flags enum
        // https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-sourceconstructflags.html
        private enum SourceConstructFlags
        {
            None = 0,
            SumType = 1,
            RecordType = 2,
            ObjectType = 3,
            Field = 4,
            Exception = 5,
            Closure = 6,
            Module = 7,
            UnionCase = 8,
            Value = 9,
            KindMask = 31,
            NonPublicRepresentation = 32
        }
    }
}
