// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Diagnostics;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace Microsoft.Extensions.Configuration.Binder.SourceGeneration
{
    public sealed partial class ConfigurationBindingGenerator : IIncrementalGenerator
    {
        private sealed partial class Emitter
        {
            private readonly SourceProductionContext _context;
            private readonly SourceGenerationSpec _sourceGenSpec;

            // Postfix for stringValueX variables used to save config value indexer
            // results e.g. if (configuration["Key"] is string stringValue0) { ... }
            private int _parseValueCount;

            private bool _precedingBlockExists;

            private readonly SourceWriter _writer = new();

            private static readonly Regex s_arrayBracketsRegex = new(Regex.Escape("[]"));

            public bool _useFullyQualifiedNames { get; private set; }

            public Emitter(SourceProductionContext context, SourceGenerationSpec sourceGenSpec)
            {
                _context = context;
                _sourceGenSpec = sourceGenSpec;
            }

            public void Emit()
            {
                if (!ShouldEmitBinders())
                {
                    return;
                }

                _writer.WriteLine(@"// <auto-generated/>
#nullable enable
");
                _useFullyQualifiedNames = true;
                EmitBinder_ConfigurationBinder();
                EmitBinder_Extensions_OptionsBuilder();
                EmitBinder_Extensions_ServiceCollection();

                _useFullyQualifiedNames = false;
                Emit_CoreBindingHelper();

                _context.AddSource($"{Identifier.GeneratedConfigurationBinder}.g.cs", _writer.ToSourceText());
            }

            private void EmitBindLogicFromRootMethod(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                TypeSpecKind kind = type.SpecKind;

                if (kind is TypeSpecKind.Nullable)
                {
                    EmitBindLogicFromRootMethod(((NullableSpec)type).UnderlyingType, expressionForMemberAccess, initKind);
                }
                else
                {
                    if (type is ParsableFromStringSpec stringParsableType)
                    {
                        if (initKind is InitializationKind.Declaration)
                        {
                            EmitCastToIConfigurationSection();
                            _writer.WriteLine($"{GetTypeDisplayString(type)} {expressionForMemberAccess} = default!;");
                        }
                        else
                        {
                            EmitCastToIConfigurationSection();
                        }

                        EmitBindLogicFromString(stringParsableType, Expression.sectionValue, Expression.sectionPath);
                    }
                    else
                    {
                        EmitBindCoreCall(type, expressionForMemberAccess, Identifier.configuration, initKind);
                    }
                }
            }

            private void EmitBindCoreCall(
                TypeSpec type,
                string expressionForMemberAccess,
                string expressionForConfigArg,
                InitializationKind initKind)
            {
                Debug.Assert(type.CanInitialize);

                string tempVarName = GetIncrementalVarName(Identifier.temp);
                if (initKind is InitializationKind.AssignmentWithNullCheck)
                {
                    _writer.WriteLine($"{type.MinimalDisplayString} {tempVarName} = {expressionForMemberAccess};");
                    EmitObjectInit(type, tempVarName, InitializationKind.AssignmentWithNullCheck);
                    EmitBindCoreCall(tempVarName);
                }
                else if (initKind is InitializationKind.None && type.IsValueType)
                {
                    EmitObjectInit(type, tempVarName, InitializationKind.Declaration);
                    _writer.WriteLine($@"{Identifier.BindCore}({expressionForConfigArg}, ref {tempVarName}, {Identifier.binderOptions});");
                    _writer.WriteLine($"{expressionForMemberAccess} = {tempVarName};");
                }
                else
                {
                    EmitObjectInit(type, expressionForMemberAccess, initKind);
                    EmitBindCoreCall(expressionForMemberAccess);
                }

                void EmitBindCoreCall(string varName)
                {
                    string bindCoreCall = $@"{GetHelperMethodDisplayString(Identifier.BindCore)}({expressionForConfigArg}, ref {varName}, {Identifier.binderOptions});";
                    _writer.WriteLine(bindCoreCall);
                }
            }

            public void EmitBindLogicFromString(
                ParsableFromStringSpec type,
                string configStringValueExpr,
                string configValuePathExpr,
                Action<string>? writeOnSuccess = null,
                bool isCollectionElement = false)
            {
                StringParsableTypeKind typeKind = type.StringParsableTypeKind;
                Debug.Assert(typeKind is not StringParsableTypeKind.None);

                string stringValueVarName = GetIncrementalVarName(Identifier.stringValue);
                string parsedValueExpr;

                if (typeKind is StringParsableTypeKind.ConfigValue)
                {
                    if (isCollectionElement)
                    {
                        parsedValueExpr = stringValueVarName;
                    }
                    else
                    {
                        writeOnSuccess?.Invoke(configStringValueExpr);
                        return;
                    }
                }
                else
                {
                    string helperMethodDisplayString = GetHelperMethodDisplayString(type.ParseMethodName);
                    parsedValueExpr = $"{helperMethodDisplayString}({stringValueVarName}, () => {configValuePathExpr})";
                }

                _writer.WriteBlockStart($"if ({configStringValueExpr} is string {stringValueVarName})");
                writeOnSuccess?.Invoke(parsedValueExpr);
                _writer.WriteBlockEnd();

                return;
            }

            private bool EmitObjectInit(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                Debug.Assert(type.CanInitialize);

                if (initKind is InitializationKind.None)
                {
                    return true;
                }

                string expressionForInit;
                CollectionSpec? collectionType = type as CollectionSpec;

                string effectiveDisplayString = GetTypeDisplayString(type);
                if (collectionType is not null)
                {
                    if (collectionType is EnumerableSpec { InitializationStrategy: InitializationStrategy.Array })
                    {
                        expressionForInit = $"new {s_arrayBracketsRegex.Replace(effectiveDisplayString, "[0]", 1)}";
                    }
                    else
                    {
                        effectiveDisplayString = GetTypeDisplayString(collectionType.ConcreteType ?? collectionType);
                        expressionForInit = $"new {effectiveDisplayString}()";
                    }
                }
                else if (type.InitializationStrategy is InitializationStrategy.ParameterlessConstructor)
                {
                    expressionForInit = $"new {effectiveDisplayString}()";
                }
                else
                {
                    Debug.Assert(type.InitializationStrategy is InitializationStrategy.ParameterizedConstructor);
                    string expressionForConfigSection = initKind is InitializationKind.Declaration ? Identifier.configuration : Identifier.section;
                    string initMethodIdentifier = GetHelperMethodDisplayString(((ObjectSpec)type).InitializeMethodDisplayString);
                    expressionForInit = $"{initMethodIdentifier}({expressionForConfigSection}, {Identifier.binderOptions});";
                }

                if (initKind == InitializationKind.Declaration)
                {
                    Debug.Assert(!expressionForMemberAccess.Contains("."));
                    _writer.WriteLine($"var {expressionForMemberAccess} = {expressionForInit};");
                }
                else if (initKind == InitializationKind.AssignmentWithNullCheck)
                {
                    if (collectionType is CollectionSpec
                        {
                            InitializationStrategy: InitializationStrategy.ParameterizedConstructor or InitializationStrategy.ToEnumerableMethod
                        })
                    {
                        if (collectionType.InitializationStrategy is InitializationStrategy.ParameterizedConstructor)
                        {
                            _writer.WriteLine($"{expressionForMemberAccess} = {expressionForMemberAccess} is null ? {expressionForInit} : new {effectiveDisplayString}({expressionForMemberAccess});");
                        }
                        else
                        {
                            _writer.WriteLine($"{expressionForMemberAccess} = {expressionForMemberAccess} is null ? {expressionForInit} : {expressionForMemberAccess}.{collectionType.ToEnumerableMethodCall!};");
                        }
                    }
                    else
                    {
                        _writer.WriteLine($"{expressionForMemberAccess} ??= {expressionForInit};");
                    }
                }
                else
                {
                    Debug.Assert(initKind is InitializationKind.SimpleAssignment);
                    _writer.WriteLine($"{expressionForMemberAccess} = {expressionForInit};");
                }

                return true;
            }

            public void EmitCastToIConfigurationSection()
            {
                string sectionTypeDisplayString;
                string exceptionTypeDisplayString;
                if (_useFullyQualifiedNames)
                {
                    sectionTypeDisplayString = "global::Microsoft.Extensions.Configuration.IConfigurationSection";
                    exceptionTypeDisplayString = FullyQualifiedDisplayString.InvalidOperationException;
                }
                else
                {
                    sectionTypeDisplayString = Identifier.IConfigurationSection;
                    exceptionTypeDisplayString = nameof(InvalidOperationException);
                }

                _writer.WriteBlock($$"""
                    if ({{Identifier.configuration}} is not {{sectionTypeDisplayString}} {{Identifier.section}})
                    {
                        throw new {{exceptionTypeDisplayString}}();
                    }
                    """);
            }

            public void EmitIConfigurationHasValueOrChildrenCheck(bool voidReturn)
            {
                string returnPostfix = voidReturn ? string.Empty : " null";
                string methodDisplayString = GetHelperMethodDisplayString(Identifier.HasValueOrChildren);

                _writer.WriteBlock($$"""
                    if (!{{methodDisplayString}}({{Identifier.configuration}}))
                    {
                        return{{returnPostfix}};
                    }
                    """);
                _writer.WriteBlankLine();
            }
        }
    }
}
