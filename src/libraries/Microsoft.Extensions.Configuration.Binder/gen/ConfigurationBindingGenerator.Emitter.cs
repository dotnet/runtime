// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Diagnostics;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace Microsoft.Extensions.Configuration.Binder.SourceGeneration
{
    internal sealed partial class Emitter
    {
        private readonly Regex _arrayBracketsRegex = new(Regex.Escape("[]"));

        private readonly SourceProductionContext _context;

        // Postfix for stringValueX variables used to save config value indexer
        // results e.g. if (configuration["Key"] is string stringValue0) { ... }
        private int _parseValueCount;

        public Emitter(SourceProductionContext context, SourceGenSpec sourceGenSpec)
        {
            _context = context;
            SourceGenSpec = sourceGenSpec;
        }

        public enum InitializationKind
        {
            None = 0,
            SimpleAssignment = 1,
            AssignmentWithNullCheck = 2,
            Declaration = 3,
        }

        public SourceGenSpec SourceGenSpec { get; }

        public SourceWriter Writer { get; } = new();

        public bool PrecedingBlockExists { get; set; }

        public bool UseFullyQualifiedNames { get; private set; }

        public void Emit()
        {
            Debug.Assert(SourceGenSpec.HasRootMethods());

            Writer.WriteLine(@"// <auto-generated/>
#nullable enable
");
            UseFullyQualifiedNames = true;
            SourceGenSpec.ConfigBinderSpec.Emit(this);
            SourceGenSpec.OptionsBuilderSpec.Emit(this);
            SourceGenSpec.ServiceCollectionSpec.Emit(this);

            UseFullyQualifiedNames = false;
            SourceGenSpec.CoreBindingHelperSpec.Emit(this);

            _context.AddSource($"{Identifier.GeneratedConfigurationBinder}.g.cs", Writer.ToSourceText());
        }

        public void EmitBindLogicFromRootMethod(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
        {
            TypeSpecKind kind = type.SpecKind;

            if (kind is TypeSpecKind.Nullable)
            {
                EmitBindLogicFromRootMethod(((NullableSpec)type).UnderlyingType, expressionForMemberAccess, initKind);
            }
            else
            {
                if (type is ParsableFromStringSpec stringParsableType)
                {
                    if (initKind is InitializationKind.Declaration)
                    {
                        EmitCastToIConfigurationSection();
                        Writer.WriteLine($"{GetTypeDisplayString(type)} {expressionForMemberAccess} = default!;");
                    }
                    else
                    {
                        EmitCastToIConfigurationSection();
                    }

                    EmitBindLogicFromString(stringParsableType, Expression.sectionValue, Expression.sectionPath);
                }
                else
                {
                    EmitBindCoreCall(type, expressionForMemberAccess, Identifier.configuration, initKind);
                }
            }
        }

        public void EmitBindCoreCall(
            TypeSpec type,
            string expressionForMemberAccess,
            string expressionForConfigArg,
            InitializationKind initKind)
        {
            Debug.Assert(type.CanInitialize);

            string tempVarName = GetIncrementalVarName(Identifier.temp);
            if (initKind is InitializationKind.AssignmentWithNullCheck)
            {
                Writer.WriteLine($"{type.MinimalDisplayString} {tempVarName} = {expressionForMemberAccess};");
                EmitObjectInit(type, tempVarName, InitializationKind.AssignmentWithNullCheck);
                EmitBindCoreCall(tempVarName);
            }
            else if (initKind is InitializationKind.None && type.IsValueType)
            {
                EmitObjectInit(type, tempVarName, InitializationKind.Declaration);
                Writer.WriteLine($@"{Identifier.BindCore}({expressionForConfigArg}, ref {tempVarName}, {Identifier.binderOptions});");
                Writer.WriteLine($"{expressionForMemberAccess} = {tempVarName};");
            }
            else
            {
                EmitObjectInit(type, expressionForMemberAccess, initKind);
                EmitBindCoreCall(expressionForMemberAccess);
            }

            void EmitBindCoreCall(string varName)
            {
                string bindCoreCall = $@"{GetHelperMethodDisplayString(Identifier.BindCore)}({expressionForConfigArg}, ref {varName}, {Identifier.binderOptions});";
                Writer.WriteLine(bindCoreCall);
            }
        }

        public void EmitBindLogicFromString(
            ParsableFromStringSpec type,
            string configStringValueExpr,
            string configValuePathExpr,
            Action<string>? writeOnSuccess = null,
            bool isCollectionElement = false)
        {
            StringParsableTypeKind typeKind = type.StringParsableTypeKind;
            Debug.Assert(typeKind is not StringParsableTypeKind.None);

            string stringValueVarName = GetIncrementalVarName(Identifier.stringValue);
            string parsedValueExpr;

            if (typeKind is StringParsableTypeKind.ConfigValue)
            {
                if (isCollectionElement)
                {
                    parsedValueExpr = stringValueVarName;
                }
                else
                {
                    writeOnSuccess?.Invoke(configStringValueExpr);
                    return;
                }
            }
            else
            {
                string helperMethodDisplayString = GetHelperMethodDisplayString(type.ParseMethodName);
                parsedValueExpr = $"{helperMethodDisplayString}({stringValueVarName}, () => {configValuePathExpr})";
            }

            Writer.WriteBlockStart($"if ({configStringValueExpr} is string {stringValueVarName})");
            writeOnSuccess?.Invoke(parsedValueExpr);
            Writer.WriteBlockEnd();

            return;
        }

        public bool EmitObjectInit(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
        {
            Debug.Assert(type.CanInitialize);

            if (initKind is InitializationKind.None)
            {
                return true;
            }

            string expressionForInit;
            CollectionSpec? collectionType = type as CollectionSpec;

            string effectiveDisplayString = GetTypeDisplayString(type);
            if (collectionType is not null)
            {
                if (collectionType is EnumerableSpec { InitializationStrategy: InitializationStrategy.Array })
                {
                    expressionForInit = $"new {_arrayBracketsRegex.Replace(effectiveDisplayString, "[0]", 1)}";
                }
                else
                {
                    effectiveDisplayString = GetTypeDisplayString(collectionType.ConcreteType ?? collectionType);
                    expressionForInit = $"new {effectiveDisplayString}()";
                }
            }
            else if (type.InitializationStrategy is InitializationStrategy.ParameterlessConstructor)
            {
                expressionForInit = $"new {effectiveDisplayString}()";
            }
            else
            {
                Debug.Assert(type.InitializationStrategy is InitializationStrategy.ParameterizedConstructor);
                string expressionForConfigSection = initKind is InitializationKind.Declaration ? Identifier.configuration : Identifier.section;
                string initMethodIdentifier = GetHelperMethodDisplayString(((ObjectSpec)type).InitializeMethodDisplayString);
                expressionForInit = $"{initMethodIdentifier}({expressionForConfigSection}, {Identifier.binderOptions});";
            }

            if (initKind == InitializationKind.Declaration)
            {
                Debug.Assert(!expressionForMemberAccess.Contains("."));
                Writer.WriteLine($"var {expressionForMemberAccess} = {expressionForInit};");
            }
            else if (initKind == InitializationKind.AssignmentWithNullCheck)
            {
                if (collectionType is CollectionSpec
                    {
                        InitializationStrategy: InitializationStrategy.ParameterizedConstructor or InitializationStrategy.ToEnumerableMethod
                    })
                {
                    if (collectionType.InitializationStrategy is InitializationStrategy.ParameterizedConstructor)
                    {
                        Writer.WriteLine($"{expressionForMemberAccess} = {expressionForMemberAccess} is null ? {expressionForInit} : new {effectiveDisplayString}({expressionForMemberAccess});");
                    }
                    else
                    {
                        Writer.WriteLine($"{expressionForMemberAccess} = {expressionForMemberAccess} is null ? {expressionForInit} : {expressionForMemberAccess}.{collectionType.ToEnumerableMethodCall!};");
                    }
                }
                else
                {
                    Writer.WriteLine($"{expressionForMemberAccess} ??= {expressionForInit};");
                }
            }
            else
            {
                Debug.Assert(initKind is InitializationKind.SimpleAssignment);
                Writer.WriteLine($"{expressionForMemberAccess} = {expressionForInit};");
            }

            return true;
        }

        public void EmitCastToIConfigurationSection()
        {
            string sectionTypeDisplayString;
            string exceptionTypeDisplayString;
            if (UseFullyQualifiedNames)
            {
                sectionTypeDisplayString = "global::Microsoft.Extensions.Configuration.IConfigurationSection";
                exceptionTypeDisplayString = FullyQualifiedDisplayString.InvalidOperationException;
            }
            else
            {
                sectionTypeDisplayString = Identifier.IConfigurationSection;
                exceptionTypeDisplayString = nameof(InvalidOperationException);
            }

            Writer.WriteBlock($$"""
                    if ({{Identifier.configuration}} is not {{sectionTypeDisplayString}} {{Identifier.section}})
                    {
                        throw new {{exceptionTypeDisplayString}}();
                    }
                    """);
        }

        public void EmitIConfigurationHasValueOrChildrenCheck(bool voidReturn)
        {
            string returnPostfix = voidReturn ? string.Empty : " null";
            string methodDisplayString = GetHelperMethodDisplayString(Identifier.HasValueOrChildren);

            Writer.WriteBlock($$"""
                    if (!{{methodDisplayString}}({{Identifier.configuration}}))
                    {
                        return{{returnPostfix}};
                    }
                    """);
            Writer.WriteBlankLine();
        }

        public string GetTypeDisplayString(TypeSpec type) => UseFullyQualifiedNames ? type.FullyQualifiedDisplayString : type.MinimalDisplayString;

        public void EmitBlankLineIfRequired()
        {
            if (PrecedingBlockExists)
            {
                Writer.WriteBlankLine();
            }

            PrecedingBlockExists = true;
        }

        public void EmitCheckForNullArgument_WithBlankLine_IfRequired(bool isValueType)
        {
            if (!isValueType)
            {
                EmitCheckForNullArgument_WithBlankLine(Identifier.obj);
            }
        }

        public void EmitCheckForNullArgument_WithBlankLine(string paramName)
        {
            string exceptionTypeDisplayString = UseFullyQualifiedNames
                ? "global::System.ArgumentNullException"
                : "ArgumentNullException";

            Writer.WriteBlock($$"""
                    if ({{paramName}} is null)
                    {
                        throw new {{exceptionTypeDisplayString}}(nameof({{paramName}}));
                    }
                    """);

            Writer.WriteBlankLine();
        }

        public bool EmitInitException(TypeSpec type)
        {
            Debug.Assert(type.InitializationStrategy is not InitializationStrategy.None);

            if (!type.CanInitialize)
            {
                Writer.WriteLine(GetInitException(type.InitExceptionMessage) + ";");
                return true;
            }

            return false;
        }

        public string GetInitException(string message) =>
            $@"throw new {GetInvalidOperationDisplayName()}(""{message}"")";

        public string GetIncrementalVarName(string prefix) => $"{prefix}{_parseValueCount++}";

        public string GetInvalidOperationDisplayName() =>
            UseFullyQualifiedNames ? FullyQualifiedDisplayString.InvalidOperationException : Identifier.InvalidOperationException;

        public string GetHelperMethodDisplayString(string methodName)
        {
            if (UseFullyQualifiedNames)
            {
                methodName = FullyQualifiedDisplayString.CoreBindingHelper + "." + methodName;
            }

            return methodName;
        }

        public static class Expression
        {
            public const string sectionKey = "section.Key";
            public const string sectionPath = "section.Path";
            public const string sectionValue = "section.Value";

            public const string GetBinderOptions = $"{FullyQualifiedDisplayString.CoreBindingHelper}.{Identifier.GetBinderOptions}";
        }

        public static class FullyQualifiedDisplayString
        {
            public const string ActionOfBinderOptions = $"global::System.Action<global::Microsoft.Extensions.Configuration.BinderOptions>";
            public const string AddSingleton = $"{ServiceCollectionServiceExtensions}.AddSingleton";
            public const string ConfigurationChangeTokenSource = "global::Microsoft.Extensions.Options.ConfigurationChangeTokenSource";
            public const string CoreBindingHelper = $"global::{ConfigurationBindingGenerator.ProjectName}.{Identifier.CoreBindingHelper}";
            public const string IConfiguration = "global::Microsoft.Extensions.Configuration.IConfiguration";
            public const string IConfigurationSection = IConfiguration + "Section";
            public const string IOptionsChangeTokenSource = "global::Microsoft.Extensions.Options.IOptionsChangeTokenSource";
            public const string InvalidOperationException = "global::System.InvalidOperationException";
            public const string IServiceCollection = "global::Microsoft.Extensions.DependencyInjection.IServiceCollection";
            public const string NotSupportedException = "global::System.NotSupportedException";
            public const string OptionsBuilderOfTOptions = $"global::Microsoft.Extensions.Options.OptionsBuilder<{Identifier.TOptions}>";
            public const string ServiceCollectionServiceExtensions = "global::Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions";
            public const string Type = $"global::System.Type";
        }

        public static class MinimalDisplayString
        {
            public const string NullableActionOfBinderOptions = "Action<BinderOptions>?";
        }

        public static class Identifier
        {
            public const string binderOptions = nameof(binderOptions);
            public const string configureOptions = nameof(configureOptions);
            public const string configuration = nameof(configuration);
            public const string configSectionPath = nameof(configSectionPath);
            public const string defaultValue = nameof(defaultValue);
            public const string element = nameof(element);
            public const string enumValue = nameof(enumValue);
            public const string exception = nameof(exception);
            public const string getPath = nameof(getPath);
            public const string key = nameof(key);
            public const string name = nameof(name);
            public const string obj = nameof(obj);
            public const string optionsBuilder = nameof(optionsBuilder);
            public const string originalCount = nameof(originalCount);
            public const string section = nameof(section);
            public const string services = nameof(services);
            public const string stringValue = nameof(stringValue);
            public const string temp = nameof(temp);
            public const string type = nameof(type);

            public const string Add = nameof(Add);
            public const string AddSingleton = nameof(AddSingleton);
            public const string Any = nameof(Any);
            public const string Array = nameof(Array);
            public const string Bind = nameof(Bind);
            public const string BindCore = nameof(BindCore);
            public const string BindCoreUntyped = nameof(BindCoreUntyped);
            public const string BinderOptions = nameof(BinderOptions);
            public const string Configure = nameof(Configure);
            public const string CopyTo = nameof(CopyTo);
            public const string ContainsKey = nameof(ContainsKey);
            public const string CoreBindingHelper = nameof(CoreBindingHelper);
            public const string Count = nameof(Count);
            public const string CultureInfo = nameof(CultureInfo);
            public const string CultureNotFoundException = nameof(CultureNotFoundException);
            public const string Enum = nameof(Enum);
            public const string ErrorOnUnknownConfiguration = nameof(ErrorOnUnknownConfiguration);
            public const string GeneratedConfigurationBinder = nameof(GeneratedConfigurationBinder);
            public const string GeneratedOptionsBuilderBinder = nameof(GeneratedOptionsBuilderBinder);
            public const string GeneratedServiceCollectionBinder = nameof(GeneratedServiceCollectionBinder);
            public const string Get = nameof(Get);
            public const string GetBinderOptions = nameof(GetBinderOptions);
            public const string GetCore = nameof(GetCore);
            public const string GetChildren = nameof(GetChildren);
            public const string GetSection = nameof(GetSection);
            public const string GetValue = nameof(GetValue);
            public const string GetValueCore = nameof(GetValueCore);
            public const string HasChildren = nameof(HasChildren);
            public const string HasConfig = nameof(HasConfig);
            public const string HasValueOrChildren = nameof(HasValueOrChildren);
            public const string HasValue = nameof(HasValue);
            public const string IConfiguration = nameof(IConfiguration);
            public const string IConfigurationSection = nameof(IConfigurationSection);
            public const string Int32 = "int";
            public const string InvalidOperationException = nameof(InvalidOperationException);
            public const string InvariantCulture = nameof(InvariantCulture);
            public const string Length = nameof(Length);
            public const string Parse = nameof(Parse);
            public const string Path = nameof(Path);
            public const string Resize = nameof(Resize);
            public const string Services = nameof(Services);
            public const string TOptions = nameof(TOptions);
            public const string TryCreate = nameof(TryCreate);
            public const string TryGetValue = nameof(TryGetValue);
            public const string TryParse = nameof(TryParse);
            public const string Uri = nameof(Uri);
            public const string Value = nameof(Value);
        }
    }
}
