// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.Extensions.Configuration.Binder.SourceGeneration
{
    public sealed partial class ConfigurationBindingSourceGenerator
    {
        private sealed partial class Emitter
        {
            private static class Expression
            {
                public const string nullableSectionValue = "section?.Value";
                public const string sectionKey = "section.Key";
                public const string sectionValue = "section.Value";
            }

            private static class GlobalName
            {
                public const string Enum = "global::System.Enum";
                public const string FromBase64String = "global::System.Convert.FromBase64String";
                public const string IConfiguration = "global::Microsoft.Extensions.Configuration.IConfiguration";
                public const string Int32 = "int";
                public const string IServiceCollection = "global::Microsoft.Extensions.DependencyInjection.IServiceCollection";
                public const string Object = "object";
                public const string String = "string";
            }

            private static class KeyWord
            {
                public const string @default = nameof(@default);
                public const string @null = nameof(@null);
            }

            private readonly SourceProductionContext _context;
            private readonly SourceGenerationSpec _generationSpec;

            private readonly Queue<TypeSpec> _privateBindCoreMethodGen_QueuedTypes = new();

            private readonly HashSet<TypeSpec> _internalBindMethodGen_ProcessedTypes = new();
            private readonly HashSet<TypeSpec> _privateBindCoreMethodGen_ProcessedTypes = new();

            // Postfix for stringValueX variables used to save config value indexer
            // results e.g. if (configuration["Key"] is string stringValue0) { ... }
            private int _parseValueCount;

            private readonly SourceWriter _writer = new();

            public Emitter(SourceProductionContext context, SourceGenerationSpec generationSpec)
            {
                _context = context;
                _generationSpec = generationSpec;
            }

            public void Emit()
            {
                _writer.WriteLine(@"// <auto-generated/>
#nullable enable

using System.Linq;
");

                _writer.WriteBlockStart($"internal static class {Literal.GeneratedConfigurationBinder}");

                EmitConfigureMethod();

                EmitGetMethod();

                EmitBindMethods();

                _writer.WriteBlockEnd();

                SourceText source = SourceText.From(_writer.GetSource(), Encoding.UTF8);
                _context.AddSource($"{Literal.GeneratedConfigurationBinder}.g.cs", source);
            }

            private void EmitConfigureMethod()
            {
                if (_generationSpec.TypesForConfigureMethodGen.Count == 0)
                {
                    return;
                }

                _writer.WriteBlockStart($"public static {GlobalName.IServiceCollection} {Literal.Configure}<T>(this {GlobalName.IServiceCollection} {Literal.services}, {GlobalName.IConfiguration} {Literal.configuration})");

                foreach (TypeSpec type in _generationSpec.TypesForConfigureMethodGen)
                {
                    string typeDisplayString = type.DisplayString;

                    _writer.WriteBlockStart($"if (typeof(T) == typeof({typeDisplayString}))");

                    _writer.WriteBlockStart($@"return {Literal.services}.{Literal.Configure}<{typeDisplayString}>({Literal.obj} =>");
                    EmitBindLogicFromIConfiguration(type, Literal.obj, InitializationKind.None);
                    _writer.WriteBlockEnd(");");

                    _writer.WriteBlockEnd();
                    _writer.WriteBlankLine();
                }

                Emit_NotSupportedException_UnableToBindType(NotSupportedReason.TypeNotDetectedAsInput);
                _writer.WriteBlockEnd();

                _writer.WriteBlankLine();
            }

            private void EmitGetMethod()
            {
                if (_generationSpec.TypesForGetMethodGen.Count == 0)
                {
                    return;
                }

                _writer.WriteBlockStart($"public static T? {Literal.Get}<T>(this {GlobalName.IConfiguration} {Literal.configuration})");

                EmitCheckForNullArgument_WithBlankLine(Literal.configuration);

                foreach (TypeSpec type in _generationSpec.TypesForGetMethodGen)
                {
                    string typeDisplayString = type.DisplayString;

                    _writer.WriteBlockStart($"if (typeof(T) == typeof({typeDisplayString}))");
                    EmitBindLogicFromIConfiguration(type, Literal.obj, InitializationKind.Declaration);
                    _writer.WriteLine($"return (T)({GlobalName.Object}){Literal.obj};");
                    _writer.WriteBlockEnd();
                    _writer.WriteBlankLine();
                }

                Emit_NotSupportedException_UnableToBindType(NotSupportedReason.TypeNotDetectedAsInput);
                _writer.WriteBlockEnd();
                _writer.WriteBlankLine();
            }

            private void EmitBindMethods()
            {
                if (_generationSpec.TypesForBindMethodGen.Count > 0)
                {
                    foreach (TypeSpec type in _generationSpec.TypesForBindMethodGen)
                    {
                        EmitBindMethod(type);
                    }
                }

                // Get & Configure method generation might have queued types for private BindCore impl
                while (_privateBindCoreMethodGen_QueuedTypes.Count > 0)
                {
                    EmitBindCoreMethod(_privateBindCoreMethodGen_QueuedTypes.Dequeue());
                }
            }

            private void EmitBindMethod(TypeSpec type)
            {
                if (_internalBindMethodGen_ProcessedTypes.Contains(type))
                {
                    return;
                }

                _internalBindMethodGen_ProcessedTypes.Add(type);

                // Binding to root level struct is a no-op.
                // TODO: maybe this should be a debug assert & the parser shouldn't include them.
                if (type.IsValueType)
                {
                    return;
                }

                _privateBindCoreMethodGen_QueuedTypes.Enqueue(type);

                _writer.WriteLine(
                    @$"public static void {Literal.Bind}(this {GlobalName.IConfiguration} {Literal.configuration}, {type.DisplayString} {Literal.obj}) => " +
                        $"{Literal.BindCore}({Literal.configuration}, ref {Literal.obj});");
                _writer.WriteBlankLine();
            }

            private void EmitBindCoreMethod(TypeSpec type)
            {
                if (_privateBindCoreMethodGen_ProcessedTypes.Contains(type))
                {
                    return;
                }
                _privateBindCoreMethodGen_ProcessedTypes.Add(type);

                string objParameterExpression = $"ref {type.DisplayString} {Literal.obj}";
                _writer.WriteBlockStart(@$"private static void {Literal.BindCore}({GlobalName.IConfiguration} {Literal.configuration}, {objParameterExpression})");
                EmitBindCoreImpl(type);
                _writer.WriteBlockEnd();
                _writer.WriteBlankLine();
            }

            private void EmitBindCoreImpl(TypeSpec type)
            {
                switch (type.SpecKind)
                {
                    case TypeSpecKind.Array:
                        {
                            EmitBindCoreImplForArray((type as EnumerableSpec)!);
                        }
                        break;
                    case TypeSpecKind.IConfigurationSection:
                        {
                            EmitCastToIConfigurationSection();
                            EmitAssignment(Literal.obj, Literal.section);
                        }
                        break;
                    case TypeSpecKind.Dictionary:
                        {
                            EmitBindCoreImplForDictionary((type as DictionarySpec)!);
                        }
                        break;
                    case TypeSpecKind.Enumerable:
                        {
                            EmitBindCoreImplForEnumerable((type as EnumerableSpec)!);
                        }
                        break;
                    case TypeSpecKind.Object:
                        {
                            EmitBindCoreImplForObject((type as ObjectSpec)!);
                        }
                        break;
                    case TypeSpecKind.Nullable:
                        {
                            EmitBindCoreImpl((type as NullableSpec)!.UnderlyingType);
                        }
                        break;
                    default:
                        Debug.Fail("Invalid type kind", type.SpecKind.ToString());
                        break;
                }
            }

            private void EmitBindCoreImplForArray(EnumerableSpec type)
            {
                EnumerableSpec concreteType = (type.ConcreteType as EnumerableSpec)!;
                Debug.Assert(type.SpecKind == TypeSpecKind.Array && type.ConcreteType is not null);

                EmitCheckForNullArgument_WithBlankLine_IfRequired(isValueType: false);

                string tempVarName = GetIncrementalVarName(Literal.temp);

                // Create and bind to temp list
                EmitBindCoreCall(concreteType, tempVarName, Literal.configuration, InitializationKind.Declaration);

                // Resize array and copy fill with additional
                EmitAssignment($"{GlobalName.Int32} {Literal.originalCount}", $"{Literal.obj}.{Literal.Length}");
                _writer.WriteLine($"{TypeFullName.Array}.{Literal.Resize}(ref {Literal.obj}, {Literal.originalCount} + {tempVarName}.{Literal.Count});");
                _writer.WriteLine($"{tempVarName}.{Literal.CopyTo}({Literal.obj}, {Literal.originalCount});");
            }

            private void EmitBindCoreImplForDictionary(DictionarySpec type)
            {
                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                TypeSpec keyType = type.KeyType;
                TypeSpec elementType = type.ElementType;

                EmitVarDeclaration(keyType, Literal.key);

                _writer.WriteBlockStart($"foreach ({TypeFullName.IConfigurationSection} {Literal.section} in {Literal.configuration}.{Literal.GetChildren}())");

                // Parse key
                EmitBindLogicFromString(
                    keyType,
                    Literal.key,
                    expressionForConfigStringValue: Expression.sectionKey,
                    writeExtraOnSuccess: Emit_BindAndAddLogic_ForElement);

                void Emit_BindAndAddLogic_ForElement()
                {
                    // For simple types: do regular dictionary add
                    if (elementType.SpecKind == TypeSpecKind.StringBasedParse)
                    {
                        EmitVarDeclaration(elementType, Literal.element);
                        EmitBindLogicFromIConfigurationSectionValue(
                            elementType,
                            Literal.element,
                            InitializationKind.SimpleAssignment,
                            writeExtraOnSuccess: () => EmitAssignment($"{Literal.obj}[{Literal.key}]", Literal.element));
                    }
                    else // For complex types:
                    {
                        string displayString = elementType.DisplayString + (elementType.IsValueType ? string.Empty : "?");

                        // If key already exists, bind to value to existing element instance if not null (for ref types)
                        string conditionToUseExistingElement = $"if ({Literal.obj}.{Literal.TryGetValue}({Literal.key}, out {displayString} {Literal.element})";
                        conditionToUseExistingElement += !elementType.IsValueType
                            ? $" && {Literal.element} is not {KeyWord.@null})"
                            : ")";
                        _writer.WriteBlockStart(conditionToUseExistingElement);
                        EmitBindLogicForElement(InitializationKind.None);
                        _writer.WriteBlockEnd();

                        // Else, create new element instance and bind to that
                        _writer.WriteBlockStart("else");
                        EmitBindLogicForElement(InitializationKind.SimpleAssignment);
                        _writer.WriteBlockEnd();

                        void EmitBindLogicForElement(InitializationKind initKind)
                        {
                            EmitBindLogicFromIConfigurationSectionValue(elementType, Literal.element, initKind);
                            EmitAssignment($"{Literal.obj}[{Literal.key}]", Literal.element);
                        }
                    }
                }

                // End foreach loop.
                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImplForEnumerable(EnumerableSpec type)
            {
                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                TypeSpec elementType = type.ElementType;

                EmitVarDeclaration(elementType, Literal.element);
                _writer.WriteBlockStart($"foreach ({TypeFullName.IConfigurationSection} {Literal.section} in {Literal.configuration}.{Literal.GetChildren}())");

                EmitBindLogicFromIConfigurationSectionValue(
                    elementType,
                    Literal.element,
                    InitializationKind.SimpleAssignment,
                    writeExtraOnSuccess: EmitAddLogicForElement);

                void EmitAddLogicForElement()
                {
                    string addExpression = $"{Literal.obj}.{Literal.Add}({Literal.element})";
                    if (elementType.IsValueType)
                    {
                        _writer.WriteLine($"{addExpression};");
                    }
                    else
                    {
                        _writer.WriteLine($"if ({Literal.element} is not {KeyWord.@null}) {{ {addExpression}; }}");
                    }
                }

                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImplForObject(ObjectSpec type)
            {
                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                foreach (PropertySpec property in type.Properties)
                {
                    TypeSpec propertyType = property.Type;

                    EmitBindCoreImplForProperty(property, propertyType, parentType: type);
                    _writer.WriteBlankLine();
                }
            }

            private void EmitBindCoreImplForProperty(PropertySpec property, TypeSpec propertyType, TypeSpec parentType)
            {
                string configurationKeyName = property.ConfigurationKeyName;

                string propertyParentReference = property.IsStatic ? parentType.DisplayString : Literal.obj;
                string expressionForPropertyAccess = $"{propertyParentReference}.{property.Name}";

                string expressionForConfigGetSection = $@"{Literal.configuration}.{Literal.GetSection}(""{configurationKeyName}"")";
                string expressionForConfigValueIndexer = $@"{Literal.configuration}[""{configurationKeyName}""]";

                bool canGet = property.CanGet;
                bool canSet = property.CanSet;

                switch (propertyType.SpecKind)
                {
                    case TypeSpecKind.System_Object:
                        {
                            EmitAssignment(expressionForPropertyAccess, $"{expressionForConfigValueIndexer}!");
                        }
                        break;
                    case TypeSpecKind.StringBasedParse:
                    case TypeSpecKind.ByteArray:
                        {
                            if (canSet)
                            {
                                EmitBindLogicFromString(
                                    propertyType,
                                    expressionForPropertyAccess,
                                    expressionForConfigValueIndexer);
                            }
                        }
                        break;
                    case TypeSpecKind.Array:
                        {
                            EmitBindCoreCallForProperty(
                                property,
                                propertyType,
                                expressionForPropertyAccess,
                                expressionForConfigArg: expressionForConfigGetSection);
                        }
                        break;
                    case TypeSpecKind.IConfigurationSection:
                        {
                            EmitAssignment(expressionForPropertyAccess, expressionForConfigGetSection);
                        }
                        break;
                    case TypeSpecKind.Nullable:
                        {
                            TypeSpec underlyingType = (propertyType as NullableSpec)!.UnderlyingType;
                            EmitBindCoreImplForProperty(property, underlyingType, parentType);
                        }
                        break;
                    default:
                        {
                            EmitBindCoreCallForProperty(
                                property,
                                propertyType,
                                expressionForPropertyAccess,
                                expressionForConfigArg: expressionForConfigGetSection);
                        }
                        break;
                }
            }

            private void EmitBindLogicFromIConfiguration(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                if (type.SpecKind is TypeSpecKind.StringBasedParse or TypeSpecKind.ByteArray)
                {
                    EmitCastToIConfigurationSection();
                    if (initKind is InitializationKind.Declaration)
                    {
                        EmitAssignment($"{type.DisplayString} {expressionForMemberAccess}", KeyWord.@default);
                    }
                    EmitBindLogicFromString(type, expressionForMemberAccess, Expression.sectionValue);
                }
                else
                {
                    if (initKind is InitializationKind.Declaration)
                    {
                        EmitAssignment($"{TypeFullName.IConfigurationSection}? {Literal.section}", $"{Literal.configuration} as {TypeFullName.IConfigurationSection}");
                        _writer.WriteBlockStart($"if ({Expression.nullableSectionValue} is null && !{Literal.configuration}.{Literal.GetChildren}().{Literal.Any}())");
                        _writer.WriteLine($"return {KeyWord.@default};");
                        _writer.WriteBlockEnd();
                        _writer.WriteBlankLine();
                    }

                    EmitBindCoreCall(type, expressionForMemberAccess, Literal.configuration, initKind);
                }
            }

            private void EmitBindLogicFromIConfigurationSectionValue(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind, Action? writeExtraOnSuccess = null)
            {
                if (type.SpecKind is TypeSpecKind.StringBasedParse or TypeSpecKind.ByteArray)
                {
                    EmitBindLogicFromString(type, expressionForMemberAccess, Expression.sectionValue, writeExtraOnSuccess);
                }
                else
                {
                    EmitBindCoreCall(type, expressionForMemberAccess, Literal.section, initKind);
                    writeExtraOnSuccess?.Invoke();
                }
            }

            private void EmitBindCoreCall(
                TypeSpec type,
                string expressionForMemberAccess,
                string expressionForConfigArg,
                InitializationKind initKind)
            {
                string tempVarName = GetIncrementalVarName(Literal.temp);
                if (initKind is InitializationKind.AssignmentWithNullCheck)
                {
                    EmitAssignment($"{type.DisplayString} {tempVarName}", $"{expressionForMemberAccess}");
                    EmitObjectInit(type, tempVarName, InitializationKind.AssignmentWithNullCheck);
                    _writer.WriteLine($@"{Literal.BindCore}({expressionForConfigArg}, ref {tempVarName});");
                }
                else if (initKind is InitializationKind.None && type.IsValueType)
                {
                    EmitObjectInit(type, tempVarName, InitializationKind.Declaration);
                    _writer.WriteLine($@"{Literal.BindCore}({expressionForConfigArg}, ref {tempVarName});");
                    EmitAssignment(expressionForMemberAccess, tempVarName);
                }
                else
                {
                    EmitObjectInit(type, expressionForMemberAccess, initKind);
                    _writer.WriteLine($@"{Literal.BindCore}({expressionForConfigArg}, ref {expressionForMemberAccess});");
                }

                _privateBindCoreMethodGen_QueuedTypes.Enqueue(type);
            }

            private void EmitBindCoreCallForProperty(
                PropertySpec property,
                TypeSpec effectivePropertyType,
                string expressionForPropertyAccess,
                string expressionForConfigArg)
            {
                bool canGet = property.CanGet;
                bool canSet = property.CanSet;

                string tempVarName = GetIncrementalVarName(Literal.temp);
                if (effectivePropertyType.IsValueType)
                {
                    if (canSet)
                    {
                        if (canGet)
                        {
                            TypeSpec actualPropertyType = property.Type;
                            if (actualPropertyType.SpecKind is TypeSpecKind.Nullable)
                            {
                                string nullableTempVarName = GetIncrementalVarName(Literal.temp);
                                EmitAssignment(
                                    $"{actualPropertyType.DisplayString} {nullableTempVarName}", expressionForPropertyAccess);
                                EmitAssignment(
                                    $"{effectivePropertyType.DisplayString} {tempVarName}",
                                    $"{nullableTempVarName}.{Literal.HasValue} ? {nullableTempVarName}.{Literal.Value} : new {effectivePropertyType.DisplayString}()");
                            }
                            else
                            {
                                EmitAssignment($"{effectivePropertyType.DisplayString} {tempVarName}", $"{expressionForPropertyAccess}");
                            }
                        }
                        else
                        {
                            EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.Declaration);
                        }

                        _writer.WriteLine($@"{Literal.BindCore}({expressionForConfigArg}, ref {tempVarName});");
                        EmitAssignment(expressionForPropertyAccess, tempVarName);
                        _privateBindCoreMethodGen_QueuedTypes.Enqueue(effectivePropertyType);
                    }
                }
                else if (canGet)
                {
                    EmitAssignment($"{effectivePropertyType.DisplayString} {tempVarName}", $"{expressionForPropertyAccess}");
                    EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.AssignmentWithNullCheck);
                    _writer.WriteLine($@"{Literal.BindCore}({expressionForConfigArg}, ref {tempVarName});");

                    if (canSet)
                    {
                        EmitAssignment(expressionForPropertyAccess, tempVarName);
                    }
                }
                else
                {
                    Debug.Assert(canSet);
                    EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.Declaration);
                    _writer.WriteLine($@"{Literal.BindCore}({expressionForConfigArg}, ref {tempVarName});");
                    EmitAssignment(expressionForPropertyAccess, tempVarName);
                }

                _privateBindCoreMethodGen_QueuedTypes.Enqueue(effectivePropertyType);
            }

            private void EmitBindLogicFromString(
                TypeSpec type,
                string expressionForMemberAccess,
                string expressionForConfigStringValue,
                Action? writeExtraOnSuccess = null)
            {
                string typeDisplayString = type.DisplayString;
                string stringValueVarName = GetIncrementalVarName(Literal.stringValue);
                string assignmentCondition = $"{expressionForConfigStringValue} is {GlobalName.String} {stringValueVarName}";

                string rhs;
                if (type.SpecialType != SpecialType.None)
                {
                    rhs = type.SpecialType switch
                    {
                        SpecialType.System_String => stringValueVarName,
                        SpecialType.System_Object => KeyWord.@default,
                        _ => $"{typeDisplayString}.{Literal.Parse}({stringValueVarName})"
                    };
                }
                else if (type.SpecKind == TypeSpecKind.Enum)
                {
                    string enumValueVarName = GetIncrementalVarName(Literal.enumValue);
                    assignmentCondition += $" && {GlobalName.Enum}.{Literal.TryParse}({stringValueVarName}, true, out {typeDisplayString} {enumValueVarName})";
                    rhs = enumValueVarName;
                }
                else if (type.SpecKind == TypeSpecKind.ByteArray)
                {
                    rhs = $"{GlobalName.FromBase64String}({stringValueVarName})";
                }
                else
                {
                    return;
                }

                _writer.WriteBlockStart($"if ({assignmentCondition})");
                EmitAssignment(expressionForMemberAccess, rhs);
                writeExtraOnSuccess?.Invoke();
                _writer.WriteBlockEnd();
            }

            private void EmitObjectInit(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                if (initKind is InitializationKind.None or InitializationKind.None)
                {
                    return;
                }

                string displayString = type.DisplayString;
                string expressionForInit = null;
                if (type is EnumerableSpec { SpecKind: TypeSpecKind.Array } arrayType)
                {
                    Regex regex = new(Regex.Escape("[]"));
                    expressionForInit = $"new {regex.Replace(type.DisplayString, "[0]", 1)};";
                }
                else if (type.ConstructionStrategy != ConstructionStrategy.ParameterlessConstructor)
                {
                    return;
                }
                else if (type is CollectionSpec { ConcreteType: { } concreteType})
                {
                    displayString = concreteType.DisplayString;
                }

                // Not an array.
                expressionForInit ??= $"new {displayString}()";

                if (initKind == InitializationKind.Declaration)
                {
                    Debug.Assert(!expressionForMemberAccess.Contains("."));
                    EmitAssignment($"{displayString} {expressionForMemberAccess}", expressionForInit);
                }
                else if (initKind == InitializationKind.AssignmentWithNullCheck)
                {
                    _writer.WriteLine($"{expressionForMemberAccess} ??= {expressionForInit};");
                }
                else
                {
                    EmitAssignment(expressionForMemberAccess, expressionForInit);
                }
            }

            private void EmitCastToIConfigurationSection()
            {
                _writer.WriteBlockStart($"if ({Literal.configuration} is not {TypeFullName.IConfigurationSection} {Literal.section})");
                _writer.WriteLine("throw new global::System.InvalidOperationException();");
                _writer.WriteBlockEnd();
            }

            private void EmitVarDeclaration(TypeSpec type, string varName) => _writer.WriteLine($"{type.DisplayString} {varName};");

            private void EmitAssignment(string lhsSource, string rhsSource) => _writer.WriteLine($"{lhsSource} = {rhsSource};");

            private void Emit_NotSupportedException_UnableToBindType(string reason, string typeDisplayString = "{typeof(T)}") =>
                _writer.WriteLine(@$"throw new global::System.NotSupportedException($""{string.Format(ExceptionMessages.TypeNotSupported, typeDisplayString, reason)}"");");

            private void EmitCheckForNullArgument_WithBlankLine_IfRequired(bool isValueType)
            {
                if (!isValueType)
                {
                    EmitCheckForNullArgument_WithBlankLine(Literal.obj);
                }
            }

            private void EmitCheckForNullArgument_WithBlankLine(string argName)
            {
                _writer.WriteBlockStart($"if ({argName} is {KeyWord.@null})");
                _writer.WriteLine($"throw new global::System.ArgumentNullException(nameof({argName}));");
                _writer.WriteBlockEnd();
                _writer.WriteBlankLine();
            }

            private string GetIncrementalVarName(string prefix) => $"{prefix}{_parseValueCount++}";
        }
    }
}
