// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace Microsoft.Extensions.Configuration.Binder.SourceGeneration
{
    public sealed partial class ConfigurationBindingSourceGenerator
    {
        private sealed partial class Emitter
        {
            private static class Expression
            {
                public const string nullableSectionValue = "section?.Value";
                public const string sectionKey = "section.Key";
                public const string sectionValue = "section.Value";

                public const string ConvertFromBase64String = "Convert.FromBase64String";
            }

            private static class FullyQualifiedDisplayName
            {
                public const string ArgumentNullException = "global::System.ArgumentNullException";
                public const string Helpers = $"global::{GeneratorProjectName}.{Identifier.Helpers}";
                public const string IConfiguration = "global::Microsoft.Extensions.Configuration.IConfiguration";
                public const string IConfigurationSection = IConfiguration + "Section";
                public const string InvalidOperationException = "global::System.InvalidOperationException";
                public const string IServiceCollection = "global::Microsoft.Extensions.DependencyInjection.IServiceCollection";
                public const string NotSupportedException = "global::System.NotSupportedException";
            }

            private enum InitializationKind
            {
                None = 0,
                SimpleAssignment = 1,
                AssignmentWithNullCheck = 2,
                Declaration = 3,
            }

            private readonly SourceProductionContext _context;
            private readonly SourceGenerationSpec _generationSpec;

            // Postfix for stringValueX variables used to save config value indexer
            // results e.g. if (configuration["Key"] is string stringValue0) { ... }
            private int _parseValueCount;

            private readonly SourceWriter _writer = new();

            private readonly Regex _arrayBracketsRegex = new(Regex.Escape("[]"));

            private bool _useFullyQualifiedNames = true;

            public Emitter(SourceProductionContext context, SourceGenerationSpec generationSpec)
            {
                _context = context;
                _generationSpec = generationSpec;
            }

            public void Emit()
            {
                _writer.WriteLine(@"// <auto-generated/>
#nullable enable
");

                // Generated binder for user consumption.
                _writer.WriteBlockStart($"internal static class {Identifier.GeneratedConfigurationBinder}");
                EmitConfigureMethod();
                EmitGetMethod();
                EmitBindMethods();
                _writer.WriteBlockEnd();

                _writer.WriteBlankLine();

                EmitGenerationNamespaceAndHelpers();

                _context.AddSource($"{Identifier.GeneratedConfigurationBinder}.g.cs", _writer.ToSourceText());
            }

            private void EmitConfigureMethod()
            {
                if (!IncludeMethodsForGen(MethodSpecifier.Configure))
                {
                    return;
                }

                _writer.WriteBlockStart($"public static {FullyQualifiedDisplayName.IServiceCollection} {Identifier.Configure}<T>(this {FullyQualifiedDisplayName.IServiceCollection} {Identifier.services}, {FullyQualifiedDisplayName.IConfiguration} {Identifier.configuration})");

                EmitCheckForNullArgument_WithBlankLine(Identifier.configuration, useFullyQualifiedNames: true);

                foreach (TypeSpec type in _generationSpec.Methods[MethodSpecifier.Configure])
                {
                    string typeDisplayString = type.FullyQualifiedDisplayString;

                    _writer.WriteBlockStart($"if (typeof(T) == typeof({typeDisplayString}))");

                    _writer.WriteBlockStart($@"return {Identifier.services}.{Identifier.Configure}<{typeDisplayString}>({Identifier.obj} =>");
                    EmitIConfigurationHasValueOrChildrenCheck();
                    EmitBindLogicFromIConfiguration(type, Identifier.obj, InitializationKind.None);
                    _writer.WriteBlockEnd(");");

                    _writer.WriteBlockEnd();
                    _writer.WriteBlankLine();
                }

                Emit_NotSupportedException_UnableToBindType(NotSupportedReason.TypeNotDetectedAsInput);
                _writer.WriteBlockEnd();
            }

            private void EmitGetMethod()
            {
                if (!IncludeMethodsForGen(MethodSpecifier.Get))
                {
                    return;
                }

                if (IncludeMethodsForGen(MethodSpecifier.Configure))
                {
                    _writer.WriteBlankLine();
                }

                _writer.WriteBlockStart($"public static T? {Identifier.Get}<T>(this {FullyQualifiedDisplayName.IConfiguration} {Identifier.configuration})");

                EmitCheckForNullArgument_WithBlankLine(Identifier.configuration, useFullyQualifiedNames: true);

                EmitIConfigurationHasValueOrChildrenCheck();

                foreach (TypeSpec type in _generationSpec.Methods[MethodSpecifier.Get])
                {
                    string typeDisplayString = type.FullyQualifiedDisplayString;

                    _writer.WriteBlockStart($"if (typeof(T) == typeof({typeDisplayString}))");
                    EmitBindLogicFromIConfiguration(type, Identifier.obj, InitializationKind.Declaration);
                    _writer.WriteLine($"return (T)(object){Identifier.obj};");
                    _writer.WriteBlockEnd();
                    _writer.WriteBlankLine();
                }

                Emit_NotSupportedException_UnableToBindType(NotSupportedReason.TypeNotDetectedAsInput);
                _writer.WriteBlockEnd();
            }

            private void EmitBindMethods()
            {
                if (!IncludeMethodsForGen(MethodSpecifier.Bind))
                {
                    return;
                }

                if (IncludeMethodsForGen(MethodSpecifier.Configure | MethodSpecifier.Get))
                {
                    _writer.WriteBlankLine();
                }

                foreach (TypeSpec type in _generationSpec.Methods[MethodSpecifier.Bind])
                {
                    EmitBindMethod(type);
                    _writer.WriteBlankLine();
                }

                _writer.RemoveBlankLine();
            }

            private void EmitBindMethod(TypeSpec type)
            {
                _writer.WriteLine(
                    @$"public static void {Identifier.Bind}(this {FullyQualifiedDisplayName.IConfiguration} {Identifier.configuration}, {type.FullyQualifiedDisplayString} {Identifier.obj}) => " +
                        $"{FullyQualifiedDisplayName.Helpers}.{Identifier.BindCore}({Identifier.configuration}, ref {Identifier.obj});");
            }

            private void EmitGenerationNamespaceAndHelpers()
            {
                _useFullyQualifiedNames = false;

                if (IncludeMethodsForGen(MethodSpecifier.BindCore | MethodSpecifier.HasValueOrChildren | MethodSpecifier.HasChildren))
                {
                    // Helper class in source-generation namespace.
                    _writer.WriteBlockStart($"namespace {GeneratorProjectName}");
                    EmitHelperUsingStatements();

                    _writer.WriteBlankLine();

                    _writer.WriteBlockStart($"internal static class {Identifier.Helpers}");
                    EmitBindCoreMethods();
                    EmitHelperMethods();
                    _writer.WriteBlockEnd();

                    _writer.WriteBlockEnd();
                }
            }

            private void EmitHelperUsingStatements()
            {
                foreach (string @namespace in _generationSpec.Namespaces)
                {
                    _writer.WriteLine($"using {@namespace};");
                }
            }

            private void EmitBindCoreMethods()
            {
                foreach (TypeSpec type in _generationSpec.Methods[MethodSpecifier.BindCore])
                {
                    EmitBindCoreMethod(type);
                    _writer.WriteBlankLine();
                }
            }

            private void EmitBindCoreMethod(TypeSpec type)
            {
                string objParameterExpression = $"ref {type.MinimalDisplayString} {Identifier.obj}";
                _writer.WriteBlockStart(@$"public static void {Identifier.BindCore}({Identifier.IConfiguration} {Identifier.configuration}, {objParameterExpression})");
                EmitBindCoreImpl(type);
                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImpl(TypeSpec type)
            {
                switch (type.SpecKind)
                {
                    case TypeSpecKind.Array:
                        {
                            EmitBindCoreImplForArray((type as EnumerableSpec)!);
                        }
                        break;
                    case TypeSpecKind.IConfigurationSection:
                        {
                            EmitCastToIConfigurationSection();
                            EmitAssignment(Identifier.obj, Identifier.section);
                        }
                        break;
                    case TypeSpecKind.Dictionary:
                        {
                            EmitBindCoreImplForDictionary((type as DictionarySpec)!);
                        }
                        break;
                    case TypeSpecKind.Enumerable:
                        {
                            EmitBindCoreImplForEnumerable((type as EnumerableSpec)!);
                        }
                        break;
                    case TypeSpecKind.Object:
                        {
                            EmitBindCoreImplForObject((type as ObjectSpec)!);
                        }
                        break;
                    case TypeSpecKind.Nullable:
                        {
                            EmitBindCoreImpl((type as NullableSpec)!.UnderlyingType);
                        }
                        break;
                    default:
                        Debug.Fail("Invalid type kind", type.SpecKind.ToString());
                        break;
                }
            }

            private void EmitBindCoreImplForArray(EnumerableSpec type)
            {
                EnumerableSpec concreteType = (type.ConcreteType as EnumerableSpec)!;
                Debug.Assert(type.SpecKind == TypeSpecKind.Array && type.ConcreteType is not null);

                EmitCheckForNullArgument_WithBlankLine_IfRequired(isValueType: false);

                string tempVarName = GetIncrementalVarName(Identifier.temp);

                // Create and bind to temp list
                EmitBindCoreCall(concreteType, tempVarName, Identifier.configuration, InitializationKind.Declaration);

                // Resize array and copy fill with additional
                _writer.WriteBlock($$"""
                    {{Identifier.Int32}} {{Identifier.originalCount}} = {{Identifier.obj}}.{{Identifier.Length}};
                    {{Identifier.Array}}.{{Identifier.Resize}}(ref {{Identifier.obj}}, {{Identifier.originalCount}} + {{tempVarName}}.{{Identifier.Count}});
                    {{tempVarName}}.{{Identifier.CopyTo}}({{Identifier.obj}}, {{Identifier.originalCount}});
                    """);
            }

            private void EmitBindCoreImplForDictionary(DictionarySpec type)
            {
                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                TypeSpec keyType = type.KeyType;
                TypeSpec elementType = type.ElementType;

                EmitVarDeclaration(keyType, Identifier.key);

                _writer.WriteBlockStart($"foreach ({Identifier.IConfigurationSection} {Identifier.section} in {Identifier.configuration}.{Identifier.GetChildren}())");

                // Parse key
                EmitBindLogicFromString(
                    keyType,
                    Identifier.key,
                    expressionForConfigStringValue: Expression.sectionKey,
                    writeExtraOnSuccess: Emit_BindAndAddLogic_ForElement);

                void Emit_BindAndAddLogic_ForElement()
                {
                    // For simple types: do regular dictionary add
                    if (elementType.SpecKind == TypeSpecKind.StringBasedParse)
                    {
                        EmitVarDeclaration(elementType, Identifier.element);
                        EmitBindLogicFromIConfigurationSectionValue(
                            elementType,
                            Identifier.element,
                            InitializationKind.SimpleAssignment,
                            writeExtraOnSuccess: () => EmitAssignment($"{Identifier.obj}[{Identifier.key}]", Identifier.element));
                    }
                    else // For complex types:
                    {
                        string displayString = elementType.MinimalDisplayString + (elementType.IsValueType ? string.Empty : "?");

                        // If key already exists, bind to value to existing element instance if not null (for ref types)
                        string conditionToUseExistingElement = $"if ({Identifier.obj}.{Identifier.TryGetValue}({Identifier.key}, out {displayString} {Identifier.element})";
                        conditionToUseExistingElement += !elementType.IsValueType
                            ? $" && {Identifier.element} is not null)"
                            : ")";
                        _writer.WriteBlockStart(conditionToUseExistingElement);
                        EmitBindLogicForElement(InitializationKind.None);
                        _writer.WriteBlockEnd();

                        // Else, create new element instance and bind to that
                        _writer.WriteBlockStart("else");
                        EmitBindLogicForElement(InitializationKind.SimpleAssignment);
                        _writer.WriteBlockEnd();

                        void EmitBindLogicForElement(InitializationKind initKind)
                        {
                            EmitBindLogicFromIConfigurationSectionValue(elementType, Identifier.element, initKind);
                            EmitAssignment($"{Identifier.obj}[{Identifier.key}]", Identifier.element);
                        }
                    }
                }

                // End foreach loop.
                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImplForEnumerable(EnumerableSpec type)
            {
                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                TypeSpec elementType = type.ElementType;

                EmitVarDeclaration(elementType, Identifier.element);
                _writer.WriteBlockStart($"foreach ({Identifier.IConfigurationSection} {Identifier.section} in {Identifier.configuration}.{Identifier.GetChildren}())");

                EmitBindLogicFromIConfigurationSectionValue(
                    elementType,
                    Identifier.element,
                    InitializationKind.SimpleAssignment,
                    writeExtraOnSuccess: EmitAddLogicForElement);

                void EmitAddLogicForElement()
                {
                    string addExpression = $"{Identifier.obj}.{Identifier.Add}({Identifier.element})";
                    if (elementType.IsValueType)
                    {
                        _writer.WriteLine($"{addExpression};");
                    }
                    else
                    {
                        _writer.WriteLine($"if ({Identifier.element} is not null) {{ {addExpression}; }}");
                    }
                }

                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImplForObject(ObjectSpec type)
            {
                List<PropertySpec> properties = type.Properties;
                if (properties.Count == 0)
                {
                    return;
                }

                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                foreach (PropertySpec property in type.Properties)
                {
                    TypeSpec propertyType = property.Type;

                    EmitBindCoreImplForProperty(property, propertyType, parentType: type);
                    _writer.WriteBlankLine();
                }

                _writer.RemoveBlankLine();
            }

            private void EmitBindCoreImplForProperty(PropertySpec property, TypeSpec propertyType, TypeSpec parentType)
            {
                string configurationKeyName = property.ConfigurationKeyName;

                string propertyParentReference = property.IsStatic ? parentType.MinimalDisplayString : Identifier.obj;
                string expressionForPropertyAccess = $"{propertyParentReference}.{property.Name}";

                string expressionForConfigSectionAccess = $@"{Identifier.configuration}.{Identifier.GetSection}(""{configurationKeyName}"")";
                string expressionForConfigValueIndexer = $@"{Identifier.configuration}[""{configurationKeyName}""]";

                bool canGet = property.CanGet;
                bool canSet = property.CanSet;

                switch (propertyType.SpecKind)
                {
                    case TypeSpecKind.System_Object:
                        {
                            EmitAssignment(expressionForPropertyAccess, $"{expressionForConfigValueIndexer}!");
                        }
                        break;
                    case TypeSpecKind.StringBasedParse:
                    case TypeSpecKind.ByteArray:
                        {
                            if (canSet)
                            {
                                EmitBindLogicFromString(
                                    propertyType,
                                    expressionForPropertyAccess,
                                    expressionForConfigValueIndexer);
                            }
                        }
                        break;
                    case TypeSpecKind.Array:
                        {
                            EmitBindCoreCallForProperty(
                                property,
                                propertyType,
                                expressionForPropertyAccess,
                                expressionForConfigSectionAccess);
                        }
                        break;
                    case TypeSpecKind.IConfigurationSection:
                        {
                            EmitAssignment(expressionForPropertyAccess, expressionForConfigSectionAccess);
                        }
                        break;
                    case TypeSpecKind.Nullable:
                        {
                            TypeSpec underlyingType = (propertyType as NullableSpec)!.UnderlyingType;
                            EmitBindCoreImplForProperty(property, underlyingType, parentType);
                        }
                        break;
                    default:
                        {
                            EmitBindCoreCallForProperty(
                                property,
                                propertyType,
                                expressionForPropertyAccess,
                                expressionForConfigSectionAccess);
                        }
                        break;
                }
            }

            private void EmitBindLogicFromIConfiguration(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                if (type.SpecKind is TypeSpecKind.StringBasedParse or TypeSpecKind.ByteArray)
                {
                    if (initKind is InitializationKind.Declaration)
                    {
                        EmitCastToIConfigurationSection();
                        EmitAssignment($"{GetTypeDisplayString(type)} {expressionForMemberAccess}", "default");
                    }
                    else
                    {
                        EmitCastToIConfigurationSection();
                    }
                    EmitBindLogicFromString(type, expressionForMemberAccess, Expression.sectionValue);
                }
                else
                {
                    EmitBindCoreCall(type, expressionForMemberAccess, Identifier.configuration, initKind);
                }
            }

            private void EmitBindLogicFromIConfigurationSectionValue(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind, Action? writeExtraOnSuccess = null)
            {
                if (type.SpecKind is TypeSpecKind.StringBasedParse or TypeSpecKind.ByteArray)
                {
                    EmitBindLogicFromString(type, expressionForMemberAccess, Expression.sectionValue, writeExtraOnSuccess);
                }
                else
                {
                    EmitBindCoreCall(type, expressionForMemberAccess, Identifier.section, initKind);
                    writeExtraOnSuccess?.Invoke();
                }
            }

            private void EmitBindCoreCall(
                TypeSpec type,
                string expressionForMemberAccess,
                string expressionForConfigArg,
                InitializationKind initKind)
            {
                string tempVarName = GetIncrementalVarName(Identifier.temp);
                if (initKind is InitializationKind.AssignmentWithNullCheck)
                {
                    EmitAssignment($"{type.MinimalDisplayString} {tempVarName}", $"{expressionForMemberAccess}");
                    EmitObjectInit(type, tempVarName, InitializationKind.AssignmentWithNullCheck);
                    EmitBindCoreCall(tempVarName);
                }
                else if (initKind is InitializationKind.None && type.IsValueType)
                {
                    EmitObjectInit(type, tempVarName, InitializationKind.Declaration);
                    _writer.WriteLine($@"{Identifier.BindCore}({expressionForConfigArg}, ref {tempVarName});");
                    EmitAssignment(expressionForMemberAccess, tempVarName);
                }
                else
                {
                    EmitObjectInit(type, expressionForMemberAccess, initKind);
                    EmitBindCoreCall(expressionForMemberAccess);
                }

                void EmitBindCoreCall(string varName)
                {
                    string bindCoreCall = $@"{GetHelperMethodDisplayString(Identifier.BindCore)}({expressionForConfigArg}, ref {varName});";
                    _writer.WriteLine(bindCoreCall);
                }
            }

            private void EmitBindCoreCallForProperty(
                PropertySpec property,
                TypeSpec effectivePropertyType,
                string expressionForPropertyAccess,
                string expressionForConfigSectionAccess)
            {
                string bindCoreConfigArg = GetIncrementalVarName(Identifier.section);
                EmitAssignment($"{Identifier.IConfigurationSection} {bindCoreConfigArg}", expressionForConfigSectionAccess);
                _writer.WriteBlockStart($"if ({Identifier.HasChildren}({bindCoreConfigArg}))");

                bool canGet = property.CanGet;
                bool canSet = property.CanSet;
                string effectivePropertyTypeDisplayString = effectivePropertyType.MinimalDisplayString;

                string tempVarName = GetIncrementalVarName(Identifier.temp);
                if (effectivePropertyType.IsValueType)
                {
                    if (canSet)
                    {
                        if (canGet)
                        {
                            TypeSpec actualPropertyType = property.Type;
                            if (actualPropertyType.SpecKind is TypeSpecKind.Nullable)
                            {
                                string nullableTempVarName = GetIncrementalVarName(Identifier.temp);
                                EmitAssignment(
                                    $"{actualPropertyType.MinimalDisplayString} {nullableTempVarName}", expressionForPropertyAccess);
                                EmitAssignment(
                                    $"{effectivePropertyTypeDisplayString} {tempVarName}",
                                    $"{nullableTempVarName}.{Identifier.HasValue} ? {nullableTempVarName}.{Identifier.Value} : new {effectivePropertyTypeDisplayString}()");
                            }
                            else
                            {
                                EmitAssignment($"{effectivePropertyTypeDisplayString} {tempVarName}", $"{expressionForPropertyAccess}");
                            }
                        }
                        else
                        {
                            EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.Declaration);
                        }

                        _writer.WriteLine($@"{Identifier.BindCore}({bindCoreConfigArg}, ref {tempVarName});");
                        EmitAssignment(expressionForPropertyAccess, tempVarName);
                    }
                }
                else if (canGet)
                {
                    EmitAssignment($"{effectivePropertyTypeDisplayString} {tempVarName}", $"{expressionForPropertyAccess}");
                    EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.AssignmentWithNullCheck);
                    _writer.WriteLine($@"{Identifier.BindCore}({bindCoreConfigArg}, ref {tempVarName});");

                    if (canSet)
                    {
                        EmitAssignment(expressionForPropertyAccess, tempVarName);
                    }
                }
                else
                {
                    Debug.Assert(canSet);
                    EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.Declaration);
                    _writer.WriteLine($@"{Identifier.BindCore}({bindCoreConfigArg}, ref {tempVarName});");
                    EmitAssignment(expressionForPropertyAccess, tempVarName);
                }

                _writer.WriteBlockEnd();
            }

            private void EmitBindLogicFromString(
                TypeSpec type,
                string expressionForMemberAccess,
                string expressionForConfigStringValue,
                Action? writeExtraOnSuccess = null)
            {
                string typeDisplayString = type.FullyQualifiedDisplayString;
                string stringValueVarName = GetIncrementalVarName(Identifier.stringValue);
                string assignmentCondition = $"{expressionForConfigStringValue} is string {stringValueVarName}";

                string rhs;
                if (type.SpecialType != SpecialType.None)
                {
                    rhs = type.SpecialType switch
                    {
                        SpecialType.System_String => stringValueVarName,
                        SpecialType.System_Object => "default",
                        _ => $"{typeDisplayString}.{Identifier.Parse}({stringValueVarName})"
                    };
                }
                else if (type.SpecKind == TypeSpecKind.Enum)
                {
                    string enumValueVarName = GetIncrementalVarName(Identifier.enumValue);
                    assignmentCondition += $" && {Identifier.Enum}.{Identifier.TryParse}({stringValueVarName}, true, out {typeDisplayString} {enumValueVarName})";
                    rhs = enumValueVarName;
                }
                else if (type.SpecKind == TypeSpecKind.ByteArray)
                {
                    rhs = $"{Expression.ConvertFromBase64String}({stringValueVarName})";
                }
                else
                {
                    return;
                }

                _writer.WriteBlockStart($"if ({assignmentCondition})");
                EmitAssignment(expressionForMemberAccess, rhs);
                writeExtraOnSuccess?.Invoke();
                _writer.WriteBlockEnd();
            }

            private void EmitObjectInit(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                if (initKind is InitializationKind.None or InitializationKind.None)
                {
                    return;
                }

                string displayString = GetTypeDisplayString(type);

                string expressionForInit = null;
                if (type is EnumerableSpec { SpecKind: TypeSpecKind.Array } arrayType)
                {
                    expressionForInit = $"new {_arrayBracketsRegex.Replace(displayString, "[0]", 1)};";
                }
                else if (type.ConstructionStrategy != ConstructionStrategy.ParameterlessConstructor)
                {
                    return;
                }
                else if (type is CollectionSpec { ConcreteType: { } concreteType })
                {
                    displayString = GetTypeDisplayString(concreteType);
                }

                // Not an array.
                expressionForInit ??= $"new {displayString}()";

                if (initKind == InitializationKind.Declaration)
                {
                    Debug.Assert(!expressionForMemberAccess.Contains("."));
                    EmitAssignment($"var {expressionForMemberAccess}", expressionForInit);
                }
                else if (initKind == InitializationKind.AssignmentWithNullCheck)
                {
                    _writer.WriteLine($"{expressionForMemberAccess} ??= {expressionForInit};");
                }
                else
                {
                    EmitAssignment(expressionForMemberAccess, expressionForInit);
                }
            }

            private void EmitIConfigurationHasValueOrChildrenCheck()
            {
                _writer.WriteBlock($$"""
                    if (!{{GetHelperMethodDisplayString(Identifier.HasValueOrChildren)}}({{Identifier.configuration}}))
                    {
                        return default;
                    }
                    """);
                _writer.WriteBlankLine();
            }

            private void EmitHelperMethods()
            {
                if (IncludeMethodsForGen(MethodSpecifier.HasValueOrChildren))
                {
                    EmitHasValueOrChildrenMethod();
                    _writer.WriteBlankLine();
                    EmitHasChildrenMethod();
                }
                else if (IncludeMethodsForGen(MethodSpecifier.HasChildren))
                {
                    EmitHasChildrenMethod();
                }
            }

            private void EmitHasValueOrChildrenMethod()
            {
                _writer.WriteBlock($$"""
                    public static bool {{Identifier.HasValueOrChildren}}({{Identifier.IConfiguration}} {{Identifier.configuration}})
                    {
                        if (({{Identifier.configuration}} as {{Identifier.IConfigurationSection}})?.{{Identifier.Value}} is not null)
                        {
                            return true;
                        }
                        return {{Identifier.HasChildren}}({{Identifier.configuration}});
                    }
                    """);
            }

            private void EmitHasChildrenMethod()
            {
                _writer.WriteBlock($$"""
                    public static bool {{Identifier.HasChildren}}({{Identifier.IConfiguration}} {{Identifier.configuration}})
                    {
                        foreach ({{Identifier.IConfigurationSection}} {{Identifier.section}} in {{Identifier.configuration}}.{{Identifier.GetChildren}}())
                        {
                            return true;
                        }
                        return false;
                    }
                    """);
            }

            private void EmitVarDeclaration(TypeSpec type, string varName) => _writer.WriteLine($"{type.MinimalDisplayString} {varName};");

            private void EmitAssignment(string lhsSource, string rhsSource) => _writer.WriteLine($"{lhsSource} = {rhsSource};");

            private void EmitCastToIConfigurationSection()
            {
                string sectionTypeDisplayString;
                string exceptionTypeDisplayString;
                if (_useFullyQualifiedNames)
                {
                    sectionTypeDisplayString = FullyQualifiedDisplayName.IConfigurationSection;
                    exceptionTypeDisplayString = FullyQualifiedDisplayName.InvalidOperationException;
                }
                else
                {
                    sectionTypeDisplayString = Identifier.IConfigurationSection;
                    exceptionTypeDisplayString = nameof(InvalidOperationException);
                }

                _writer.WriteBlock($$"""
                    if ({{Identifier.configuration}} is not {{sectionTypeDisplayString}} {{Identifier.section}})
                    {
                        throw new {{exceptionTypeDisplayString}}();
                    }
                    """);
            }

            private void Emit_NotSupportedException_UnableToBindType(string reason, string typeDisplayString = "{typeof(T)}") =>
                _writer.WriteLine(@$"throw new {FullyQualifiedDisplayName.NotSupportedException}($""{string.Format(ExceptionMessages.TypeNotSupported, typeDisplayString, reason)}"");");

            private void EmitCheckForNullArgument_WithBlankLine_IfRequired(bool isValueType)
            {
                if (!isValueType)
                {
                    EmitCheckForNullArgument_WithBlankLine(Identifier.obj);
                }
            }

            private void EmitCheckForNullArgument_WithBlankLine(string argName, bool useFullyQualifiedNames = false)
            {
                string exceptionTypeDisplayString = useFullyQualifiedNames
                    ? FullyQualifiedDisplayName.ArgumentNullException
                    : Identifier.ArgumentNullException;

                _writer.WriteBlock($$"""
                    if ({{argName}} is null)
                    {
                        throw new {{exceptionTypeDisplayString}}(nameof({{argName}}));
                    }
                    """);

                _writer.WriteBlankLine();
            }

            private bool IncludeMethodsForGen(MethodSpecifier method)
                => (_generationSpec.MethodsToGen & method) != 0;

            private string GetIncrementalVarName(string prefix) => $"{prefix}{_parseValueCount++}";

            private string GetTypeDisplayString(TypeSpec type) => _useFullyQualifiedNames ? type.FullyQualifiedDisplayString : type.MinimalDisplayString;

            private string GetHelperMethodDisplayString(string methodName)
            {
                if (_useFullyQualifiedNames)
                {
                    methodName = FullyQualifiedDisplayName.Helpers + "." + methodName;
                }

                return methodName;
            }
        }
    }
}
