// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace Microsoft.Extensions.Configuration.Binder.SourceGeneration
{
    public sealed partial class ConfigurationBindingSourceGenerator
    {
        private sealed partial class Emitter
        {
            private static class Expression
            {
                public const string sectionKey = "section.Key";
                public const string sectionPath = "section.Path";
                public const string sectionValue = "section.Value";
            }

            private static class FullyQualifiedDisplayName
            {
                public const string Helpers = $"global::{GeneratorProjectName}.{Identifier.Helpers}";
                public const string IConfiguration = "global::Microsoft.Extensions.Configuration.IConfiguration";
                public const string IConfigurationSection = IConfiguration + "Section";
                public const string InvalidOperationException = "global::System.InvalidOperationException";
                public const string IServiceCollection = "global::Microsoft.Extensions.DependencyInjection.IServiceCollection";
            }

            private enum InitializationKind
            {
                None = 0,
                SimpleAssignment = 1,
                AssignmentWithNullCheck = 2,
                Declaration = 3,
            }

            private readonly SourceProductionContext _context;
            private readonly SourceGenerationSpec _generationSpec;

            // Postfix for stringValueX variables used to save config value indexer
            // results e.g. if (configuration["Key"] is string stringValue0) { ... }
            private int _parseValueCount;

            private readonly SourceWriter _writer = new();

            private readonly Regex _arrayBracketsRegex = new(Regex.Escape("[]"));

            private bool _useFullyQualifiedNames = true;

            public Emitter(SourceProductionContext context, SourceGenerationSpec generationSpec)
            {
                _context = context;
                _generationSpec = generationSpec;
            }

            public void Emit()
            {
                _writer.WriteLine(@"// <auto-generated/>
#nullable enable
");

                // Generated binder for user consumption.
                _writer.WriteBlockStart($"internal static class {Identifier.GeneratedConfigurationBinder}");
                EmitConfigureMethod();
                EmitGetMethod();
                EmitBindMethods();
                _writer.WriteBlockEnd();

                _writer.WriteBlankLine();

                EmitGenerationNamespaceAndHelpers();

                _context.AddSource($"{Identifier.GeneratedConfigurationBinder}.g.cs", _writer.ToSourceText());
            }

            private void EmitConfigureMethod()
            {
                if (!IncludeMethodsForGen(MethodSpecifier.Configure))
                {
                    return;
                }

                _writer.WriteBlockStart($"public static {FullyQualifiedDisplayName.IServiceCollection} {Identifier.Configure}<T>(this {FullyQualifiedDisplayName.IServiceCollection} {Identifier.services}, {FullyQualifiedDisplayName.IConfiguration} {Identifier.configuration})");

                EmitCheckForNullArgument_WithBlankLine(Identifier.configuration, useFullyQualifiedNames: true);

                foreach (TypeSpec type in _generationSpec.RootConfigTypes[MethodSpecifier.Configure])
                {
                    string typeDisplayString = type.FullyQualifiedDisplayString;

                    _writer.WriteBlockStart($"if (typeof(T) == typeof({typeDisplayString}))");

                    _writer.WriteBlockStart($@"return {Identifier.services}.{Identifier.Configure}<{typeDisplayString}>({Identifier.obj} =>");
                    EmitIConfigurationHasValueOrChildrenCheck();
                    EmitBindLogicFromRootMethod(type, Identifier.obj, InitializationKind.None);
                    _writer.WriteBlockEnd(");");

                    _writer.WriteBlockEnd();
                    _writer.WriteBlankLine();
                }

                Emit_NotSupportedException_UnableToBindType(NotSupportedReason.TypeNotDetectedAsInput);
                _writer.WriteBlockEnd();
            }

            private void EmitGetMethod()
            {
                if (!IncludeMethodsForGen(MethodSpecifier.Get))
                {
                    return;
                }

                if (IncludeMethodsForGen(MethodSpecifier.Configure))
                {
                    _writer.WriteBlankLine();
                }

                _writer.WriteBlockStart($"public static T? {Identifier.Get}<T>(this {FullyQualifiedDisplayName.IConfiguration} {Identifier.configuration})");

                EmitCheckForNullArgument_WithBlankLine(Identifier.configuration, useFullyQualifiedNames: true);

                EmitIConfigurationHasValueOrChildrenCheck();

                foreach (TypeSpec type in _generationSpec.RootConfigTypes[MethodSpecifier.Get])
                {
                    string typeDisplayString = type.FullyQualifiedDisplayString;

                    _writer.WriteBlockStart($"if (typeof(T) == typeof({typeDisplayString}))");
                    EmitBindLogicFromRootMethod(type, Identifier.obj, InitializationKind.Declaration);
                    _writer.WriteLine($"return (T)(object){Identifier.obj};");
                    _writer.WriteBlockEnd();
                    _writer.WriteBlankLine();
                }

                Emit_NotSupportedException_UnableToBindType(NotSupportedReason.TypeNotDetectedAsInput);
                _writer.WriteBlockEnd();
            }

            private void EmitBindMethods()
            {
                if (!IncludeMethodsForGen(MethodSpecifier.Bind))
                {
                    return;
                }

                if (IncludeMethodsForGen(MethodSpecifier.Configure | MethodSpecifier.Get))
                {
                    _writer.WriteBlankLine();
                }

                foreach (TypeSpec type in _generationSpec.RootConfigTypes[MethodSpecifier.Bind])
                {
                    EmitBindMethod(type);
                    _writer.WriteBlankLine();
                }

                _writer.RemoveBlankLine();
            }

            private void EmitBindMethod(TypeSpec type)
            {
                _writer.WriteLine(
                    @$"public static void {Identifier.Bind}(this {FullyQualifiedDisplayName.IConfiguration} {Identifier.configuration}, {type.FullyQualifiedDisplayString} {Identifier.obj}) => " +
                        $"{FullyQualifiedDisplayName.Helpers}.{Identifier.BindCore}({Identifier.configuration}, ref {Identifier.obj});");
            }

            private void EmitGenerationNamespaceAndHelpers()
            {
                _useFullyQualifiedNames = false;

                if (IncludeMethodsForGen(MethodSpecifier.BindCore | MethodSpecifier.HasValueOrChildren | MethodSpecifier.HasChildren))
                {
                    // Helper class in source-generation namespace.
                    _writer.WriteBlockStart($"namespace {GeneratorProjectName}");
                    EmitHelperUsingStatements();

                    _writer.WriteBlankLine();

                    _writer.WriteBlockStart($"internal static class {Identifier.Helpers}");
                    EmitBindCoreMethods();
                    EmitHelperMethods();
                    _writer.WriteBlockEnd();

                    _writer.WriteBlockEnd();
                }
            }

            private void EmitHelperUsingStatements()
            {
                foreach (string @namespace in _generationSpec.Namespaces)
                {
                    _writer.WriteLine($"using {@namespace};");
                }
            }

            private void EmitBindCoreMethods()
            {
                foreach (TypeSpec type in _generationSpec.RootConfigTypes[MethodSpecifier.BindCore])
                {
                    EmitBindCoreMethod(type);
                    _writer.WriteBlankLine();
                }
            }

            private void EmitBindCoreMethod(TypeSpec type)
            {
                string objParameterExpression = $"ref {type.MinimalDisplayString} {Identifier.obj}";
                _writer.WriteBlockStart(@$"public static void {Identifier.BindCore}({Identifier.IConfiguration} {Identifier.configuration}, {objParameterExpression})");
                EmitBindCoreImpl(type);
                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImpl(TypeSpec type)
            {
                switch (type.SpecKind)
                {
                    case TypeSpecKind.Array:
                        {
                            EmitBindCoreImplForArray((ArraySpec)type);
                        }
                        break;
                    case TypeSpecKind.Enumerable:
                        {
                            EmitBindCoreImplForEnumerable((EnumerableSpec)type);
                        }
                        break;
                    case TypeSpecKind.Dictionary:
                        {
                            EmitBindCoreImplForDictionary((DictionarySpec)type);
                        }
                        break;
                    case TypeSpecKind.IConfigurationSection:
                        {
                            EmitCastToIConfigurationSection();
                            EmitAssignment(Identifier.obj, Identifier.section);
                        }
                        break;
                    case TypeSpecKind.Object:
                        {
                            EmitBindCoreImplForObject((ObjectSpec)type);
                        }
                        break;
                    case TypeSpecKind.Nullable:
                        {
                            EmitBindCoreImpl(((NullableSpec)type).UnderlyingType);
                        }
                        break;
                    default:
                        Debug.Fail("Invalid type kind", type.SpecKind.ToString());
                        break;
                }
            }

            private void EmitBindCoreImplForArray(ArraySpec type)
            {
                EnumerableSpec concreteType = (EnumerableSpec)type.ConcreteType;

                EmitCheckForNullArgument_WithBlankLine_IfRequired(isValueType: false);

                // Create, bind, and add elements to temp list.
                string tempVarName = GetIncrementalVarName(Identifier.temp);
                EmitBindCoreCall(concreteType, tempVarName, Identifier.configuration, InitializationKind.Declaration);

                // Resize array and copy additional elements.
                _writer.WriteBlock($$"""
                    {{Identifier.Int32}} {{Identifier.originalCount}} = {{Identifier.obj}}.{{Identifier.Length}};
                    {{Identifier.Array}}.{{Identifier.Resize}}(ref {{Identifier.obj}}, {{Identifier.originalCount}} + {{tempVarName}}.{{Identifier.Count}});
                    {{tempVarName}}.{{Identifier.CopyTo}}({{Identifier.obj}}, {{Identifier.originalCount}});
                    """);
            }

            private void EmitBindCoreImplForEnumerable(EnumerableSpec type)
            {
                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                TypeSpec elementType = type.ElementType;

                _writer.WriteBlockStart($"foreach ({Identifier.IConfigurationSection} {Identifier.section} in {Identifier.configuration}.{Identifier.GetChildren}())");
                _writer.WriteBlockStart($"if ({Identifier.HasValueOrChildren}({Identifier.section}))");

                string addStatement = $"{Identifier.obj}.{Identifier.Add}({Identifier.element})";

                if (elementType.SpecKind is TypeSpecKind.ParsableFromString)
                {
                    ParsableFromStringTypeSpec stringParsableType = (ParsableFromStringTypeSpec)elementType;
                    if (stringParsableType.StringParsableTypeKind is StringParsableTypeKind.ConfigValue)
                    {
                        string tempVarName = GetIncrementalVarName(Identifier.stringValue);
                        _writer.WriteBlockStart($"if ({Expression.sectionValue} is string {tempVarName})");
                        _writer.WriteLine($"{Identifier.obj}.{Identifier.Add}({tempVarName});");
                        _writer.WriteBlockEnd();
                    }
                    else
                    {
                        EmitVarDeclaration(elementType, Identifier.element);
                        EmitBindLogicFromString(stringParsableType, Identifier.element, Expression.sectionValue, Expression.sectionPath, () => _writer.WriteLine($"{addStatement};"));
                    }
                }
                else
                {
                    EmitBindCoreCall(elementType, Identifier.element, Identifier.section, InitializationKind.Declaration);
                    _writer.WriteLine($"{addStatement};");
                }

                _writer.WriteBlockEnd();
                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImplForDictionary(DictionarySpec type)
            {
                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                _writer.WriteBlockStart($"foreach ({Identifier.IConfigurationSection} {Identifier.section} in {Identifier.configuration}.{Identifier.GetChildren}())");
                _writer.WriteBlockStart($"if ({Identifier.HasValueOrChildren}({Identifier.section}))");

                // Parse key
                ParsableFromStringTypeSpec keyType = type.KeyType;

                if (keyType.StringParsableTypeKind is StringParsableTypeKind.ConfigValue)
                {
                    _writer.WriteLine($"{keyType.MinimalDisplayString} {Identifier.key} = {Expression.sectionKey};");
                    Emit_BindAndAddLogic_ForElement();
                }
                else
                {
                    EmitVarDeclaration(keyType, Identifier.key);
                    EmitBindLogicFromString(
                        keyType,
                        Identifier.key,
                        expressionForConfigStringValue: Expression.sectionKey,
                        expressionForConfigValuePath: Expression.sectionValue,
                        writeOnSuccess: Emit_BindAndAddLogic_ForElement);
                }

                void Emit_BindAndAddLogic_ForElement()
                {
                    TypeSpec elementType = type.ElementType;

                    if (elementType.SpecKind == TypeSpecKind.ParsableFromString)
                    {
                        ParsableFromStringTypeSpec stringParsableType = (ParsableFromStringTypeSpec)elementType;
                        if (stringParsableType.StringParsableTypeKind is StringParsableTypeKind.ConfigValue)
                        {
                            string tempVarName = GetIncrementalVarName(Identifier.stringValue);
                            _writer.WriteBlockStart($"if ({Expression.sectionValue} is string {tempVarName})");
                            _writer.WriteLine($"{Identifier.obj}[{Identifier.key}] = {tempVarName};");
                            _writer.WriteBlockEnd();
                        }
                        else
                        {
                            EmitVarDeclaration(elementType, Identifier.element);
                            EmitBindLogicFromString(
                                stringParsableType,
                                Identifier.element,
                                Expression.sectionValue,
                                Expression.sectionPath,
                                () => _writer.WriteLine($"{Identifier.obj}[{Identifier.key}] = {Identifier.element};"));
                        }
                    }
                    else // For complex types:
                    {
                        string elementTypeDisplayString = elementType.MinimalDisplayString + (elementType.IsValueType ? string.Empty : "?");

                        // If key already exists, bind to value to existing element instance if not null (for ref types).
                        string conditionToUseExistingElement = $"{Identifier.obj}.{Identifier.TryGetValue}({Identifier.key}, out {elementTypeDisplayString} {Identifier.element})";
                        if (!elementType.IsValueType)
                        {
                            conditionToUseExistingElement += $" && {Identifier.element} is not null";
                        }
                        _writer.WriteBlockStart($"if (!({conditionToUseExistingElement}))");
                        EmitObjectInit(elementType, Identifier.element, InitializationKind.SimpleAssignment);
                        _writer.WriteBlockEnd();

                        EmitBindCoreCall(elementType, $"{Identifier.element}!", Identifier.section, InitializationKind.None);
                        _writer.WriteLine($"{Identifier.obj}[{Identifier.key}] = {Identifier.element};");
                    }
                }

                _writer.WriteBlockEnd();
                _writer.WriteBlockEnd();
            }

            private void EmitBindCoreImplForObject(ObjectSpec type)
            {
                List<PropertySpec> properties = type.Properties;
                if (properties.Count == 0)
                {
                    return;
                }

                EmitCheckForNullArgument_WithBlankLine_IfRequired(type.IsValueType);

                foreach (PropertySpec property in type.Properties)
                {
                    TypeSpec propertyType = property.Type;

                    EmitBindCoreImplForProperty(property, propertyType, parentType: type);
                    _writer.WriteBlankLine();
                }

                _writer.RemoveBlankLine();
            }

            private void EmitBindCoreImplForProperty(PropertySpec property, TypeSpec propertyType, TypeSpec parentType)
            {
                string configurationKeyName = property.ConfigurationKeyName;

                string propertyParentReference = property.IsStatic ? parentType.MinimalDisplayString : Identifier.obj;
                string expressionForPropertyAccess = $"{propertyParentReference}.{property.Name}";

                string expressionForConfigSectionAccess = $@"{Identifier.configuration}.{Identifier.GetSection}(""{configurationKeyName}"")";
                string expressionForConfigValueIndexer = $@"{Identifier.configuration}[""{configurationKeyName}""]";

                bool canSet = property.CanSet;

                switch (propertyType.SpecKind)
                {
                    case TypeSpecKind.ParsableFromString:
                        {
                            if (canSet)
                            {
                                EmitBindLogicFromString(
                                    (ParsableFromStringTypeSpec)propertyType,
                                    expressionForPropertyAccess,
                                    expressionForConfigValueIndexer,
                                    expressionForConfigValuePath: $@"{expressionForConfigSectionAccess}.{Identifier.Path}");
                            }
                        }
                        break;
                    case TypeSpecKind.Array:
                        {
                            EmitBindCoreCallForProperty(
                                property,
                                propertyType,
                                expressionForPropertyAccess,
                                expressionForConfigSectionAccess);
                        }
                        break;
                    case TypeSpecKind.IConfigurationSection:
                        {
                            EmitAssignment(expressionForPropertyAccess, expressionForConfigSectionAccess);
                        }
                        break;
                    case TypeSpecKind.Nullable:
                        {
                            TypeSpec underlyingType = ((NullableSpec)propertyType).UnderlyingType;
                            EmitBindCoreImplForProperty(property, underlyingType, parentType);
                        }
                        break;
                    default:
                        {
                            EmitBindCoreCallForProperty(
                                property,
                                propertyType,
                                expressionForPropertyAccess,
                                expressionForConfigSectionAccess);
                        }
                        break;
                }
            }

            private void EmitBindLogicFromRootMethod(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                if (type.SpecKind is TypeSpecKind.ParsableFromString)
                {
                    if (initKind is InitializationKind.Declaration)
                    {
                        EmitCastToIConfigurationSection();
                        EmitAssignment($"{GetTypeDisplayString(type)} {expressionForMemberAccess}", "default");
                    }
                    else
                    {
                        EmitCastToIConfigurationSection();
                    }
                    EmitBindLogicFromString((ParsableFromStringTypeSpec)type, expressionForMemberAccess, Expression.sectionValue, Expression.sectionPath);
                }
                else
                {
                    EmitBindCoreCall(type, expressionForMemberAccess, Identifier.configuration, initKind);
                }
            }

            private void EmitBindCoreCall(
                TypeSpec type,
                string expressionForMemberAccess,
                string expressionForConfigArg,
                InitializationKind initKind)
            {
                string tempVarName = GetIncrementalVarName(Identifier.temp);
                if (initKind is InitializationKind.AssignmentWithNullCheck)
                {
                    EmitAssignment($"{type.MinimalDisplayString} {tempVarName}", $"{expressionForMemberAccess}");
                    EmitObjectInit(type, tempVarName, InitializationKind.AssignmentWithNullCheck);
                    EmitBindCoreCall(tempVarName);
                }
                else if (initKind is InitializationKind.None && type.IsValueType)
                {
                    EmitObjectInit(type, tempVarName, InitializationKind.Declaration);
                    _writer.WriteLine($@"{Identifier.BindCore}({expressionForConfigArg}, ref {tempVarName});");
                    EmitAssignment(expressionForMemberAccess, tempVarName);
                }
                else
                {
                    EmitObjectInit(type, expressionForMemberAccess, initKind);
                    EmitBindCoreCall(expressionForMemberAccess);
                }

                void EmitBindCoreCall(string varName)
                {
                    string bindCoreCall = $@"{GetHelperMethodDisplayString(Identifier.BindCore)}({expressionForConfigArg}, ref {varName});";
                    _writer.WriteLine(bindCoreCall);
                }
            }

            private void EmitBindCoreCallForProperty(
                PropertySpec property,
                TypeSpec effectivePropertyType,
                string expressionForPropertyAccess,
                string expressionForConfigSectionAccess)
            {
                string bindCoreConfigArg = GetIncrementalVarName(Identifier.section);
                EmitAssignment($"{Identifier.IConfigurationSection} {bindCoreConfigArg}", expressionForConfigSectionAccess);
                _writer.WriteBlockStart($"if ({Identifier.HasChildren}({bindCoreConfigArg}))");

                bool canGet = property.CanGet;
                bool canSet = property.CanSet;
                string effectivePropertyTypeDisplayString = effectivePropertyType.MinimalDisplayString;

                string tempVarName = GetIncrementalVarName(Identifier.temp);
                if (effectivePropertyType.IsValueType)
                {
                    if (canSet)
                    {
                        if (canGet)
                        {
                            TypeSpec actualPropertyType = property.Type;
                            if (actualPropertyType.SpecKind is TypeSpecKind.Nullable)
                            {
                                string nullableTempVarName = GetIncrementalVarName(Identifier.temp);
                                EmitAssignment(
                                    $"{actualPropertyType.MinimalDisplayString} {nullableTempVarName}", expressionForPropertyAccess);
                                EmitAssignment(
                                    $"{effectivePropertyTypeDisplayString} {tempVarName}",
                                    $"{nullableTempVarName}.{Identifier.HasValue} ? {nullableTempVarName}.{Identifier.Value} : new {effectivePropertyTypeDisplayString}()");
                            }
                            else
                            {
                                EmitAssignment($"{effectivePropertyTypeDisplayString} {tempVarName}", $"{expressionForPropertyAccess}");
                            }
                        }
                        else
                        {
                            EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.Declaration);
                        }

                        _writer.WriteLine($@"{Identifier.BindCore}({bindCoreConfigArg}, ref {tempVarName});");
                        EmitAssignment(expressionForPropertyAccess, tempVarName);
                    }
                }
                else if (canGet)
                {
                    EmitAssignment($"{effectivePropertyTypeDisplayString} {tempVarName}", $"{expressionForPropertyAccess}");
                    EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.AssignmentWithNullCheck);
                    _writer.WriteLine($@"{Identifier.BindCore}({bindCoreConfigArg}, ref {tempVarName});");

                    if (canSet)
                    {
                        EmitAssignment(expressionForPropertyAccess, tempVarName);
                    }
                }
                else
                {
                    Debug.Assert(canSet);
                    EmitObjectInit(effectivePropertyType, tempVarName, InitializationKind.Declaration);
                    _writer.WriteLine($@"{Identifier.BindCore}({bindCoreConfigArg}, ref {tempVarName});");
                    EmitAssignment(expressionForPropertyAccess, tempVarName);
                }

                _writer.WriteBlockEnd();
            }

            private void EmitBindLogicFromString(
                ParsableFromStringTypeSpec type,
                string expressionForMemberAccess,
                string expressionForConfigStringValue,
                string expressionForConfigValuePath,
                Action? writeOnSuccess = null)
            {
                StringParsableTypeKind typeKind = type.StringParsableTypeKind;
                Debug.Assert(typeKind is not StringParsableTypeKind.None);

                string stringValueVarName = GetIncrementalVarName(Identifier.stringValue);

                _writer.WriteBlockStart($"if ({expressionForConfigStringValue} is string {stringValueVarName})");

                string parsedValue = typeKind is StringParsableTypeKind.ConfigValue
                    ? stringValueVarName
                    : $"{GetHelperMethodDisplayString(type.ParseMethodName)}({stringValueVarName}, () => {expressionForConfigValuePath})";

                EmitAssignment(expressionForMemberAccess, parsedValue);
                writeOnSuccess?.Invoke();
                _writer.WriteBlockEnd();

                return;
            }

            private void EmitObjectInit(TypeSpec type, string expressionForMemberAccess, InitializationKind initKind)
            {
                if (initKind is InitializationKind.None)
                {
                    return;
                }

                string displayString = GetTypeDisplayString(type);

                string expressionForInit = null;
                if (type is ArraySpec)
                {
                    expressionForInit = $"new {_arrayBracketsRegex.Replace(displayString, "[0]", 1)}";
                }
                else if (type.ConstructionStrategy != ConstructionStrategy.ParameterlessConstructor)
                {
                    return;
                }
                else if (type is CollectionSpec { ConcreteType: { } concreteType })
                {
                    displayString = GetTypeDisplayString(concreteType);
                }

                // Not an array.
                expressionForInit ??= $"new {displayString}()";

                if (initKind == InitializationKind.Declaration)
                {
                    Debug.Assert(!expressionForMemberAccess.Contains("."));
                    EmitAssignment($"var {expressionForMemberAccess}", expressionForInit);
                }
                else if (initKind == InitializationKind.AssignmentWithNullCheck)
                {
                    _writer.WriteLine($"{expressionForMemberAccess} ??= {expressionForInit};");
                }
                else
                {
                    EmitAssignment(expressionForMemberAccess, expressionForInit);
                }
            }

            private void EmitIConfigurationHasValueOrChildrenCheck()
            {
                _writer.WriteBlock($$"""
                    if (!{{GetHelperMethodDisplayString(Identifier.HasValueOrChildren)}}({{Identifier.configuration}}))
                    {
                        return default;
                    }
                    """);
                _writer.WriteBlankLine();
            }

            private void EmitHelperMethods()
            {
                if (IncludeMethodsForGen(MethodSpecifier.HasValueOrChildren))
                {
                    EmitHasValueOrChildrenMethod();
                    _writer.WriteBlankLine();
                    EmitHasChildrenMethod();
                }
                else if (IncludeMethodsForGen(MethodSpecifier.HasChildren))
                {
                    EmitHasChildrenMethod();
                }

                if (_generationSpec.PrimitivesForHelperGen.Count > 0)
                {
                    foreach (ParsableFromStringTypeSpec type in _generationSpec.PrimitivesForHelperGen)
                    {
                        _writer.WriteBlankLine();
                        EmitPrimitiveParseMethod(type);
                    }
                }
            }

            private void EmitHasValueOrChildrenMethod()
            {
                _writer.WriteBlock($$"""
                    public static bool {{Identifier.HasValueOrChildren}}({{Identifier.IConfiguration}} {{Identifier.configuration}})
                    {
                        if (({{Identifier.configuration}} as {{Identifier.IConfigurationSection}})?.{{Identifier.Value}} is not null)
                        {
                            return true;
                        }
                        return {{Identifier.HasChildren}}({{Identifier.configuration}});
                    }
                    """);
            }

            private void EmitHasChildrenMethod()
            {
                _writer.WriteBlock($$"""
                    public static bool {{Identifier.HasChildren}}({{Identifier.IConfiguration}} {{Identifier.configuration}})
                    {
                        foreach ({{Identifier.IConfigurationSection}} {{Identifier.section}} in {{Identifier.configuration}}.{{Identifier.GetChildren}}())
                        {
                            return true;
                        }
                        return false;
                    }
                    """);
            }

            private void EmitPrimitiveParseMethod(ParsableFromStringTypeSpec type)
            {
                string innerExceptionTypeDisplayString;
                string cultureInfoTypeDisplayString;
                string numberStylesTypeDisplayString;

                if (_useFullyQualifiedNames)
                {
                    innerExceptionTypeDisplayString = "global::System.Exception";
                    cultureInfoTypeDisplayString = "global::System.Globalization.CultureInfo";
                    numberStylesTypeDisplayString = "global::System.Globalization.NumberStyles";
                }
                else
                {
                    innerExceptionTypeDisplayString = "Exception";
                    cultureInfoTypeDisplayString = "CultureInfo";
                    numberStylesTypeDisplayString = "NumberStyles";
                }

                string invariantCultureExpression = $"{cultureInfoTypeDisplayString}.InvariantCulture";

                string expressionForParsedValue;
                StringParsableTypeKind typeKind = type.StringParsableTypeKind;
                string typeDisplayString = type.MinimalDisplayString;

                switch (typeKind)
                {
                    case StringParsableTypeKind.Enum:
                        {
                            expressionForParsedValue = $"({typeDisplayString}){Identifier.Enum}.{Identifier.Parse}(typeof({typeDisplayString}), {Identifier.stringValue}, ignoreCase: true)";
                        }
                        break;
                    case StringParsableTypeKind.ByteArray:
                        {
                            expressionForParsedValue = $"Convert.FromBase64String({Identifier.stringValue})";
                        }
                        break;
                    case StringParsableTypeKind.Integer:
                        {
                            expressionForParsedValue = $"{typeDisplayString}.{Identifier.Parse}({Identifier.stringValue}, {numberStylesTypeDisplayString}.Integer, {invariantCultureExpression})";
                        }
                        break;
                    case StringParsableTypeKind.Float:
                        {
                            expressionForParsedValue = $"{typeDisplayString}.{Identifier.Parse}({Identifier.stringValue}, {numberStylesTypeDisplayString}.Float, {invariantCultureExpression})";
                        }
                        break;
                    case StringParsableTypeKind.Parse:
                        {
                            expressionForParsedValue = $"{typeDisplayString}.{Identifier.Parse}({Identifier.stringValue})";
                        }
                        break;
                    case StringParsableTypeKind.ParseInvariant:
                        {
                            expressionForParsedValue = $"{typeDisplayString}.{Identifier.Parse}({Identifier.stringValue}, {invariantCultureExpression})"; ;
                        }
                        break;
                    case StringParsableTypeKind.CultureInfo:
                        {
                            expressionForParsedValue = $"{cultureInfoTypeDisplayString}.GetCultureInfo({Identifier.stringValue})";
                        }
                        break;
                    case StringParsableTypeKind.Uri:
                        {
                            expressionForParsedValue = $"new Uri({Identifier.stringValue}, UriKind.RelativeOrAbsolute)";
                        }
                        break;
                    default:
                        {
                            Debug.Fail($"Invalid string parsable kind: {typeKind}");
                            return;
                        }
                }

                string exceptionTypeDisplayString = _useFullyQualifiedNames ? FullyQualifiedDisplayName.InvalidOperationException : Identifier.InvalidOperationException;

                _writer.WriteBlock($$"""
                    public static {{typeDisplayString}} {{type.ParseMethodName}}(string {{Identifier.stringValue}}, Func<string?> {{Identifier.getPath}})
                    {
                        try
                        {
                            return {{expressionForParsedValue}};
                    """);

                string exceptionArg1 = string.Format(ExceptionMessages.FailedBinding, $"{{{Identifier.getPath}()}}", $"{{typeof({typeDisplayString})}}");

                _writer.WriteBlock($$"""
                        }
                        catch ({{innerExceptionTypeDisplayString}} {{Identifier.exception}})
                        {
                            throw new {{exceptionTypeDisplayString}}($"{{exceptionArg1}}", {{Identifier.exception}});
                        }
                    }
                    """);
            }

            private void EmitVarDeclaration(TypeSpec type, string varName) => _writer.WriteLine($"{type.MinimalDisplayString} {varName};");

            private void EmitAssignment(string lhsSource, string rhsSource) => _writer.WriteLine($"{lhsSource} = {rhsSource};");

            private void EmitCastToIConfigurationSection()
            {
                string sectionTypeDisplayString;
                string exceptionTypeDisplayString;
                if (_useFullyQualifiedNames)
                {
                    sectionTypeDisplayString = "global::Microsoft.Extensions.Configuration.IConfigurationSection";
                    exceptionTypeDisplayString = FullyQualifiedDisplayName.InvalidOperationException;
                }
                else
                {
                    sectionTypeDisplayString = Identifier.IConfigurationSection;
                    exceptionTypeDisplayString = nameof(InvalidOperationException);
                }

                _writer.WriteBlock($$"""
                    if ({{Identifier.configuration}} is not {{sectionTypeDisplayString}} {{Identifier.section}})
                    {
                        throw new {{exceptionTypeDisplayString}}();
                    }
                    """);
            }

            private void Emit_NotSupportedException_UnableToBindType(string reason, string typeDisplayString = "{typeof(T)}") =>
                _writer.WriteLine(@$"throw new global::System.NotSupportedException($""{string.Format(ExceptionMessages.TypeNotSupported, typeDisplayString, reason)}"");");

            private void EmitCheckForNullArgument_WithBlankLine_IfRequired(bool isValueType)
            {
                if (!isValueType)
                {
                    EmitCheckForNullArgument_WithBlankLine(Identifier.obj);
                }
            }

            private void EmitCheckForNullArgument_WithBlankLine(string argName, bool useFullyQualifiedNames = false)
            {
                string exceptionTypeDisplayString = useFullyQualifiedNames
                    ? "global::System.ArgumentNullException"
                    : "ArgumentNullException";

                _writer.WriteBlock($$"""
                    if ({{argName}} is null)
                    {
                        throw new {{exceptionTypeDisplayString}}(nameof({{argName}}));
                    }
                    """);

                _writer.WriteBlankLine();
            }

            private bool IncludeMethodsForGen(MethodSpecifier method)
                => (_generationSpec.MethodsToGen & method) != 0;

            private string GetIncrementalVarName(string prefix) => $"{prefix}{_parseValueCount++}";

            private string GetTypeDisplayString(TypeSpec type) => _useFullyQualifiedNames ? type.FullyQualifiedDisplayString : type.MinimalDisplayString;

            private string GetHelperMethodDisplayString(string methodName)
            {
                if (_useFullyQualifiedNames)
                {
                    methodName = FullyQualifiedDisplayName.Helpers + "." + methodName;
                }

                return methodName;
            }
        }
    }
}
