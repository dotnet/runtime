<Project InitialTargets="UpdateProjectReferencesWithAttributes">
  <PropertyGroup>
    <!-- Override strong name key to default to Open for test projects,
         Tests which wish to control this should set TestStrongNameKeyId. -->
    <TestStrongNameKeyId Condition="'$(TestStrongNameKeyId)' == '' and $(MSBuildProjectName.StartsWith('Microsoft.Extensions.'))">MicrosoftAspNetCore</TestStrongNameKeyId>
    <TestStrongNameKeyId Condition="'$(TestStrongNameKeyId)' == ''">Open</TestStrongNameKeyId>
    <StrongNameKeyId Condition="'$(IsTestProject)' == 'true' or '$(IsTestSupportProject)' == 'true'">$(TestStrongNameKeyId)</StrongNameKeyId>
  </PropertyGroup>

  <!-- resources.targets need to be imported before the Arcade SDK. -->
  <Import Project="$(RepositoryEngineeringDir)resources.targets" />
  <Import Project="..\..\Directory.Build.targets" />

  <PropertyGroup>
    <TargetsForTfmSpecificContentInPackage Condition="'$(IsPackable)' == 'true'">$(TargetsForTfmSpecificContentInPackage);LibIntellisenseDocs</TargetsForTfmSpecificContentInPackage>
    <SymbolPackageOutputPath>$(PackageOutputPath)</SymbolPackageOutputPath>
    <NoWarn Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == '.NETStandard' or ('$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '3.0')))">$(NoWarn);nullable</NoWarn>
    <NoWarn Condition="'$(GeneratePlatformNotSupportedAssembly)' == 'true' or '$(GeneratePlatformNotSupportedAssemblyMessage)' != ''">$(NoWarn);nullable;CA1052</NoWarn>
    <!-- Ignore Obsolete errors within the generated shims that type-forward types.
         SYSLIB0003: Code Access Security (CAS).
         SYSLIB0004: Constrained Execution Region (CER).
         SYSLIB0017: Strong name signing.
         SYSLIB0021: Derived cryptographic types.
         SYSLIB0022: Rijndael types.
         SYSLIB0023: RNGCryptoServiceProvider.
    -->
    <NoWarn Condition="'$(IsPartialFacadeAssembly)' == 'true'">$(NoWarn);SYSLIB0003;SYSLIB0004;SYSLIB0015;SYSLIB0017;SYSLIB0021;SYSLIB0022;SYSLIB0023</NoWarn>
    <!-- Reset these properties back to blank, since they are defaulted by Microsoft.NET.Sdk -->
    <WarningsAsErrors Condition="'$(WarningsAsErrors)' == 'NU1605'" />
    <!-- Set the documentation output file globally. -->
    <DocumentationFile Condition="'$(IsSourceProject)' == 'true' and '$(DocumentationFile)' == '' and '$(MSBuildProjectExtension)' != '.vbproj'">$(OutputPath)$(MSBuildProjectName).xml</DocumentationFile>
    <IsNETCoreAppSrc Condition="'$(IsNETCoreAppSrc)' == '' and
                                '$(IsSourceProject)' == 'true' and
                                $(NetCoreAppLibrary.Contains('$(AssemblyName);'))">true</IsNETCoreAppSrc>
    <IsNETCoreAppRef Condition="'$(IsNETCoreAppRef)' == '' and
                                '$(IsReferenceAssembly)' == 'true' and
                                $(NetCoreAppLibrary.Contains('$(AssemblyName);')) and
                                !$(NetCoreAppLibraryNoReference.Contains('$(AssemblyName);'))">true</IsNETCoreAppRef>
    <!-- By default, disable implicit framework references for NetCoreAppCurrent libraries. -->
    <DisableImplicitFrameworkReferences Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and
                                                   $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '$(NETCoreAppCurrentVersion)')) and
                                                   ('$(IsNETCoreAppRef)' == 'true' or '$(IsNETCoreAppSrc)' == 'true')">true</DisableImplicitFrameworkReferences>
    <!-- Disable implicit assembly references for .NETCoreApp refs and sources. -->
    <DisableImplicitAssemblyReferences Condition="'$(DisableImplicitAssemblyReferences)' == '' and
                                                  '$(DisableImplicitFrameworkReferences)' != 'true' and
                                                  '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and
                                                  ('$(IsReferenceAssembly)' == 'true' or '$(IsSourceProject)' == 'true')">true</DisableImplicitAssemblyReferences>
  </PropertyGroup>

  <Import Project="$(RepositoryEngineeringDir)versioning.targets" />

  <!-- Libraries-specific binplacing properties -->
  <PropertyGroup>
    <IsRuntimeAssembly Condition="'$(IsRuntimeAssembly)'=='' and '$(IsReferenceAssembly)' != 'true' and '$(BinPlaceRef)' != 'true' and '$(IsGeneratorProject)' != 'true' and '$(IsTestProject)' != 'true' and '$(IsTestSupportProject)' != 'true'">true</IsRuntimeAssembly>
    <!-- Try to determine if this is a simple library without a ref project.
         https://github.com/dotnet/runtime/issues/19584 is tracking cleaning this up -->
    <IsRuntimeAndReferenceAssembly Condition="'$(IsRuntimeAndReferenceAssembly)' == '' and '$(IsRuntimeAssembly)' == 'true' and Exists('$(LibrariesProjectRoot)$(MSBuildProjectName)') and !Exists('$(LibrariesProjectRoot)$(MSBuildProjectName)/ref') and !$(MSBuildProjectName.StartsWith('System.Private'))">true</IsRuntimeAndReferenceAssembly>

    <BinPlaceRef Condition="'$(BinPlaceRef)' == '' and ('$(IsReferenceAssembly)' == 'true' or '$(IsRuntimeAndReferenceAssembly)' == 'true')">true</BinPlaceRef>
    <BinPlaceRuntime Condition="'$(BinPlaceRuntime)' == '' and ('$(IsRuntimeAssembly)' == 'true' or '$(IsRuntimeAndReferenceAssembly)' == 'true')">true</BinPlaceRuntime>
    <BinPlaceForTargetVertical Condition="'$(BinPlaceForTargetVertical)' == ''">true</BinPlaceForTargetVertical>
  </PropertyGroup>

  <ItemGroup Condition="$(MSBuildProjectName.StartsWith('Microsoft.Extensions.'))">
    <!-- Microsoft.Extensions are not yet using the doc-file package -->
    <BinPlaceItem Include="$(DocumentationFile)" />
  </ItemGroup>

  <ItemGroup Condition="'@(BinPlaceTargetFrameworks)' == ''">
    <!-- binplace to directories for the target vertical -->
    <BinPlaceTargetFrameworks Include="$(NetCoreAppCurrent)-$(TargetOS)"
                              Condition="'$(BinPlaceForTargetVertical)' == 'true'">
      <NativePath>$(NetCoreAppCurrentRuntimePath)</NativePath>
      <RefPath>$(NetCoreAppCurrentRefPath)</RefPath>
      <RuntimePath>$(NetCoreAppCurrentRuntimePath)</RuntimePath>
    </BinPlaceTargetFrameworks>

    <!-- binplace to directories for packages -->
    <BinPlaceTargetFrameworks Include="$(NetCoreAppCurrent)-$(TargetOS)"
                              Condition="'$(BuildingNETCoreAppVertical)' == 'true'">
      <PackageFileNativePath Condition="'$(IsNETCoreAppSrc)' == 'true'">$(NETCoreAppPackageRuntimePath)</PackageFileNativePath>
      <PackageFileRefPath Condition="'$(IsNETCoreAppRef)' == 'true'">$(NETCoreAppPackageRefPath)</PackageFileRefPath>
      <PackageFileRuntimePath Condition="'$(IsNETCoreAppSrc)' == 'true'">$(NETCoreAppPackageRuntimePath)</PackageFileRuntimePath>
      <NativePath Condition="'$(IsNETCoreAppSrc)' == 'true'">$(NETCoreAppPackageRuntimePath)\..\runtime\$(TargetOS)-$(Configuration)-$(TargetArchitecture)</NativePath>
      <RefPath Condition="'$(IsNETCoreAppRef)' == 'true'">$(RefRootPath)microsoft.netcore.app\$(Configuration)</RefPath>
      <RuntimePath Condition="'$(IsNETCoreAppSrc)' == 'true'">$(NETCoreAppPackageRuntimePath)\..\runtime\$(TargetOS)-$(Configuration)-$(TargetArchitecture)</RuntimePath>
      <!-- enable trimming for any runtime project that's part of the shared framework and hasn't already set ILLinkTrimAssembly -->
      <SetProperties Condition="'$(IsNETCoreAppSrc)' == 'true' and
                                '$(BinPlaceRuntime)' == 'true' and
                                '$(ILLinkTrimAssembly)' == ''">ILLinkTrimAssembly=true</SetProperties>
    </BinPlaceTargetFrameworks>
    <BinPlaceTargetFrameworks Include="$(NetCoreAppCurrent)"
                              Condition="'$(IsAspNetCoreApp)' == 'true'">
      <RuntimePath>$(ASPNETCoreAppPackageRuntimePath)</RuntimePath>
      <RefPath>$(ASPNETCoreAppPackageRefPath)</RefPath>
    </BinPlaceTargetFrameworks>

    <!-- Setup the shared framework directory for testing -->
    <BinPlaceTargetFrameworks Include="$(NetCoreAppCurrent)-$(TargetOS)"
                              Condition="'$(BinPlaceTestSharedFramework)' == 'true'">
      <NativePath >$(NETCoreAppTestSharedFrameworkPath)</NativePath>
      <RuntimePath Condition="'$(IsNETCoreAppSrc)' == 'true'">$(NETCoreAppTestSharedFrameworkPath)</RuntimePath>
    </BinPlaceTargetFrameworks>

    <!-- Microsoft.NetCore.App.Ref and Microsoft.NetCore.App.Runtime targeting packs -->
    <BinPlaceTargetFrameworks Include="$(NetCoreAppCurrent)-$(TargetOS)">
      <NativePath>$(MicrosoftNetCoreAppRuntimePackNativeDir)</NativePath>
      <RefPath Condition="'$(IsNETCoreAppRef)' == 'true'">$(MicrosoftNetCoreAppRefPackRefDir)</RefPath>
      <RuntimePath Condition="'$(IsNETCoreAppSrc)' == 'true'">$(MicrosoftNetCoreAppRuntimePackRidLibTfmDir)</RuntimePath>
    </BinPlaceTargetFrameworks>

    <BinPlaceTargetFrameworks Include="@(AdditionalBinPlaceTargetFrameworks)" />
  </ItemGroup>

  <Import Project="$(RepositoryEngineeringDir)codeOptimization.targets" />
  <Import Project="$(RepositoryEngineeringDir)targetingpacks.targets" />
  <Import Project="$(RepositoryEngineeringDir)references.targets" />
  <Import Project="$(RepositoryEngineeringDir)resolveContract.targets" />
  <Import Project="$(RepositoryEngineeringDir)testing\tests.targets" Condition="'$(EnableTestSupport)' == 'true'" />
  <Import Project="$(RepositoryEngineeringDir)testing\linker\trimmingTests.targets" Condition="'$(IsTrimmingTestProject)' == 'true'" />
  <Import Project="$(RepositoryEngineeringDir)testing\runtimeConfiguration.targets" />
  <Import Project="$(RepositoryEngineeringDir)testing\runsettings.targets" Condition="'$(EnableRunSettingsSupport)' == 'true'" />
  <Import Project="$(RepositoryEngineeringDir)testing\coverage.targets" Condition="'$(EnableRunSettingsSupport)' == 'true' or '$(EnableCoverageSupport)' == 'true'" />
  <Import Project="$(RepositoryEngineeringDir)slngen.targets" />

  <Import Sdk="Microsoft.DotNet.Build.Tasks.TargetFramework.Sdk" Project="Sdk.targets" Condition="'$(UseTargetFrameworkSDK)' != 'false'"  />
  <Import Project="$(RepositoryEngineeringDir)restore\repoRestore.targets" Condition="'$(DisableProjectRestore)' == 'true'" />
  <Import Project="$(RepositoryEngineeringDir)illink.targets" Condition="'$(IsSourceProject)' == 'true'" />
  <Import Project="$(RepositoryEngineeringDir)AvoidRestoreCycleOnSelfReference.targets" Condition="'$(AvoidRestoreCycleOnSelfReference)' == 'true'" />

  <ItemGroup Condition="'$(IsSourceProject)' == 'true' or '$(IsReferenceAssembly)' == 'true' or '$(IsPartialFacadeAssembly)' == 'true'">
    <PackageReference Include="Microsoft.DotNet.Build.Tasks.Packaging" Version="$(MicrosoftDotNetBuildTasksPackagingVersion)" PrivateAssets="all" IsImplicitlyDefined="true" />
    <PackageReference Include="Microsoft.DotNet.ApiCompat" Condition="'$(DotNetBuildFromSource)' != 'true'" Version="$(MicrosoftDotNetApiCompatVersion)" PrivateAssets="all" IsImplicitlyDefined="true" />
    <PackageReference Include="Microsoft.DotNet.GenAPI" Condition="'$(DotNetBuildFromSource)' != 'true'" Version="$(MicrosoftDotNetGenApiVersion)" PrivateAssets="all" IsImplicitlyDefined="true" />
    <PackageReference Include="Microsoft.DotNet.GenFacades" Version="$(MicrosoftDotNetGenFacadesVersion)" PrivateAssets="all" IsImplicitlyDefined="true" />
  </ItemGroup>

  <Target Name="SetGenApiProperties"
          BeforeTargets="GenerateReferenceAssemblySource">
    <PropertyGroup>
      <_ExcludeAPIList>$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '..', 'ref', 'ReferenceSourceExcludeApi.txt'))</_ExcludeAPIList>
      <_ExcludeAttributesList>$(RepositoryEngineeringDir)DefaultGenApiDocIds.txt</_ExcludeAttributesList>
      <_LicenseHeaderTxtPath>$(RepositoryEngineeringDir)LicenseHeader.txt</_LicenseHeaderTxtPath>
      <GenAPITargetPath>$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '..', 'ref', '$(AssemblyName).cs'))</GenAPITargetPath>
      <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --exclude-attributes-list "$(_ExcludeAttributesList)"</GenAPIAdditionalParameters>
      <GenAPIAdditionalParameters Condition="Exists('$(_ExcludeAPIList)')">$(GenAPIAdditionalParameters) --exclude-api-list "$(_ExcludeAPIList)"</GenAPIAdditionalParameters>
      <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --header-file "$(_LicenseHeaderTxtPath)"</GenAPIAdditionalParameters>
      <GenAPIAdditionalParameters Condition="'$(LangVersion)' != ''">$(GenAPIAdditionalParameters) --lang-version "$(LangVersion)"</GenAPIAdditionalParameters>
      <GenAPIAdditionalParameters Condition="'%(ProjectReference.Identity)' == '$(CoreLibProject)'">$(GenAPIAdditionalParameters) --follow-type-forwards</GenAPIAdditionalParameters>
    </PropertyGroup>
  </Target>

  <Target Name="GenerateReferenceSource" DependsOnTargets="GenerateReferenceAssemblySource">
    <Message Text="This is a deprecated target. It will be replaced by GenerateReferenceAssemblySource in next infra rollout changes." Importance="high" />
  </Target>

  <Import Project="$(RepositoryEngineeringDir)outerBuild.targets" Condition="'$(IsCrossTargetingBuild)' == 'true'" />

  <!-- Import Packaging targets -->
  <Import Project="$(RepositoryEngineeringDir)packaging.targets" />

  <!-- Define this now until we can clean-up targets that depend on it in the packaging targets -->
  <Target Name="CreateVersionFileDuringBuild" />

  <!-- Define this target to override the workaround in arcade as we don't need it for our pkgprojs -->
  <Target Name="InitializeStandardNuspecProperties" />

  <Target Name="UpdateProjectReferencesWithAttributes" Condition="'@(ProjectReference)' != ''">
    <ItemGroup>
      <ProjectReference Condition="'%(Filename)' == 'System.Private.CoreLib'">
        <!-- Don't flow TargetFramework and Platform to use same inputs and outputs as the CoreLib's build as part of the runtime. -->
        <UndefineProperties>$(UndefineProperties);TargetFramework;Platform</UndefineProperties>
        <SetConfiguration Condition="'$(RuntimeFlavor)' == 'CoreCLR' and
                                     '$(Configuration)' != '$(CoreCLRConfiguration)'">Configuration=$(CoreCLRConfiguration)</SetConfiguration>
        <SetConfiguration Condition="'$(RuntimeFlavor)' == 'Mono' and
                                     '$(Configuration)' != '$(MonoConfiguration)'">Configuration=$(MonoConfiguration)</SetConfiguration>
        <Private>false</Private>
      </ProjectReference>
    </ItemGroup>
    <!-- Disable TargetArchitectureMismatch warning when we reference CoreLib which is platform specific. -->
    <PropertyGroup Condition="@(ProjectReference->AnyHaveMetadataValue('Identity', '$(CoreLibProject)'))">
      <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
    </PropertyGroup>
  </Target>

  <!-- Used for packaging -->
  <Target Name="IsNotNetCoreAppProject" Returns="@(IsNotNetCoreAppProjectResult)">
    <ItemGroup>
      <IsNotNetCoreAppProjectResult Include="$(MSBuildProjectName)"
                                    Version="$(PackageVersion)"
                                    Condition="!$(NetCoreAppLibrary.Contains('$(MSBuildProjectName);'))" />
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <!--
    Hack workaround to skip the GenerateCompiledExpressionsTempFile target in
    Microsoft.WorkflowBuildExtensions.targets target that always runs in VS
    -->
    <GenerateCompiledExpressionsTempFilePathForEditing />
  </PropertyGroup>

  <!-- Returns the assembly version of the project for consumption
       by the NuGet package generation -->
  <Target Name="GetAssemblyVersion"
          Returns="$(AssemblyVersion)"/>

  <!-- Returns the generated documentation file for consumption
       by the NuGet package generation -->
  <Target Name="GetDocumentationFile"
          Returns="$(DocumentationFile)"/>

  <!--
    Do not clean binplace assets in the ref targeting pack to avoid incremental build failures
    when the SDK tries to resolve the assets from the FrameworkList.
  -->
  <Target Name="RemoveTargetingPackIncrementalClean"
          Condition="'@(AdditionalCleanDirectories)' != ''"
          BeforeTargets="IncrementalCleanAdditionalDirectories;
                         CleanAdditionalDirectories">
    <ItemGroup>
      <AdditionalCleanDirectories Remove="@(AdditionalCleanDirectories)" Condition="'%(Identity)' == '$(MicrosoftNetCoreAppRefPackRefDir)'" />
    </ItemGroup>
  </Target>

  <!-- Adds Nullable annotation attributes to netstandard <= 2.0 builds -->
  <Choose>
    <When Condition="'$(Nullable)' != '' and ($(TargetFramework.StartsWith('netstandard1')) or '$(TargetFramework)' == 'netstandard2.0' or $(TargetFramework.StartsWith('netcoreapp2')) or '$(TargetFrameworkIdentifier)' == '.NETFramework')">
      <ItemGroup>
        <Compile Include="$(CoreLibSharedDir)System\Diagnostics\CodeAnalysis\NullableAttributes.cs" Link="System\Diagnostics\CodeAnalysis\NullableAttributes.cs" />
      </ItemGroup>
    </When>
  </Choose>

  <PropertyGroup>
    <ExcludeFromPackage Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', '$(NetCoreAppCurrent)')) and '$(ExcludeCurrentNetCoreAppFromPackage)' == 'true'">true</ExcludeFromPackage>
  </PropertyGroup>

  <PropertyGroup Condition="'$(IsCrossTargetingBuild)' != 'true' and '$(DotnetBuildFromSource)' == 'true' and '$(IsPackable)' == 'true' and !$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', '$(NetCoreAppCurrent)')) and '$(TargetFrameworkIdentifier)' != '.NETStandard' and '$(TargetFrameworkVersion)' != 'v2.0'">
    <IncludeBuildOutput>false</IncludeBuildOutput>
    <SuppressDependenciesWhenPacking>true</SuppressDependenciesWhenPacking>
  </PropertyGroup>

  <!-- If a project is downlevel from net5.0 but uses the platform support attributes, then we include the
       System.Runtime.Versioning*Platform* annotation attribute classes in the project as internal.

       If a project has specified assembly-level SupportedOSPlatforms or UnsupportedOSPlatforms,
       we can infer the need without having IncludePlatformAttributes set. -->
  <PropertyGroup>
    <IncludePlatformAttributes Condition="'$(IncludePlatformAttributes)' == '' and ('$(SupportedOSPlatforms)' != '' or '$(UnsupportedOSPlatforms)' != '')">true</IncludePlatformAttributes>
  </PropertyGroup>

  <ItemGroup Condition="'$(IncludePlatformAttributes)' == 'true' and !$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net5.0'))">
    <Compile Include="$(CoreLibSharedDir)System\Runtime\Versioning\PlatformAttributes.cs" Link="System\Runtime\Versioning\PlatformAttributes.cs" />
  </ItemGroup>

  <!-- Adds ObsoleteAttribute to projects that need to apply downlevel Obsoletions with DiagnosticId and UrlFormat -->
  <Choose>
    <When Condition="'$(IncludeInternalObsoleteAttribute)' == 'true' and !$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net5.0'))">
      <ItemGroup>
        <Compile Include="$(CoreLibSharedDir)System\ObsoleteAttribute.cs" Link="System\ObsoleteAttribute.cs" />
      </ItemGroup>
      <PropertyGroup>
        <!-- Suppress CS0436 to allow ObsoleteAttribute to be internally defined and used in netstandard -->
        <NoWarn>$(NoWarn);CS0436</NoWarn>
      </PropertyGroup>
    </When>
  </Choose>

  <PropertyGroup>
    <SkipLocalsInit Condition="'$(SkipLocalsInit)' == '' and '$(MSBuildProjectExtension)' == '.csproj' and '$(IsNETCoreAppSrc)' == 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', '$(NetCoreAppCurrent)')))">true</SkipLocalsInit>
  </PropertyGroup>

  <!--Instructs compiler not to emit .locals init, using SkipLocalsInitAttribute.-->
  <Choose>
    <When Condition="'$(SkipLocalsInit)' == 'true'">
      <PropertyGroup >
        <!-- This is needed to use the SkipLocalsInitAttribute. -->
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
      </PropertyGroup>

      <ItemGroup>
        <Compile Include="$(CommonPath)SkipLocalsInit.cs" Link="Common\SkipLocalsInit.cs" />
      </ItemGroup>
    </When>
  </Choose>

  <Target Name="LibIntellisenseDocs" Condition="'$(IncludeBuildOutput)' == 'true'">
   <ItemGroup>
      <TfmSpecificPackageFile Include="$(XmlDocFileRoot)1033\$(TargetName).xml"
                              Condition="Exists('$(XmlDocFileRoot)1033\$(TargetName).xml')"
                              PackagePath="lib/$(TargetFramework)" />
    </ItemGroup>
  </Target>

  <!-- TODO: Remove this after https://github.com/NuGet/NuGet.Client/pull/3980 is merged.-->
  <Target Name="RemoveXmlFilesFromBuildOutput" BeforeTargets="GenerateNuspec">
    <PropertyGroup>
      <AllowedOutputExtensionsInPackageBuildOutputFolder>.dll;.exe;.winmd;.json;.pri;</AllowedOutputExtensionsInPackageBuildOutputFolder> 
      <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>.pdb;.mdb;$(AllowedOutputExtensionsInPackageBuildOutputFolder)</AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>
    </PropertyGroup>
  </Target>

  <PropertyGroup>
    <BeforePack>IncludeAnalyzersInPackage;$(BeforePack)</BeforePack>
  </PropertyGroup>

  <ItemGroup>
    <!-- Ensure AnalyzerReference items are restored and built 
         The target framework of Analyzers has no relationship to that of the refrencing project, 
         so we don't apply TargetFramework filters nor do we pass in TargetFramework.
         When BuildProjectReferences=false we make sure to set BuildReference=false to make
         sure not to try to call GetTargetPath in the outerbuild of the analyzer project. -->
    <ProjectReference Include="@(AnalyzerReference)" SkipGetTargetFrameworkProperties="true" UndefineProperties="TargetFramework" ReferenceOutputAssembly="false" PrivateAssets="all" BuildReference="$(BuildProjectReferences)"  />
  </ItemGroup>

  <Target Name="IncludeAnalyzersInPackage" Condition="'@(AnalyzerReference)' != ''">
    <!-- Call a target in the analyzer project to get all the files it would normally place in a package.
         These will be returned as items with identity pointing to the built file, and PackagePath metadata
         set to their location in the package.  IsSymbol metadata will be set to distinguish symbols. -->
    <MSBuild Projects="@(AnalyzerReference)"
             Targets="GetAnalyzerPackFiles">
      <Output TaskParameter="TargetOutputs" ItemName="_AnalyzerFile" />
    </MSBuild>

    <ItemGroup>
      <Content Include="@(_AnalyzerFile)" Pack="True" Condition="!%(_AnalyzerFile.IsSymbol)" />
      <!-- Symbols don't honor PackagePath.  By default they are placed in lib/%(TargetFramework).           
           Pack does honor TargetPath and does Path.Combine("lib/%(TargetFramework)", "%(TargetPath)"),
           so a rooted path value for TargetPath will override lib. 
           https://github.com/NuGet/Home/issues/10860 -->
      <_TargetPathsToSymbols Include="@(_AnalyzerFile)" TargetPath="/%(_AnalyzerFile.PackagePath)" Condition="%(_AnalyzerFile.IsSymbol)" />
    </ItemGroup>
  </Target>

  <Target Name="GetAnalyzerPackFiles" DependsOnTargets="$(GenerateNuspecDependsOn)" Returns="@(_AnalyzerPackFile)">
    <PropertyGroup>
      <_analyzerPath>analyzers/dotnet</_analyzerPath>
      <_analyzerPath Condition="'$(AnalyzerLanguage)' != ''">$(_analyzerPath)/$(AnalyzerLanguage)</_analyzerPath>
    </PropertyGroup>
    <ItemGroup>
      <_AnalyzerPackFile Include="@(_BuildOutputInPackage)" IsSymbol="false" />
      <_AnalyzerPackFile Include="@(_TargetPathsToSymbols)" IsSymbol="true" />
      <_AnalyzerPackFile PackagePath="$(_analyzerPath)/%(TargetPath)" />
    </ItemGroup>
    <Error Condition="'%(_AnalyzerPackFile.TargetFramework)' != 'netstandard2.0'" 
           Text="Analyzers must only target netstandard2.0 since they run in the compiler which targets netstandard2.0. The following files were found to target '%(_AnalyzerPackFile.TargetFramework)': @(_AnalyzerPackFile)" />
  </Target>

</Project>
