// Â© Microsoft Corporation. All rights reserved.

//#define LOGGER_MESSAGE_DEFINE

using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace Microsoft.Extensions.Logging.Generators
{
    public partial class LoggerMessageGenerator
    {
        internal class Emitter
        {
            // The maximum arity of the LogValues-family of types. Beyond this number, parameters are just kepts in an array (which implies an allocation
            // for the array and boxing of all logging method arguments.
            private const int MaxLogValuesArity = 6;
#if !LOGGER_MESSAGE_DEFINE
            private const int MinLogValuesWithNameArray = 2;
#endif
            private const string InternalNamespace = "Microsoft.Extensions.Logging.Internal";

            private readonly string _generatedCodeAttribute =
                $"global::System.CodeDom.Compiler.GeneratedCodeAttribute(" +
                $"\"{typeof(Emitter).Assembly.GetName().Name}\", " +
                $"\"{typeof(Emitter).Assembly.GetName().Version}\")";
            private readonly Stack<StringBuilder> _builders = new ();
            private readonly bool _pascalCaseArguments;
            private readonly bool _emitDefaultMessage;
            
            public Emitter(bool pascalCaseArguments, bool emitDefaultMessage = true)
            {
                _pascalCaseArguments = pascalCaseArguments;
                _emitDefaultMessage = emitDefaultMessage;
            }

            public string Emit(IReadOnlyList<LoggerClass> logClasses, CancellationToken cancellationToken)
            {
                var sb = GetStringBuilder();
                try
                {
                    _ = sb.Append("// <auto-generated/>\n");
                    _ = sb.Append("#nullable enable\n");

                    foreach (var lc in logClasses)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        _ = sb.Append(GenType(lc));
                    }

                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private static string EscapeMessageString(string message)
            {
                return message
                    .Replace("\n", "\\n")
                    .Replace("\r", "\\r")
                    .Replace("\"", "\\\"");
            }

            private string GenType(LoggerClass lc)
            {
                var sb = GetStringBuilder();
                try
                {
                    foreach (var lm in lc.Methods)
                    {
                        AutoGenerateMessage(lm);
                    }

#if !LOGGER_MESSAGE_DEFINE
                    foreach (var lm in lc.Methods)
                    {
                        _ = sb.Append(GenNameArray(lm));
                    }

                    foreach (var lm in lc.Methods)
                    {
                        _ = sb.Append(GenFormatFunc(lm));
                    }
#endif
                    foreach (var lm in lc.Methods)
                    {
                        _ = sb.Append(GenLogMethod(lm));
                    }

                    if (string.IsNullOrWhiteSpace(lc.Namespace))
                    {
                        return $@"
                        partial class {lc.Name} {lc.Constraints}
                        {{
                            {sb}
                        }}
                        ";
                    }

                    return $@"
                    namespace {lc.Namespace}
                    {{
                        partial class {lc.Name} {lc.Constraints}
                        {{
                            {sb}
                        }}
                    }}
                    ";
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

#if !LOGGER_MESSAGE_DEFINE
            private string GenFormatFunc(LoggerMethod lm)
            {
                if (lm.Templates.Count == 0)
                {
                    return string.Empty;
                }

                var sb = GetStringBuilder();
                try
                {
                    string typeName;
                    if (lm.RegularParameters.Count == 1)
                    {
                        typeName = $"global::{InternalNamespace}.LogValues<{lm.RegularParameters[0].Type}>";
                    }
                    else if (lm.RegularParameters.Count > MaxLogValuesArity)
                    {
                        typeName = $"global::{InternalNamespace}.LogValuesN";
                    }
                    else
                    {
                        _ = sb.Append($"global::{InternalNamespace}.LogValues<");

                        foreach (var p in lm.RegularParameters)
                        {
                            if (p != lm.RegularParameters[0])
                            {
                                _ = sb.Append(", ");
                            }

                            _ = sb.Append(p.Type);
                        }

                        _ = sb.Append('>');
                        typeName = sb.ToString();
                        _ = sb.Clear();
                    }

                    foreach (var t in lm.Templates)
                    {
                        if (lm.RegularParameters.Count == 1)
                        {
                            if (lm.RegularParameters[0].IsEnumerable)
                            {
                                _ = sb.Append($"                                var {t} = global::{InternalNamespace}.ArgumentFormatter.Enumerate(_holder.Value);\n");
                            }
                            else
                            {
                                _ = sb.Append($"                                var {t} = _holder.Value;\n");
                            }
                        }
                        else
                        {
                            int index = 0;
                            foreach (var p in lm.RegularParameters)
                            {
                                if (p.Name == t)
                                {
                                    break;
                                }

                                index++;
                            }

                            // check for an index that's too big, this can happen in some cases of malformed input
                            if (index < lm.RegularParameters.Count)
                            {
                                if (lm.RegularParameters.Count > MaxLogValuesArity)
                                {
                                    if (lm.RegularParameters[index].IsEnumerable)
                                    {
                                        _ = sb.Append($"                                var {t} = "
                                            + $"global::{InternalNamespace}.ArgumentFormatter.Enumerate((global::System.Collections.IEnumerable ?)_holder[{index}].Value);\n");
                                    }
                                    else
                                    {
                                        _ = sb.Append($"                                var {t} = _holder[{index}].Value;\n");
                                    }
                                }
                                else
                                {
                                    if (lm.RegularParameters[index].IsEnumerable)
                                    {
                                        _ = sb.Append($"                                var {t} = "
                                            + $"global::{InternalNamespace}.ArgumentFormatter.Enumerate((global::System.Collections.IEnumerable ?)_holder.Value{index + 1});\n");
                                    }
                                    else
                                    {
                                        _ = sb.Append($"                                var {t} = _holder.Value{index + 1};\n");
                                    }
                                }
                            }
                        }
                    }

                    return $@"
                            [{_generatedCodeAttribute}]
                            private static readonly global::System.Func<{typeName}, global::System.Exception?, string> _format{lm.Name} = (_holder, _) =>
                            {{
{sb}
                                global::System.FormattableString fs = $""{EscapeMessageString(lm.Message!)}"";
                                return global::System.FormattableString.Invariant(fs);
                            }};
                ";
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string GenNameArray(LoggerMethod lm)
            {
                if (lm.RegularParameters.Count is < MinLogValuesWithNameArray or > MaxLogValuesArity)
                {
                    return string.Empty;
                }

                var sb = GetStringBuilder();
                try
                {
                    _ = sb.Append($"\n                            [{_generatedCodeAttribute}]\n");
                    _ = sb.Append($"                            private static readonly string[] _names{lm.Name} = new[] {{ ");
                    foreach (var p in lm.RegularParameters)
                    {
                        _ = sb.Append($"\"{NormalizeArgumentName(p.Name)}\", ");
                    }

                    _ = sb.Append("};\n");
                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }
#endif

            private string GenLogMethod(LoggerMethod lm)
            {
                string level = string.Empty;

                if (lm.Level == null)
                {
#if LOGGER_MESSAGE_DEFINE
                    level = "global::Microsoft.Extensions.Logging.LogLevel.Debug";
#else
                    foreach (var p in lm.AllParameters)
                    {
                        if (p.IsLogLevel)
                        {
                            level = p.Name;
                            break;
                        }
                    }
#endif
                }
                else
                {
#pragma warning disable S109 // Magic numbers should not be used
                    level = lm.Level switch
                    {
                        0 => "global::Microsoft.Extensions.Logging.LogLevel.Trace",
                        1 => "global::Microsoft.Extensions.Logging.LogLevel.Debug",
                        2 => "global::Microsoft.Extensions.Logging.LogLevel.Information",
                        3 => "global::Microsoft.Extensions.Logging.LogLevel.Warning",
                        4 => "global::Microsoft.Extensions.Logging.LogLevel.Error",
                        5 => "global::Microsoft.Extensions.Logging.LogLevel.Critical",
                        6 => "global::Microsoft.Extensions.Logging.LogLevel.None",
                        _ => $"(global::Microsoft.Extensions.Logging.LogLevel){lm.Level}",
                    };
#pragma warning restore S109 // Magic numbers should not be used
                }

                string eventName;
                if (string.IsNullOrWhiteSpace(lm.EventName))
                {
                    eventName = $"nameof({lm.Name})";
                }
                else
                {
                    eventName = $"\"{lm.EventName}\"";
                }

                string exceptionArg = "null";
                foreach (var p in lm.AllParameters)
                {
                    if (p.IsException)
                    {
                        exceptionArg = p.Name;
                        break;
                    }
                }

                string formatFunc;
                if (lm.Templates.Count != 0)
                {
                    formatFunc = $"_format{lm.Name}";
                }
                else
                {
                    formatFunc = $"(_, _) => \"{EscapeMessageString(lm.Message!)}\"";
                }

                string logger = lm.LoggerField;
                foreach (var p in lm.AllParameters)
                {
                    if (p.IsLogger)
                    {
                        logger = p.Name;
                        break;
                    }
                }

#if LOGGER_MESSAGE_DEFINE
                return $@"
                        [{_generatedCodeAttribute}]
                        private static readonly global::System.Action<global::Microsoft.Extensions.Logging.ILogger, {GenDefineTypes(lm, false)}global::System.Exception?> _{lm.Name}Callback =
                            global::Microsoft.Extensions.Logging.LoggerMessage.Define{GenDefineTypes(lm, true)}({level}, new global::Microsoft.Extensions.Logging.EventId({lm.EventId}, {eventName}), ""{EscapeMessageString(lm.Message!)}""); 

                        [{_generatedCodeAttribute}]
                        {lm.Modifiers} void {lm.Name}({(lm.IsExtensionMethod ? "this " : string.Empty)}{GenParameters(lm)})
                        {{
                            if ({logger}.IsEnabled({level}))
                            {{
                                _{lm.Name}Callback({logger}, {GenCallbackArguments(lm)}{exceptionArg});
                            }}
                        }}
                    ";

#else

                return $@"
                            [{_generatedCodeAttribute}]
                            {lm.Modifiers} void {lm.Name}({(lm.IsExtensionMethod ? "this " : string.Empty)}{GenParameters(lm)})
                            {{
                                if ({logger}.IsEnabled({level}))
                                {{
                                    {logger}.Log(
                                        {level},
                                        new global::Microsoft.Extensions.Logging.EventId({lm.EventId}, {eventName}),
                                        {GenHolder(lm, formatFunc)},
                                        {exceptionArg},
                                        {formatFunc});
                                }}
                            }}
                        ";
#endif
            }

            private void AutoGenerateMessage(LoggerMethod lm)
            {
                if (!string.IsNullOrEmpty(lm.Message))
                {
                    // already got a message
                    return;
                }

                if (!_emitDefaultMessage)
                {
                    lm.Message = string.Empty;
                    return;
                }

                if (lm.RegularParameters.Count == 0)
                {
                    lm.Message = "{}";
                    return;
                }

                var sb = GetStringBuilder();
                try
                {
                    _ = sb.Append("{{");
                    foreach (var p in lm.RegularParameters)
                    {
                        if (p != lm.RegularParameters[0])
                        {
                            _ = sb.Append(',');
                        }

                        _ = sb.Append($"\"{p.Name}\":\"{{{p.Name}}}\"");
                        _ = lm.Templates.Add(p.Name);
                    }

                    _ = sb.Append("}}");
                    lm.Message = sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

#if LOGGER_MESSAGE_DEFINE
            private string GenCallbackArguments(LoggerMethod lm)
            {
                var sb = GetStringBuilder();
                try
                {
                    int count = 0;
                    foreach (var p in lm.AllParameters)
                    {
                        if (p.IsRegular)
                        {
                            _ = sb.Append($"{p.Name}, ");

                            count++;
                            if (count == 6)
                            {
                                break;
                            }
                        }
                    }

                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string GenDefineTypes(LoggerMethod lm, bool brackets)
            {
                var sb = GetStringBuilder();
                try
                {
                    int count = 0;
                    foreach (var p in lm.AllParameters)
                    {
                        if (p.IsRegular)
                        {
                            if (count > 0)
                            {
                                _ = sb.Append(", ");
                            }

                            _ = sb.Append($"{p.Type}");

                            count++;
                            if (count == 6)
                            {
                                break;
                            }
                        }
                    }

                    var result = sb.ToString();
                    if (!string.IsNullOrEmpty(result))
                    {
                        if (brackets)
                        {
                            result = "<" + result + ">";
                        }
                        else
                        {
                            result += ", ";
                        }
                    }

                    return result;
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }
#endif

            private string GenParameters(LoggerMethod lm)
            {
                var sb = GetStringBuilder();
                try
                {
                    foreach (var p in lm.AllParameters)
                    {
                        if (p != lm.AllParameters[0])
                        {
                            _ = sb.Append(", ");
                        }

                        _ = sb.Append($"{p.Type} {p.Name}");
                    }

                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string GenHolder(LoggerMethod lm, string formatFunc)
            {
                var originalFormat = EscapeMessageString(lm.Message!);

                if (lm.RegularParameters.Count == 0)
                {
                    return $"new global::{InternalNamespace}.LogValues({formatFunc}, \"{originalFormat}\")";
                }

                if (lm.RegularParameters.Count == 1)
                {
                    return $"new global::{InternalNamespace}.LogValues<{lm.RegularParameters[0].Type}>" +
                            $"({formatFunc}, \"{originalFormat}\", \"{NormalizeArgumentName(lm.RegularParameters[0].Name)}\", {lm.RegularParameters[0].Name})";
                }

                var sb = GetStringBuilder();
                try
                {
                    if (lm.RegularParameters.Count > MaxLogValuesArity)
                    {
                        _ = sb.Append($"new global::{InternalNamespace}.LogValuesN({formatFunc}, \"{originalFormat}\", new global::System.Collections.Generic.KeyValuePair<string, object?>[] {{ ");
                        foreach (var p in lm.RegularParameters)
                        {
                            _ = sb.Append($"new (\"{NormalizeArgumentName(p.Name)}\", {p.Name}), ");
                        }

                        _ = sb.Append("})");
                    }
                    else
                    {
                        foreach (var p in lm.RegularParameters)
                        {
                            if (p != lm.RegularParameters[0])
                            {
                                _ = sb.Append(", ");
                            }

                            _ = sb.Append(p.Type);
                        }

                        var tp = sb.ToString();

                        _ = sb.Clear();
                        _ = sb.Append($"new global::{InternalNamespace}.LogValues<{tp}>({formatFunc}, \"{originalFormat}\", _names{lm.Name}, ");
                        foreach (var p in lm.RegularParameters)
                        {
                            if (p != lm.RegularParameters[0])
                            {
                                _ = sb.Append(", ");
                            }

                            _ = sb.Append(p.Name);
                        }

                        _ = sb.Append(')');
                    }

                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string NormalizeArgumentName(string name)
            {
                if (_pascalCaseArguments)
                {
                    var sb = GetStringBuilder();
                    try
                    {
                        _ = sb.Append(char.ToUpperInvariant(name[0]));
                        _ = sb.Append(name, 1, name.Length - 1);
                        name = sb.ToString();
                    }
                    finally
                    {
                        ReturnStringBuilder(sb);
                    }
                }

                return name;
            }

            // our own cheezy object pool since we can't use the .NET core version (since this code runs in legacy .NET framework)
            private StringBuilder GetStringBuilder()
            {
                const int DefaultStringBuilderCapacity = 1024;

                if (_builders.Count == 0)
                {
                    return new StringBuilder(DefaultStringBuilderCapacity);
                }

                var sb = _builders.Pop();
                _ = sb.Clear();
                return sb;
            }

            private void ReturnStringBuilder(StringBuilder sb)
            {
                _builders.Push(sb);
            }
        }
    }
}
