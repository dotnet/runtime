// Â© Microsoft Corporation. All rights reserved.

using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace Microsoft.Extensions.Logging.Generators
{
    public partial class LoggerMessageGenerator
    {
        internal class Emitter
        {
            // The maximum arity of the LogStateHolder-family of types. Beyond this number, parameters are just kepts in an array (which implies an allocation
            // for the array and boxing of all logging method arguments.
            private const int MaxStateHolderArity = 6;
            private const int MinStateHolderWithNameArray = 2;
            private const string StateHolderNamespace = "Microsoft.Extensions.Logging.Internal";

            private readonly Stack<StringBuilder> _builders = new ();
            private readonly bool _pascalCaseArguments;

            public Emitter(bool pascalCaseArguments)
            {
                _pascalCaseArguments = pascalCaseArguments;
            }

            public string Emit(IReadOnlyList<LoggerClass> logClasses, CancellationToken cancellationToken)
            {
                var sb = GetStringBuilder();
                try
                {
                    _ = sb.Append("// <auto-generated/>\n");
                    _ = sb.Append("#nullable enable\n");

                    foreach (var lc in logClasses)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        _ = sb.Append(GenType(lc));
                    }

                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private static string EscapeMessageString(string message)
            {
                return message
                    .Replace("\n", "\\n")
                    .Replace("\r", "\\r")
                    .Replace("\"", "\\\"");
            }

            private string GenType(LoggerClass lc)
            {
                var sb = GetStringBuilder();
                try
                {
                    foreach (var lm in lc.Methods)
                    {
                        _ = sb.Append(GenNameArray(lm));
                    }

                    foreach (var lm in lc.Methods)
                    {
                        _ = sb.Append(GenFormatFunc(lm));
                    }

                    foreach (var lm in lc.Methods)
                    {
                        _ = sb.Append(GenLogMethod(lm));
                    }

                    if (string.IsNullOrWhiteSpace(lc.Namespace))
                    {
                        return $@"
                        partial class {lc.Name} {lc.Constraints}
                        {{
                            {sb}
                        }}
                        ";
                    }

                    return $@"
                    namespace {lc.Namespace}
                    {{
                        partial class {lc.Name} {lc.Constraints}
                        {{
                            {sb}
                        }}
                    }}
                    ";
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string GenFormatFunc(LoggerMethod lm)
            {
                if (!lm.MessageHasTemplates)
                {
                    return string.Empty;
                }

                var sb = GetStringBuilder();
                try
                {
                    string typeName;
                    if (lm.Parameters.Count == 1)
                    {
                        typeName = $"global::{StateHolderNamespace}.LogStateHolder<{lm.Parameters[0].Type}>";
                        _ = sb.Append($"                                var {lm.Parameters[0].Name} = _holder.Value;\n");
                    }
                    else if (lm.Parameters.Count > MaxStateHolderArity)
                    {
                        typeName = $"global::{StateHolderNamespace}.LogStateHolderN";

                        var index = 0;
                        foreach (var p in lm.Parameters)
                        {
                            _ = sb.Append($"                                var {p.Name} = _holder[{index++}].Value;\n");
                        }
                    }
                    else
                    {
                        _ = sb.Append($"global::{StateHolderNamespace}.LogStateHolder<");

                        foreach (var p in lm.Parameters)
                        {
                            if (p != lm.Parameters[0])
                            {
                                _ = sb.Append(", ");
                            }

                            _ = sb.Append(p.Type);
                        }

                        _ = sb.Append('>');
                        typeName = sb.ToString();

                        _ = sb.Clear();
                        var index = 1;
                        foreach (var p in lm.Parameters)
                        {
                            _ = sb.Append($"                                var {p.Name} = _holder.Value{index++};\n");
                        }
                    }

                    return $@"
                            [global::System.Runtime.CompilerServices.CompilerGenerated]
                            private static readonly global::System.Func<{typeName}, global::System.Exception?, string> _format{lm.Name} = (_holder, _) =>
                            {{
{sb}
                                return $""{EscapeMessageString(lm.Message)}"";
                            }};
                ";
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string GenNameArray(LoggerMethod lm)
            {
                if (lm.Parameters.Count is < MinStateHolderWithNameArray or > MaxStateHolderArity)
                {
                    return string.Empty;
                }

                var sb = GetStringBuilder();
                try
                {
                    _ = sb.Append("\n                            [global::System.Runtime.CompilerServices.CompilerGenerated]\n");
                    _ = sb.Append($"                            private static readonly string[] _names{lm.Name} = new[] {{ ");
                    foreach (var p in lm.Parameters)
                    {
                        _ = sb.Append($"\"{NormalizeArgumentName(p.Name)}\", ");
                    }

                    _ = sb.Append("};\n");
                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string GenLogMethod(LoggerMethod lm)
            {
                string level = string.Empty;

                if (lm.Level == null)
                {
                    foreach (var p in lm.Parameters)
                    {
                        if (p.IsLogLevel)
                        {
                            level = p.Name;
                            break;
                        }
                    }
                }
                else
                {
#pragma warning disable S109 // Magic numbers should not be used
                    level = lm.Level switch
                    {
                        0 => "global::Microsoft.Extensions.Logging.LogLevel.Trace",
                        1 => "global::Microsoft.Extensions.Logging.LogLevel.Debug",
                        2 => "global::Microsoft.Extensions.Logging.LogLevel.Information",
                        3 => "global::Microsoft.Extensions.Logging.LogLevel.Warning",
                        4 => "global::Microsoft.Extensions.Logging.LogLevel.Error",
                        5 => "global::Microsoft.Extensions.Logging.LogLevel.Critical",
                        6 => "global::Microsoft.Extensions.Logging.LogLevel.None",
                        _ => $"(global::Microsoft.Extensions.Logging.LogLevel){lm.Level}",
                    };
#pragma warning restore S109 // Magic numbers should not be used
                }

                string eventName;
                if (string.IsNullOrWhiteSpace(lm.EventName))
                {
                    eventName = $"nameof({lm.Name})";
                }
                else
                {
                    eventName = $"\"{lm.EventName}\"";
                }

                string exceptionArg = "null";
                foreach (var p in lm.Parameters)
                {
                    if (p.IsException)
                    {
                        exceptionArg = p.Name;
                        break;
                    }
                }

                string formatFunc;
                if (lm.MessageHasTemplates)
                {
                    formatFunc = $"_format{lm.Name}";
                }
                else
                {
                    formatFunc = $"(_, _) => \"{EscapeMessageString(lm.Message)}\"";
                }

#pragma warning disable S103 // Lines should not be too long
                return $@"
                            [global::System.Runtime.CompilerServices.CompilerGenerated]
                            {lm.Modifiers} void {lm.Name}({(lm.IsExtensionMethod ? "this " : string.Empty)}{lm.LoggerType} {lm.LoggerName}{(lm.Parameters.Count > 0 ? ", " : string.Empty)}{GenParameters(lm)})
                            {{
                                if ({lm.LoggerName}.IsEnabled({level}))
                                {{
                                    {lm.LoggerName}.Log(
                                        {level},
                                        new global::Microsoft.Extensions.Logging.EventId({lm.EventId}, {eventName}),
                                        {GenHolder(lm, formatFunc)},
                                        {exceptionArg},
                                        {formatFunc});
                                }}
                            }}
                        ";
#pragma warning restore S103 // Lines should not be too long
            }

            private string GenParameters(LoggerMethod lm)
            {
                var sb = GetStringBuilder();
                try
                {
                    foreach (var p in lm.Parameters)
                    {
                        if (p != lm.Parameters[0])
                        {
                            _ = sb.Append(", ");
                        }

                        _ = sb.Append($"{p.Type} {p.Name}");
                    }

                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string GenHolder(LoggerMethod lm, string formatFunc)
            {
                if (lm.Parameters.Count == 0)
                {
                    return $"new global::{StateHolderNamespace}.LogStateHolder({formatFunc})";
                }

                if (lm.Parameters.Count == 1)
                {
                    return $"new global::{StateHolderNamespace}.LogStateHolder<{lm.Parameters[0].Type}>" +
                        $"({formatFunc}, \"{NormalizeArgumentName(lm.Parameters[0].Name)}\", {lm.Parameters[0].Name})";
                }

                var sb = GetStringBuilder();
                try
                {
                    if (lm.Parameters.Count > MaxStateHolderArity)
                    {
                        _ = sb.Append($"new global::{StateHolderNamespace}.LogStateHolderN({formatFunc}, new global::System.Collections.Generic.KeyValuePair<string, object?>[] {{ ");
                        foreach (var p in lm.Parameters)
                        {
                            _ = sb.Append($"new (\"{NormalizeArgumentName(p.Name)}\", {p.Name}), ");
                        }

                        _ = sb.Append("})");
                    }
                    else
                    {
                        foreach (var p in lm.Parameters)
                        {
                            if (p != lm.Parameters[0])
                            {
                                _ = sb.Append(", ");
                            }

                            _ = sb.Append(p.Type);
                        }

                        var tp = sb.ToString();

                        _ = sb.Clear();
                        _ = sb.Append($"new global::{StateHolderNamespace}.LogStateHolder<{tp}>({formatFunc}, _names{lm.Name}, ");
                        foreach (var p in lm.Parameters)
                        {
                            if (p != lm.Parameters[0])
                            {
                                _ = sb.Append(", ");
                            }

                            _ = sb.Append(p.Name);
                        }

                        _ = sb.Append(')');
                    }

                    return sb.ToString();
                }
                finally
                {
                    ReturnStringBuilder(sb);
                }
            }

            private string NormalizeArgumentName(string name)
            {
                if (_pascalCaseArguments)
                {
                    var sb = GetStringBuilder();
                    try
                    {
                        _ = sb.Append(char.ToUpperInvariant(name[0]));
                        _ = sb.Append(name, 1, name.Length - 1);
                        name = sb.ToString();
                    }
                    finally
                    {
                        ReturnStringBuilder(sb);
                    }
                }

                return name;
            }

            // our own cheezy object pool since we can't use the .NET core version (since this code runs in legacy .NET framework)
            private StringBuilder GetStringBuilder()
            {
                const int DefaultStringBuilderCapacity = 1024;

                if (_builders.Count == 0)
                {
                    return new StringBuilder(DefaultStringBuilderCapacity);
                }

                var sb = _builders.Pop();
                _ = sb.Clear();
                return sb;
            }

            private void ReturnStringBuilder(StringBuilder sb)
            {
                _builders.Push(sb);
            }
        }
    }
}
