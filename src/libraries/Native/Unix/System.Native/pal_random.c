// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include "pal_config.h"
#include "pal_random.h"
/*

Generate random bytes. The generated bytes are not cryptographically strong.

*/

#if HAVE_ARC4RANDOM_BUF

#define MAY_NEED_XOR_WITH_LRAND 0
static bool PlatformRandomFillBuffer(uint8_t *buffer, size_t bufferLength)
{
    arc4random_buf(buffer, bufferLength);
    return true;
}

#elif HAVE_SYS_GETRANDOM

#include <sys/syscall.h>

#define MAY_NEED_XOR_WITH_LRAND 1
static bool PlatformRandomFillBuffer(uint8_t *buffer, size_t bufferLength)
{
    static bool sSyscallNotSupported;

    if (sSyscallNotSupported)
    {
        return false;
    }

    for (;;)
    {
        long bytesFilled = syscall(SYS_getrandom, buffer, bufferLength, 1 /* GRND_NONBLOCK */);

        if (bytesFilled == -1)
        {
            switch (errno)
            {
                case EINTR:
                    continue;
                case ENOSYS:
                    sSyscallNotSupported = true;
                    // Fallthrough
                default:
                    return false;
            }
        }

        if (bytesFilled == (long)bufferLength)
        {
            return true;
        }

        if (bytesFilled < (long)bufferLength)
        {
            bufferLength -= (size_t)bytesFilled;
            buffer += bytesFilled;
        }
    }
}

#else // !HAVE_ARC4RANDOM_BUF && !HAVE_SYS_GETRANDOM

#define MAY_NEED_XOR_WITH_LRAND 1
static bool PlatformRandomFillBuffer(uint8_t *buffer, size_t bufferLength)
{
    (void)buffer;
    (void)bufferLength;

    return false;
}

#endif

static bool PlatformRandomFillBufferUrandomFallback(uint8_t *buffer, size_t bufferLength)
{
    static int sUrandomFd = -1;
    static bool sDevUrandomIsUnusable;

    if (sDevUrandomIsUnusable)
    {
        return false;
    }

    if (sUrandomFd < 0)
    {
        int fd;

        do
        {
#if HAVE_O_CLOEXEC
            fd = open("/dev/urandom", O_RDONLY | O_CLOEXEC);
#else
            fd = open("/dev/urandom", O_RDONLY);
            fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
        }
        while ((fd < 0) && (errno == EINTR));

        if (fd >= 0)
        {
            int expected = -1;

            if (!__atomic_compare_exchange_n(&sUrandomFd, &expected, fd, false, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST))
            {
                // Another thread set sUrandomFd
                close(fd);
            }
        }
        else
        {
            switch (errno) {
            case EACCES:
            case EPERM:
            case ENOENT:
                sDevUrandomIsUnusable = true;
                // Fallthrough
            default:
                // Assume other errors here are transient (e.g. too many open files), so
                // try opening urandom next time we need more data.
                return false;
            }
        }
    }

    do
    {
        ssize_t n = read(sUrandomFd, buffer, bufferLength);

        if (n == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }

            assert(false && "read from /dev/urandom has failed");
            return false;
        }

        buffer += n;
        bufferLength -= (size_t)n;
    }
    while (bufferLength);

    return true;
}

static bool TryAllRandomFillBufferMethods(uint8_t *buffer, size_t bufferLength)
{
    assert(buffer != NULL);

    return PlatformRandomFillBuffer(buffer, bufferLength) ||
           PlatformRandomFillBufferUrandomFallback(buffer, bufferLength);
}

static bool NeedsXorWithLrand(uint8_t *buffer, size_t bufferLength)
{
    // In some circumstances, data filled by
    // TryAllRandomFillBufferMethods() will be either all zeroed out or
    // will have all bits set.  This happens in some rare occasions in
    // some systems (e.g.  resuming from suspend).  Try to detect this
    // situation here and XOR every byte with something obtained from
    // srand48().

    if (bufferLength >= sizeof(uint32_t))
    {
        uint32_t first32bits;

        memcpy(&first32bits, buffer, sizeof(first32bits));

        return (first32bits == 0u) || (first32bits == 0xffffffffu);
    }

    return !memcmp(buffer, (const uint8_t[]) {0x00, 0x00, 0x00}, bufferLength) ||
           !memcmp(buffer, (const uint8_t[]) {0xff, 0xff, 0xff}, bufferLength);
}

void SystemNative_GetNonCryptographicallySecureRandomBytes(uint8_t *buffer, int32_t bufferLengthAsInt)
{
    size_t bufferLength = (size_t)bufferLengthAsInt;
    bool filledBuffers = TryAllRandomFillBufferMethods(buffer, bufferLength);

    if (MAY_NEED_XOR_WITH_LRAND && (!filledBuffers || NeedsXorWithLrand(buffer, bufferLength)))
    {
        static bool sInitializedMRand;

        if (!sInitializedMRand)
        {
            srand48(time(NULL));
            sInitializedMRand = true;
        }

        if (!filledBuffers)
        {
            // Zero out buffer first to avoid UB when reading back from buffer
            memset(buffer, 0, bufferLength);
        }

        while (bufferLength >= sizeof(uint32_t))
        {
            uint32_t asInteger;

            memcpy(&asInteger, buffer, sizeof(asInteger));
            asInteger ^= (uint32_t)lrand48();
            memcpy(buffer, &asInteger, sizeof(asInteger));

            buffer += sizeof(asInteger);
            bufferLength -= sizeof(asInteger);
        }

        if (bufferLength)
        {
            long int lastLrandRound = lrand48();

            switch (bufferLength)
            {
                case 3:
                    buffer[2] ^= lastLrandRound & 0xff;
                    lastLrandRound >>= 8;
                    // Fallthrough
                case 2:
                    buffer[1] ^= lastLrandRound & 0xff;
                    lastLrandRound >>= 8;
                    // Fallthrough
                case 1:
                    buffer[0] ^= lastLrandRound & 0xff;
                    break;
                default:
                    assert(bufferLength < sizeof(uint32_t));
            }

            lastLrandRound = 0;
            // Ensure dead store elimination does not yank the previous assignment
            __asm__ __volatile__("" ::"g"(lastLrandRound) : "memory");
        }
    }
}
