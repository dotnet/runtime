// Do not edit this file manually it is auto-generated during the build based on the .resx file for this project.
namespace System
{
    internal static partial class SR
    {
#pragma warning disable 0414
        private const string s_resourcesName = "System.Threading.Tasks.Dataflow.resources"; // assembly Name + .resources
#pragma warning restore 0414

#if !DEBUGRESOURCES
        internal static string ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity {
              get { return SR.GetResourceString("ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity", null); }
        }
        internal static string ArgumentOutOfRange_GenericPositive {
              get { return SR.GetResourceString("ArgumentOutOfRange_GenericPositive", null); }
        }
        internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 {
              get { return SR.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1", null); }
        }
        internal static string Argument_BoundedCapacityNotSupported {
              get { return SR.GetResourceString("Argument_BoundedCapacityNotSupported", null); }
        }
        internal static string Argument_CantConsumeFromANullSource {
              get { return SR.GetResourceString("Argument_CantConsumeFromANullSource", null); }
        }
        internal static string Argument_InvalidMessageHeader {
              get { return SR.GetResourceString("Argument_InvalidMessageHeader", null); }
        }
        internal static string Argument_InvalidMessageId {
              get { return SR.GetResourceString("Argument_InvalidMessageId", null); }
        }
        internal static string Argument_InvalidSourceForFilteredLink {
              get { return SR.GetResourceString("Argument_InvalidSourceForFilteredLink", null); }
        }
        internal static string Argument_NonGreedyNotSupported {
              get { return SR.GetResourceString("Argument_NonGreedyNotSupported", null); }
        }
        internal static string event_DataflowBlockCompleted {
              get { return SR.GetResourceString("event_DataflowBlockCompleted", null); }
        }
        internal static string event_DataflowBlockCreated {
              get { return SR.GetResourceString("event_DataflowBlockCreated", null); }
        }
        internal static string event_DataflowBlockLinking {
              get { return SR.GetResourceString("event_DataflowBlockLinking", null); }
        }
        internal static string event_DataflowBlockUnlinking {
              get { return SR.GetResourceString("event_DataflowBlockUnlinking", null); }
        }
        internal static string event_TaskLaunchedForMessageHandling {
              get { return SR.GetResourceString("event_TaskLaunchedForMessageHandling", null); }
        }
        internal static string InvalidOperation_DataNotAvailableForReceive {
              get { return SR.GetResourceString("InvalidOperation_DataNotAvailableForReceive", null); }
        }
        internal static string InvalidOperation_FailedToConsumeReservedMessage {
              get { return SR.GetResourceString("InvalidOperation_FailedToConsumeReservedMessage", null); }
        }
        internal static string InvalidOperation_MessageNotReservedByTarget {
              get { return SR.GetResourceString("InvalidOperation_MessageNotReservedByTarget", null); }
        }
        internal static string NotSupported_MemberNotNeeded {
              get { return SR.GetResourceString("NotSupported_MemberNotNeeded", null); }
        }
        internal static string ConcurrentCollection_SyncRoot_NotSupported {
              get { return SR.GetResourceString("ConcurrentCollection_SyncRoot_NotSupported", null); }
        }
#else
        internal static string ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity {
              get { return SR.GetResourceString("ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity", @"Number must be no greater than the value specified in BoundedCapacity."); }
        }
        internal static string ArgumentOutOfRange_GenericPositive {
              get { return SR.GetResourceString("ArgumentOutOfRange_GenericPositive", @"Number must be positive."); }
        }
        internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 {
              get { return SR.GetResourceString("ArgumentOutOfRange_NeedNonNegOrNegative1", @"Number must be either non-negative and less than or equal to Int32.MaxValue or -1"); }
        }
        internal static string Argument_BoundedCapacityNotSupported {
              get { return SR.GetResourceString("Argument_BoundedCapacityNotSupported", @"BoundedCapacity must be Unbounded or -1 for this dataflow block."); }
        }
        internal static string Argument_CantConsumeFromANullSource {
              get { return SR.GetResourceString("Argument_CantConsumeFromANullSource", @"The argument must be false if no source from which to consume is specified."); }
        }
        internal static string Argument_InvalidMessageHeader {
              get { return SR.GetResourceString("Argument_InvalidMessageHeader", @"The DataflowMessageHeader instance does not represent a valid message header."); }
        }
        internal static string Argument_InvalidMessageId {
              get { return SR.GetResourceString("Argument_InvalidMessageId", @"To construct a DataflowMessageHeader instance, either pass a non-zero value or use the parameterless constructor."); }
        }
        internal static string Argument_InvalidSourceForFilteredLink {
              get { return SR.GetResourceString("Argument_InvalidSourceForFilteredLink", @"This block must only be used with the source from which it was created."); }
        }
        internal static string Argument_NonGreedyNotSupported {
              get { return SR.GetResourceString("Argument_NonGreedyNotSupported", @"Greedy must be true for this dataflow block."); }
        }
        internal static string event_DataflowBlockCompleted {
              get { return SR.GetResourceString("event_DataflowBlockCompleted", @"Block {0} completed as {1}. {2}"); }
        }
        internal static string event_DataflowBlockCreated {
              get { return SR.GetResourceString("event_DataflowBlockCreated", @"Block of type {0} instantiated with Id {1}."); }
        }
        internal static string event_DataflowBlockLinking {
              get { return SR.GetResourceString("event_DataflowBlockLinking", @"Source {0} linked to target {1}."); }
        }
        internal static string event_DataflowBlockUnlinking {
              get { return SR.GetResourceString("event_DataflowBlockUnlinking", @"Source {0} unlinked from target {1}."); }
        }
        internal static string event_TaskLaunchedForMessageHandling {
              get { return SR.GetResourceString("event_TaskLaunchedForMessageHandling", @"{1} task launched from block {0} with {2} message(s) pending."); }
        }
        internal static string InvalidOperation_DataNotAvailableForReceive {
              get { return SR.GetResourceString("InvalidOperation_DataNotAvailableForReceive", @"The source completed without providing data to receive."); }
        }
        internal static string InvalidOperation_FailedToConsumeReservedMessage {
              get { return SR.GetResourceString("InvalidOperation_FailedToConsumeReservedMessage", @"The target block failed to consume a message it had successfully reserved."); }
        }
        internal static string InvalidOperation_MessageNotReservedByTarget {
              get { return SR.GetResourceString("InvalidOperation_MessageNotReservedByTarget", @"The target does not have the message reserved."); }
        }
        internal static string NotSupported_MemberNotNeeded {
              get { return SR.GetResourceString("NotSupported_MemberNotNeeded", @"This member is not supported on this dataflow block. The block is intended for a specific purpose that does not utilize this member."); }
        }
        internal static string ConcurrentCollection_SyncRoot_NotSupported {
              get { return SR.GetResourceString("ConcurrentCollection_SyncRoot_NotSupported", @"The SyncRoot property may not be used for the synchronization of concurrent collections."); }
        }

#endif
    }
}
