// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.Diagnostics.Tracing
{
    /// <summary>
    /// NativeRuntimeEventSource is an EventSource that represents the ETW/EventPipe events emitted by the native runtime.
    /// Most of NativeRuntimeEventSource is auto-generated by scripts/genRuntimeEventSources.py based on the contents of the
    /// Microsoft-Windows-DotNETRuntime provider and will throw a NotImplementedException without hand-written overloads of the Events.
    /// To have a runtime event be fired from the managed code, you need to add a managed definition for that event
    /// and QCall into the native runtime that invoke the appropriate native sinks for the platform (i.e. ETW, EventPipe, LTTng).
    /// To see some examples of this, refer to NativeRuntimeEventSource.PortableThreadPool.cs.
    /// Then, modify genRuntimeEventSources.py to skip over the event so that it doesn't generate the dummy method.
    /// </summary>
    [EventSource(Guid = "E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4", Name = EventSourceName)]
    [EventSourceAutoGenerate]
    internal sealed partial class NativeRuntimeEventSource : EventSource
    {
        internal const string EventSourceName = "Microsoft-Windows-DotNETRuntime";
        public static readonly NativeRuntimeEventSource Log = new NativeRuntimeEventSource();

        // Parameterized constructor to block initialization and ensure the EventSourceGenerator is creating the default constructor
        // as you can't make a constructor partial.
        private NativeRuntimeEventSource(int _) { }


        // On Mono, we don't have these keywords defined from the genRuntimeEventSources.py, so we need to manually define them here.
#if MONO
        public class Keywords
        {
            public const EventKeywords GCKeyword = (EventKeywords)0x1;
            public const EventKeywords GCHandleKeyword = (EventKeywords)0x2;
            public const EventKeywords AssemblyLoaderKeyword = (EventKeywords)0x4;
            public const EventKeywords LoaderKeyword = (EventKeywords)0x8;
            public const EventKeywords JitKeyword = (EventKeywords)0x10;
            public const EventKeywords NGenKeyword = (EventKeywords)0x20;
            public const EventKeywords StartEnumerationKeyword = (EventKeywords)0x40;
            public const EventKeywords EndEnumerationKeyword = (EventKeywords)0x80;
            public const EventKeywords SecurityKeyword = (EventKeywords)0x400;
            public const EventKeywords AppDomainResourceManagementKeyword = (EventKeywords)0x800;
            public const EventKeywords JitTracingKeyword = (EventKeywords)0x1000;
            public const EventKeywords InteropKeyword = (EventKeywords)0x2000;
            public const EventKeywords ContentionKeyword = (EventKeywords)0x4000;
            public const EventKeywords ExceptionKeyword = (EventKeywords)0x8000;
            public const EventKeywords ThreadingKeyword = (EventKeywords)0x10000;
            public const EventKeywords JittedMethodILToNativeMapKeyword = (EventKeywords)0x20000;
            public const EventKeywords OverrideAndSuppressNGenEventsKeyword = (EventKeywords)0x40000;
            public const EventKeywords TypeKeyword = (EventKeywords)0x80000;
            public const EventKeywords GCHeapDumpKeyword = (EventKeywords)0x100000;
            public const EventKeywords GCSampledObjectAllocationHighKeyword = (EventKeywords)0x200000;
            public const EventKeywords GCHeapSurvivalAndMovementKeyword = (EventKeywords)0x400000;
            public const EventKeywords GCHeapCollectKeyword = (EventKeywords)0x800000;
            public const EventKeywords GCHeapAndTypeNamesKeyword = (EventKeywords)0x1000000;
            public const EventKeywords GCSampledObjectAllocationLowKeyword = (EventKeywords)0x2000000;
            public const EventKeywords PerfTrackKeyword = (EventKeywords)0x20000000;
            public const EventKeywords StackKeyword = (EventKeywords)0x40000000;
            public const EventKeywords ThreadTransferKeyword = (EventKeywords)0x80000000;
            public const EventKeywords DebuggerKeyword = (EventKeywords)0x100000000;
            public const EventKeywords MonitoringKeyword = (EventKeywords)0x200000000;
            public const EventKeywords CodeSymbolsKeyword = (EventKeywords)0x400000000;
            public const EventKeywords EventSourceKeyword = (EventKeywords)0x800000000;
            public const EventKeywords CompilationKeyword = (EventKeywords)0x1000000000;
            public const EventKeywords CompilationDiagnosticKeyword = (EventKeywords)0x2000000000;
            public const EventKeywords MethodDiagnosticKeyword = (EventKeywords)0x4000000000;
            public const EventKeywords TypeDiagnosticKeyword = (EventKeywords)0x8000000000;
            public const EventKeywords JitInstrumentationDataKeyword = (EventKeywords)0x10000000000;
        }
#endif // MONO

        /// <summary>
        /// Dispatch a single event with the specified event ID and payload.
        /// </summary>
        /// <param name="eventID">The eventID corresponding to the event as defined in the auto-generated portion of the NativeRuntimeEventSource class.</param>
        /// <param name="osThreadID">The thread ID of the operating system thread.</param>
        /// <param name="timeStamp">The current timestamp.</param>
        /// <param name="activityId">The ID of the current activity.</param>
        /// <param name="childActivityId">The ID of the current child activity.</param>
        /// <param name="payload">A span pointing to the data payload for the event.</param>
        [NonEvent]
        internal unsafe void ProcessEvent(uint eventID, uint osThreadID, DateTime timeStamp, Guid activityId, Guid childActivityId, ReadOnlySpan<byte> payload)
        {
            // A simple fix to avoid dependencies brought by this method if event source is disabled via a feature switch.
            // Should be reconsidered when https://github.com/dotnet/runtime/issues/43657 is done.
            if (!IsSupported)
            {
                return;
            }

            // Make sure the eventID is valid.
            if (eventID >= m_eventData!.Length)
            {
                return;
            }

            // Decode the payload.
            object[] decodedPayloadFields = EventPipePayloadDecoder.DecodePayload(ref m_eventData[eventID], payload);
            WriteToAllListeners(
                eventId: (int)eventID,
                osThreadId: &osThreadID,
                timeStamp: &timeStamp,
                activityID: &activityId,
                childActivityID: &childActivityId,
                args: decodedPayloadFields);
        }

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolWorkerThreadStart(uint ActiveWorkerThreadCount, uint RetiredWorkerThreadCount, ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolWorkerThreadStop(uint ActiveWorkerThreadCount, uint RetiredWorkerThreadCount, ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolWorkerThreadWait(uint ActiveWorkerThreadCount, uint RetiredWorkerThreadCount, ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolWorkerThreadAdjustmentSample(double Throughput, ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolWorkerThreadAdjustmentAdjustment(double AverageThroughput, uint NewWorkerThreadCount, NativeRuntimeEventSource.ThreadAdjustmentReasonMap Reason, ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolWorkerThreadAdjustmentStats(
            double Duration,
            double Throughput,
            double ThreadPoolWorkerThreadWait,
            double ThroughputWave,
            double ThroughputErrorEstimate,
            double AverageThroughputErrorEstimate,
            double ThroughputRatio,
            double Confidence,
            double NewControlSetting,
            ushort NewThreadWaveMagnitude,
            ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolIOEnqueue(
            IntPtr NativeOverlapped,
            IntPtr Overlapped,
            bool MultiDequeues,
            ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolIODequeue(
            IntPtr NativeOverlapped,
            IntPtr Overlapped,
            ushort ClrInstanceID);

        [NonEvent]
        [DllImport(RuntimeHelpers.QCall)]
        internal static extern void LogThreadPoolWorkingThreadCount(
            uint Count,
            ushort ClrInstanceID
        );
    }
}
