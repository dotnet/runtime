// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Buffers.Binary;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis.CSharp;

// NOTE: The logic in this file is largely a copy of logic in RegexCompiler, emitting C# instead of MSIL.
// Most changes made to this file should be kept in sync, so far as bug fixes and relevant optimizations
// are concerned.

namespace System.Text.RegularExpressions.Generator
{
    public partial class RegexGenerator
    {
        /// <summary>Code for a [GeneratedCode] attribute to put on the top-level generated members.</summary>
        private static readonly string s_generatedCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{typeof(RegexGenerator).Assembly.GetName().Name}\", \"{typeof(RegexGenerator).Assembly.GetName().Version}\")]";
        /// <summary>Header comments and usings to include at the top of every generated file.</summary>
        private static readonly string[] s_headers = new string[]
        {
            "// <auto-generated/>",
            "#nullable enable",
            "#pragma warning disable CS0162 // Unreachable code",
            "#pragma warning disable CS0164 // Unreferenced label",
            "#pragma warning disable CS0168 // Variable declared but never used",
            "#pragma warning disable CS0219 // Variable assigned but never used",
            "",
        };

        /// <summary>Generates the code for one regular expression class.</summary>
        private static string EmitRegexType(RegexType regexClass)
        {
            var sb = new StringBuilder(1024);
            var writer = new IndentedTextWriter(new StringWriter(sb));

            // Emit the namespace
            if (!string.IsNullOrWhiteSpace(regexClass.Namespace))
            {
                writer.WriteLine($"namespace {regexClass.Namespace}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            // Emit containing types
            RegexType parent = regexClass.ParentClass;
            var parentClasses = new Stack<string>();
            while (parent != null)
            {
                parentClasses.Push($"partial {parent.Keyword} {parent.Name} {parent.Constraints}");
                parent = parent.ParentClass;
            }
            while (parentClasses.Count != 0)
            {
                writer.WriteLine($"{parentClasses.Pop()}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            // Emit the direct parent type
            writer.WriteLine($"partial {regexClass.Keyword} {regexClass.Name} {regexClass.Constraints}");
            writer.WriteLine("{");
            writer.Indent++;

            // Generate a name to describe the regex instance.  This includes the method name
            // the user provided and a non-randomized (for determinism) hash of it to try to make
            // the name that much harder to predict.
            string generatedName = $"GeneratedRegex_{regexClass.Method.MethodName}_";
            generatedName += ComputeStringHash(generatedName).ToString("X");

            // Generate the regex type
            EmitRegexMethod(writer, regexClass.Method, generatedName);

            while (writer.Indent != 0)
            {
                writer.Indent--;
                writer.WriteLine("}");
            }

            writer.Flush();
            return sb.ToString();

            // FNV-1a hash function.  The actual algorithm used doesn't matter; just something simple
            // to create a pseudo-random value based on input text.
            static uint ComputeStringHash(string s)
            {
                uint hashCode = 2166136261;
                foreach (char c in s)
                {
                    hashCode = (c ^ hashCode) * 16777619;
                }
                return hashCode;
            }
        }

        /// <summary>Gets whether a given regular expression method is supported by the code generator.</summary>
        private static bool SupportsCustomCodeGeneration(RegexMethod rm)
        {
            const RegexOptions SupportedOptions =
                RegexOptions.IgnoreCase |
                RegexOptions.Multiline |
                RegexOptions.ExplicitCapture |
                RegexOptions.Compiled |
                RegexOptions.Singleline |
                RegexOptions.IgnorePatternWhitespace |
                RegexOptions.RightToLeft |
                RegexOptions.ECMAScript |
                RegexOptions.CultureInvariant;

            // If we see an option we're not aware of (but that was allowed through), don't emit custom regex code.
            return (rm.Options & ~(int)SupportedOptions) == 0;
        }

        /// <summary>Generates the code for a regular expression method.</summary>
        private static void EmitRegexMethod(IndentedTextWriter writer, RegexMethod rm, string id)
        {
            string patternExpression = Literal(rm.Pattern);
            string optionsExpression = $"(global::System.Text.RegularExpressions.RegexOptions)({rm.Options})";
            string timeoutExpression = rm.MatchTimeout == Timeout.Infinite ?
                "global::System.Threading.Timeout.InfiniteTimeSpan" :
                $"global::System.TimeSpan.FromMilliseconds({rm.MatchTimeout.Value.ToString(CultureInfo.InvariantCulture)})";

            writer.WriteLine(s_generatedCodeAttribute);
            writer.WriteLine($"{rm.Modifiers} global::System.Text.RegularExpressions.Regex {rm.MethodName}() => {id}.Instance;");
            writer.WriteLine();
            writer.WriteLine(s_generatedCodeAttribute);
            writer.WriteLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
            writer.WriteLine($"{(writer.Indent != 0 ? "private" : "internal")} sealed class {id} : global::System.Text.RegularExpressions.Regex");
            writer.WriteLine("{");
            writer.Write("    public static global::System.Text.RegularExpressions.Regex Instance { get; } = ");

            // If we can't support custom generation for this regex, spit out a Regex constructor call.
            if (!SupportsCustomCodeGeneration(rm))
            {
                writer.WriteLine($"new global::System.Text.RegularExpressions.Regex({patternExpression}, {optionsExpression}, {timeoutExpression});");
                writer.WriteLine("}");
                return;
            }

            writer.WriteLine($"new {id}();");
            writer.WriteLine();
            writer.WriteLine($"    private {id}()");
            writer.WriteLine($"    {{");
            writer.WriteLine($"        pattern = {patternExpression};");
            writer.WriteLine($"        roptions = {optionsExpression};");
            writer.WriteLine($"        internalMatchTimeout = {timeoutExpression};");
            writer.WriteLine($"        factory = new RunnerFactory();");
            if (rm.Code.Caps is not null)
            {
                writer.Write("        Caps = new global::System.Collections.Hashtable {");
                AppendHashtableContents(writer, rm.Code.Caps);
                writer.WriteLine(" };");
            }
            if (rm.Tree.CapNames is not null)
            {
                writer.Write("        CapNames = new global::System.Collections.Hashtable {");
                AppendHashtableContents(writer, rm.Tree.CapNames);
                writer.WriteLine(" };");
            }
            if (rm.Tree.CapsList is not null)
            {
                writer.Write("        capslist = new string[] {");
                string separator = "";
                foreach (string s in rm.Tree.CapsList)
                {
                    writer.Write(separator);
                    writer.Write(Literal(s));
                    separator = ", ";
                }
                writer.WriteLine(" };");
            }
            writer.WriteLine($"        capsize = {rm.Code.CapSize};");
            writer.WriteLine($"        base.InitializeReferences();");
            writer.WriteLine($"    }}");
            writer.WriteLine("    ");
            writer.WriteLine($"    private sealed class RunnerFactory : global::System.Text.RegularExpressions.RegexRunnerFactory");
            writer.WriteLine($"    {{");
            writer.WriteLine($"        protected override global::System.Text.RegularExpressions.RegexRunner CreateInstance() => new Runner();");
            writer.WriteLine();
            writer.WriteLine($"        private sealed class Runner : global::System.Text.RegularExpressions.RegexRunner");
            writer.WriteLine($"        {{");

            // Main implementation methods
            writer.WriteLine($"            protected override void InitTrackCount() => base.runtrackcount = {rm.Code.TrackCount};");
            writer.WriteLine();
            writer.WriteLine($"            protected override bool FindFirstChar()");
            writer.WriteLine($"            {{");
            writer.Indent += 4;
            EmitFindFirstChar(writer, rm, id);
            writer.Indent -= 4;
            writer.WriteLine($"            }}");
            writer.WriteLine();
            writer.WriteLine($"            protected override void Go()");
            writer.WriteLine($"            {{");
            writer.Indent += 4;
            EmitGo(writer, rm, id);
            writer.Indent -= 4;
            writer.WriteLine($"            }}");
            writer.WriteLine($"        }}");
            writer.WriteLine($"    }}");
            writer.WriteLine("}");

            static void AppendHashtableContents(IndentedTextWriter writer, Hashtable ht)
            {
                IDictionaryEnumerator en = ht.GetEnumerator();
                string separator = "";
                while (en.MoveNext())
                {
                    writer.Write(separator);
                    separator = ", ";

                    writer.Write(" { ");
                    if (en.Key is int key)
                    {
                        writer.Write(key);
                    }
                    else
                    {
                        writer.Write($"\"{en.Key}\"");
                    }
                    writer.Write($", {en.Value} }} ");
                }
            }
        }

        /// <summary>Emits the body of the FindFirstChar override.</summary>
        private static void EmitFindFirstChar(IndentedTextWriter writer, RegexMethod rm, string id)
        {
            RegexOptions options = (RegexOptions)rm.Options;
            var code = rm.Code;
            var lcc = code.LeadingCharClasses;
            bool rtl = code.RightToLeft;
            bool hasTextInfo = false;
            bool textInfoEmitted = false;

            // Emit locals initialization
            writer.WriteLine("string runtext = base.runtext!;");
            writer.WriteLine("int runtextpos = base.runtextpos;");
            writer.WriteLine("int runtextend = base.runtextend;");
            if (rtl)
            {
                writer.WriteLine("int runtextbeg = base.runtextbeg;");
            }
            writer.WriteLine("int ch;");
            writer.WriteLine();

            // Generate length check.  If the input isn't long enough to possibly match, fail quickly.
            // It's rare for min required length to be 0, so we don't bother special-casing the check,
            // especially since we want the "return false" code regardless.
            writer.WriteLine("// Minimum required length check");
            int minRequiredLength = rm.Tree.MinRequiredLength;
            string minRequiredLengthOffset = rm.Tree.MinRequiredLength > 0 ? $" - {rm.Tree.MinRequiredLength}" : "";
            Debug.Assert(minRequiredLength >= 0);
            using (EmitBlock(writer, !rtl ?
                $"if (runtextpos <= runtextend{minRequiredLengthOffset})" :
                $"if (runtextpos{minRequiredLengthOffset} >= runtextbeg)"))
            {
                EmitAnchorAndLeadingChecks();
            }
            writer.WriteLine();

            writer.WriteLine("// No match");
            writer.WriteLine("ReturnFalse:");
            writer.WriteLine(!rm.Code.RightToLeft ? "base.runtextpos = runtextend;" : "base.runtextpos = runtextbeg;");
            writer.WriteLine("return false;");

            void EmitAnchorAndLeadingChecks()
            {
                // Generate anchor checks.
                if ((code.LeadingAnchor & (RegexPrefixAnalyzer.Beginning | RegexPrefixAnalyzer.Start | RegexPrefixAnalyzer.EndZ | RegexPrefixAnalyzer.End | RegexPrefixAnalyzer.Bol)) != 0)
                {
                    // TODO: RegexInterpreter also factors in a Boyer-Moore prefix check in places Compiled just returns true.
                    // Determine if we should do so here and in Compiled as well, and potentially update RegexInterpreter.
                    // Interpreted and Compiled also differ in various places as to whether they update positions, as do LTR vs RTL. Determine why.
                    switch (code.LeadingAnchor)
                    {
                        case RegexPrefixAnalyzer.Beginning:
                            writer.WriteLine("// Beginning \\A anchor");
                            if (!rtl)
                            {
                                using (EmitBlock(writer, "if (runtextpos > runtextbeg)"))
                                {
                                    writer.WriteLine("goto ReturnFalse;");
                                }
                                writer.WriteLine("return true;");
                            }
                            else
                            {
                                // TODO: RegexOptions.Compiled doesn't ever return false here. Instead it updates the position. Why?
                                using (EmitBlock(writer, "if (runtextpos > runtextbeg)"))
                                {
                                    writer.WriteLine("base.runtextpos = runtextbeg;");
                                }
                                writer.WriteLine("return true;");
                            }
                            writer.WriteLine();
                            return;

                        case RegexPrefixAnalyzer.Start:
                            writer.WriteLine("// Start \\G anchor");
                            if (!rtl)
                            {
                                using (EmitBlock(writer, "if (runtextpos > runtextstart)"))
                                {
                                    writer.WriteLine("goto ReturnFalse;");
                                }
                                writer.WriteLine("return true;");
                            }
                            else
                            {
                                // TODO: RegexOptions.Compiled doesn't ever return false here. Instead it updates the position. Why?
                                using (EmitBlock(writer, "if (runtextpos < runtextstart)"))
                                {
                                    writer.WriteLine("goto ReturnFalse;");
                                }
                                writer.WriteLine("return true;");
                            }
                            writer.WriteLine();
                            return;

                        case RegexPrefixAnalyzer.EndZ:
                            // TODO: Why are the LTR and RTL cases inconsistent here with RegexOptions.Compiled?
                            writer.WriteLine("// End \\Z anchor");
                            if (!rtl)
                            {
                                using (EmitBlock(writer, "if (runtextpos < runtextend - 1)"))
                                {
                                    writer.WriteLine("base.runtextpos = runtextend - 1;");
                                }
                                writer.WriteLine("return true;");
                            }
                            else
                            {
                                // TODO: This differs subtly between interpreted and compiled. Why?
                                using (EmitBlock(writer, "if (runtextpos < runtextend - 1 || (runtextpos == runtextend - 1 && runtext[runtextpos] != '\\n'))"))
                                {
                                    writer.WriteLine("goto ReturnFalse;");
                                }
                                writer.WriteLine("return true;");
                            }
                            writer.WriteLine();
                            return;

                        case RegexPrefixAnalyzer.End when minRequiredLength == 0: // if it's > 0, we already output a more stringent check
                            writer.WriteLine("// End \\z anchor");
                            if (!rtl)
                            {
                                using (EmitBlock(writer, "if (runtextpos < runtextend)"))
                                {
                                    writer.WriteLine("base.runtextpos = runtextend;");
                                }
                                writer.WriteLine("return true;");
                            }
                            else
                            {
                                using (EmitBlock(writer, "if (runtextpos < runtextend)"))
                                {
                                    writer.WriteLine("goto ReturnFalse;");
                                }
                                writer.WriteLine("return true;");
                            }
                            writer.WriteLine();
                            return;

                        case RegexPrefixAnalyzer.Bol when !rtl: // Don't bother optimizing for the niche case of RegexOptions.RightToLeft | RegexOptions.Multiline
                            // Optimize the handling of a Beginning-Of-Line (BOL) anchor.  BOL is special, in that unlike
                            // other anchors like Beginning, there are potentially multiple places a BOL can match.  So unlike
                            // the other anchors, which all skip all subsequent processing if found, with BOL we just use it
                            // to boost our position to the next line, and then continue normally with any Boyer-Moore or
                            // leading char class searches.
                            writer.WriteLine("// Beginning-of-line anchor");
                            using (EmitBlock(writer, "if (runtextpos > runtextbeg && runtext[runtextpos - 1] != '\\n')"))
                            {
                                writer.WriteLine("int newlinePos = runtext.IndexOf('\\n', runtextpos);");
                                using (EmitBlock(writer, "if (newlinePos == -1 || newlinePos + 1 > runtextend)"))
                                {
                                    writer.WriteLine("goto ReturnFalse;");
                                }
                                writer.WriteLine("runtextpos = newlinePos + 1;");
                            }
                            writer.WriteLine();
                            break;
                    }
                }

                if (code.BoyerMoorePrefix is RegexBoyerMoore rbm && rbm.NegativeUnicode is null)
                {
                    // Compiled Boyer-Moore string matching
                    writer.WriteLine("// Boyer-Moore prefix matching");

                    EmitTextInfoIfRequired(writer, ref textInfoEmitted, ref hasTextInfo, rm);

                    int beforefirst;
                    int last;
                    if (!rtl)
                    {
                        //limitLocal = "runtextend";
                        beforefirst = -1;
                        last = rbm.Pattern.Length - 1;
                    }
                    else
                    {
                        //limitLocal = "runtextbeg";
                        beforefirst = rbm.Pattern.Length;
                        last = 0;
                    }

                    int chLast = rbm.Pattern[last];

                    writer.WriteLine(!rtl ?
                        $"runtextpos += {rbm.Pattern.Length - 1};" :
                        $"runtextpos -= {rbm.Pattern.Length};");
                    writer.WriteLine("int offset = 0;");

                    writer.WriteLine("goto Start;");
                    writer.WriteLine();
                    writer.WriteLine("DefaultAdvance:");
                    writer.WriteLine($"offset = {(!rtl ? rbm.Pattern.Length : -rbm.Pattern.Length)};");
                    writer.WriteLine();
                    writer.WriteLine("Advance:");
                    writer.WriteLine("runtextpos += offset;");
                    writer.WriteLine();
                    writer.WriteLine("Start:");
                    using (EmitBlock(writer, !rtl ? "if (runtextpos >= runtextend)" : "if (runtextpos < runtextbeg)"))
                    {
                        writer.WriteLine("goto ReturnFalse;");
                    }
                    writer.WriteLine();
                    writer.WriteLine($"ch = {ToLowerIfNeeded(hasTextInfo, options, "runtext[runtextpos]", rbm.CaseInsensitive)};");

                    using (EmitBlock(writer, $"if (ch == {Literal((char)chLast)})"))
                    {
                        writer.WriteLine("goto PartialMatch;");
                    }
                    writer.WriteLine($"ch -= {rbm.LowASCII};");
                    using (EmitBlock(writer, $"if ((uint)ch > {rbm.HighASCII - rbm.LowASCII})"))
                    {
                        writer.WriteLine("goto DefaultAdvance;");
                    }

                    writer.Write("offset = ");
                    int negativeRange = rbm.HighASCII - rbm.LowASCII + 1;
                    if (negativeRange > 1)
                    {
                        // Create a string to store the lookup table we use to find the offset.
                        // Store the offsets into the string.  RightToLeft has negative offsets, so to support it with chars (unsigned), we negate
                        // the values to be stored in the string, and then at run time after looking up the offset in the string, negate it again.
                        Debug.Assert(rbm.Pattern.Length <= char.MaxValue, "RegexBoyerMoore should have limited the size allowed.");
                        Span<char> span = new char[negativeRange];
                        for (int i = 0; i < span.Length; i++)
                        {
                            int offset = rbm.NegativeASCII[i + rbm.LowASCII];
                            if (offset == beforefirst)
                            {
                                offset = rbm.Pattern.Length;
                            }
                            else if (rtl)
                            {
                                offset = -offset;
                            }
                            Debug.Assert(offset >= 0 && offset <= char.MaxValue);
                            span[i] = (char)offset;
                        }

                        if (rtl)
                        {
                            writer.Write('-');
                        }
                        writer.WriteLine($"{Literal(span.ToString())}[ch];");
                    }
                    else
                    {
                        Debug.Assert(negativeRange == 1);
                        int offset = rbm.NegativeASCII[rbm.LowASCII];
                        if (offset == beforefirst)
                        {
                            offset = rtl ? -rbm.Pattern.Length : rbm.Pattern.Length;
                        }
                        writer.WriteLine($"{offset.ToString(CultureInfo.InvariantCulture)};");
                    }
                    writer.WriteLine("goto Advance;");
                    writer.WriteLine();

                    writer.WriteLine("PartialMatch:");
                    writer.WriteLine("int test = runtextpos;");

                    int nextAvailableLabelId = 0;
                    int prevLabelOffset = int.MaxValue;
                    int prevLabel = 0;
                    for (int i = rbm.Pattern.Length - 2; i >= 0; i--)
                    {
                        int charIndex = !rtl ? i : rbm.Pattern.Length - 1 - i;

                        string nextCharExpr = ToLowerIfNeeded(hasTextInfo, options, (!rtl ? "runtext[--test]" : "runtext[++test]"), rbm.CaseInsensitive && RegexCharClass.ParticipatesInCaseConversion(rbm.Pattern[charIndex]));
                        string matchExpr = Literal(rbm.Pattern[charIndex]);
                        if (prevLabelOffset == rbm.Positive[charIndex])
                        {
                            using (EmitBlock(writer, $"if ({nextCharExpr} != {matchExpr})"))
                            {
                                writer.WriteLine($"goto L{prevLabel};");
                            }
                        }
                        else
                        {
                            int lNext = nextAvailableLabelId++;
                            using (EmitBlock(writer, $"if ({nextCharExpr} == {matchExpr})"))
                            {
                                writer.WriteLine($"goto L{lNext};");
                            }
                            prevLabel = nextAvailableLabelId++;
                            prevLabelOffset = rbm.Positive[charIndex];
                            writer.WriteLine();

                            writer.WriteLine($"L{prevLabel}:");
                            writer.WriteLine($"offset = {prevLabelOffset.ToString(CultureInfo.InvariantCulture)};");
                            writer.WriteLine("goto Advance;");
                            writer.WriteLine();

                            writer.WriteLine($"L{lNext}:");
                        }
                    }

                    writer.WriteLine();
                    writer.WriteLine(!rtl ?
                        "base.runtextpos = test;" :
                        "base.runtextpos = test + 1;");
                    writer.WriteLine("return true;");
                }
                else if (code.LeadingCharClasses is null)
                {
                    writer.WriteLine("return true;");
                }
                else if (rtl)
                {
                    EmitTextInfoIfRequired(writer, ref textInfoEmitted, ref hasTextInfo, rm);

                    Debug.Assert(lcc.Length == 1, "Only the FirstChars and not MultiFirstChars computation is supported for RightToLeft");
                    string set = lcc[0].CharClass;
                    if (RegexCharClass.IsSingleton(set))
                    {
                        char ch = RegexCharClass.SingletonChar(set);
                        using (EmitBlock(writer, "for (int i = runtextpos - 1; i >= runtextbeg; i--)"))
                        {
                            using (EmitBlock(writer, $"if (runtext[i] == {ToLowerIfNeeded(hasTextInfo, options, Literal(ch), lcc[0].CaseInsensitive)})"))
                            {
                                writer.WriteLine("base.runtextpos = i + 1;");
                                writer.WriteLine("return true;");
                            }
                        }
                    }
                    else
                    {
                        using (EmitBlock(writer, "for (int i = runtextpos - 1; i >= runtextbeg; i--)"))
                        {
                            using (EmitBlock(writer, $"if ({MatchCharacterClass(hasTextInfo, options, "runtext[i]", set, lcc[0].CaseInsensitive)})"))
                            {
                                writer.WriteLine("runtextpos = i + 1;");
                                writer.WriteLine("return true;");
                            }
                        }
                    }
                }
                else
                {
                    Debug.Assert(lcc is not null && lcc.Length > 0);

                    // If minRequiredLength > 0, we already output a more stringent check.  In the rare case
                    // where we were unable to get an accurate enough min required length to ensure it's larger
                    // than the prefixes we calculated, we also need to ensure we have enough space for those,
                    // as they also represent a min required length.
                    if (minRequiredLength < lcc.Length)
                    {
                        writer.WriteLine($"// Validate at least {lcc.Length} characters are available to match");
                        string endExpr = lcc.Length > 1 ? $"runtextend - {lcc.Length - 1}" : "runtextend";
                        using (EmitBlock(writer, $"if (runtextpos >= {endExpr})"))
                        {
                            writer.WriteLine("goto ReturnFalse;");
                        }
                        writer.WriteLine();
                    }

                    writer.WriteLine("global::System.ReadOnlySpan<char> span = global::System.MemoryExtensions.AsSpan(runtext, runtextpos, runtextend - runtextpos);");

                    // If we can use IndexOf{Any}, try to accelerate the skip loop via vectorization to match the first prefix.
                    // We can use it if this is a case-sensitive class with a small number of characters in the class.
                    Span<char> setChars = stackalloc char[3]; // up to 3 characters handled by IndexOf{Any} below
                    int setCharsCount = 0, charClassIndex = 0;
                    bool canUseIndexOf =
                        !lcc[0].CaseInsensitive &&
                        (setCharsCount = RegexCharClass.GetSetChars(lcc[0].CharClass, setChars)) > 0 &&
                        !RegexCharClass.IsNegated(lcc[0].CharClass);
                    bool needLoop = !canUseIndexOf || lcc.Length > 1;

                    FinishEmitScope loopBlock = default;
                    if (needLoop)
                    {
                        EmitTextInfoIfRequired(writer, ref textInfoEmitted, ref hasTextInfo, rm);
                        writer.WriteLine();
                        string upperBound = lcc.Length > 1 ? $"span.Length - {lcc.Length - 1}" : "span.Length";
                        loopBlock = EmitBlock(writer, $"for (int i = 0; i < {upperBound}; i++)");
                    }

                    if (canUseIndexOf)
                    {
                        charClassIndex = 1;

                        string span = needLoop ? "span.Slice(i)" : "span";
                        string indexOf = setCharsCount switch
                        {
                            1 => $"global::System.MemoryExtensions.IndexOf({span}, {Literal(setChars[0])})",
                            2 => $"global::System.MemoryExtensions.IndexOfAny({span}, {Literal(setChars[0])}, {Literal(setChars[1])})",
                            _ => $"global::System.MemoryExtensions.IndexOfAny({span}, {Literal(setChars[0])}, {Literal(setChars[1])}, {Literal(setChars[2])})",
                        };

                        if (needLoop)
                        {
                            writer.WriteLine($"int indexOfPos = {indexOf};");
                            using (EmitBlock(writer, "if (indexOfPos < 0)"))
                            {
                                writer.WriteLine("goto ReturnFalse;");
                            }
                            writer.WriteLine("i += indexOfPos;");
                            writer.WriteLine();

                            if (lcc.Length > 1)
                            {
                                using (EmitBlock(writer, $"if (i >= span.Length - {lcc.Length - 1})"))
                                {
                                    writer.WriteLine("goto ReturnFalse;");
                                }
                            }
                        }
                        else
                        {
                            writer.WriteLine($"int i = {indexOf};");
                            using (EmitBlock(writer, "if (i < 0)"))
                            {
                                writer.WriteLine("goto ReturnFalse;");
                            }
                        }
                        writer.WriteLine();
                    }

                    Debug.Assert(charClassIndex == 0 || charClassIndex == 1);
                    if (charClassIndex < lcc.Length)
                    {
                        // if (!CharInClass(textSpan[i + charClassIndex], prefix[0], "...") ||
                        //     ...)
                        // {
                        //     continue;
                        // }
                        Debug.Assert(needLoop);
                        int start = charClassIndex;
                        for (; charClassIndex < lcc.Length; charClassIndex++)
                        {
                            string spanIndex = charClassIndex > 0 ? $"span[i + {charClassIndex}]" : "span[i]";
                            string charInClassExpr = MatchCharacterClass(hasTextInfo, options, spanIndex, lcc[charClassIndex].CharClass, lcc[charClassIndex].CaseInsensitive);

                            if (charClassIndex == start)
                            {
                                writer.Write($"if (!{charInClassExpr}");
                            }
                            else
                            {
                                writer.WriteLine(" ||");
                                writer.Write($"    !{charInClassExpr}");
                            }
                        }
                        writer.WriteLine(")");
                        using (EmitBlock(writer, null))
                        {
                            writer.WriteLine("continue;");
                        }
                        writer.WriteLine();
                    }

                    writer.WriteLine("base.runtextpos = runtextpos + i;");
                    writer.WriteLine("return true;");

                    loopBlock.Dispose();
                }
            }
        }

        /// <summary>Emits the body of the Go override.</summary>
        private static void EmitGo(IndentedTextWriter writer, RegexMethod rm, string id)
        {
            Debug.Assert(rm.Tree.Root.Type == RegexNode.Capture);
            if (RegexNode.NodeSupportsSimplifiedCodeGenerationImplementation(rm.Tree.Root.Child(0), RegexNode.DefaultMaxRecursionDepth) &&
                (((RegexOptions)rm.Tree.Root.Options) & RegexOptions.RightToLeft) == 0)
            {
                EmitSimplifiedGo(writer, rm, id);
            }
            else
            {
                EmitCompleteGo(writer, rm, id);
            }
        }

        /// <summary>Emits the body of a simplified Go implementation that's possible when there's minimal backtracking required by the expression.</summary>
        private static void EmitSimplifiedGo(IndentedTextWriter writer, RegexMethod rm, string id)
        {
            RegexOptions options = (RegexOptions)rm.Options;
            var code = rm.Code;
            var lcc = code.LeadingCharClasses;
            bool rtl = code.RightToLeft;
            bool hasTimeout = false;

            int nextLocalId = 0;
            string GetNextLocalId() => $"i{nextLocalId++}"; ;

            RegexNode node = rm.Tree.Root;
            Debug.Assert(node.Type == RegexNode.Capture, "Every generated tree should begin with a capture node");
            Debug.Assert(node.ChildCount() == 1, "Capture nodes should have one child");

            // Skip the Capture node. We handle the implicit root capture specially.
            node = node.Child(0);

            // Declare some locals.
            string textSpanLocal = "textSpan";
            writer.WriteLine("string runtext = base.runtext!;");
            writer.WriteLine("int runtextpos = base.runtextpos;");
            writer.WriteLine("int runtextend = base.runtextend;");
            writer.WriteLine("int originalruntextpos = runtextpos;");
            writer.WriteLine("char ch;");
            hasTimeout = EmitLoopTimeoutCounterIfNeeded(writer, rm);

            // TextInfo textInfo = CultureInfo.CurrentCulture.TextInfo; // only if the whole expression or any subportion is ignoring case, and we're not using invariant
            bool hasTextInfo = EmitInitializeCultureForGoIfNecessary(writer, rm);

            // The implementation tries to use const indexes into the span wherever possible, which we can do
            // in all places except for variable-length loops.  For everything else, we know at any point in
            // the regex exactly how far into it we are, and we can use that to index into the span created
            // at the beginning of the routine to begin at exactly where we're starting in the input.  For
            // variable-length loops, we index at this textSpanPos + i, and then after the loop we slice the input
            // by i so that this position is still accurate for everything after it.
            int textSpanPos = 0;
            LoadTextSpanLocal(writer, defineLocal: true);
            writer.WriteLine();

            int localCounter = 0;
            string NextLocalName(string prefix) => $"{prefix}{localCounter++}";

            int labelCounter = 0;
            string DefineLabel() => $"L{labelCounter++}";
            void MarkLabel(string label) => writer.WriteLine($"{label}:");
            void Goto(string label) => writer.WriteLine($"goto {label};");
            string doneLabel = "NoMatch";

            // Emit the code for all nodes in the tree.
            EmitNode(node);

            // Emit success
            writer.WriteLine("// Match");
            if (textSpanPos > 0)
            {
                writer.WriteLine($"runtextpos += {textSpanPos};");
            }
            writer.WriteLine("base.runtextpos = runtextpos;");
            writer.WriteLine("base.Capture(0, originalruntextpos, runtextpos);");
            writer.WriteLine("return;");
            writer.WriteLine();

            // Emit failure
            writer.WriteLine("// No match");
            MarkLabel(doneLabel);
            if ((node.Options & RegexNode.HasCapturesFlag) != 0)
            {
                writer.WriteLine("while (base.Crawlpos() != 0) base.Uncapture();");
            }
            else
            {
                // We can't have a label at the end of the method, so explicitly
                // add a "return;" if the End label would otherwise be an issue.
                writer.WriteLine("return;");
            }
            return;

            static bool IsCaseInsensitive(RegexNode node) => (node.Options & RegexOptions.IgnoreCase) != 0;

            // Creates a span for runtext starting at runtextpos until base.runtextend.
            void LoadTextSpanLocal(IndentedTextWriter writer, bool defineLocal = false)
            {
                if (defineLocal)
                {
                    writer.Write("global::System.ReadOnlySpan<char> ");
                }
                writer.WriteLine($"{textSpanLocal} = global::System.MemoryExtensions.AsSpan(runtext, runtextpos, runtextend - runtextpos);");
            }

            // Emits the sum of a constant and a value from a local.
            string Sum(int constant, string? local = null) =>
                local is null ? constant.ToString() :
                constant == 0 ? local :
                $"{constant} + {local}";

            // Emits a check that the span is large enough at the currently known static position to handle the required additional length.
            void EmitSpanLengthCheck(int requiredLength, string? dynamicRequiredLength = null)
            {
                Debug.Assert(requiredLength > 0);
                using (EmitBlock(writer, $"if ({SpanLengthCheck(requiredLength, dynamicRequiredLength)})"))
                {
                    writer.WriteLine($"goto {doneLabel};");
                }
            }

            string SpanLengthCheck(int requiredLength, string? dynamicRequiredLength = null) =>
                $"(uint){textSpanLocal}.Length < {Sum(textSpanPos + requiredLength, dynamicRequiredLength)}";

            // Adds the value of textSpanPos into the runtextpos local, slices textspan by the corresponding amount,
            // and zeros out textSpanPos.
            void TransferTextSpanPosToRunTextPos()
            {
                if (textSpanPos > 0)
                {
                    writer.WriteLine($"runtextpos += {textSpanPos};");
                    writer.WriteLine($"{textSpanLocal} = {textSpanLocal}.Slice({textSpanPos});");
                    textSpanPos = 0;
                }
            }

            string AddTextSpanPos() => textSpanPos > 0 ? $" + {textSpanPos}" : "";

            // Emits the code for an atomic alternate, one that once a branch successfully matches is non-backtracking into it.
            // This amounts to generating the code for each branch, with failures in a branch resetting state to what it was initially
            // and then jumping to the next branch. We don't need to worry about uncapturing, because capturing is only allowed for the
            // implicit capture that happens for the whole match at the end.
            void EmitAtomicAlternate(RegexNode node)
            {
                // Label to jump to when any branch completes successfully.
                string doneAlternateLabel = DefineLabel();

                // Save off runtextpos.  We'll need to reset this each time a branch fails.
                string startingRunTextPosName = NextLocalName("startingRunTextPos");
                writer.WriteLine($"int {startingRunTextPosName} = runtextpos;");
                int startingTextSpanPos = textSpanPos;

                // If the alternation's branches contain captures, save off the relevant
                // state.  Note that this is only about subexpressions within the alternation,
                // as the alternation is atomic, so we're not concerned about captures after
                // the alternation.
                bool hasStartingCrawlpos = (node.Options & RegexNode.HasCapturesFlag) != 0;
                if (hasStartingCrawlpos)
                {
                    writer.WriteLine("int startingCrawlpos = base.Crawlpos();");
                }
                writer.WriteLine();

                // A failure in a branch other than the last should jump to the next
                // branch, not to the final done.
                string postAlternateDoneLabel = doneLabel;

                int childCount = node.ChildCount();
                for (int i = 0; i < childCount - 1; i++)
                {
                    using var __ = EmitScope(writer, $"Branch {i}");

                    string nextBranch = DefineLabel();
                    doneLabel = nextBranch;

                    // Emit the code for each branch.
                    EmitNode(node.Child(i));

                    // If we get here in the generated code, the branch completed successfully.
                    // Before jumping to the end, we need to zero out textSpanPos, so that no
                    // matter what the value is after the branch, whatever follows the alternate
                    // will see the same textSpanPos.
                    TransferTextSpanPosToRunTextPos();
                    writer.WriteLine($"goto {doneAlternateLabel};");

                    // Reset state for next branch and loop around to generate it.  This includes
                    // setting runtextpos back to what it was at the beginning of the alternation,
                    // updating textSpan to be the full length it was, and if there's a capture that
                    // needs to be reset, uncapturing it.
                    MarkLabel(nextBranch);
                    writer.WriteLine($"runtextpos = {startingRunTextPosName};");
                    LoadTextSpanLocal(writer);
                    textSpanPos = startingTextSpanPos;
                    if (hasStartingCrawlpos)
                    {
                        EmitUncaptureUntil();
                    }
                }

                // If the final branch fails, that's like any other failure, and we jump to
                // done (unless we have captures we need to unwind first, in which case we uncapture
                // them and then jump to done).
                using (EmitScope(writer, $"Branch {childCount - 1}"))
                {
                    if (hasStartingCrawlpos)
                    {
                        string uncapture = DefineLabel();
                        doneLabel = uncapture;
                        EmitNode(node.Child(childCount - 1));
                        doneLabel = postAlternateDoneLabel;
                        TransferTextSpanPosToRunTextPos();
                        writer.WriteLine($"goto {doneAlternateLabel};");
                        MarkLabel(uncapture);
                        EmitUncaptureUntil();
                        writer.WriteLine($"goto {doneLabel};");
                    }
                    else
                    {
                        doneLabel = postAlternateDoneLabel;
                        EmitNode(node.Child(childCount - 1));
                        TransferTextSpanPosToRunTextPos();
                    }
                }

                // Successfully completed the alternate.
                MarkLabel(doneAlternateLabel);
                writer.WriteLine(";");
                Debug.Assert(textSpanPos == 0);
            }

            // Emits the code for a Capture node.
            void EmitCapture(RegexNode node)
            {
                Debug.Assert(node.N == -1);

                // Get the capture number.  This needs to be kept in sync with MapCapNum in RegexWriter.
                Debug.Assert(node.Type == RegexNode.Capture);
                Debug.Assert(node.N == -1, "Currently only support capnum, not uncapnum");
                int capnum = node.M;
                if (capnum != -1 && rm.Code.Caps != null)
                {
                    capnum = (int)rm.Code.Caps[capnum]!;
                }

                TransferTextSpanPosToRunTextPos();
                string startingRunTextPosName = NextLocalName("startingRunTextPos");
                writer.WriteLine($"int {startingRunTextPosName} = runtextpos;");

                // Emit child node.
                EmitNode(node.Child(0));

                TransferTextSpanPosToRunTextPos();
                writer.WriteLine($"base.Capture({capnum}, {startingRunTextPosName}, runtextpos);");
            }

            // Emits code to unwind the capture stack until the crawl position specified in the provided local.
            void EmitUncaptureUntil()
            {
                writer.WriteLine("while (base.Crawlpos() != startingCrawlpos) base.Uncapture();");
            }

            // Emits the code to handle a positive lookahead assertion.
            void EmitPositiveLookaheadAssertion(RegexNode node)
            {
                // Save off runtextpos.  We'll need to reset this upon successful completion of the lookahead.
                string startingRunTextPosName = NextLocalName("startingRunTextPos");
                writer.WriteLine($"int {startingRunTextPosName} = runtextpos;");
                int startingTextSpanPos = textSpanPos;

                // Emit the child.
                EmitNode(node.Child(0));

                // After the child completes successfully, reset the text positions.
                // Do not reset captures, which persist beyond the lookahead.
                writer.WriteLine($"runtextpos = {startingRunTextPosName};");
                LoadTextSpanLocal(writer);
                textSpanPos = startingTextSpanPos;
            }

            // Emits the code to handle a negative lookahead assertion.
            void EmitNegativeLookaheadAssertion(RegexNode node)
            {
                // Save off runtextpos.  We'll need to reset this upon successful completion of the lookahead.
                string startingRunTextPosName = NextLocalName("startingRunTextPos");
                writer.WriteLine($"int {startingRunTextPosName} = runtextpos;");
                int startingTextSpanPos = textSpanPos;

                string originalDoneLabel = doneLabel;
                doneLabel = DefineLabel();

                // Emit the child.
                EmitNode(node.Child(0));

                // If the generated code ends up here, it matched the lookahead, which actually
                // means failure for a _negative_ lookahead, so we need to jump to the original done.
                Goto(originalDoneLabel);

                // Failures (success for a negative lookahead) jump here.
                MarkLabel(doneLabel);
                doneLabel = originalDoneLabel;

                // After the child completes in failure (success for negative lookahead), reset the text positions.
                writer.WriteLine($"runtextpos = {startingRunTextPosName};");
                LoadTextSpanLocal(writer);
                textSpanPos = startingTextSpanPos;
            }

            // Emits the code for the node.
            void EmitNode(RegexNode node)
            {
                using var _ = EmitScope(writer, SymbolDisplay.FormatLiteral(node.Description(), quote: false));
                switch (node.Type)
                {
                    case RegexNode.One:
                    case RegexNode.Notone:
                    case RegexNode.Set:
                        EmitSingleChar(node);
                        break;

                    case RegexNode.Boundary:
                    case RegexNode.NonBoundary:
                    case RegexNode.ECMABoundary:
                    case RegexNode.NonECMABoundary:
                        EmitBoundary(node);
                        break;

                    case RegexNode.Beginning:
                    case RegexNode.Start:
                    case RegexNode.Bol:
                    case RegexNode.Eol:
                    case RegexNode.End:
                    case RegexNode.EndZ:
                        EmitAnchors(node);
                        break;

                    case RegexNode.Multi:
                        EmitMultiChar(node);
                        break;

                    case RegexNode.Oneloopatomic:
                    case RegexNode.Notoneloopatomic:
                    case RegexNode.Setloopatomic:
                        EmitSingleCharAtomicLoop(node);
                        break;

                    case RegexNode.Loop:
                        EmitAtomicNodeLoop(node);
                        break;

                    case RegexNode.Lazyloop:
                        // An atomic lazy loop amounts to doing the minimum amount of work possible.
                        // That means iterating as little as is required, which means a repeater
                        // for the min, and if min is 0, doing nothing.
                        Debug.Assert(node.M == node.N || (node.Next != null && node.Next.Type == RegexNode.Atomic));
                        if (node.M > 0)
                        {
                            EmitNodeRepeater(node);
                        }
                        break;

                    case RegexNode.Atomic:
                        EmitNode(node.Child(0));
                        break;

                    case RegexNode.Alternate:
                        EmitAtomicAlternate(node);
                        break;

                    case RegexNode.Oneloop:
                    case RegexNode.Onelazy:
                    case RegexNode.Notoneloop:
                    case RegexNode.Notonelazy:
                    case RegexNode.Setloop:
                    case RegexNode.Setlazy:
                        EmitSingleCharRepeater(node);
                        break;

                    case RegexNode.Concatenate:
                        int childCount = node.ChildCount();
                        for (int i = 0; i < childCount; i++)
                        {
                            EmitNode(node.Child(i));
                        }
                        break;

                    case RegexNode.Capture:
                        EmitCapture(node);
                        break;

                    case RegexNode.Require:
                        EmitPositiveLookaheadAssertion(node);
                        break;

                    case RegexNode.Prevent:
                        EmitNegativeLookaheadAssertion(node);
                        break;

                    case RegexNode.Nothing:
                        writer.WriteLine($"goto {doneLabel};");
                        break;

                    case RegexNode.Empty:
                        // Emit nothing.
                        break;

                    case RegexNode.UpdateBumpalong:
                        EmitUpdateBumpalong();
                        break;

                    default:
                        Debug.Fail($"Unexpected node type: {node.Type}");
                        break;
                }
            }

            // Emits the code to handle updating base.runtextpos to runtextpos in response to
            // an UpdateBumpalong node.  This is used when we want to inform the scan loop that
            // it should bump from this location rather than from the original location.
            void EmitUpdateBumpalong()
            {
                TransferTextSpanPosToRunTextPos();
                writer.WriteLine("base.runtextpos = runtextpos;");
            }

            // Emits the code to handle a single-character match.
            void EmitSingleChar(RegexNode node, bool emitLengthCheck = true, string offset = null)
            {
                string expr = $"{textSpanLocal}[{Sum(textSpanPos, offset)}]";
                switch (node.Type)
                {
                    // This only emits a single check, but it's called from the looping constructs in a loop
                    // to generate the code for a single check, so we map those looping constructs to the
                    // appropriate single check.

                    case RegexNode.Set:
                    case RegexNode.Setlazy:
                    case RegexNode.Setloop:
                    case RegexNode.Setloopatomic:
                        expr = $"!{MatchCharacterClass(hasTextInfo, options, expr, node.Str!, IsCaseInsensitive(node))}";
                        break;

                    case RegexNode.One:
                    case RegexNode.Onelazy:
                    case RegexNode.Oneloop:
                    case RegexNode.Oneloopatomic:
                        expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive(node) && RegexCharClass.ParticipatesInCaseConversion(node.Ch));
                        expr = $"{expr} != {Literal(node.Ch)}";
                        break;

                    default:
                        Debug.Assert(node.Type == RegexNode.Notone || node.Type == RegexNode.Notonelazy || node.Type == RegexNode.Notoneloop || node.Type == RegexNode.Notoneloopatomic);
                        expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive(node) && RegexCharClass.ParticipatesInCaseConversion(node.Ch));
                        expr = $"{expr} == {Literal(node.Ch)}";
                        break;
                }

                using (EmitBlock(writer, emitLengthCheck ? $"if ({SpanLengthCheck(1, offset)} || {expr})" : $"if ({expr})"))
                {
                    writer.WriteLine($"goto {doneLabel};");
                }

                textSpanPos++;
            }

            // Emits the code to handle a boundary check on a character.
            void EmitBoundary(RegexNode node)
            {
                string call;
                switch (node.Type)
                {
                    case RegexNode.Boundary:
                        call = "!base.IsBoundary";
                        break;

                    case RegexNode.NonBoundary:
                        call = "base.IsBoundary";
                        break;

                    case RegexNode.ECMABoundary:
                        call = "!base.IsECMABoundary";
                        break;

                    default:
                        Debug.Assert(node.Type == RegexNode.NonECMABoundary);
                        call = "base.IsECMABoundary";
                        break;
                }

                using (EmitBlock(writer, $"if ({call}(runtextpos{AddTextSpanPos()}, base.runtextbeg, runtextend))"))
                {
                    writer.WriteLine($"goto {doneLabel};");
                }
            }

            // Emits the code to handle various anchors.
            void EmitAnchors(RegexNode node)
            {
                Debug.Assert(textSpanPos >= 0);
                switch (node.Type)
                {
                    case RegexNode.Beginning:
                    case RegexNode.Start:
                        if (textSpanPos > 0)
                        {
                            // If we statically know we've already matched part of the regex, there's no way we're at the
                            // beginning or start, as we've already progressed past it.
                            Goto(doneLabel);
                        }
                        else
                        {
                            using (EmitBlock(writer, node.Type == RegexNode.Beginning ? "if (runtextpos != runtextbeg)" : "if (runtextpos != runtextstart)"))
                            {
                                writer.WriteLine($"goto {doneLabel};");
                            }
                        }
                        break;

                    case RegexNode.Bol:
                        if (textSpanPos > 0)
                        {
                            using (EmitBlock(writer, $"if ({textSpanLocal}[{textSpanPos - 1}] != '\\n')"))
                            {
                                writer.WriteLine($"goto {doneLabel};");
                            }
                        }
                        else
                        {
                            // We can't use our textSpan in this case, because we'd need to access textSpan[-1], so we access the runtext field directly:
                            using (EmitBlock(writer, $"if (runtextpos > runtextbeg && runtext[runtextpos - 1] != '\\n')"))
                            {
                                writer.WriteLine($"goto {doneLabel};");
                            }
                        }
                        break;

                    case RegexNode.End:
                        using (EmitBlock(writer, $"if ({textSpanLocal}.Length > {textSpanPos})"))
                        {
                            writer.WriteLine($"goto {doneLabel};");
                        }
                        break;

                    case RegexNode.EndZ:
                        writer.WriteLine($"if ({textSpanPos} < {textSpanLocal}.Length - 1 || ({textSpanPos} < {textSpanLocal}.Length && {textSpanLocal}[{textSpanPos}] != '\\n'))");
                        using (EmitBlock(writer, null))
                        {
                            writer.WriteLine($"goto {doneLabel};");
                        }
                        break;

                    case RegexNode.Eol:
                        using (EmitBlock(writer, $"if ({textSpanPos} < {textSpanLocal}.Length && {textSpanLocal}[{textSpanPos}] != '\\n')"))
                        {
                            writer.WriteLine($"goto {doneLabel};");
                        }
                        break;
                }
            }

            // Emits the code to handle a multiple-character match.
            void EmitMultiChar(RegexNode node)
            {
                bool caseInsensitive = IsCaseInsensitive(node);

                string str = node.Str!;
                Debug.Assert(str.Length != 0);

                const int MaxUnrollLength = 64;
                if (str.Length <= MaxUnrollLength)
                {
                    // Unroll shorter strings.

                    // TODO: This might employ 64-bit operations on a 32-bit machine.  Decide if avoiding that
                    // is worth adding further complexity for (RegexOptions.Compiled doesn't have to deal with
                    // this, as the machine generating the code in-memory is the same one running it.)

                    // For strings more than two characters and when performing case-sensitive searches, we try to do fewer comparisons
                    // by comparing 2 or 4 characters at a time.  Because we might be compiling on one endianness and running on another,
                    // both little and big endian values are emitted and which is used is selected at run-time.
                    ReadOnlySpan<byte> byteStr = MemoryMarshal.AsBytes(str.AsSpan());
                    bool useMultiCharReads = !caseInsensitive && byteStr.Length > sizeof(uint);
                    if (useMultiCharReads)
                    {
                        writer.WriteLine($"ref byte byteStr = ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(global::System.Runtime.InteropServices.MemoryMarshal.AsBytes({textSpanLocal}));");
                    }

                    writer.Write($"if ((uint){textSpanLocal}.Length < {textSpanPos + str.Length}");

                    if (useMultiCharReads)
                    {
                        while (byteStr.Length >= sizeof(ulong))
                        {
                            writer.WriteLine(" ||");
                            ulong little = BinaryPrimitives.ReadUInt64LittleEndian(byteStr);
                            ulong big = BinaryPrimitives.ReadUInt64BigEndian(byteStr);
                            writer.Write($"    global::System.Runtime.CompilerServices.Unsafe.ReadUnaligned<ulong>(ref global::System.Runtime.CompilerServices.Unsafe.Add(ref byteStr, {textSpanPos * 2})) != (global::System.BitConverter.IsLittleEndian ? 0x{little:X}ul : 0x{big:X}ul)");
                            textSpanPos += sizeof(ulong) / 2;
                            byteStr = byteStr.Slice(sizeof(ulong));
                        }

                        while (byteStr.Length >= sizeof(uint))
                        {
                            writer.WriteLine(" ||");
                            uint little = BinaryPrimitives.ReadUInt32LittleEndian(byteStr);
                            uint big = BinaryPrimitives.ReadUInt32BigEndian(byteStr);
                            writer.Write($"    global::System.Runtime.CompilerServices.Unsafe.ReadUnaligned<uint>(ref global::System.Runtime.CompilerServices.Unsafe.Add(ref byteStr, {textSpanPos * 2})) != (global::System.BitConverter.IsLittleEndian ? 0x{little:X}u : 0x{big:X}u)");
                            textSpanPos += sizeof(uint) / 2;
                            byteStr = byteStr.Slice(sizeof(uint));
                        }
                    }

                    // Emit remaining comparisons character by character.
                    for (int i = (str.Length * 2 - byteStr.Length) / 2; i < str.Length; i++)
                    {
                        writer.WriteLine(" ||");
                        writer.Write($"    {ToLowerIfNeeded(hasTextInfo, options, $"{textSpanLocal}[{textSpanPos}]", caseInsensitive)} != {Literal(str[i])}");
                        textSpanPos++;
                    }

                    writer.WriteLine(")");
                    using (EmitBlock(writer, null))
                    {
                        writer.WriteLine($"goto {doneLabel};");
                    }
                }
                else
                {
                    // Longer strings are compared character by character.  If this is a case-sensitive comparison, we can simply
                    // delegate to StartsWith.  If this is case-insensitive, we open-code the comparison loop, as we need to lowercase
                    // each character involved, and none of the StringComparison options provide the right semantics of comparing
                    // character-by-character while respecting the culture.
                    if (!caseInsensitive)
                    {
                        using (EmitBlock(writer, $"if (!global::System.MemoryExtensions.StartsWith({textSpanLocal}.Slice({textSpanPos}), {Literal(node.Str)}))"))
                        {
                            writer.WriteLine($"goto {doneLabel};");
                        }
                        textSpanPos += node.Str.Length;
                    }
                    else
                    {
                        EmitSpanLengthCheck(str.Length);
                        string i = GetNextLocalId();
                        using (EmitBlock(writer, $"for (int {i} = 0; {i} < {Literal(node.Str)}.Length; {i}++)"))
                        {
                            using (EmitBlock(writer, $"if ({ToLower(hasTextInfo, options, $"{textSpanLocal}[{textSpanPos} + {i}]")} != {Literal(str)}[{i}])"))
                            {
                                writer.WriteLine($"goto {doneLabel};");
                            }
                        }
                        textSpanPos += node.Str.Length;
                    }
                }
            }

            // Emits the code to handle a loop (repeater) with a fixed number of iterations.
            // RegexNode.M is used for the number of iterations; RegexNode.N is ignored.
            void EmitSingleCharRepeater(RegexNode node)
            {
                int iterations = node.M;
                if (iterations == 0)
                {
                    // No iterations, nothing to do.
                    return;
                }

                // if ((uint)(textSpanPos + iterations - 1) >= (uint)textSpan.Length) goto doneLabel;
                EmitSpanLengthCheck(iterations);

                // Arbitrary limit for unrolling vs creating a loop.  We want to balance size in the generated
                // code with other costs, like the (small) overhead of slicing to create the temp span to iterate.
                const int MaxUnrollSize = 16;

                if (iterations <= MaxUnrollSize)
                {
                    // if (textSpan[textSpanPos] != c1 ||
                    //     textSpan[textSpanPos + 1] != c2 ||
                    //     ...)
                    //       goto doneLabel;
                    for (int i = 0; i < iterations; i++)
                    {
                        EmitSingleChar(node, emitLengthCheck: false);
                    }
                }
                else
                {
                    string spanLocal = "slice"; // As this repeater doesn't wrap arbitrary node emits, this shouldn't conflict with anything
                    writer.WriteLine($"global::System.ReadOnlySpan<char> {spanLocal} = {textSpanLocal}.Slice({textSpanPos}, {iterations});");
                    string i = GetNextLocalId();
                    using (EmitBlock(writer, $"for (int {i} = 0; {i} < {spanLocal}.Length; {i}++)"))
                    {
                        EmitTimeoutCheck(writer, hasTimeout);

                        string tmpTextSpanLocal = textSpanLocal; // we want EmitSingleChar to refer to this temporary
                        int tmpTextSpanPos = textSpanPos;
                        textSpanLocal = spanLocal;
                        textSpanPos = 0;
                        EmitSingleChar(node, emitLengthCheck: false, offset: i);
                        textSpanLocal = tmpTextSpanLocal;
                        textSpanPos = tmpTextSpanPos;
                    }
                    textSpanPos += iterations;
                }
            }

            // Emits the code to handle a loop (repeater) with a fixed number of iterations.
            // This is used both to handle the case of A{5, 5} where the min and max are equal,
            // and also to handle part of the case of A{3, 5}, where this method is called to
            // handle the A{3, 3} portion, and then remaining A{0, 2} is handled separately.
            void EmitNodeRepeater(RegexNode node)
            {
                int iterations = node.M;
                Debug.Assert(iterations > 0);
                Debug.Assert(node.ChildCount() == 1);

                if (iterations == 1)
                {
                    EmitNode(node.Child(0));
                    return;
                }

                // Ensure textSpanPos is 0 prior to emitting the child.
                TransferTextSpanPosToRunTextPos();

                string i = GetNextLocalId();
                using (EmitBlock(writer, $"for (int {i} = 0; {i} < {iterations}; {i}++)"))
                {
                    EmitTimeoutCheck(writer, hasTimeout);
                    EmitNode(node.Child(0));
                    TransferTextSpanPosToRunTextPos();
                    Debug.Assert(textSpanPos == 0);
                }
            }

            // Emits the code to handle a non-backtracking, variable-length loop around a single character comparison.
            void EmitSingleCharAtomicLoop(RegexNode node)
            {
                Debug.Assert(
                    node.Type == RegexNode.Oneloopatomic ||
                    node.Type == RegexNode.Notoneloopatomic ||
                    node.Type == RegexNode.Setloopatomic);

                // If this is actually a repeater, emit that instead.
                if (node.M == node.N)
                {
                    EmitSingleCharRepeater(node);
                    return;
                }

                // If this is actually an optional single char, emit that instead.
                if (node.M == 0 && node.N == 1)
                {
                    EmitAtomicSingleCharZeroOrOne(node);
                    return;
                }

                Debug.Assert(node.N > node.M);
                int minIterations = node.M;
                int maxIterations = node.N;

                string originalDoneLabel = doneLabel;
                doneLabel = DefineLabel();

                Span<char> setChars = stackalloc char[3]; // 3 is max we can use with IndexOfAny
                int numSetChars = 0;

                string iterationLocal = "i"; // No need for a dynamically named value, as no other 'i' can be in scope
                if (node.Type == RegexNode.Notoneloopatomic &&
                    maxIterations == int.MaxValue &&
                    (!IsCaseInsensitive(node) || !RegexCharClass.ParticipatesInCaseConversion(node.Ch)))
                {
                    // For Notoneloopatomic, we're looking for a specific character, as everything until we find
                    // it is consumed by the loop.  If we're unbounded, such as with ".*" and if we're case-sensitive,
                    // we can use the vectorized IndexOf to do the search, rather than open-coding it.  The unbounded
                    // restriction is purely for simplicity; it could be removed in the future with additional code to
                    // handle the unbounded case.

                    writer.Write($"int {iterationLocal} = global::System.MemoryExtensions.IndexOf({textSpanLocal}");
                    if (textSpanPos > 0)
                    {
                        writer.Write($".Slice({textSpanPos})");
                    }
                    writer.WriteLine($", {Literal(node.Ch)});");
                    
                    using (EmitBlock(writer, $"if ({iterationLocal} != -1)"))
                    {
                        writer.WriteLine($"goto {doneLabel};");
                    }

                    writer.WriteLine(textSpanPos > 0 ?
                        $"{iterationLocal} = {textSpanLocal}.Length - {textSpanPos};" :
                        $"{iterationLocal} = {textSpanLocal}.Length;");
                }
                else if (node.Type == RegexNode.Setloopatomic &&
                    maxIterations == int.MaxValue &&
                    !IsCaseInsensitive(node) &&
                    (numSetChars = RegexCharClass.GetSetChars(node.Str!, setChars)) > 1 &&
                    RegexCharClass.IsNegated(node.Str!))
                {
                    // If the set is negated and contains only 2 or 3 characters (if it contained 1 and was negated, it would
                    // have been reduced to a Notoneloopatomic), we can use an IndexOfAny to find any of the target characters.
                    // As with the notoneloopatomic above, the unbounded constraint is purely for simplicity.

                    writer.Write($"int {iterationLocal} = global::System.MemoryExtensions.IndexOfAny({textSpanLocal}");
                    if (textSpanPos != 0)
                    {
                        writer.Write($".Slice({textSpanPos})");
                    }
                    writer.WriteLine(numSetChars == 2 ?
                        $", {Literal(setChars[0])}, {Literal(setChars[1])});" :
                        $", {Literal(setChars[0])}, {Literal(setChars[1])}, {Literal(setChars[2])});");
                    using (EmitBlock(writer, $"if ({iterationLocal} != -1)"))
                    {
                        writer.WriteLine($"goto {doneLabel};");
                    }

                    writer.WriteLine(textSpanPos > 0 ?
                        $"{iterationLocal} = {textSpanLocal}.Length - {textSpanPos};" :
                        $"{iterationLocal} = {textSpanLocal}.Length;");
                }
                else if (node.Type == RegexNode.Setloopatomic && maxIterations == int.MaxValue && node.Str == RegexCharClass.AnyClass)
                {
                    // .* was used with RegexOptions.Singleline, which means it'll consume everything.  Just jump to the end.
                    // The unbounded constraint is the same as in the Notoneloopatomic case above, done purely for simplicity.

                    // int i = runtextend - runtextpos;
                    TransferTextSpanPosToRunTextPos();
                    writer.WriteLine($"int {iterationLocal} = runtextend - runtextpos;");
                }
                else
                {
                    // For everything else, do a normal loop.

                    string expr = $"{textSpanLocal}[{iterationLocal}]";
                    switch (node.Type)
                    {
                        case RegexNode.Oneloopatomic:
                            expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive(node) && RegexCharClass.ParticipatesInCaseConversion(node.Ch));
                            expr = $"{expr} != {Literal(node.Ch)}";
                            break;
                        case RegexNode.Notoneloopatomic:
                            expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive(node) && RegexCharClass.ParticipatesInCaseConversion(node.Ch));
                            expr = $"{expr} == {Literal(node.Ch)}";
                            break;
                        case RegexNode.Setloopatomic:
                            expr = MatchCharacterClass(hasTextInfo, options, expr, node.Str!, IsCaseInsensitive(node));
                            expr = $"!{expr}";
                            break;
                    }

                    // Transfer text pos to runtextpos to help with bounds check elimination on the loop.
                    TransferTextSpanPosToRunTextPos();

                    writer.WriteLine($"int {iterationLocal} = 0;");
                    using (EmitBlock(writer, $"while (true)"))
                    {
                        EmitTimeoutCheck(writer, hasTimeout);
                        string clause = "if (";
                        if (maxIterations != int.MaxValue)
                        {
                            clause += $"{iterationLocal} >= {maxIterations} || ";
                        }
                        using (EmitBlock(writer, $"{clause}(uint){iterationLocal} >= (uint){textSpanLocal}.Length || {expr})"))
                        {
                            writer.WriteLine($"goto {doneLabel};");
                        }
                        writer.WriteLine($"{iterationLocal}++;");
                    }
                }

                // Done:
                MarkLabel(doneLabel);
                doneLabel = originalDoneLabel; // Restore the original done label

                // Check to ensure we've found at least min iterations.
                if (minIterations > 0)
                {
                    using (EmitBlock(writer, $"if ({iterationLocal} < {minIterations})"))
                    {
                        writer.WriteLine($"goto {doneLabel};");
                    }
                }

                // Now that we've completed our optional iterations, advance the text span
                // and runtextpos by the number of iterations completed.

                writer.WriteLine($"{textSpanLocal} = {textSpanLocal}.Slice({iterationLocal});");
                writer.WriteLine($"runtextpos += {iterationLocal};");
            }

            // Emits the code to handle a non-backtracking optional zero-or-one loop.
            void EmitAtomicSingleCharZeroOrOne(RegexNode node)
            {
                string skipUpdatesLabel = DefineLabel();

                Debug.Assert(
                    node.Type == RegexNode.Oneloopatomic ||
                    node.Type == RegexNode.Notoneloopatomic ||
                    node.Type == RegexNode.Setloopatomic);
                Debug.Assert(node.M == 0 && node.N == 1);

                string expr = $"{textSpanLocal}[{textSpanPos}]";
                switch (node.Type)
                {
                    case RegexNode.Oneloopatomic:
                        expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive(node) && RegexCharClass.ParticipatesInCaseConversion(node.Ch));
                        expr = $"{expr} == {Literal(node.Ch)}";
                        break;
                    case RegexNode.Notoneloopatomic:
                        expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive(node) && RegexCharClass.ParticipatesInCaseConversion(node.Ch));
                        expr = $"{expr} != {Literal(node.Ch)}";
                        break;
                    case RegexNode.Setloopatomic:
                        expr = MatchCharacterClass(hasTextInfo, options, expr, node.Str!, IsCaseInsensitive(node));
                        expr = $"{expr}";
                        break;
                }

                using (EmitBlock(writer, $"if ((uint){textSpanPos} < (uint){textSpanLocal}.Length && {expr})"))
                {
                    writer.WriteLine($"{textSpanLocal} = {textSpanLocal}.Slice(1);");
                    writer.WriteLine($"runtextpos++;");
                }
            }

            // Emits the code to handle a non-backtracking, variable-length loop around another node.
            void EmitAtomicNodeLoop(RegexNode node)
            {
                Debug.Assert(node.Type == RegexNode.Loop, $"Unexpected type: {node.Type}");
                Debug.Assert(node.M < int.MaxValue, $"Unexpected M={node.M}");
                Debug.Assert(node.N >= node.M, $"Unexpected M={node.M}, N={node.N}");
                int minIterations = node.M;
                int maxIterations = node.N;

                // If this is actually a repeater, emit that instead.
                if (minIterations == maxIterations)
                {
                    EmitNodeRepeater(node);
                    return;
                }

                string originalDoneLabel = doneLabel;
                doneLabel = DefineLabel();

                // We might loop any number of times.  In order to ensure this loop
                // and subsequent code sees textSpanPos the same regardless, we always need it to contain
                // the same value, and the easiest such value is 0.  So, we transfer
                // textSpanPos to runtextpos, and ensure that any path out of here has
                // textSpanPos as 0.
                TransferTextSpanPosToRunTextPos();

                // int i = 0;
                string iterationLocal = NextLocalName("iter");
                writer.WriteLine($"int {iterationLocal} = 0;");
                using (EmitBlock(writer, maxIterations == int.MaxValue ? "while (true)" : $"while ({iterationLocal} < {maxIterations})"))
                {
                    EmitTimeoutCheck(writer, hasTimeout);
                    string successfulIterationLabel = DefineLabel();

                    // Iteration body

                    string prevDone = doneLabel;
                    doneLabel = DefineLabel();

                    // Save off runtextpos.
                    string startingRunTextPosLocal = NextLocalName("startingRunTextPos");
                    writer.WriteLine($"int {startingRunTextPosLocal} = runtextpos;");

                    // Emit the child.
                    Debug.Assert(textSpanPos == 0);
                    EmitNode(node.Child(0));
                    TransferTextSpanPosToRunTextPos(); // ensure textSpanPos remains 0
                    Goto(successfulIterationLabel); // iteration succeeded

                    // If the generated code gets here, the iteration failed.
                    // Reset state, branch to done.
                    MarkLabel(doneLabel);
                    doneLabel = prevDone; // reset done label
                    writer.WriteLine($"runtextpos = {startingRunTextPosLocal};");
                    Goto(doneLabel);

                    // Successful iteration.
                    MarkLabel(successfulIterationLabel);
                    writer.WriteLine($"{iterationLocal}++;");
                }

                // Check to ensure we've found at least min iterations.
                if (minIterations > 0)
                {
                    // Done:
                    MarkLabel(doneLabel);
                    doneLabel = originalDoneLabel; // Restore the original done label
                    using (EmitBlock(writer, $"if ({iterationLocal} < {minIterations})"))
                    {
                        writer.WriteLine($"goto {doneLabel};");
                    }
                }

                // We can't have a label in front of a closing brace, so if we didn't emit the label
                // earlier, emit now that we've closed out the scope.
                if (minIterations <= 0)
                {
                    // Done:
                    MarkLabel(doneLabel);
                    writer.WriteLine(";");
                    doneLabel = originalDoneLabel; // Restore the original done label
                }
            }
        }

        /// <summary>Emits the body of a complete Go implementation that fully supports backtracking.</summary>
        private static void EmitCompleteGo(IndentedTextWriter writer, RegexMethod rm, string id)
        {
            const int Stackpop = 0;       // pop one
            const int Stackpop2 = 1;      // pop two
            const int Capback = 3;        // uncapture
            const int Capback2 = 4;       // uncapture 2
            const int Branchmarkback2 = 5;      // back2 part of branchmark
            const int Lazybranchmarkback2 = 6;  // back2 part of lazybranchmark
            const int Branchcountback2 = 7;     // back2 part of branchcount
            const int Lazybranchcountback2 = 8; // back2 part of lazybranchcount
            const int Forejumpback = 9;         // back part of forejump
            const int Uniquecount = 10;
            const string Backtrack = "Backtrack"; // label for backtracking

            int[] codes = rm.Code.Codes;
            RegexOptions options = (RegexOptions)rm.Options.Value;

            int labelCounter = 0;
            string DefineLabel(string prefix = "L") => $"{prefix}{labelCounter++}";
            void MarkLabel(string label) => writer.WriteLine($"{label}:");

            var labels = new string?[codes.Length]; // a label for every operation in _codes
            BacktrackNote[]? notes = null; // a list of the backtracking states to be generated
            int noteCount = 0; // true count of _notes (allocation grows exponentially)
            
            int currentOpcode = 0; // the current opcode being processed
            int currentCodePos = 0; // the current code being translated
            int currentBacktrackNote = 0; // the current backtrack-note being translated
            
            // special code fragments
            var uniqueNote = new int[Uniquecount]; // notes indices for code that should be emitted <= once
            var forwardJumpsThroughSwitch = new int[codes.Length]; // indices for forward-jumps-through-switch (for allocations)

            // Generates the forward logic corresponding directly to the regex codes.
            // In the absence of backtracking, this is all we would need.
            writer.WriteLine("string runtext = base.runtext!;");
            writer.WriteLine("int runtextbeg = base.runtextbeg;");
            writer.WriteLine("int runtextend = base.runtextend;");
            writer.WriteLine("int runtextpos = base.runtextpos;");
            writer.WriteLine("int[] runtrack = base.runtrack!;");
            writer.WriteLine("int runtrackpos = base.runtrackpos;");
            writer.WriteLine("int[] runstack = base.runstack!;");
            writer.WriteLine("int runstackpos = base.runstackpos;");
            writer.WriteLine("int tmp1, tmp2, ch;");
            bool hasTimeout = EmitLoopTimeoutCounterIfNeeded(writer, rm);
            bool hasTextInfo = EmitInitializeCultureForGoIfNecessary(writer, rm);
            writer.WriteLine();

            uniqueNote.AsSpan().Fill(-1);
            for (int codepos = 0; codepos < codes.Length; codepos += RegexCode.OpcodeSize(codes[codepos]))
            {
                forwardJumpsThroughSwitch[codepos] = -1;
                labels[codepos] = DefineLabel();
            }

            currentBacktrackNote = -1;
            for (int codepos = 0; codepos < codes.Length; codepos += RegexCode.OpcodeSize(codes[codepos]))
            {
                currentCodePos = codepos;
                currentOpcode = codes[codepos];
                EmitOneCode(labels[codepos]);
                writer.WriteLine();
            }

            // Generate the backtracking switch jump table that allows us to simulate a stack of addresses,
            // and contains the calls that expand the tracking and the grouping stack when they get too full.
            MarkLabel(Backtrack);

            // (Equivalent of EnsureStorage, but written to avoid unnecessary local spilling.)
            writer.WriteLine("int limit = base.runtrackcount * 4;");
            using (EmitBlock(writer, "if (runstackpos < limit)"))
            {
                writer.WriteLine("base.runstackpos = runstackpos;");
                writer.WriteLine("base.DoubleStack(); // might change runstackpos and runstack");
                writer.WriteLine("runstackpos = base.runstackpos;");
                writer.WriteLine("runstack = base.runstack!;");
            }
            using (EmitBlock(writer, "if (runtrackpos < limit)"))
            {
                writer.WriteLine("base.runtrackpos = runtrackpos;");
                writer.WriteLine("base.DoubleTrack(); // might change runtrackpos and runtrack");
                writer.WriteLine("runtrackpos = base.runtrackpos;");
                writer.WriteLine("runtrack = base.runtrack!;");
            }
            writer.WriteLine();
            using (EmitBlock(writer, "switch (runtrack[runtrackpos++])"))
            {
                for (int i = 0; i < noteCount; i++)
                {
                    using (EmitBlock(writer, $"case {i}:"))
                    {
                        BacktrackNote n = notes[i];
                        if (n.flags != 0)
                        {
                            currentCodePos = n.codepos;
                            currentBacktrackNote = i;
                            currentOpcode = codes[n.codepos] | n.flags;
                            EmitOneCode(null); // should always end in a goto
                        }
                        else
                        {
                            writer.WriteLine($"goto {n.label};");
                        }
                    }

                    writer.WriteLine();
                }

                using (EmitBlock(writer, "default:"))
                {
                    writer.WriteLine("global::System.Diagnostics.Debug.Fail($\"Unexpected backtracking state {runtrack[runtrackpos - 1]}\");");
                    writer.WriteLine("break;");
                }
            }

            return;

            /// <summary>
            /// The main translation function. It translates the logic for a single opcode at
            /// the current position. The structure of this function exactly mirrors
            /// the structure of the inner loop of RegexInterpreter.Go().
            /// </summary>
            /// <remarks>
            /// Note that since we're generating code, we can collapse many cases that are
            /// dealt with one-at-a-time in RegexIntepreter. We can also unroll loops that
            /// iterate over constant strings or sets.
            /// </remarks>
            void EmitOneCode(string? label)
            {
                writer.WriteLine($"// {SymbolDisplay.FormatLiteral(RegexCode.OpcodeDescription(currentCodePos, rm.Code.Codes, rm.Code.Strings), quote: false)}");

                if (label is not null)
                {
                    MarkLabel(label);
                }

                // Before executing any Regex code in the unrolled loop,
                // we try checking for the match timeout:
                EmitTimeoutCheck(writer, hasTimeout);

                // Now generate the code for the Regex code saved in _regexopcode.
                switch (currentOpcode)
                {
                    case RegexCode.Stop:
                        writer.WriteLine("base.runtextpos = runtextpos;");
                        writer.WriteLine("return;");
                        break;

                    case RegexCode.Nothing:
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.UpdateBumpalong:
                        // UpdateBumpalong should only exist in the code stream at such a point where the root
                        // of the backtracking stack contains the runtextpos from the start of this Go call. Replace
                        // that tracking value with the current runtextpos value.
                        writer.WriteLine("runtrack[^1] = runtextpos;");
                        break;

                    case RegexCode.Goto:
                        Goto(Operand(0));
                        break;

                    case RegexCode.Testref:
                        using (EmitBlock(writer, $"if (!base.IsMatched({Operand(0)}))"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Lazybranch:
                        PushTrack("runtextpos");
                        Track();
                        break;

                    case RegexCode.Lazybranch | RegexCode.Back:
                        writer.WriteLine($"runtextpos = {PopTrack()};");
                        Goto(Operand(0));
                        break;

                    case RegexCode.Nullmark:
                        PushStack(-1);
                        TrackUnique(Stackpop);
                        break;

                    case RegexCode.Setmark:
                        PushStack("runtextpos");
                        TrackUnique(Stackpop);
                        break;

                    case RegexCode.Nullmark | RegexCode.Back:
                    case RegexCode.Setmark | RegexCode.Back:
                        PopDiscardStack();
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Getmark:
                        writer.WriteLine($"runtextpos = {PopStack()};");
                        PushTrack("runtextpos");
                        Track();
                        break;

                    case RegexCode.Getmark | RegexCode.Back:
                        PushStack(PopTrack());
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Capturemark:
                        {
                            if (Operand(1) != -1)
                            {
                                using (EmitBlock(writer, $"if (!base.IsMatched({Operand(1)}))"))
                                {
                                    writer.WriteLine($"goto {Backtrack};");
                                }
                            }

                            const string Stacked = "tmp1";
                            writer.WriteLine($"{Stacked} = {PopStack()};");
                            writer.WriteLine(Operand(1) != -1 ?
                                $"base.TransferCapture({Operand(0)}, {Operand(1)}, {Stacked}, runtextpos);" :
                                $"base.Capture({Operand(0)}, {Stacked}, runtextpos);");
                            PushTrack(Stacked);
                            TrackUnique(Operand(0) != -1 && Operand(1) != -1 ? Capback2 : Capback);
                        }
                        break;

                    case RegexCode.Capturemark | RegexCode.Back:
                        PushStack(PopTrack());
                        writer.WriteLine("base.Uncapture();");
                        if (Operand(0) != -1 && Operand(1) != -1)
                        {
                            writer.WriteLine("base.Uncapture();");
                        }
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Branchmark:
                        {
                            const string Mark = "tmp1";
                            writer.WriteLine($"{Mark} = {PopStack()}; // mark");
                            PushTrack(Mark);
                            using (EmitBlock(writer, $"if (runtextpos != {Mark})"))
                            {
                                PushTrack("runtextpos");
                                PushStack("runtextpos");
                                Track();
                                Goto(Operand(0));
                            }
                            using (EmitBlock(writer, "else"))
                            {
                                TrackUnique2(Branchmarkback2);
                            }
                        }
                        break;

                    case RegexCode.Branchmark | RegexCode.Back:
                        writer.WriteLine($"runtextpos = {PopTrack()};");
                        PopDiscardStack();
                        TrackUnique2(Branchmarkback2); // track spot 0 is already in place
                        Advance();
                        break;

                    case RegexCode.Branchmark | RegexCode.Back2:
                        PushStack(PopTrack());
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Lazybranchmark:
                        {
                            const string Mark = "tmp1";
                            writer.WriteLine($"{Mark} = {PopStack()}; // mark");
                            PushTrack($"{Mark} != -1 ? {Mark} : runtextpos");
                            using (EmitBlock(writer, $"if (runtextpos != {Mark})"))
                            {
                                PushTrack("runtextpos");
                                Track();
                                Advance();
                            }
                            PushStack(Mark);
                            TrackUnique2(Lazybranchmarkback2);
                        }
                        break;

                    case RegexCode.Lazybranchmark | RegexCode.Back:
                        writer.WriteLine($"runtextpos = {PopTrack()};");
                        PushStack("runtextpos");
                        TrackUnique2(Lazybranchmarkback2);
                        Goto(Operand(0));
                        break;

                    case RegexCode.Lazybranchmark | RegexCode.Back2:
                        writer.WriteLine($"{ReadyReplaceStack(0)} = {PopTrack()};");
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Nullcount:
                        PushStack(-1);
                        PushStack(Operand(0));
                        TrackUnique(Stackpop2);
                        break;

                    case RegexCode.Setcount:
                        PushStack("runtextpos");
                        PushStack(Operand(0));
                        TrackUnique(Stackpop2);
                        break;

                    case RegexCode.Nullcount | RegexCode.Back:
                    case RegexCode.Setcount | RegexCode.Back:
                        PopDiscardStack(2);
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Branchcount:
                        {
                            const string Count = "tmp1";
                            const string Mark = "tmp2";
                            writer.WriteLine($"{Count} = {PopStack()}; // count");
                            writer.WriteLine($"{Mark} = {PopStack()}; // mark");
                            PushTrack(Mark);
                            using (EmitBlock(writer, $"if ({Count} < ({Mark} == runtextpos ? 0 : {Operand(1)}))"))
                            {
                                PushStack("runtextpos");
                                PushStack($"{Count} + 1");
                                Track();
                                Goto(Operand(0));
                            }
                            PushTrack(Count);
                            TrackUnique2(Branchcountback2);
                        }
                        break;

                    case RegexCode.Branchcount | RegexCode.Back:
                        {
                            const string Count = "tmp1";
                            writer.WriteLine($"{Count} = {PopStack()} - 1; // count");
                            using (EmitBlock(writer, $"if ({Count} >= 0)"))
                            {
                                writer.WriteLine($"runtextpos = {PopStack()};");
                                PushTrack(Count);
                                TrackUnique2(Branchcountback2);
                                Advance();
                            }
                            writer.WriteLine($"{ReadyReplaceStack(0)} = {PopTrack()};");
                            PushStack(Count);
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Branchcount | RegexCode.Back2:
                        {
                            const string Mark = "tmp1";
                            writer.WriteLine($"{Mark} = {PopTrack()}; // mark");
                            PushStack(PopTrack());
                            PushStack(Mark);
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Lazybranchcount:
                        {
                            const string Count = "tmp1";
                            writer.WriteLine($"{Count} = {PopStack()}; // count");
                            PushTrack(PopStack()); // mark
                            using (EmitBlock(writer, $"if ({Count} < 0)"))
                            {
                                PushStack("runtextpos");
                                PushStack($"{Count} + 1");
                                TrackUnique2(Lazybranchcountback2);
                                Goto(Operand(0));
                            }
                            PushTrack(Count);
                            PushTrack("runtextpos");
                            Track();
                        }
                        break;

                    case RegexCode.Lazybranchcount | RegexCode.Back:
                        {
                            const string C = "tmp1";
                            writer.WriteLine($"runtextpos = {PopTrack()};");
                            writer.WriteLine($"{C} = {PopTrack()}; // c");
                            using (EmitBlock(writer, $"if ({C} < {Operand(1)} && runtextpos != {TopTrack()})"))
                            {
                                PushStack("runtextpos");
                                PushStack($"{C} + 1");
                                TrackUnique2(Lazybranchcountback2);
                                Goto(Operand(0));
                            }
                            PushStack(PopTrack());
                            PushStack(C);
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Lazybranchcount | RegexCode.Back2:
                        writer.WriteLine($"{ReadyReplaceStack(1)} = {PopTrack()};");
                        writer.WriteLine($"{ReadyReplaceStack(0)} = {TopStack()} - 1;");
                        ReadyReplaceStack(0);
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Setjump:
                        PushStack("runtrack.Length - runtrackpos");
                        PushStack("base.Crawlpos()");
                        TrackUnique(Stackpop2);
                        break;

                    case RegexCode.Setjump | RegexCode.Back:
                        PopDiscardStack(2);
                        writer.WriteLine($"goto {Backtrack};");
                        break;

                    case RegexCode.Backjump:
                        {
                            const string Stacked = "tmp1";
                            writer.WriteLine($"{Stacked} = {PopStack()}; // stacked");
                            writer.WriteLine($"runtrackpos = runtrack.Length - {PopStack()};");
                            writer.WriteLine($"while (base.Crawlpos() != {Stacked}) base.Uncapture();");
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Forejump:
                        {
                            const string Stacked = "tmp1";
                            writer.WriteLine($"{Stacked} = {PopStack()}; // stacked");
                            writer.WriteLine($"runtrackpos = runtrack.Length - {PopStack()};");
                            PushTrack(Stacked);
                            TrackUnique(Forejumpback);
                        }
                        break;

                    case RegexCode.Forejump | RegexCode.Back:
                        {
                            const string TrackedCrawlpos = "tmp1";
                            writer.WriteLine($"{TrackedCrawlpos} = {PopTrack()}; // tracked crawlpos");
                            writer.WriteLine($"while (base.Crawlpos() != {TrackedCrawlpos}) base.Uncapture();");
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Bol:
                        using (EmitBlock(writer, $"if (runtextpos <= runtextbeg)"))
                        {
                            writer.WriteLine($"goto {labels[NextCodepos()]};");
                        }
                        using (EmitBlock(writer, $"if ({Leftchar()} != '\\n')"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Eol:
                        using (EmitBlock(writer, $"if (runtextpos >= runtextend)"))
                        {
                            writer.WriteLine($"goto {labels[NextCodepos()]};");
                        }
                        using (EmitBlock(writer, $"if ({Rightchar()} != '\\n')"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Boundary:
                    case RegexCode.NonBoundary:
                        using (EmitBlock(writer, $"if ({(Code() == RegexCode.Boundary ? "!" : "")}base.IsBoundary(runtextpos, runtextbeg, runtextend))"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.ECMABoundary:
                    case RegexCode.NonECMABoundary:
                        using (EmitBlock(writer, $"if ({(Code() == RegexCode.ECMABoundary ? "!" : "")}base.IsECMABoundary(runtextpos, runtextbeg, runtextend))"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Beginning:
                        using (EmitBlock(writer, $"if (runtextpos > runtextbeg)"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.Start:
                        using (EmitBlock(writer, $"if (runtextpos != runtextstart)"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.EndZ:
                        using (EmitBlock(writer, $"if (runtextpos < runtextend - 1)"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        using (EmitBlock(writer, $"if (runtextpos >= runtextend)"))
                        {
                            writer.WriteLine($"goto {labels[NextCodepos()]};");
                        }
                        using (EmitBlock(writer, $"if ({Rightchar()} != '\\n')"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.End:
                        using (EmitBlock(writer, $"if (runtextpos < runtextend)"))
                        {
                            writer.WriteLine($"goto {Backtrack};");
                        }
                        break;

                    case RegexCode.One:
                    case RegexCode.Notone:
                    case RegexCode.Set:
                    case RegexCode.One | RegexCode.Rtl:
                    case RegexCode.Notone | RegexCode.Rtl:
                    case RegexCode.Set | RegexCode.Rtl:
                    case RegexCode.One | RegexCode.Ci:
                    case RegexCode.Notone | RegexCode.Ci:
                    case RegexCode.Set | RegexCode.Ci:
                    case RegexCode.One | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Notone | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Set | RegexCode.Ci | RegexCode.Rtl:
                        {
                            string clause;
                            string expr;
                            if (!IsRightToLeft())
                            {
                                clause = $"runtextpos >= runtextend || ";
                                expr = Rightcharnext();
                            }
                            else
                            {
                                clause = $"runtextpos <= runtextbeg || ";
                                expr = Leftcharnext();
                            }

                            clause += Code() == RegexCode.Set ?
                                $"!{MatchCharacterClass(hasTextInfo, options, expr, rm.Code.Strings[Operand(0)], IsCaseInsensitive())}" :
                                $"{ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive() && RegexCharClass.ParticipatesInCaseConversion(Operand(0)))} {(Code() == RegexCode.One ? "!=" : "==")} {Operand(0)}";

                            using (EmitBlock(writer, $"if ({clause})"))
                            {
                                writer.WriteLine($"goto {Backtrack};");
                            }
                        }
                        break;

                    case RegexCode.Multi:
                    case RegexCode.Multi | RegexCode.Ci:
                        {
                            string str = rm.Code.Strings[Operand(0)];
                            Debug.Assert(str.Length != 0);
                            writer.WriteLine($"if (runtextend - runtextpos < {str.Length} ||");
                            for (int i = 0; i < str.Length; i++)
                            {
                                writer.Write($"    {ToLowerIfNeeded(hasTextInfo, options, $"runtext[runtextpos{(i == 0 ? "" : $" + {i}")}]", IsCaseInsensitive() && RegexCharClass.ParticipatesInCaseConversion(str[i]))} != {Literal(str[i])}");
                                writer.WriteLine(i < str.Length - 1 ? " ||" : ")");
                            }
                            using (EmitBlock(writer, null))
                            {
                                writer.WriteLine($"goto {Backtrack};");
                            }
                            writer.WriteLine($"runtextpos += {str.Length};");
                            break;
                        }

                    case RegexCode.Multi | RegexCode.Rtl:
                    case RegexCode.Multi | RegexCode.Ci | RegexCode.Rtl:
                        {
                            string str = rm.Code.Strings[Operand(0)];
                            Debug.Assert(str.Length != 0);
                            writer.WriteLine($"if (runtextpos - runtextbeg < {str.Length} ||");
                            for (int i = str.Length; i > 0;)
                            {
                                i--;
                                writer.Write($"    {ToLowerIfNeeded(hasTextInfo, options, $"runtext[runtextpos - {str.Length - i}]", IsCaseInsensitive() && RegexCharClass.ParticipatesInCaseConversion(str[i]))} != {Literal(str[i])}");
                                writer.WriteLine(i == 0 ? ")" : " ||");
                            }
                            using (EmitBlock(writer, null))
                            {
                                writer.WriteLine($"goto {Backtrack};");
                            }
                            writer.WriteLine($"runtextpos -= {str.Length};");
                            break;
                        }

                    case RegexCode.Ref:
                    case RegexCode.Ref | RegexCode.Ci:
                    case RegexCode.Ref | RegexCode.Rtl:
                    case RegexCode.Ref | RegexCode.Ci | RegexCode.Rtl:
                        {
                            const string Length = "tmp1";
                            const string Index = "tmp2";

                            using (EmitBlock(writer, $"if (!base.IsMatched({Operand(0)}))"))
                            {
                                writer.WriteLine($"goto {((options & RegexOptions.ECMAScript) != 0 ? AdvanceLabel() : Backtrack)};");
                            }

                            writer.WriteLine($"{Length} = base.MatchLength({Operand(0)}); // length");

                            using (EmitBlock(writer, !IsRightToLeft() ? $"if (runtextend - runtextpos < {Length})" : $"if (runtextpos - runtextbeg < {Length})"))
                            {
                                writer.WriteLine($"goto {Backtrack};");
                            }

                            if (!IsRightToLeft())
                            {
                                writer.WriteLine($"{Index} = base.MatchIndex({Operand(0)}) + {Length}; // index");
                                writer.WriteLine($"runtextpos += {Length};");
                            }
                            else
                            {
                                writer.WriteLine($"{Index} = base.MatchIndex({Operand(0)}); // index");
                                writer.WriteLine($"runtextpos -= {Length};");
                            }

                            using (EmitBlock(writer, "while (true)"))
                            {
                                using (EmitBlock(writer, $"if ({Length} <= 0)"))
                                {
                                    writer.WriteLine($"goto {AdvanceLabel()};");
                                }

                                using (EmitBlock(writer, !IsRightToLeft() ?
                                    $"if ({ToLowerIfNeeded(hasTextInfo, options, $"runtext[{Index} - {Length}]", IsCaseInsensitive())} != {ToLowerIfNeeded(hasTextInfo, options, $"runtext[runtextpos - {Length}--]", IsCaseInsensitive())})" :
                                    $"if ({ToLowerIfNeeded(hasTextInfo, options, $"runtext[{Index} + --{Length}]", IsCaseInsensitive())} != {ToLowerIfNeeded(hasTextInfo, options, $"runtext[runtextpos + {Length}]", IsCaseInsensitive())})"))
                                {
                                    writer.WriteLine($"break;");
                                }
                            }

                            writer.WriteLine($"goto {Backtrack};");
                            break;
                        }

                    case RegexCode.Onerep:
                    case RegexCode.Notonerep:
                    case RegexCode.Setrep:
                    case RegexCode.Onerep | RegexCode.Ci:
                    case RegexCode.Notonerep | RegexCode.Ci:
                    case RegexCode.Setrep | RegexCode.Ci:
                        {
                            int c = Operand(1);
                            if (c != 0)
                            {
                                using (EmitBlock(writer, $"if (runtextend - runtextpos < {c})"))
                                {
                                    writer.WriteLine($"goto {Backtrack};");
                                }

                                using (EmitBlock(writer, $"for (int i = 0; i < {c}; i++)"))
                                {
                                    string expr = "runtext[runtextpos + i]";
                                    if (Code() == RegexCode.Setrep)
                                    {
                                        EmitTimeoutCheck(writer, hasTimeout);
                                        expr = $"!{MatchCharacterClass(hasTextInfo, options, expr, rm.Code.Strings[Operand(0)], IsCaseInsensitive())}";
                                    }
                                    else
                                    {
                                        expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive() && RegexCharClass.ParticipatesInCaseConversion(Operand(0)));
                                        expr = $"{expr} {(Code() == RegexCode.Onerep ? "!=" : "==")} {Literal((char)Operand(0))}";
                                    }

                                    using (EmitBlock(writer, $"if ({expr})"))
                                    {
                                        writer.WriteLine($"goto {Backtrack};");
                                    }
                                }
                                writer.WriteLine($"runtextpos += {c};");
                            }
                        }
                        break;

                    case RegexCode.Onerep | RegexCode.Rtl:
                    case RegexCode.Notonerep | RegexCode.Rtl:
                    case RegexCode.Setrep | RegexCode.Rtl:
                    case RegexCode.Onerep | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Notonerep | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Setrep | RegexCode.Ci | RegexCode.Rtl:
                        {
                            int c = Operand(1);
                            if (c != 0)
                            {
                                const string Length = "tmp1";

                                using (EmitBlock(writer, $"if (runtextpos - runtextbeg < {c})"))
                                {
                                    writer.WriteLine($"goto {Backtrack};");
                                }
                                writer.WriteLine($"runtextpos -= {c};");
                                writer.WriteLine($"{Length} = {c}; // length");

                                string l1 = DefineLabel();
                                MarkLabel(l1);

                                string expr = $"runtext[runtextpos + --{Length}]";
                                if (Code() == RegexCode.Setrep)
                                {
                                    EmitTimeoutCheck(writer, hasTimeout);
                                    using (EmitBlock(writer, $"if (!{MatchCharacterClass(hasTextInfo, options, expr, rm.Code.Strings[Operand(0)], IsCaseInsensitive())})"))
                                    {
                                        writer.WriteLine($"goto {Backtrack};");
                                    }
                                }
                                else
                                {
                                    expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive() && RegexCharClass.ParticipatesInCaseConversion(Operand(0)));
                                    string op = Code() == RegexCode.Onerep ? "!=" : "==";
                                    using (EmitBlock(writer, $"if ({expr} {op} {Literal((char)Operand(0))})"))
                                    {
                                        writer.WriteLine($"goto {Backtrack};");
                                    }
                                }

                                using (EmitBlock(writer, $"if ({Length} > 0)"))
                                {
                                    writer.WriteLine($"goto {l1};");
                                }
                            }
                            break;
                        }

                    case RegexCode.Oneloop:
                    case RegexCode.Notoneloop:
                    case RegexCode.Setloop:
                    case RegexCode.Oneloop | RegexCode.Rtl:
                    case RegexCode.Notoneloop | RegexCode.Rtl:
                    case RegexCode.Setloop | RegexCode.Rtl:
                    case RegexCode.Oneloop | RegexCode.Ci:
                    case RegexCode.Notoneloop | RegexCode.Ci:
                    case RegexCode.Setloop | RegexCode.Ci:
                    case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Oneloopatomic:
                    case RegexCode.Notoneloopatomic:
                    case RegexCode.Setloopatomic:
                    case RegexCode.Oneloopatomic | RegexCode.Rtl:
                    case RegexCode.Notoneloopatomic | RegexCode.Rtl:
                    case RegexCode.Setloopatomic | RegexCode.Rtl:
                    case RegexCode.Oneloopatomic | RegexCode.Ci:
                    case RegexCode.Notoneloopatomic | RegexCode.Ci:
                    case RegexCode.Setloopatomic | RegexCode.Ci:
                    case RegexCode.Oneloopatomic | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Notoneloopatomic | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Setloopatomic | RegexCode.Ci | RegexCode.Rtl:
                        {
                            int c = Operand(1);
                            if (c != 0)
                            {
                                const string Len = "tmp1";
                                const string I = "tmp2";

                                if (c == int.MaxValue)
                                {
                                    writer.WriteLine(!IsRightToLeft() ?
                                        $"{Len} = runtextend - runtextpos; // length" :
                                        $"{Len} = runtextpos - runtextbeg; // length");
                                }
                                else
                                {
                                    writer.WriteLine(!IsRightToLeft() ?
                                        $"{Len} = global::System.Math.Min(runtextend - runtextpos, {c}); // length" :
                                        $"{Len} = global::System.Math.Min(runtextpos - runtextbeg, {c}); // length");
                                }

                                string? set = Code() == RegexCode.Setloop || Code() == RegexCode.Setloopatomic ? rm.Code.Strings[Operand(0)] : null;
                                Span<char> setChars = stackalloc char[3];
                                int numSetChars;

                                // If this is a notoneloop{atomic} and we're left-to-right and case-sensitive,
                                // we can use the vectorized IndexOf to search for the target character.
                                if ((Code() == RegexCode.Notoneloop || Code() == RegexCode.Notoneloopatomic) &&
                                    !IsRightToLeft() &&
                                    (!IsCaseInsensitive() || !RegexCharClass.ParticipatesInCaseConversion(Operand(0))))
                                {
                                    writer.WriteLine($"{I} = global::System.MemoryExtensions.IndexOf(global::System.MemoryExtensions.AsSpan(runtext, runtextpos, {Len}), {Literal((char)Operand(0))}); // i");
                                    using (EmitBlock(writer, $"if ({I} == -1)"))
                                    {
                                        writer.WriteLine($"runtextpos += {Len};");
                                        writer.WriteLine($"{I} = 0;");
                                    }
                                    using (EmitBlock(writer, "else"))
                                    {
                                        writer.WriteLine($"runtextpos += {I};");
                                        writer.WriteLine($"{I} = {Len} - {I};");
                                    }
                                }
                                else if ((Code() == RegexCode.Setloop || Code() == RegexCode.Setloopatomic) &&
                                    !IsRightToLeft() &&
                                    !IsCaseInsensitive() &&
                                    (numSetChars = RegexCharClass.GetSetChars(set!, setChars)) > 1 &&
                                    RegexCharClass.IsNegated(set!))
                                {
                                    // Similarly, if this is a setloop{atomic} and we're left-to-right and case-sensitive,
                                    // and if the set contains only 2 or 3 negated chars, we can use the vectorized IndexOfAny
                                    // to search for those chars.

                                    Debug.Assert(numSetChars is 2 or 3);
                                    writer.Write($"{I} = global::System.MemoryExtensions.IndexOfAny(global::System.MemoryExtensions.AsSpan(runtext, runtextpos, {Len}), {Literal(setChars[0])}, {Literal(setChars[1])}");
                                    if (numSetChars == 3)
                                    {
                                        writer.Write($", {Literal(setChars[2])}");
                                    }
                                    writer.WriteLine("); // i");
                                    using (EmitBlock(writer, $"if ({I} == -1)"))
                                    {
                                        writer.WriteLine($"runtextpos += {Len};");
                                        writer.WriteLine($"{I} = 0;");
                                    }
                                    using (EmitBlock(writer, "else"))
                                    {
                                        writer.WriteLine($"runtextpos += {I};");
                                        writer.WriteLine($"{I} = {Len} - {I};");
                                    }
                                }
                                else if ((Code() == RegexCode.Setloop || Code() == RegexCode.Setloopatomic) &&
                                    !IsRightToLeft() &&
                                    set == RegexCharClass.AnyClass)
                                {
                                    // If someone uses .* along with RegexOptions.Singleline, that becomes [anycharacter]*, which means it'll
                                    // consume everything.  As such, we can simply update our position to be the last allowed, without
                                    // actually checking anything.
                                    writer.WriteLine($"runtextpos += {Len};");
                                    writer.WriteLine($"{I} = 0;");
                                }
                                else
                                {
                                    // Otherwise, we emit the open-coded loop.
                                    writer.WriteLine($"{I} = {Len} + 1;");
                                    using (EmitBlock(writer, $"while (--{I} > {0})"))
                                    {
                                        string expr = !IsRightToLeft() ?
                                            Rightcharnext() :
                                            Leftcharnext();

                                        if (Code() == RegexCode.Setloop || Code() == RegexCode.Setloopatomic)
                                        {
                                            EmitTimeoutCheck(writer, hasTimeout);
                                            expr = $"!{MatchCharacterClass(hasTextInfo, options, expr, rm.Code.Strings[Operand(0)], IsCaseInsensitive())}";
                                        }
                                        else
                                        {
                                            string op = Code() == RegexCode.Oneloop || Code() == RegexCode.Oneloopatomic ? "!=" : "==";
                                            expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive() && RegexCharClass.ParticipatesInCaseConversion(Operand(0)));
                                            expr = $"{expr} {op} {Literal((char)Operand(0))}";
                                        }

                                        using (EmitBlock(writer, $"if ({expr})"))
                                        {
                                            writer.WriteLine(!IsRightToLeft() ?
                                                "runtextpos--;" :
                                                "runtextpos++;");
                                            writer.WriteLine("break;");
                                        }
                                    }
                                }

                                if (Code() != RegexCode.Oneloopatomic && Code() != RegexCode.Notoneloopatomic && Code() != RegexCode.Setloopatomic)
                                {
                                    using (EmitBlock(writer, $"if ({I} >= {Len})"))
                                    {
                                        writer.WriteLine($"goto {AdvanceLabel()};");
                                    }
                                    PushTrack($"{Len} - {I} - 1");
                                    PushTrack(!IsRightToLeft() ?
                                        "runtextpos - 1" :
                                        "runtextpos + 1");
                                    Track();
                                }
                            }
                            break;
                        }

                    case RegexCode.Oneloop | RegexCode.Back:
                    case RegexCode.Notoneloop | RegexCode.Back:
                    case RegexCode.Setloop | RegexCode.Back:
                    case RegexCode.Oneloop | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Notoneloop | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Setloop | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Back:
                    case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Back:
                    case RegexCode.Setloop | RegexCode.Ci | RegexCode.Back:
                    case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                        {
                            const string Position = "tmp1";
                            writer.WriteLine($"runtextpos = {PopTrack()};");
                            writer.WriteLine($"{Position} = {PopTrack()}; // position");
                            using (EmitBlock(writer, $"if ({Position} > 0)"))
                            {
                                PushTrack($"{Position} - 1");
                                PushTrack(!IsRightToLeft() ?
                                    "runtextpos - 1" :
                                    "runtextpos + 1");
                                Trackagain();
                            }
                            Advance();
                        }
                        break;

                    case RegexCode.Onelazy:
                    case RegexCode.Notonelazy:
                    case RegexCode.Setlazy:
                    case RegexCode.Onelazy | RegexCode.Rtl:
                    case RegexCode.Notonelazy | RegexCode.Rtl:
                    case RegexCode.Setlazy | RegexCode.Rtl:
                    case RegexCode.Onelazy | RegexCode.Ci:
                    case RegexCode.Notonelazy | RegexCode.Ci:
                    case RegexCode.Setlazy | RegexCode.Ci:
                    case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl:
                    case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl:
                        {
                            int count = Operand(1);
                            if (count != 0)
                            {
                                const string C = "tmp1";
                                if (count == int.MaxValue)
                                {
                                    writer.WriteLine(!IsRightToLeft() ?
                                        $"{C} = runtextend - runtextpos; // count" :
                                        $"{C} = runtextpos - runtextbeg; // count");
                                }
                                else
                                {
                                    writer.WriteLine(!IsRightToLeft() ?
                                        $"{C} = global::System.Math.Min(runtextend - runtextpos, {count}); // count" :
                                        $"{C} = global::System.Math.Min(runtextpos - runtextbeg, {count}); // count");
                                }

                                using (EmitBlock(writer, $"if ({C} <= 0)"))
                                {
                                    writer.WriteLine($"goto {AdvanceLabel()};");
                                }

                                PushTrack($"{C} - 1");
                                PushTrack("runtextpos");
                                Track();
                            }
                            break;
                        }

                    case RegexCode.Onelazy | RegexCode.Back:
                    case RegexCode.Notonelazy | RegexCode.Back:
                    case RegexCode.Setlazy | RegexCode.Back:
                    case RegexCode.Onelazy | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Notonelazy | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Setlazy | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Back:
                    case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Back:
                    case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Back:
                    case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                    case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                        {
                            const string I = "tmp1";

                            writer.WriteLine($"runtextpos = {PopTrack()};");
                            writer.WriteLine($"{I} = {PopTrack()}; // i");

                            string expr = !IsRightToLeft() ?
                                Rightcharnext() :
                                Leftcharnext();

                            if (Code() == RegexCode.Setlazy)
                            {
                                EmitTimeoutCheck(writer, hasTimeout);
                                expr = $"!{MatchCharacterClass(hasTextInfo, options, expr, rm.Code.Strings[Operand(0)], IsCaseInsensitive())}";
                            }
                            else
                            {
                                expr = ToLowerIfNeeded(hasTextInfo, options, expr, IsCaseInsensitive() && RegexCharClass.ParticipatesInCaseConversion(Operand(0)));
                                expr = $"{expr} {(Code() == RegexCode.Onelazy ? "!=" : "==")} {Literal((char)Operand(0))}";
                            }

                            using (EmitBlock(writer, $"if ({expr})"))
                            {
                                writer.WriteLine($"goto {Backtrack};");
                            }

                            using (EmitBlock(writer, $"if ({I} > 0)"))
                            {
                                PushTrack($"{I} - 1");
                                PushTrack("runtextpos");
                                Trackagain();
                            }

                            Advance();
                        }
                        break;

                    default:
                        Debug.Fail($"Unimplemented state: {currentOpcode:X8}");
                        break;
                }
            }



            /// <summary>
            /// Branch to the label corresponding to the regex code at i
            /// </summary>
            /// <remarks>
            /// A trick: since track and stack space is gobbled up unboundedly
            /// only as a result of branching backwards, this is where we check
            /// for sufficient space and trigger reallocations.
            ///
            /// If the "goto" is backwards, we generate code that checks
            /// available space against the amount of space that would be needed
            /// in the worst case by code that will only go forward; if there's
            /// not enough, we push the destination on the tracking stack, then
            /// we jump to the place where we invoke the allocator.
            ///
            /// Since forward gotos pose no threat, they just turn into a Br.
            /// </remarks>
            void Goto(int i)
            {
                // When going backwards, ensure enough space.
                if (i < currentCodePos)
                {
                    using (EmitBlock(writer, $"if (runtrackpos <= {rm.Code.TrackCount * 4} || runstackpos <= {rm.Code.TrackCount * 3})"))
                    {
                        writer.WriteLine($"{ReadyPushTrack()} = {AddGoto(i)};");
                        writer.WriteLine($"goto {Backtrack};");
                    }
                }

                writer.WriteLine($"goto {labels[i]};");
            }

            string ReadyPushTrack() => "runtrack[--runtrackpos]";

            void Track() => PushTrack(AddTrack());

            /// <summary>
            /// Pushes the current switch index on the tracking stack so the backtracking
            /// logic will be repeated again next time we backtrack here.
            /// </summary>
            void Trackagain() => PushTrack(currentBacktrackNote);

            void PushTrack<T>(T expr) => writer.WriteLine($"{ReadyPushTrack()} = {(expr is IFormattable ? ((IFormattable)expr).ToString(null, CultureInfo.InvariantCulture) : expr.ToString())};");

            /// <summary>Retrieves the top entry on the tracking stack without popping.</summary>
            string TopTrack() => "runtrack[runtrackpos]";

            int Operand(int i) => codes[currentCodePos + i + 1];

            /// <summary>True if the current operation is marked for the leftward direction.</summary>
            bool IsRightToLeft() => (currentOpcode & RegexCode.Rtl) != 0;

            /// <summary>True if the current operation is marked for case insensitive operation.</summary>
            bool IsCaseInsensitive() => (currentOpcode & RegexCode.Ci) != 0;

            /// <summary>Returns the raw regex opcode (masking out Back and Rtl).</summary>
            int Code() => currentOpcode & RegexCode.Mask;

            /// <summary>Saves the value of a local variable on the grouping stack.</summary>
            void PushStack<T>(T expr) => writer.WriteLine($"{ReadyPushStack()} = {(expr is IFormattable ? ((IFormattable)expr).ToString(null, CultureInfo.InvariantCulture) : expr.ToString())};");

            string ReadyPushStack() => "runstack[--runstackpos]";

            /// <summary>Retrieves the top entry on the stack without popping.</summary>
            string TopStack() => "runstack[runstackpos]";

            void TrackUnique(int i) => PushTrack(AddUniqueTrack(i));

            void TrackUnique2(int i) => PushTrack(AddUniqueTrack(i, RegexCode.Back2));

            int AddUniqueTrack(int i, int flags = RegexCode.Back)
            {
                if (uniqueNote[i] == -1)
                {
                    uniqueNote[i] = AddTrack(flags);
                }

                return uniqueNote[i];
            }

            /// <summary>
            /// Returns the position of the next operation in the regex code, taking
            /// into account the different numbers of arguments taken by operations
            /// </summary>
            int NextCodepos() => currentCodePos + RegexCode.OpcodeSize(codes[currentCodePos]);

            /// <summary>The label for the next (forward) operation.</summary>
            string AdvanceLabel() => labels![NextCodepos()];

            /// <summary>Goto the next (forward) operation.</summary>
            void Advance() => writer.WriteLine($"goto {AdvanceLabel()};");

            /// <summary>Loads the char to the left of the current position.</summary>
            string Leftchar() => "runtext[runtextpos - 1]";

            /// <summary>Loads the char to the left of the current position and advances (leftward).</summary>
            string Leftcharnext() => "runtext[--runtextpos]";

            /// <summary>Loads the char to the right of the current position.</summary>
            string Rightchar() => "runtext[runtextpos]";

            /// <summary>Loads the char to the right of the current position and advances the current position.</summary>
            string Rightcharnext() => "runtext[runtextpos++]";

            /// <summary>
            /// Adds a backtrack note to the list of them, and returns the index of the new
            /// note (which is also the index for the jump used by the switch table)
            /// </summary>
            int AddBacktrackNote(int flags, string l, int codepos)
            {
                if (notes == null || noteCount >= notes.Length)
                {
                    var newnotes = new BacktrackNote[notes == null ? 16 : notes.Length * 2];
                    if (notes != null)
                    {
                        Array.Copy(notes, newnotes, noteCount);
                    }
                    notes = newnotes;
                }

                notes[noteCount] = new BacktrackNote(flags, l, codepos);
                return noteCount++;
            }

            /// <summary>
            /// Adds a backtrack note for the current operation; creates a new label for
            /// where the code will be, and returns the switch index.
            /// </summary>
            int AddTrack(int flags = RegexCode.Back) => AddBacktrackNote(flags, DefineLabel(), currentCodePos);

            int AddGoto(int destpos)
            {
                if (forwardJumpsThroughSwitch[destpos] == -1)
                {
                    forwardJumpsThroughSwitch[destpos] = AddBacktrackNote(0, labels![destpos], destpos);
                }

                return forwardJumpsThroughSwitch[destpos];
            }

            /// <summary>Pops an element off the tracking stack.</summary>
            string PopTrack() => "runtrack[runtrackpos++]";

            /// <summary>Pops an element off the grouping stack (leave it on the operand stack).</summary>
            string PopStack() => "runstack[runstackpos++]";

            /// <summary>Pops i elements off the grouping stack and discards them.</summary>
            void PopDiscardStack(int i = 1) => writer.WriteLine(i == 1 ? "runstackpos++;" : $"runstackpos += {i};");

            /// <summary>Prologue to code that will replace the ith element on the grouping stack.</summary>
            string ReadyReplaceStack(int i) => i == 0 ? "runstack[runstackpos]" : $"runstack[runstackpos + {i}]";
        }

        /// <summary>
        /// Keeps track of an operation that needs to be referenced in the backtrack-jump
        /// switch table, and that needs backtracking code to be emitted (if flags != 0)
        /// </summary>
        private record BacktrackNote(int flags, string label, int codepos);

        private static bool EmitLoopTimeoutCounterIfNeeded(IndentedTextWriter writer, RegexMethod rm)
        {
            if (rm.MatchTimeout.HasValue && rm.MatchTimeout.Value != Timeout.Infinite)
            {
                writer.WriteLine("int loopTimeoutCounter = 0;");
                return true;
            }

            return false;
        }

        /// <summary>Emits a timeout check.</summary>
        private static void EmitTimeoutCheck(IndentedTextWriter writer, bool hasTimeout)
        {
            const int LoopTimeoutCheckCount = 2048; // A conservative value to guarantee the correct timeout handling.
            if (hasTimeout)
            {
                // Increment counter for each loop iteration.
                // Emit code to check the timeout every 2048th iteration.
                using (EmitBlock(writer, $"if (++loopTimeoutCounter == {LoopTimeoutCheckCount})"))
                {
                    writer.WriteLine("loopTimeoutCounter = 0;");
                    writer.WriteLine("base.CheckTimeout();");
                }
                writer.WriteLine();
            }
        }

        private static bool EmitInitializeCultureForGoIfNecessary(IndentedTextWriter writer, RegexMethod rm)
        {
            if (((RegexOptions)rm.Options & RegexOptions.CultureInvariant) == 0)
            {
                bool needsCulture = ((RegexOptions)rm.Options & RegexOptions.IgnoreCase) != 0;
                if (!needsCulture)
                {
                    int[] codes = rm.Code.Codes;
                    for (int codepos = 0; codepos < codes.Length; codepos += RegexCode.OpcodeSize(codes[codepos]))
                    {
                        if ((codes[codepos] & RegexCode.Ci) == RegexCode.Ci)
                        {
                            needsCulture = true;
                            break;
                        }
                    }
                }

                if (needsCulture)
                {
                    writer.WriteLine("global::System.Globalization.TextInfo textInfo = global::System.Globalization.CultureInfo.CurrentCulture.TextInfo;");
                    return true;
                }
            }

            return false;
        }

        private static bool UseToLowerInvariant(bool hasTextInfo, RegexOptions options) => !hasTextInfo || (options & RegexOptions.CultureInvariant) != 0;

        private static string ToLower(bool hasTextInfo, RegexOptions options, string expression) => UseToLowerInvariant(hasTextInfo, options) ? $"char.ToLowerInvariant({expression})" : $"textInfo.ToLower({expression})";

        private static string ToLowerIfNeeded(bool hasTextInfo, RegexOptions options, string expression, bool toLower) => toLower ? ToLower(hasTextInfo, options, expression) : expression;

        private static void EmitTextInfoIfRequired(IndentedTextWriter writer, ref bool textInfoEmitted, ref bool hasTextInfo, RegexMethod rm)
        {
            if (textInfoEmitted)
            {
                return;
            }
            textInfoEmitted = true;

            // Emit local to store current culture if needed
            if ((((RegexOptions)rm.Options) & RegexOptions.CultureInvariant) == 0)
            {
                bool needsCulture = (((RegexOptions)rm.Options) & RegexOptions.IgnoreCase) != 0 || rm.Code.BoyerMoorePrefix?.CaseInsensitive == true;
                if (!needsCulture && rm.Code.LeadingCharClasses is not null)
                {
                    for (int i = 0; i < rm.Code.LeadingCharClasses.Length; i++)
                    {
                        if (rm.Code.LeadingCharClasses[i].CaseInsensitive)
                        {
                            needsCulture = true;
                            break;
                        }
                    }
                }

                if (needsCulture)
                {
                    hasTextInfo = true;
                    writer.WriteLine("// IgnoreCase with CultureInfo.CurrentCulture");
                    writer.WriteLine("global::System.Globalization.TextInfo textInfo = global::System.Globalization.CultureInfo.CurrentCulture.TextInfo;");
                    writer.WriteLine();
                }
            }
        }

        private static string MatchCharacterClass(bool hasTextInfo, RegexOptions options, string chExpr, string charClass, bool caseInsensitive)
        {
            // We need to perform the equivalent of calling RegexRunner.CharInClass(ch, charClass),
            // but that call is relatively expensive.  Before we fall back to it, we try to optimize
            // some common cases for which we can do much better, such as known character classes
            // for which we can call a dedicated method, or a fast-path for ASCII using a lookup table.

            // First, see if the char class is a built-in one for which there's a better function
            // we can just call directly.  Everything in this section must work correctly for both
            // case-sensitive and case-insensitive modes, regardless of culture.
            switch (charClass)
            {
                case RegexCharClass.AnyClass:
                    // ideally this could just be "return true;", but we need to evaluate the expression for its side effects
                    return $"({chExpr} != -1)"; // a char is unsigned and thus won't ever be equal to -1, so this is equivalent to true

                case RegexCharClass.DigitClass:
                    return $"char.IsDigit({chExpr})";

                case RegexCharClass.NotDigitClass:
                    return $"!char.IsDigit({chExpr})";

                case RegexCharClass.SpaceClass:
                    return $"char.IsWhiteSpace({chExpr})";

                case RegexCharClass.NotSpaceClass:
                    return $"!char.IsWhiteSpace({chExpr})";
            }

            // If we're meant to be doing a case-insensitive lookup, and if we're not using the invariant culture,
            // lowercase the input.  If we're using the invariant culture, we may still end up calling ToLower later
            // on, but we may also be able to avoid it, in particular in the case of our lookup table, where we can
            // generate the lookup table already factoring in the invariant case sensitivity.  There are multiple
            // special-code paths between here and the lookup table, but we only take those if invariant is false;
            // if it were true, they'd need to use CallToLower().
            bool invariant = false;
            if (caseInsensitive)
            {
                invariant = UseToLowerInvariant(hasTextInfo, options);
                if (!invariant)
                {
                    chExpr = ToLower(hasTextInfo, options, chExpr);
                }
            }

            // Next, handle simple sets of one range, e.g. [A-Z], [0-9], etc.  This includes some built-in classes, like ECMADigitClass.
            if (!invariant && RegexCharClass.TryGetSingleRange(charClass, out char lowInclusive, out char highInclusive))
            {
                bool invert = RegexCharClass.IsNegated(charClass);
                if (lowInclusive == highInclusive)
                {
                    chExpr = $"({chExpr} {(invert ? "!=" : "==")} {Literal(lowInclusive)})";
                }
                else
                {
                    chExpr = $"(((uint){chExpr}) - {Literal(lowInclusive)} {(invert ? ">=" : "<")} (uint){highInclusive - lowInclusive + 1})";
                }

                return chExpr;
            }

            // Next if the character class contains nothing but a single Unicode category, we can calle char.GetUnicodeCategory and
            // compare against it.  It has a fast-lookup path for ASCII, so is as good or better than any lookup we'd generate (plus
            // we get smaller code), and it's what we'd do for the fallback (which we get to avoid generating) as part of CharInClass.
            if (!invariant && RegexCharClass.TryGetSingleUnicodeCategory(charClass, out UnicodeCategory category, out bool negated))
            {
                return $"(char.GetUnicodeCategory({chExpr}) {(negated ? "!=" : "==")} global::System.Globalization.UnicodeCategory.{category})";
            }

            // Next, if there's only 2 or 3 chars in the set (fairly common due to the sets we create for prefixes),
            // it's cheaper and smaller to compare against each than it is to use a lookup table.
            if (!invariant)
            {
                Span<char> setChars = stackalloc char[3];
                int numChars = RegexCharClass.GetSetChars(charClass, setChars);
                if (!RegexCharClass.IsNegated(charClass))
                {
                    switch (numChars)
                    {
                        case 2:
                            return $"(((ch = {chExpr}) == {Literal(setChars[0])}) | (ch == {Literal(setChars[1])}))";

                        case 3:
                            return $"(((ch = {chExpr}) == {Literal(setChars[0])}) | (ch == {Literal(setChars[1])}) | (ch == {Literal(setChars[2])}))";
                    }
                }
            }

            // Analyze the character set more to determine what code to generate.
            RegexCharClass.CharClassAnalysisResults analysis = RegexCharClass.Analyze(charClass);

            if (!invariant) // if we're being asked to do a case insensitive, invariant comparison, use the lookup table
            {
                if (analysis.ContainsNoAscii)
                {
                    // We determined that the character class contains only non-ASCII,
                    // for example if the class were [\p{IsGreek}\p{IsGreekExtended}], which is
                    // the same as [\u0370-\u03FF\u1F00-1FFF]. (In the future, we could possibly
                    // extend the analysis to produce a known lower-bound and compare against
                    // that rather than always using 128 as the pivot point.)
                    return invariant ?
                        $"((ch = {chExpr}) >= 128 && global::System.Text.RegularExpressions.RegexRunner.CharInClass(char.ToLowerInvariant((char)ch), {Literal(charClass)}))" :
                        $"((ch = {chExpr}) >= 128 && global::System.Text.RegularExpressions.RegexRunner.CharInClass((char)ch, {Literal(charClass)}))";
                }

                if (analysis.AllAsciiContained)
                {
                    // We determined that every ASCII character is in the class, for example
                    // if the class were the negated example from case 1 above:
                    // [^\p{IsGreek}\p{IsGreekExtended}].
                    return invariant ?
                        $"((ch = {chExpr}) < 128 || global::System.Text.RegularExpressions.RegexRunner.CharInClass(char.ToLowerInvariant((char)ch), {Literal(charClass)}))" :
                        $"((ch = {chExpr}) < 128 || global::System.Text.RegularExpressions.RegexRunner.CharInClass((char)ch, {Literal(charClass)}))";
                }
            }

            // Now, our big hammer is to generate a lookup table that lets us quickly index by character into a yes/no
            // answer as to whether the character is in the target character class.  However, we don't want to store
            // a lookup table for every possible character for every character class in the regular expression; at one
            // bit for each of 65K characters, that would be an 8K bitmap per character class.  Instead, we handle the
            // common case of ASCII input via such a lookup table, which at one bit for each of 128 characters is only
            // 16 bytes per character class.  We of course still need to be able to handle inputs that aren't ASCII, so
            // we check the input against 128, and have a fallback if the input is >= to it.  Determining the right
            // fallback could itself be expensive.  For example, if it's possible that a value >= 128 could match the
            // character class, we output a call to RegexRunner.CharInClass, but we don't want to have to enumerate the
            // entire character class evaluating every character against it, just to determine whether it's a match.
            // Instead, we employ some quick heuristics that will always ensure we provide a correct answer even if
            // we could have sometimes generated better code to give that answer.

            // Generate the lookup table to store 128 answers as bits. We use a const string instead of a byte[] / static
            // data property because it lets IL emit handle all the details for us.
            string bitVectorString = StringExtensions.Create(8, (charClass, invariant), static (dest, state) => // String length is 8 chars == 16 bytes == 128 bits.
            {
                for (int i = 0; i < 128; i++)
                {
                    char c = (char)i;
                    bool isSet = state.invariant ?
                        RegexCharClass.CharInClass(char.ToLowerInvariant(c), state.charClass) :
                        RegexCharClass.CharInClass(c, state.charClass);
                    if (isSet)
                    {
                        dest[i >> 4] |= (char)(1 << (i & 0xF));
                    }
                }
            });

            // We determined that the character class may contain ASCII, so we
            // output the lookup against the lookup table.

            if (analysis.ContainsOnlyAscii)
            {
                // We know that all inputs that could match are ASCII, for example if the
                // character class were [A-Za-z0-9], so since the ch is now known to be >= 128, we
                // can just fail the comparison.
                return $"((ch = {chExpr}) < 128 && ({Literal(bitVectorString)}[ch >> 4] & (1 << (ch & 0xF))) != 0)";
            }

            if (analysis.AllNonAsciiContained)
            {
                // We know that all non-ASCII inputs match, for example if the character
                // class were [^\r\n], so since we just determined the ch to be >= 128, we can just
                // give back success.
                return $"((ch = {chExpr}) >= 128 || ({Literal(bitVectorString)}[ch >> 4] & (1 << (ch & 0xF))) != 0)";
            }

            // We know that the whole class wasn't ASCII, and we don't know anything about the non-ASCII
            // characters other than that some might be included, for example if the character class
            // were [\w\d], so since ch >= 128, we need to fall back to calling CharInClass.
            return invariant ?
                $"((ch = {chExpr}) < 128 ? ({Literal(bitVectorString)}[ch >> 4] & (1 << (ch & 0xF))) != 0 : CharInClass(char.ToLowerInvariant((char)ch), {Literal(charClass)}))" :
                $"((ch = {chExpr}) < 128 ? ({Literal(bitVectorString)}[ch >> 4] & (1 << (ch & 0xF))) != 0 : CharInClass((char)ch, {Literal(charClass)}))";
        }

        private static string Literal(char c) => SymbolDisplay.FormatLiteral(c, quote: true);

        private static string Literal(string s) => SymbolDisplay.FormatLiteral(s, quote: true);

        private static FinishEmitScope EmitScope(IndentedTextWriter writer, string title) => EmitBlock(writer, $"// {title}", appendBlankLine: true);

        private static FinishEmitScope EmitBlock(IndentedTextWriter writer, string? clause, bool appendBlankLine = false)
        {
            if (clause is not null)
            {
                writer.WriteLine(clause);
            }
            writer.WriteLine("{");
            writer.Indent++;
            return new FinishEmitScope(writer, appendBlankLine);
        }

        private readonly struct FinishEmitScope : IDisposable
        {
            private readonly IndentedTextWriter _writer;
            private readonly bool _appendBlankLine;

            public FinishEmitScope(IndentedTextWriter writer, bool appendBlankLine)
            {
                _writer = writer;
                _appendBlankLine = appendBlankLine;
            }

            public void Dispose()
            {
                if (_writer is not null)
                {
                    _writer.Indent--;
                    _writer.WriteLine("}");
                    if (_appendBlankLine)
                    {
                        _writer.WriteLine();
                    }
                }
            }
        }
    }
}
