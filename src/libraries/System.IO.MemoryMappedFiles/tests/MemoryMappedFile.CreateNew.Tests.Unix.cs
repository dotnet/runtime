// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using Microsoft.Win32.SafeHandles;
using Xunit;

namespace System.IO.MemoryMappedFiles.Tests
{
    public partial class MemoryMappedFileTests_CreateNew : MemoryMappedFilesTestBase
    {
        [Theory]
        [InlineData("/1dotnet/test1")] // contains '/'
        [InlineData("/dotnet/test/")] // ends with '/' (in theory could suggest a directory)
        [InlineData("/dotnet+test")] // contains '+'
        [InlineData("/dotnet1+test+")] // ends with '+'
        [InlineData("/dotnet1+/+test+/")] // combination of
        public void ShmOpenAcceptsAllCharactersUsedByBase64Encoding(string mapName)
        {
            // The POSIX shared memory object name must begin with '/' and beside it's max length, that is all we know.
            // The name is generated by MemoryMappedFile implementation and the user must pass null as map name on Unix.
            // So we can't use the public API surface to test the behaviour for specific map names.
            // The name is random, so there is no guarantee whether it's going to contain given characters or not.
            // Base64 encoding uses a-Z, 0-9, '/' and '+' characters.
            // The purpose of this test it to check whether the generated map name can contain '+' and more than one '/'.

            Interop.Sys.OpenFlags flags = Interop.Sys.OpenFlags.O_RDWR | Interop.Sys.OpenFlags.O_CREAT | Interop.Sys.OpenFlags.O_EXCL;
            Interop.Sys.Permissions perms = Interop.Sys.Permissions.S_IWUSR;

            using SafeFileHandle fd = Interop.Sys.ShmOpen(mapName, flags, (int)perms);
            if (fd.IsInvalid)
            {
                Interop.ErrorInfo errorInfo = Interop.Sys.GetLastErrorInfo();
                Assert.Equal(Interop.Error.ENOTSUP, errorInfo.Error); // it's not supported everywhere
            }

            Interop.Sys.ShmUnlink(mapName);
        }
    }
}
