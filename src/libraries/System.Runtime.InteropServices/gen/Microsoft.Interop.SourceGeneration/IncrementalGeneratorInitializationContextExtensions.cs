// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Microsoft.Interop
{
    public static class IncrementalGeneratorInitializationContextExtensions
    {
        // This type is a record to get the generated equality and hashing operators
        // which will be faster than the reflection-based ones.
        private record struct TargetFrameworkSettings
        {
            public TargetFrameworkSettings(AnalyzerConfigOptions options)
            {
                options.TryGetValue("build_property.TargetFrameworkIdentifier", out string? frameworkIdentifier);
                Identifier = frameworkIdentifier;
                options.TryGetValue("build_property.TargetFrameworkVersion", out string? version);
                // TargetFrameworkVersion starts with a 'v'.
                Version = version is not null ? Version.Parse(version.Substring(1)) : null;
            }

            public string? Identifier { get; init; }

            public Version? Version { get; init; }
        }

        private static readonly Version FirstNonCoreVersion = new(5, 0);

        public static IncrementalValueProvider<StubEnvironment> CreateStubEnvironmentProvider(this IncrementalGeneratorInitializationContext context)
        {
            // PERF: With the .NET SDK, this path is equivalent to calling CompilationExtensions.CreateStubEnvironment.
            // However, using the compilation here has been known to cause perf issues, so instead we'll use MSBuild properties
            // and directly inferring from syntax the information we need to calculate for the StubEnvironment object
            // and only include the compilation after all of that is already done.
            var tfmVersion = context.AnalyzerConfigOptionsProvider
                .Select((options, ct) => new TargetFrameworkSettings(options.GlobalOptions))
                .Select((tfm, ct) => (TargetFramework: tfm.Identifier switch
                {
                    ".NETStandard" => TargetFramework.Standard,
                    ".NETCoreApp" when tfm.Version is not null && tfm.Version < FirstNonCoreVersion => TargetFramework.Core,
                    ".NETCoreApp" => TargetFramework.Net,
                    _ => TargetFramework.Framework
                }, tfm.Version));

            var isModuleSkipLocalsInit = context.SyntaxProvider.ForAttributeWithMetadataName(
                TypeNames.System_Runtime_CompilerServices_SkipLocalsInitAttribute,
                (node, ct) => node is ICompilationUnitSyntax,
                // If SkipLocalsInit is applied at the top level, it is either applied to the module
                // or is invalid syntax. As a result, we just need to know if there's any top-level
                // SkipLocalsInit attributes. So the result we return here is meaningless.
                (context, ct) => true)
                .Collect()
                .Select((topLevelAttrs, ct) => !topLevelAttrs.IsEmpty);

            return tfmVersion
                .Combine(isModuleSkipLocalsInit)
                .Combine(context.CompilationProvider)
                .Select((data, ct) =>
                    new StubEnvironment(data.Right, data.Left.Left.TargetFramework, data.Left.Left.Version, data.Left.Right));
        }

        public static void RegisterDiagnostics(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Diagnostic> diagnostics)
        {
            context.RegisterSourceOutput(diagnostics, (context, diagnostic) =>
            {
                context.ReportDiagnostic(diagnostic);
            });
        }

        public static void RegisterConcatenatedSyntaxOutputs<TNode>(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<TNode> nodes, string fileName)
            where TNode : SyntaxNode
        {
            IncrementalValueProvider<ImmutableArray<string>> generatedMethods = nodes
                .Select(
                    static (node, ct) => node.NormalizeWhitespace().ToFullString())
                .Collect();

            context.RegisterSourceOutput(generatedMethods,
                (context, generatedSources) =>
                {
                    // Don't generate a file if we don't have to, to avoid the extra IDE overhead once we have generated
                    // files in play.
                    if (generatedSources.IsEmpty)
                        return;

                    StringBuilder source = new();
                    // Mark in source that the file is auto-generated.
                    source.AppendLine("// <auto-generated/>");
                    foreach (string generated in generatedSources)
                    {
                        source.AppendLine(generated);
                    }

                    // Once https://github.com/dotnet/roslyn/issues/61326 is resolved, we can avoid the ToString() here.
                    context.AddSource(fileName, source.ToString());
                });
        }
    }
}
