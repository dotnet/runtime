<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
    <body>
      <trans-unit id="AddGeneratedComClassAddUnsafe">
        <source>Add 'GeneratedComClassAttribute' to enable passing objects of this type to COM and allow unsafe code</source>
        <target state="translated">新增 'GeneratedComClassAttribute' 以啟用將此類型的物件傳遞至 COM 並允許不安全的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="AddGeneratedComClassAttributeDescription">
        <source>This type implements at least one type with the 'GeneratedComInterfaceAttribute' attribute. Add the 'GeneratedComClassAttribute' to enable passing this type to COM and exposing the COM interfaces for the types with the 'GeneratedComInterfaceAttribute' from objects of this type.</source>
        <target state="translated">此類型至少實作一個具有 'GeneratedComInterfaceAttribute' 屬性的類型。新增 'GeneratedComClassAttribute' 以啟用將此類型傳遞到 COM，並公開具有此類型物件之 'GeneratedComInterfaceAttribute' 類型的 COM 介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddGeneratedComClassAttributeMessage">
        <source>Add the 'GeneratedComClassAttribute' to '{0}' to enable passing objects of type '{0}' to COM</source>
        <target state="translated">將 'GeneratedComClassAttribute' 新增至 '{0}' 以啟用將類型 '{0}' 的物件傳遞至 COM</target>
        <note />
      </trans-unit>
      <trans-unit id="AddGeneratedComClassAttributeTitle">
        <source>Add 'GeneratedComClassAttribute' to enable passing objects of this type to COM</source>
        <target state="translated">新增 'GeneratedComClassAttribute' 以啟用將此類型的物件傳遞至 COM</target>
        <note />
      </trans-unit>
      <trans-unit id="AddMissingCustomTypeMarshallerMembers">
        <source>Add missing custom type marshaller members</source>
        <target state="translated">新增遺漏的自訂類型排列器成員</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedDescription">
        <source>The analysis required to generate code for this interface or method has failed due to an unexpected code pattern. If you are using new or unconventional syntax, consider using other syntax.</source>
        <target state="translated">產生此介面或方法程式碼所需的分析失敗，因為有未預期的程式碼模式。如果您使用的是新語法或非常規語法，請考慮使用其他語法。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedInterfaceMessage">
        <source>Analysis of interface '{0}' has failed. ComInterfaceGenerator will not generate code for this interface.</source>
        <target state="translated">介面 '{0}' 分析失敗。ComInterfaceGenerator 不會產生此介面的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedMethodMessage">
        <source>Analysis of method '{0}' has failed. ComInterfaceGenerator will not generate code for this method.</source>
        <target state="translated">方法 '{0}' 分析失敗。ComInterfaceGenerator 不會產生此方法的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedTitle">
        <source>Analysis for COM interface generation has failed.</source>
        <target state="translated">COM 介面產生的分析失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArraySizeMustBeSpecified">
        <source>Marshalling an array from unmanaged to managed requires either the 'SizeParamIndex' or 'SizeConst' fields to be set on a 'MarshalAsAttribute' or the 'ConstantElementCount' or 'CountElementName' properties to be set on a 'MarshalUsingAttribute'.</source>
        <target state="translated">將數組從未受管理排列到受管理，需要在 'MarshalUsingAttribute' 上設定 'SizeParamIndex' 或 'SizeConst' 字段，或在 'MarshalUsingAttribute' 上設定 'ConstantElementCount' 或 'CountElementName' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceCannotBeGeneratedDescription">
        <source>COM interface source generation requires all base COM interfaces to be valid interfaces. Fix any issues on the base interface to resolve this diagnostic.</source>
        <target state="translated">產生 COM 介面來源要求所有基底 COM 介面都必須是有效的介面。請修正基底介面上的任何問題，以解決此診斷。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceCannotBeGeneratedMessage">
        <source>COM interface {0} inherits from {1}, which has errors. ComInterfaceGenerator will not generate source for {0}.</source>
        <target state="translated">COM 介面 {0} 繼承自有錯誤的 {1}。ComInterfaceGenerator 不會產生 {0} 的來源。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceCannotBeGeneratedTitle">
        <source>The base COM interface failed to generate source. Code will not be generated for this interface.</source>
        <target state="translated">基底 COM 介面無法產生來源。將不會產生此介面的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceMustGenerateAtLeastSameWrappers">
        <source>A 'GeneratedComInterface' cannot specify 'ComInterfaceOptions.ManagedObjectWrapper' or 'ComInterfaceOptions.ComObjectWrapper' unless the base interface type did not specify options or specified at least the same options.</source>
        <target state="translated">除非基本介面類型未指定選項或至少指定了相同的選項，否則 'GeneratedComInterface' 不能指定 'ComInterfaceOptions.ManagedObjectWrapper' 或 'ComInterfaceOptions.ComObjectWrapper'。</target>
        <note />
      </trans-unit>
      <trans-unit id="BidirectionalMissingRequiredMarshaller">
        <source>The specified parameter needs to be marshalled from managed to unmanaged and unmanaged to managed, but the marshaller type '{0}' does not support it.</source>
        <target state="translated">指定的參數必須從受控封送處理到非受控，以及從非受控封送處理到受控，但封送處理程式類型 '{0}' 不支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing a 'FromManaged' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">當透過提供在封送處理器類型上採用 'Span&lt;T&gt;' 的 'FromManaged' 方法來使用 'Managed to Unmanaged with Caller-Allocated Buffer' 圖形時，該類型必須提供靜態 'BufferSize' 屬性以提供 caller-allocated 緩衝區中的元素數字。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has a FromManaged method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">封送處理器類型 '{0}' 必須有靜態唯讀 'int' 'BufferSize' 屬性，以指定 caller-allocated 緩衝區的大小，因為它具有採用 caller-allocated 'Span&lt;{1}&gt;' 的 FromManaged 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportDescription">
        <source>The generated 'DllImportAttribute' will not have a value corresponding to '{0}'.</source>
        <target state="translated">產生的 'DllImportAttribute' 將不會有對應至 '{0}' 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportMessage">
        <source>'{0}' has no equivalent in 'DllImportAttribute' and will not be forwarded</source>
        <target state="translated">'{0}'在 'DllImportAttribute' 中没有相等項目，將不會轉寄</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportTitle">
        <source>Specified 'LibraryImportAttribute' arguments cannot be forwarded to 'DllImportAttribute'</source>
        <target state="translated">指定的 'LibraryImportAttribute' 自變量無法轉送到 'DllImportAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="CastsBetweenRuntimeComAndSourceGeneratedComNotSupportedDescription">
        <source>Casting between a 'ComImport' type and a source-generated COM type is not supported and will fail at runtime</source>
        <target state="translated">不支援在 'ComImport' 類型與來源產生的 COM 類型之間轉換,且將在執行階段失敗</target>
        <note />
      </trans-unit>
      <trans-unit id="CastsBetweenRuntimeComAndSourceGeneratedComNotSupportedMessage">
        <source>Casting between a 'ComImport' type and a source-generated COM type is not supported</source>
        <target state="translated">不支援在 'ComImport' 類型與來源產生的 COM 類型之間轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="CastsBetweenRuntimeComAndSourceGeneratedComNotSupportedTitle">
        <source>Casting between a 'ComImport' type and a source-generated COM type is not supported</source>
        <target state="translated">不支援在 'ComImport' 類型與來源產生的 COM 類型之間轉換</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassDoesNotImplementAnyGeneratedComInterfacesDescription">
        <source>A class with 'GeneratedComClassAttribute' must implement at least one interface with 'GeneratedComInterfaceAttribute' or else the generated code with not have an effect.</source>
        <target state="translated">具有 'GeneratedComClassAttribute' 的類別必須使用 'GeneratedComInterfaceAttribute' 來實作至少一個介面，否則產生的程式碼將沒有效果。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassDoesNotImplementAnyGeneratedComInterfacesMessage">
        <source>Class '{0}' with 'GeneratedComClassAttribute' does not implement any interfaces with 'GeneratedComInterfaceAttribute'. Source will not be generated for '{0}'.</source>
        <target state="translated">具有 'GeneratedComClassAttribute' 的類別 '{0}' 未使用 'GeneratedComInterfaceAttribute' 來實作任何介面。將不會為 '{0}' 產生來源。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionSizeParamTypeMustBeIntegral">
        <source>The specified collection size parameter for an collection must be an integer type. If the size information is applied to a nested collection, the size parameter must be a collection of one less level of nesting with an integral element.</source>
        <target state="translated">為集合指定的集合大小參數必須是整數類型。如果大小資訊套用至巢狀集合，大小參數必須是少於一層巢狀元素的集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComHostingDoesNotSupportGeneratedComInterfaceDescription">
        <source>.NET COM hosting with 'EnableComHosting' only supports built-in COM interop. It does not support source-generated COM interop with 'GeneratedComInterfaceAttribute'.</source>
        <target state="translated">以 'EnableComHosting' 裝載的 .NET COM 僅支援內建 COM Interop。它並不支援使用 'GeneratedComInterfaceAttribute'來源產生的 COM Interop。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComHostingDoesNotSupportGeneratedComInterfaceMessage">
        <source>.NET COM hosting with 'EnableComHosting' does not support interfaces with the 'GeneratedComInterfaceAttribute'. Change any COM exposed interfaces implemented by '{0}' to use the 'System.Runtime.InteropServices.ComVisibleAttribute' instead</source>
        <target state="translated">以 'EnableComHosting' 裝載的 .NET COM 不支援具有 'GeneratedComInterfaceAttribute' 的介面。變更 '{0}' 實作的任何 COM 公開介面，以改為使用 'System.Runtime.InteropServices.ComVisibleAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ComHostingDoesNotSupportGeneratedComInterfaceTitle">
        <source>.NET COM hosting with 'EnableComHosting' does not support interfaces with the 'GeneratedComInterfaceAttribute'</source>
        <target state="translated">以 'EnableComHosting' 裝載的 .NET COM 不支援具有 'GeneratedComInterfaceAttribute' 的介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ComInterfaceUsageDoesNotFollowBestPracticesMessageWithDetails">
        <source>The usage of 'GeneratedComInterfaceAttribute' does not follow recommendations. {0}</source>
        <target state="translated">'GeneratedComInterfaceAttribute' 的使用方式未遵循建議。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ComInterfaceUsageDoesNotFollowBestPracticesTitle">
        <source>The usage of 'GeneratedComInterfaceAttribute' does not follow recommendations.</source>
        <target state="translated">'GeneratedComInterfaceAttribute' 的使用方式未遵循建議。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComMethodReturningIntWillBeOutParameterMessage">
        <source>The return value in the managed definition will be converted to an 'out' parameter when calling the unmanaged COM method. If the return value is intended to be the HRESULT code returned by the unmanaged COM method, use '[PreserveSig]' on the method.</source>
        <target state="translated">呼叫未受控 COM 方法時，受控定義中的傳回值將轉換為 'out' 參數。如果傳回值預期是未受控 COM 方法傳回的 HRESULT 代碼，請在方法上使用 '[PreserveSig]'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComMethodReturningIntWillBeOutParameterTitle">
        <source>The return value in the managed definition will be converted to an additional 'out' parameter at the end of the parameter list when calling the unmanaged COM method.</source>
        <target state="translated">呼叫未受控 COM 方法時，受控定義中的傳回值將在參數清單尾端轉換為額外的 'out' 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedDescriptionCom">
        <source>Source-generated COM will ignore any configuration that is not supported.</source>
        <target state="translated">来源產生的 COM 將會略過任何不支援的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedDescriptionLibraryImport">
        <source>Source-generated P/Invokes will ignore any configuration that is not supported.</source>
        <target state="translated">来源產生的 P/Invokes 將會忽略任何不支援的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageCom">
        <source>The '{0}' configuration is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">來源產生的 COM 不支援 '{0}' 設定。如果需要指定的設定，請改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageLibraryImport">
        <source>The '{0}' configuration is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援 '{0}' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageMarshallingInfoCom">
        <source>The specified marshalling configuration is not supported by source-generated COM. {0}.</source>
        <target state="translated">来源產生的 COM 不支援指定的封送處理設定。{0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageMarshallingInfoLibraryImport">
        <source>The specified marshalling configuration is not supported by source-generated P/Invokes. {0}.</source>
        <target state="translated">来源產生的 P/Invokes 不支援指定的排列設定。{0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageParameterCom">
        <source>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">來源產生的 COM 不支援為參數 '{1}' 指定的 '{0}' 設定。如果需要指定的設定，請改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageParameterLibraryImport">
        <source>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為參數 '{1}' 指定的 '{0}' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageReturnCom">
        <source>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">來源產生的 COM 不支援為方法 '{1}' 的傳回值指定 '{0}' 設定。如果需要指定的設定，請改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageReturnLibraryImport">
        <source>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為方法 '{1}' 的傳回值指定 '{0}' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageValueCom">
        <source>The specified value '{0}' for '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">來源產生的 COM 不支援為 '{1}' 指定的值 '{0}'。如果需要指定的設定，請改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageValueLibraryImport">
        <source>The specified value '{0}' for '{1}' is not supported by source-generated P/Invokes. If the specified value is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為 '{1}' 指定的值 '{0}'。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedTitleCom">
        <source>Specified configuration is not supported by source-generated COM.</source>
        <target state="translated">来源產生的 COM 不支援指定的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedTitleLibraryImport">
        <source>Specified configuration is not supported by source-generated P/Invokes.</source>
        <target state="translated">来源產生的 P/Invokes 不支援指定的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantAndElementCountInfoDisallowed">
        <source>Only one of 'ConstantElementCount' or 'ElementCountInfo' may be used in a 'MarshalUsingAttribute' for a given 'ElementIndirectionDepth'</source>
        <target state="translated">在指定的 'ElementIndirectionDepth' 的 'MarshalUsingAttribute' 中只能使用 'ConstantElementCount' 或 'ElementCountInfo' 其中之一</target>
        <note />
      </trans-unit>
      <trans-unit id="ContainingTypeAccessibilityDetails">
        <source>Containing type '{0}' has accessibility '{1}'.</source>
        <target state="translated">包含的類型 '{0}' 具有存取範圍 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertComInterfaceMayProduceInvalidCode">
        <source>Converting this interface to use 'GeneratedComInterfaceAttribute' may produce invalid code and may require additional work</source>
        <target state="translated">將此介面轉換為使用 'GeneratedComInterfaceAttribute' 可能會產生無效程式碼，而且可能需要額外作業</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertNoPreserveSigDllImportToGeneratedMayProduceInvalidCode">
        <source>Automatically converting a P/Invoke with 'PreserveSig' set to 'false' to a source-generated P/Invoke may produce invalid code</source>
        <target state="translated">將 'PreserveSig' 設為 'false' 的 P/Invoke 自動轉換來源產生的 P/Invoke 可能會產生無效的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceAddUnsafe">
        <source>Convert to 'GeneratedComInterface' and allow unsafe code</source>
        <target state="translated">轉換為 'GeneratedComInterface' 並允許不安全的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceDescription">
        <source>Use 'GeneratedComInterfaceAttribute' instead of 'ComImportAttribute' to generate COM marshalling code at compile time</source>
        <target state="translated">使用 GeneratedComInterfaceAttribute' (而非 'ComImportAttribute') 以於編譯時間產生 COM 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceMayRequireCustomMarshalling">
        <source>Converting this API to 'GeneratedComInterfaceAttribute' will require additional code to provide custom marshallers for some parameters.</source>
        <target state="translated">將此 API 轉換為 'GeneratedComInterfaceAttribute' 需要額外的程式碼，才能提供某些參數的自訂封送處理器。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceMessage">
        <source>Mark the type '{0}' with 'GeneratedComInterfaceAttribute' instead of 'ComImportAttribute' to generate COM marshalling code at compile time</source>
        <target state="translated">使用 GeneratedComInterfaceAttribute' (而非 'ComImportAttribute') 標記類型 '{0}'，以於編譯時間產生 COM 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceTitle">
        <source>Convert to 'GeneratedComInterface'</source>
        <target state="translated">轉換為 'GeneratedComInterface'</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImport">
        <source>Convert to 'LibraryImport'</source>
        <target state="translated">轉換為 'LibraryImport'</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportAddUnsafe">
        <source>Convert to 'LibraryImport' and enable unsafe code</source>
        <target state="translated">轉換為 'LibraryImport'，並啟用不安全的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportDescription">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">使用 'LibraryImportAttribute' 而非 'DllImportAttribute' 在編譯時間產生 P/Invoke 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMayRequireCustomMarshalling">
        <source>Converting this API to 'LibraryImport' will require additional code to provide custom marshallers for some parameters.</source>
        <target state="translated">將此 API 轉換為 'LibraryImport' 需要額外的程式碼，才能提供某些參數的自訂封送處理器。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMessage">
        <source>Mark the method '{0}' with 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">以 'LibraryImportAttribute' 代替 'DllImportAttribute' 標示方法'{0}'，以在編譯時間產生 P/Invoke 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportTitle">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">使用 'LibraryImportAttribute' 而非 'DllImportAttribute' 在編譯時間產生 P/Invoke 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffix">
        <source>Convert to 'LibraryImport' with '{0}' suffix</source>
        <target state="translated">轉換為具有 '{0}'後綴的 'LibraryImport'</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffixAddUnsafe">
        <source>Convert to 'LibraryImport' with '{0}' suffix and enable unsafe code</source>
        <target state="translated">轉換為具有 '{0}' 尾碼的 'LibraryImport'，並啟用不安全的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomMarshallerTypeMustHaveRequiredShapeTitle">
        <source>Marshaller type does not have the required shape</source>
        <target state="translated">封送處理器類型沒有必要的圖形</target>
        <note />
      </trans-unit>
      <trans-unit id="CyclicalCountInfo">
        <source>This element cannot depend on '{0}' for collection size information without creating a dependency cycle</source>
        <target state="translated">此元素不需要建立相依性循環，就無法依存 '{0}' 集合大小資訊</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCountInfo">
        <source>Count information for a given element at a given indirection level can only be specified once</source>
        <target state="translated">在指定的間接層級，指定元素的計數資訊只能指定一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMarshallingInfo">
        <source>Multiple marshalling attributes per element per indirection level is unsupported, but duplicate information was provided for indirection level {0}</source>
        <target state="translated">不支援每個元素的每個間接層級有多個排列屬性，但為間接層級提供了重複的資訊{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulDescription">
        <source>A marshaller for an element scenario cannot be stateful.</source>
        <target state="translated">元素案例的封送處理器不可為可設定狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulMessage">
        <source>The specified marshaller type '{0}' is a stateful marshaller, but stateful marshallers are not allowed in the provided marshal mode '{1}'</source>
        <target state="translated">指定的封送處理器類型 '{0}' 是可設定狀態的封送處理器，但是在提供的封送處理模式 '{1}' 中不允許有狀態的封送處理器</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchDescription">
        <source>The element type of the span returned by the first method must be the same type as the element type of the span returned by the second method.</source>
        <target state="translated">第一個方法傳回之跨距的元素類型必須與第二個方法傳回之跨距的元素類型相同類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchMessage">
        <source>The element type of the span returned by '{0}' must be the same type as the element type of the span returned by '{1}'.</source>
        <target state="translated">'{0}' 傳回之跨距的元素類型必須與 '{1}' 傳回之跨距的元素類型相同類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullDescription">
        <source>An entry-point type for marshalling a given type must not be 'null'.</source>
        <target state="translated">封送處理指定類型的進入點類型不得為 'null'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullMessage">
        <source>The entry-point marshaller type for the type '{0}' must be not 'null'</source>
        <target state="translated">類型 '{0}' 的進入點封送處理器類型不能是 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeDescription">
        <source>An entry-point type for marshalling a given type must have a 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type.</source>
        <target state="translated">指定類型的封送處理進入點類型必須有 'System.Runtime.InteropServices.CustomMarshallerAttribute'，指定此類型為受控類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeMessage">
        <source>The entry-point marshaller type '{0}' for the type '{1}' must be a type with at least one 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type</source>
        <target state="translated">類型 '{1}' 的進入點封送處理器類型 '{0}' 必須是具有至少一個 'System.Runtime.InteropServices.CustomMarshallerAttribute' 的類型，指定此類型為受控類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraneousMarshallingInfo">
        <source>Marshalling info was specified for 'ElementIndirectionDepth' {0}, but marshalling info was only needed for {1} level(s) of indirection</source>
        <target state="translated">已為 'ElementIndirectionDepth' {0}指定封送處理資訊，但只有 {1}層級 (間接) 需要封送處理資訊</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeDescription">
        <source>The first parameter of the first method must be the same type as the return types of the second method.</source>
        <target state="translated">第一個方法的第一個參數必須與第二個方法的傳回類型相同類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeMessage">
        <source>The first parameter of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">'{0}' 的第一個參數必須與 '{1}' 的傳回類型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchDescription">
        <source>The first parameters of the two methods must be the same type.</source>
        <target state="translated">兩種方法的第一個參數必須是相同的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchMessage">
        <source>The first parameter of '{0}' and '{1}' must be the same type</source>
        <target state="translated">'{0}' 與 '{1}' 的第一個參數必須是相同的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedDescription">
        <source>Overloading the 'FromUnmanaged' method is unuspported as some shapes are unable to distinguish between overloads.</source>
        <target state="translated">不支援多載 'FromUnmanaged' 方法，因為某些圖形無法區分多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedMessage">
        <source>The type '{0}' overloads the 'FromUnmanaged' method, which is not supported in custom marshallers</source>
        <target state="translated">自訂封送處理器中不支援類型 '{0}' 多載 'FromUnmanaged' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="GeneratedComInterfaceStringMarshallingMustMatchBase">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' must match the base COM interface.</source>
        <target state="translated">'StringMarshalling' 和 'StringMarshallingCustomType' 的設定必須和基底 COM 介面相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">封送處理器類型必須是封閉式泛型或具有與受控類型相同的泛型參數數目，因此發出的程式碼可以使用特定的具現化。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' for managed type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">受控類型 '{1}' 的封送處理器類型 '{0}' 必須是封閉的泛型類型、如果是值封送處理器，則其 arity 必須與受控類型相同，如果是集合封送處理器，則必須有另一個泛型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableDescription">
        <source>The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable.</source>
        <target state="translated">('ref' 帳戶處理後的) 'GetPinnableReference' 傳回類型必須是 blittable。</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableMessage">
        <source>The dereferenced type of the return type of the 'GetPinnableReference' method must be blittable</source>
        <target state="translated">'GetPinnableReference' 方法傳回類型的解除参照類型必須是 blittable</target>
        <note />
      </trans-unit>
      <trans-unit id="GraphHasCycles">
        <source>The provided graph has cycles and cannot be topologically sorted.</source>
        <target state="translated">提供的圖表有週期，無法以拓撲排序。</target>
        <note />
      </trans-unit>
      <trans-unit id="HResultTypeWillBeTreatedAsStructMessage">
        <source>The type '{0}' will be treated as a struct in the native signature, not as a native HRESULT. To treat this as an HRESULT, add '[return:MarshalAs(UnmanagedType.Error)]' to the method.</source>
        <target state="translated">類型 '{0}' 會被視為原生簽章中的結構，而非原生 HRESULT。若要將此視為 HRESULT，請將 '[return:MarshalAs(UnmanagedType.Error)]' 新增至方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="HResultTypeWillBeTreatedAsStructTitle">
        <source>This type will be treated as a struct in the native signature, not as a native HRESULT</source>
        <target state="translated">此類型會被視為原生簽章中的結構，而非原生 HRESULT</target>
        <note />
      </trans-unit>
      <trans-unit id="InAttributeNotSupportedOnByValueParameters">
        <source>The '[In]' attribute is only supported on array parameters. By-value parameters are considered read-only by default.</source>
        <target state="translated">只有在陣列參數上才支援 '[In]' 屬性。預設會將 By-value 參數視為唯讀。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAttributeNotSupportedWithoutOutBlittableArray">
        <source>The '[In]' attribute is not supported unless the '[Out]' attribute is also used. Blittable arrays cannot be marshalled as '[In]' only.</source>
        <target state="translated">除非也使用 '[Out]' 屬性，否則不支援 '[In]' 屬性。無法只將 Blittable 陣列整理為 '[In]'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAttributeOnlyIsDefault">
        <source>The '[In]' attribute is not necessary unless the '[Out]' attribute is also used. The behavior of the '[In]' attribute without the '[Out]' attribute is the same as the default behavior.</source>
        <target state="translated">除非一併使用'[Out]'屬性，否則'[In]'屬性為非必要。沒有'[Out]'屬性的'[In]'屬性行為與默認行為相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributeByRefNotSupported">
        <source>The '[In]' and '[Out]' attributes are unsupported on parameters passed by reference. Use the 'in', 'ref', or 'out' keywords instead.</source>
        <target state="translated">參考所傳遞的參數不支援'[In]'和'[Out]'屬性。請改用 'in'、'ref' 或 'out' 關鍵詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributeMarshalerNotSupported">
        <source>The provided '[In]' and '[Out]' attributes on this parameter are unsupported on this parameter.</source>
        <target state="translated">此參數不支援在此參數上提供的 '[In]' 和 '[Out]' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributeNotSupportedOnByValueParameters">
        <source>The '[In]' and '[Out]' attributes are only supported on array parameters. Consider using the 'ref' keyword to make the parameter mutable.</source>
        <target state="translated">只有在陣列參數上才支援 '[In]' 和 '[Out]' 屬性。請考慮使用 'ref' 關鍵字，讓參數成為可變動。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributes">
        <source>[In] and [Out] attributes</source>
        <target state="translated">[In] 與 [Out] 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="InVariantShouldBeRef">
        <source>Objects marshalled from VARIANTs as 'in' parameters in unmanaged-to-managed calls will not propagate back the updated result, even if the VARIANT is a VT_BYREF variant. Use a 'ref' parameter instead of an 'in' parameter to propagate the updated value back to the caller.</source>
        <target state="new">Objects marshalled from VARIANTs as 'in' parameters in unmanaged-to-managed calls will not propagate back the updated result, even if the VARIANT is a VT_BYREF variant. Use a 'ref' parameter instead of an 'in' parameter to propagate the updated value back to the caller.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstanceEventDeclaredInInterfaceDescription">
        <source>Events are not a concept in COM, so no interop code will be source generated for instance events on source-generated COM interfaces.</source>
        <target state="translated">事件不是 COM 中的概念，因此不會為來源產生的 COM 介面上的執行個體事件來源產生 Interop 程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstanceEventDeclaredInInterfaceMessage">
        <source>The instance event '{0}' is declared in the interface '{1}', which has the 'GeneratedComInterfaceAttribute' applied</source>
        <target state="translated">執行個體事件 '{0}' 是在套用了 'GeneratedComInterfaceAttribute' 的介面 '{1}' 中宣告的</target>
        <note />
      </trans-unit>
      <trans-unit id="InstanceEventDeclaredInInterfaceTitle">
        <source>Declaring an instance event in a type with the 'GeneratedComInterfaceAttribute' is not supported</source>
        <target state="translated">不支援在具有 'GeneratedComInterfaceAttribute' 的類型中宣告執行個體事件</target>
        <note />
      </trans-unit>
      <trans-unit id="InstancePropertyDeclaredInInterfaceDescription">
        <source>Properties are not a concept in COM, so no interop code will be source generated for instance properties on source-generated COM interfaces.</source>
        <target state="translated">屬性不是 COM 中的概念，因此不會為來源產生的 COM 介面上的執行個體屬性來源產生 Interop 程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstancePropertyDeclaredInInterfaceMessage">
        <source>The instance property '{0}' is declared in the interface '{1}', which has the 'GeneratedComInterfaceAttribute' applied</source>
        <target state="translated">執行個體屬性 '{0}' 是在套用了 'GeneratedComInterfaceAttribute' 的介面 '{1}' 中宣告的</target>
        <note />
      </trans-unit>
      <trans-unit id="InstancePropertyDeclaredInInterfaceTitle">
        <source>Declaring an instance property in a type with the 'GeneratedComInterfaceAttribute' is not supported</source>
        <target state="translated">不支援在具有 'GeneratedComInterfaceAttribute' 的類型中宣告執行個體屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceTypeNotSupportedMessage">
        <source>Using 'GeneratedComInterfaceAttribute' and 'InterfaceTypeAttribute' is not supported with 'ComInterfaceType' value '{0}'.</source>
        <target state="translated">'ComInterfaceType' 值 '{0}' 不支援使用 'GeneratedComInterfaceAttribute' 和 'InterfaceTypeAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceTypeNotSupportedTitle">
        <source>'GeneratedComInterfaceType' does not support the 'ComInterfaceType' value supplied to 'InterfaceTypeAttribute' on the same type.</source>
        <target state="translated">'GeneratedComInterfaceType' 不支援提供給相同類型 'InterfaceTypeAttribute' 的 'ComInterfaceType' 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingModifiersMessageCom">
        <source>Method '{0}' is contained in a type '{1}' that is not marked 'partial'. COM source generation will ignore method '{0}'.</source>
        <target state="translated">方法 '{0}' 包含在未標示為 'partial' 的類型 '{1}' 中。COM 来源產生將略過方法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingModifiersMessageLibraryImport">
        <source>Method '{0}' is contained in a type '{1}' that is not marked 'partial'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">方法 '{0}' 包含在未標示為 'partial' 的類型'{1}'中。產生 P/Invoke 来源會忽略方法'{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingUnmanagedObjectUnwrapperAttributeMessage">
        <source>Containing type of method with VirtualMethodIndexAttribute does not have a UnmanagedObjectUnwrapperAttribute. </source>
        <target state="translated">包含具有 VirtualMethodIndexAttribute 的方法類型沒有 UnmanagedObjectUnwrapperAttribute。 </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodDescriptionCom">
        <source>Methods on interfaces marked with 'GeneratedComInterfaceAttribute' should be non-generic. COM source generation will ignore methods that are generic.</source>
        <target state="translated">標示為 'GeneratedComInterfaceAttribute' 之介面上的方法應該是非泛型的。COM 來源產生將略過泛型方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodDescriptionLibraryImport">
        <source>Methods marked with 'LibraryImportAttribute' should be 'static', 'partial', and non-generic. P/Invoke source generation will ignore methods that are non-'static', non-'partial', or generic.</source>
        <target state="translated">以 'LibraryImportAttribute' 標示的方法應該是 'static'、'partial' 和非泛型。產生 P/Invoke 来源會忽略非'static'、non-'partial' 或一般的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodSignatureMessageCom">
        <source>Method '{0}' should be non-generic when on interfaces marked with the 'GeneratedComInterfaceAttribute'. COM source generation will ignore method '{0}'.</source>
        <target state="translated">在用 'GeneratedComInterfaceAttribute' 標示的介面上，方法 '{0}' 應該是非泛型的。COM 來源產生將略過方法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodSignatureMessageLibraryImport">
        <source>Method '{0}' should be 'static', 'partial', and non-generic when marked with 'LibraryImportAttribute'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">以 'LibraryImportAttribute' 標示時，方法'{0}'應為 'static'、'partial' 和非泛型。產生 P/Invoke 来源會忽略方法'{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCustomMarshallerAttributeUsageTitle">
        <source>Invalid 'CustomMarshallerAttribute' usage</source>
        <target state="translated">`CustomMarshallerAttribute` 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationDescription">
        <source>The configuration of 'ExceptionMarshalling' and 'ExceptionMarshallingCustomType' is invalid.</source>
        <target state="translated">'ExceptionMarshalling' 和 'ExceptionMarshallingCustomType' 的設定無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationMessage">
        <source>The configuration of 'ExceptionMarshalling' and 'ExceptionMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">方法 '{0}' 上的 'ExceptionMarshalling' 和 'ExceptionMarshallingCustomType' 的設定無效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationMissingCustomType">
        <source>'ExceptionMarshallingCustomType' must be specified when 'ExceptionMarshalling' is set to 'ExceptionMarshalling.Custom'.</source>
        <target state="translated">當 'ExceptionMarshalling' 設定為 'ExceptionMarshalling.Custom' 時，必須指定 'ExceptionMarshallingCustomType'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationNotCustom">
        <source>'ExceptionMarshalling' should be set to 'ExceptionMarshalling.Custom' when 'ExceptionMarshallingCustomType' is specified.</source>
        <target state="translated">指定 'ExceptionMarshallingCustomType' 時，'ExceptionMarshalling' 應設定為 'ExceptionMarshalling.Custom'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingValue">
        <source>The provided value is not a known flag of the 'ExceptionMarshalling' enum.</source>
        <target state="translated">提供的值不是 'ExceptionMarshalling' 列舉的已知旗標。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComClassAttributeUsageDescription">
        <source>Classes with 'GeneratedComClassAttribute' must implement one or more interfaces with 'GeneratedComInterfaceAttribute', be marked partial, and be non-generic.</source>
        <target state="translated">具有 'GeneratedComClassAttribute' 的類別必須實作一或多個具有 'GeneratedComInterfaceAttribute' 的介面、標示為部份且非泛型。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComClassAttributeUsageMissingPartialModifier">
        <source>Class '{0}' with 'GeneratedComClassAttribute' or one of its containing types is not marked 'partial'.</source>
        <target state="translated">具有 'GeneratedComClassAttribute' 或其中一個包含類型的類別 '{0}' 未標示為 'partial'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComClassAttributeUsageTitle">
        <source>Invalid 'GeneratedComClassAttribute' usage</source>
        <target state="translated">'GeneratedComClassAttribute' 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageDescription">
        <source>Interfaces attributed with 'GeneratedComInterfaceAttribute' must have 'public' or 'internal' accessibility and be partial, non-generic, and must specify a GUID with 'System.Runtime.InteropServices.GuidAttribute'.</source>
        <target state="translated">屬性為 'GeneratedComInterfaceAttribute' 的介面必須具有 'public' 或 'internal' 存取範圍，且是部分的非泛型介面，且必須使用 'System.Runtime.InteropServices.GuidAttribute' 指定 GUID。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageInterfaceIsGeneric">
        <source>Interface '{0}' is attributed with 'GeneratedComInterfaceAttribute' but is generic.</source>
        <target state="translated">介面 '{0}' 的屬性為 'GeneratedComInterfaceAttribute'，但為泛型介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageInterfaceNotAccessible">
        <source>Interface '{0}' is attributed with 'GeneratedComInterfaceAttribute' but is not accessible by generated code. The interface and all containing types must have accessibility 'internal' or 'public' for generated code to access it. {1}</source>
        <target state="translated">介面 '{0}' 的屬性為 'GeneratedComInterfaceAttribute'，但無法由產生的程式碼存取。介面和所有包含的類型的必須具有 'internal' 或 'public' 存取範圍，產生的程式碼才能存取它。{1}</target>
        <note>{1} is details about which type/containing type is not accessible</note>
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageMissingGuidAttribute">
        <source>Interface '{0}' is attributed with 'GeneratedComInterfaceAttribute' but is missing 'System.Runtime.InteropServices.GuidAttribute'.</source>
        <target state="translated">介面 '{0}' 的屬性為 'GeneratedComInterfaceAttribute'，但遺漏 'System.Runtime.InteropServices.GuidAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageTitle">
        <source>Invalid 'GeneratedComInterfaceAttribute' usage.</source>
        <target state="translated">無效的 'GeneratedComInterfaceAttribute' 使用方式。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceUsageMissingPartialModifier">
        <source>The interface '{0}' or one of its containing types is missing the 'partial' keyword. Code will not be generated for '{0}'.</source>
        <target state="translated">介面 '{0}' 或其中一個包含類型的介面遺漏 'partial' 關鍵字。將不會為 '{0}' 產生程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLibraryImportAttributeUsageTitle">
        <source>Invalid 'LibraryImportAttribute' usage</source>
        <target state="translated">'LibraryImportAttribute' 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidManagedTypeTitle">
        <source>Specified managed type is invalid</source>
        <target state="translated">指定的受控類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMarshalModeTitle">
        <source>Invalid 'MarshalMode' value.</source>
        <target state="translated">'MarshalMode' 值無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMarshallerTypeTitle">
        <source>Specified marshaller type is invalid</source>
        <target state="translated">指定的封送處理器類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNativeMarshallingAttributeUsageTitle">
        <source>Invalid 'NativeMarshallingAttribute' usage</source>
        <target state="translated">'NativeMarshallingAttribute' 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidOptionsOnInterfaceDescription">
        <source>The specified 'ComInterfaceOptions' are invalid.</source>
        <target state="translated">指定的 'ComInterfaceOptions' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidOptionsOnInterfaceMessage">
        <source>The specified 'ComInterfaceOptions' on '{0}' are invalid. {1}</source>
        <target state="translated">'{0}' 上指定的 'ComInterfaceOptions' 無效。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSignaturesInMarshallerShapeTitle">
        <source>Marshaller type has incompatible method signatures</source>
        <target state="translated">封送處理器類型有不相容的方法簽章</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationDescription">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' is invalid.</source>
        <target state="translated">'StringMarshalling' 和 'StringMarshallingCustomType' 的設定無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMessageCom">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on interface '{0}' is invalid. {1}</source>
        <target state="translated">介面 '{0}' 上的 'StringMarshalling' 和 'StringMarshallingCustomType' 設定無效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMessageLibraryImport">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">方法 '{0}' 上的 'StringMarshalling' 和 'StringMarshallingCustomType' 設定無效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMissingCustomType">
        <source>'StringMarshallingCustomType' must be specified when 'StringMarshalling' is set to 'StringMarshalling.Custom'.</source>
        <target state="translated">當 'StringMarshalling' 設定為 'StringMarshalling.Custom' 時，必須指定 'StringMarshallingCustomType'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationNotCustom">
        <source>'StringMarshalling' should be set to 'StringMarshalling.Custom' when 'StringMarshallingCustomType' is specified.</source>
        <target state="translated">指定 'StringMarshallingCustomType' 時，'StringMarshalling' 應設定為 'StringMarshalling.Custom'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationOnInterfaceMessage">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on interface '{0}' is invalid. {1}</source>
        <target state="translated">介面 '{0}' 上的 'StringMarshalling' 和 'StringMarshallingCustomType' 設定無效。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationOnMethodMessage">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">方法 '{0}' 上的 'StringMarshalling' 和 'StringMarshallingCustomType' 設定無效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidVirtualMethodIndexAttributeUsage">
        <source>Invalid 'VirtualMethodIndexAttribute' usage</source>
        <target state="translated">'VirtualMethodIndexAttribute' 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="LibraryImportUsageDoesNotFollowBestPracticesMessageWithDetails">
        <source>The usage of 'LibraryImportAttribute' does not follow recommendations. {0}</source>
        <target state="translated">'LibraryImportAttribute' 的使用方式未遵循建議。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="LibraryImportUsageDoesNotFollowBestPracticesTitle">
        <source>The usage of 'LibraryImportAttribute' does not follow recommendations.</source>
        <target state="translated">'LibraryImportAttribute' 的使用方式未遵循建議。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchDescription">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'.</source>
        <target state="translated">'GetManagedValuesSource' 傳回的 'ReadOnlySpan' 元素類型必須與 'GetManagedValuesDestination' 傳回的元素類型相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchMessage">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'</source>
        <target state="translated">'GetManagedValuesSource' 傳回的 'ReadOnlySpan' 元素類型必須與 'GetManagedValuesDestination' 傳回的元素類型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'LinearCollection'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a three-parameter constructor taking the managed type as the first parameter, a 'Span&lt;byte&gt;' as the second parameter, and the native size of the element as the third parameter</source>
        <target state="translated">支援 'CallerAllocatedBuffer' 功能的 'LinearCollection'-kind 原生類型必須提供以 Managed 類型作為第一個參數的三個參數建構函式、將 'Span&lt;byte&gt;' 作為第二個參數，以及元素的原生大小作為第三個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a three-parameter constructor that takes a '{1}' , a 'Span&lt;byte&gt;', and an 'int'</source>
        <target state="translated">類型 '{0}' 指定其支援 'In' 封送處理，且'{1}'的 'CallerAllocatedBuffer' 功能，但不提供接受'{1}'、'Span&lt;byte&gt;' 和 'int' 的三個參數建構函示</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'.</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesSource' 和傳回 'Span&lt;&gt;' 的 'GetNativeValuesDestination' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesSource' 和傳回 'Span&lt;&gt;' 的 'GetNativeValuesDestination' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供接受 'int' 和傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受 'int' 和傳回 'ReadOnlySpan&lt;&gt;' 的 'GetNativeValuesSource' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供接受 'int' 和傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受 'int' 和傳回 'ReadOnlySpan&lt;&gt;' 的 'GetNativeValuesSource' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedToUnmanagedMissingRequiredMarshaller">
        <source>The specified parameter needs to be marshalled from managed to unmanaged, but the marshaller type '{0}' does not support it.</source>
        <target state="translated">指定的參數必須從受控封送處理到非受控，但封送處理程式類型 '{0}' 不支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the generator can determine which methods are available on the specific marshaller types.</source>
        <target state="translated">封送處理器類型必須是封閉的泛型或具有與受控類型相同的泛型參數數目，以便產生器可以判斷哪些方法可用於特定的封送處理器類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityMessage">
        <source>The managed type '{0}' for entry-point marshaller type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">進入點封送處理器類型 '{1}' 的受控類型 '{0}' 必須是封閉的泛型類型、如果是值封送處理器，則其 arity 必須與受控類型相同，如果是集合封送處理器，則必須有另一個泛型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullDescription">
        <source>The managed type for a custom marshaller must be non-null.</source>
        <target state="translated">自訂封送處理器的受控類型必須是非 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullMessage">
        <source>The managed type for the entry-point marshaller type '{0}' must not be 'null'</source>
        <target state="translated">進入點封送處理器類型 '{0}' 的受控類型不得為 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageParameterCom">
        <source>The specified 'MarshalAsAttribute' configuration for parameter '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">來源產生的 COM 不支援為參數 '{1}' 指定 'MarshalAsAttribute' 設定。如果需要指定的設定，請改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageParameterLibraryImport">
        <source>The specified 'MarshalAsAttribute' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為參數 '{1}' 指定 'MarshalAsAttribute' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageReturnCom">
        <source>The specified 'MarshalAsAttribute' configuration for the return value of method '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">來源產生的 COM 不支援為方法 '{1}' 的傳回值指定 'MarshalAsAttribute' 設定。如果需要指定的設定，請改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageReturnLibraryImport">
        <source>The specified 'MarshalAsAttribute' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為方法 '{1}' 的傳回值指定 'MarshalAsAttribute' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalModeMustBeValidEnumValue">
        <source>The 'marshalMode' argument of 'CustomMarshallerAttribute' must be a valid enum value of 'MarshalMode'.</source>
        <target state="translated">'CustomMarshallerAttribute' 的 'marshalMode' 引數必須是有效的列舉值 'MarshalMode'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerEntryPointTypeMustMatchArity">
        <source>The marshaller entry point type '{0}' for managed type '{1}' must have an arity of one greater than the managed type.</source>
        <target state="translated">受控類型 '{1}' 的封送處理器進入點類型 '{0}' 必須具有大於受控類型的 arity。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerInNativeReturnPositionMustMatchNativeReturnType">
        <source>All marshallers for values that are passed as the unmanaged return value must have the same unmanaged type.</source>
        <target state="translated">以非受控傳回值傳遞之值的所有封送處理常式，都必須具有相同的非受控類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">封送處理器類型必須是封閉式泛型或具有與受控類型相同的泛型參數數目，因此發出的程式碼可以使用特定的具現化。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' pointed to by the entry-point marshaller type '{1}' must be a closed generic type or have the same arity as the managed type</source>
        <target state="translated">進入點封送處理器類型 '{1}' 指向的封送處理器類型 '{0}' 必須是封閉的泛型類型或與受控類型具有相同的 Arity</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullDescription">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'.</source>
        <target state="translated">'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' 中的 'marshallerType' 參數不可以是 'null'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullMessage">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'</source>
        <target state="translated">'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' 中的 'marshallerType' 參數不可以是 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStruct">
        <source>The marshaller type '{0}' for managed type '{1}' must be a static class or a struct.</source>
        <target state="translated">受控型別 '{1}' 的封送處理器類型 '{0}' 必須是靜態類別或結構。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructDescription">
        <source>A marshaller type must either be a stateless static class or a stateful value type. A non-static class is not allowed.</source>
        <target state="translated">封送處理程式類型必須是無狀態靜態類型或具狀態的數值類型。不允許非靜態類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructMessage">
        <source>The type '{0}' must be a static class or a value type</source>
        <target state="translated">類型 '{0}' 必須是靜態類別或數值類型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeDescription">
        <source>A type with a 'System.Runtime.InteropServices.CustomMarshallerAttribute' must specify a non-'null' managed type</source>
        <target state="translated">具有 'System.Runtime.InteropServices.CustomMarshallerAttribute' 的類型必須指定非 Null 受控類型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeMessage">
        <source>The type '{0}' does not specify a managed type in the 'System.Runtime.InteropServices.CustomMarshallerAttribute' applied to the type</source>
        <target state="translated">類型 '{0}' 未在套用至類型的 'System.Runtime.InteropServices.CustomMarshallerAttribute' 中指定受控類型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingBoolAsUndefinedNotSupported">
        <source>Marshalling bool without explicit marshalling information is not supported. Specify either 'MarshalUsingAttribute' or 'MarshalAsAttribute'.</source>
        <target state="translated">不支援沒有明確排列資訊的封送處理布林值。指定 'MarshalUsingAttribute' 或 'MarshalAsAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingCharAsSpecifiedStringMarshallingNotSupported">
        <source>Marshalling char with 'StringMarshalling.{0}' is not supported. Instead, manually convert the char type to the desired byte representation and pass to the source-generated P/Invoke.</source>
        <target state="translated">不支援具有 'StringMarshalling.{0}' 的封送字元。請改為手動將字元類型轉換為想要的位元組表示法，並傳遞至來源產生的 P/Invoke。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingCharAsStringMarshallingCustomNotSupported">
        <source>Marshalling char with 'StringMarshalling.Custom' is not supported. To use a custom type marshaller, specify 'MarshalUsingAttribute'.</source>
        <target state="translated">不支援具有 'StringMarshalling.Custom' 的封送處理字元。若要使用自訂類型封送處理器，請指定 'MarshalUsingAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingStringOrCharAsUndefinedNotSupported">
        <source>Marshalling string or char without explicit marshalling information is not supported. Specify '{0}.StringMarshalling', '{0}.StringMarshallingCustomType', 'MarshalUsingAttribute' or 'MarshalAsAttribute'.</source>
        <target state="translated">不支援沒有明確封送處理資訊的封送處理字串或字元。請指定 '{0}.StringMarshalling、'{0}.StringMarshallingCustomType'、'MarshalUsingAttribute' 或 'MarshalAsAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodNotDeclaredInAttributedInterfaceDescription">
        <source>All methods must be declared in the same partial definition of a 'GeneratedComInterface'-attributed interface type to ensure reliable calculation for virtual method table offsets.</source>
        <target state="translated">所有方法都必須在 'GeneratedComInterface' 屬性化介面類型的相同部分定義中宣告，以確保對虛擬方法資料表位移進行可靠的計算。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodNotDeclaredInAttributedInterfaceMessage">
        <source>The method '{0}' is declared on a different partial definition of the interface '{1}' than the definition that has the 'GeneratedComInterface' attribute</source>
        <target state="translated">方法 '{0}' 是在介面 '{1}' 的不同部分定義上宣告的，而不是在具有 'GeneratedComInterface' 屬性的定義上宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodNotDeclaredInAttributedInterfaceTitle">
        <source>Method is declared in different partial declaration than the 'GeneratedComInterface' attribute.</source>
        <target state="translated">方法是在不同於 'GeneratedComInterface' 屬性的部分宣告中宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleComInterfaceBaseTypesDescription">
        <source>A 'GeneratedComInterfaceAttribute'-attributed interface can only derive from at most one other 'GeneratedComInterfaceAttribute'-attributed interface.</source>
        <target state="translated">'GeneratedComInterfaceAttribute'-屬性介面最多只能衍生自另一個 'GeneratedComInterfaceAttribute'-屬性介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleComInterfaceBaseTypesMessage">
        <source>Interface '{0}' is derived from two or more interfaces attributed with 'GeneratedComInterfaceAttribute'.</source>
        <target state="translated">介面 '{0}' 衍生自具有 'GeneratedComInterfaceAttribute' 的兩個或多個介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleComInterfaceBaseTypesTitle">
        <source>Specified interface derives from two or more 'GeneratedComInterfaceAttribute'-attributed interfaces.</source>
        <target state="translated">指定的介面衍生自兩個或兩個以上的 'GeneratedComInterfaceAttribute'-屬性介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWrapperMustBeGenerated">
        <source>Either 'ComInterfaceOptions.ManagedObjectWrapper' or 'ComInterfaceOptions.ComObjectWrapper' must be specified.</source>
        <target state="translated">必須指定 'ComInterfaceOptions.ManagedObjectWrapper' 或 'ComInterfaceOptions.ComObjectWrapper'。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutAttributeNotSupportedOnByValueParameters">
        <source>The '[Out]' attribute is only supported on array parameters. Consider using 'out' or 'ref' keywords to make the parameter mutable.</source>
        <target state="translated">只有在陣列參數上才支援 '[Out]' 屬性。請考慮使用 'out' 或 'ref' 關鍵字，讓參數成為可變動。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedDescription">
        <source>A 'Value' or 'LinearCollection'-kind native type that supports marshalling in the 'Out' direction must provide a 'ToManaged' method that returns the managed type.</source>
        <target state="translated">支援在 'Out' 方向排列的 'Value' 或 'LinearCollection'-kind 原生類型必須提供傳回 Managed 類型的 'ToManaged' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedMessage">
        <source>The type '{0}' specifies it supports marshalling in the 'Out' direction, but it does not provide a 'ToManaged' method that returns the managed type</source>
        <target state="translated">類型 '{0}' 指定它支援以 'Out' 方向排列，但未提供傳回受管理類型的 'ToManaged' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferExplicitInOutAttributesOnArrays">
        <source>It is recommended to use explicit '[In]' and '[Out]' attributes on array parameters.</source>
        <target state="translated">建議在陣列參數上使用明確的 '[In]' 和 '[Out]' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksDescriptionCom">
        <source>'GeneratedComInterfaceAttribute' and 'GeneratedComClassAttribute' require unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">'GeneratedComInterfaceAttribute' 和 'GeneratedComClassAttribute' 需要不安全的程式碼。專案必須以 '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;' 更新。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksDescriptionLibraryImport">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的程式碼。專案必須以 '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;' 更新。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksMessageCom">
        <source>'GeneratedComInterfaceAttribute' and 'GeneratedComClassAttribute' require unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">'GeneratedComInterfaceAttribute' 和 'GeneratedComClassAttribute' 需要不安全的程式碼。專案必須以 '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;' 更新。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksMessageLibraryImport">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的程式碼。專案必須以 '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;' 更新。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksTitleCom">
        <source>'GeneratedComInterfaceAttribute' and 'GeneratedComClassAttribute' require unsafe code.</source>
        <target state="translated">'GeneratedComInterfaceAttribute' 和 'GeneratedComClassAttribute' 需要不安全的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksTitleLibraryImport">
        <source>LibraryImportAttribute requires unsafe code.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeDescription">
        <source>The return type the two method must be the expected type.</source>
        <target state="translated">兩種方法的傳回類型必須是預期的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeMessage">
        <source>The return type of '{0}' must be '{1}'</source>
        <target state="translated">'{0}' 的傳回類型必須為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchDescription">
        <source>The return types of the two methods must be the same type.</source>
        <target state="translated">兩種方法的傳回類型必須是相同的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchMessage">
        <source>The return type of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">'{0}' 的傳回類型必須與 '{1}' 的傳回類型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeComApisDoNotSupportSourceGeneratedComDescription">
        <source>COM Interop APIs on 'System.Runtime.InteropServices.Marshal' do not support source-generated COM and will fail at runtime</source>
        <target state="translated">'System.Runtime.InteropServices.Marshal' 上的 COM Interop API 不支援來源產生的 COM，且將於執行階段中失敗</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeComApisDoNotSupportSourceGeneratedComMessage">
        <source>The method '{0}' only supports runtime-based COM interop and will not work with type '{1}'</source>
        <target state="translated">方法 '{0}' 只支援執行階段型 COM Interop，且不適用於類型 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeComApisDoNotSupportSourceGeneratedComTitle">
        <source>COM Interop APIs on 'System.Runtime.InteropServices.Marshal' do not support source-generated COM</source>
        <target state="translated">'System.Runtime.InteropServices.Marshal' 上的 COM Interop API 不支援來源產生的 COM</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeMarshallingMustBeDisabled">
        <source>Runtime marshalling must be disabled in this project by applying the 'System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute' to the assembly to enable marshalling this type.</source>
        <target state="translated">必須將 'System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute' 套用到組件，以停用此專案中的執行階段封送處理，以啟用此類型的封送處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeOfCollectionMustBeKnownAtMarshalTimeMessageOutParam">
        <source>The size of parameter '{0}' that is marshalled to the callee must be defined when the method is called, but count parameter '{1}' is an 'out' parameter.</source>
        <target state="translated">呼叫方法時，必須定義封送處理給被呼叫者的參數 '{0}' 的大小，但 count 參數 '{1}' 是 'out' 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeOfCollectionMustBeKnownAtMarshalTimeMessageReturnValue">
        <source>The size of parameter '{0}' that is marshalled to the callee must be defined when the method is called, but the return value is used as the size of the collection.</source>
        <target state="translated">呼叫方法時，必須定義封送處理給被呼叫者的參數 '{0}' 的大小，但使用傳回值做為集合的大小。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeOfCollectionMustBeKnownAtMarshalTimeTitle">
        <source>The size of a collection that is marshalled to the callee must be defined when the method is called.</source>
        <target state="translated">呼叫方法時，必須定義封送處理給被呼叫者的集合大小。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeDescription">
        <source>A stateful marshaller must have a zero-parameter void-returning instance method named 'Free'.</source>
        <target state="translated">具狀態的封送處理常式必須有名稱為 'Free' 的零參數無效傳回執行個體方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeMessage">
        <source>The type '{0}' is a stateful marshaller and does not have a zero-parameter void-returning instance method named 'Free'</source>
        <target state="translated">類型 '{0}' 是具狀態的封送處理器，且沒有名為 'Free' 的零參數無效傳回執行個體方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'FromManaged' instance method that takes the managed value as a parameter and returns 'void'.</source>
        <target state="translated">支援從受控到未受控封送處理的具狀態封送處理器必須提供 'FromManaged' 執行個體方法，該方法將受控值作為參數並傳回 'void'。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromManaged' that takes a '{2}' as a parameter and returns 'void'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但它不提供名為 'FromManaged' 的單一參數執行個體方法，該方法將 '{2}' 值作為參數並傳回 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'FromUnmanaged' instance method that takes the unmanaged value as a parameter and returns 'void'.</source>
        <target state="translated">支援從未受控到受控封送處理的具狀態封送處理器必須提供 'FromUnmanaged' 執行個體方法，該方法將未受控值作為參數並傳回 'void'。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromUnmanaged' that takes the 'unmanaged' value as a parameter and returns 'void'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但它不提供名為 'FromUnmanaged' 的單一參數執行個體方法，該方法將 'unmanaged' 值作為參數並傳回 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'ToManaged' instance method that takes no parameters and returns the managed type.</source>
        <target state="translated">支援從未受控到受控封送處理的具狀態封送處理器必須提供 'ToManaged' 執行個體方法，該方法沒有參數並傳回受控類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToManaged' that returns '{2}'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但不提供名為 'ToManaged' 的零參數執行個體方法，該方法會傳回 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'ToUnmanaged' instance method that takes no parameters and returns the 'unmanaged' type.</source>
        <target state="translated">支援從受控到未受控封送處理的具狀態封送處理器必須提供 'ToUnmanaged' 執行個體方法，該方法沒有參數並傳回 'unmanaged' 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToUnmanaged' that returns the 'unmanaged' type for the marshaller</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但不提供名為 'ToUnmanaged' 的零參數執行個體方法，該方法會傳回封送處理器的 'unmanaged' 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing an 'AllocateContainerForUnmanagedElements' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">當透過提供在封送處理程式類型上採用 'Span&lt;T&gt;' 的 'AllocateContainerForUnmanagedElements' 方法來使用 'Managed to Unmanaged with Caller-Allocated Buffer' 圖形時，該類型必須提供靜態 'BufferSize' 屬性以提供 caller-allocated 緩衝區中的元素數目。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has an 'AllocateContainerForUnmanagedElements' method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">封送處理程式類型 '{0}' 必須有靜態唯讀 'int' 'BufferSize' 屬性，以指定 caller-allocated 緩衝區的大小，因為它具有採用 caller-allocated 'Span&lt;{1}&gt;' 的 'AllocateContainerForUnmanagedElements' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that takes the managed value as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供接受受控值為參數並傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesDestination'，和接受非受控值為參數並傳回 'Span&lt;&gt;' 的 'GetUnmanagedValuesSource' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that takes '{2}' as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供接受 '{2}' 為參數並傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesSource' ，和接受未受控值為參數並傳回 'Span&lt;&gt;' 的 'GetUnmanagedValuesDestination' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes the managed value and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供接受受控值並傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受非受控值及 'int' 並傳回 'ReadOnlySpan&lt;&gt;' 的 'GetUnmanagedValuesSource' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes '{2}' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供接受 '{2}' 和傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受未受控值和傳回 'ReadOnlySpan&lt;&gt;' 的 'GetUnmanagedValuesSource' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForManagedElements' method taking the unmanaged type as the first parameter and the number of elements as an 'int' parameter</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態連續集合封送處理程式必須提供 'AllocateContainerForManagedElements' 方法，將未受控的類型作為第一個參數，以及元素數目作為 'int' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForManagedElements' method that takes the unmanaged type as the first parameter and an 'int' as the second parameter</source>
        <target state="translated">類型 '{0}' 指定它支援 '{2}' 的 '{1}' 封送處理模式，但不提供接受未受控類型作爲第一個參數和 'int' 作為第二個參數的雙參數 'AllocateContainerForManagedElements' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForUnmanagedElements' method taking the managed type as the first parameter and providing the number of elements as an 'out int' parameter</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態連續集合封送處理程式必須提供 'AllocateContainerForManagedElements' 方法，將受控類型作為第一個參數，以及提供元素數目作為 'out int' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForUnmanagedElements' method that takes a '{2}' as the first parameter and an 'out int' as the second parameter</source>
        <target state="translated">類型 '{0}' 指定它支援 '{2}' 的 '{1}' 封送處理模式，但不提供接受 '{2}' 作爲第一個參數和 'out int' 作為第二個參數的雙參數 'AllocateContainerForUnmanagedElements' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedDescription">
        <source>A stateless value marshaller that supports marshalling from unmanaged to managed must provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns the the managed type.</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態值封送處理程式必須提供接受未受控類型作為參數，並傳回受控類型的 'ConvertToManaged' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedMessage">
        <source>The type '{0}' specifies it supports the '{1}' marshal mode, but it does not provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns '{2}'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供將未受控的類型當做參數並傳回 '{2}' 的 'ConvertToManaged' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedDescription">
        <source>A stateless value marshaller that supports marshalling from managed to unmanaged must provide a one-parameter 'ConvertToUnmanaged' method that takes the managed value as the parameter and returns a value of the 'unmanaged' type.</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態值封送處理程式必須提供單一參數 'ConvertToUnmanaged' 方法，將受控值作為參數，並傳回 'unmanaged' 類型的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a one-parameter 'ConvertToUnmanaged' method that takes a '{2}' as a parameter and returns a value of an 'unmanaged' type</source>
        <target state="translated">類型 '{0}' 指定它支援 '{2}' 的 '{1}' 封送處理模式，但不提供以 '{2}' 為參數的單一參數 'ConvertToUnmanaged' 方法，並傳回 'unmanaged' 類型的值</target>
        <note />
      </trans-unit>
      <trans-unit id="StringMarshallingCustomTypeNotAccessibleByGeneratedCode">
        <source>The type '{0}' specified as 'GeneratedComInterfaceAttribute.StringMarshallingCustomType' is not accessible by generated code. The type must have at least 'internal' accessibility. {1}</source>
        <target state="translated">指定為 'GeneratedComInterfaceAttribute.StringMarshallingCustomType' 的類型 '{0}' 無法由產生的程式碼存取。類型必須至少具有 'internal' 存取範圍。{1}</target>
        <note>{1} is details about which type/containing type is not accessible</note>
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchDescription">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same.</source>
        <target state="translated">'ToUnmanaged' 的傳回類型與 'FromUnmanaged' 的參數類型必須相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchMessage">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same</source>
        <target state="translated">'ToUnmanaged' 的傳回類型與 'FromUnmanaged' 的參數類型必須相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchDescription">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same.</source>
        <target state="translated">'ConvertToUnmanaged' 的傳回類型與 'ConvertToManaged' 的參數類型必須相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchMessage">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same</source>
        <target state="translated">'ConvertToUnmanaged' 的傳回類型與 'ConvertToManaged' 的參數類型必須相同</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeAccessibilityDetails">
        <source>'{0}' has accessibility '{1}'.</source>
        <target state="translated">'{0}' 具有存取範圍 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedDescription">
        <source>The unmanaged type for a custom marshaller must be a C# unmanaged type.</source>
        <target state="translated">自訂封送處理程式的未受控類型必須是 C# 未受控類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedMessage">
        <source>The return type of '{0}' must be unmanaged</source>
        <target state="translated">'{0}' 的傳回類型必須為不受控</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerDescription">
        <source>'void*' must be castable to the type so the pinned result of the static 'GetPinnableReference' method can be passed to the native context after being pinned.</source>
        <target state="translated">'void*' 必須可轉換為類型，以致靜態 'GetPinnableReference' 方法的釘選結果可在釘選之後傳遞至原生內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerMessage">
        <source>'void*' must be castable to the type '{0}' because the managed type '{1}' has a static 'GetPinnableReference' method</source>
        <target state="translated">'void*' 必須轉換為類型 '{0}'，因為受控類型 '{1}' 具有靜態 'GetPinnableReference' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedDescriptionCom">
        <source>For types that are not supported by source-generated COM, the resulting function pointer will rely on the underlying runtime to marshal the specified type.</source>
        <target state="translated">對於來源產生的 COM 不支援的類型，產生的函式指標將依賴基礎執行階段來封送處理指定的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedDescriptionLibraryImport">
        <source>For types that are not supported by source-generated P/Invokes, the resulting P/Invoke will rely on the underlying runtime to marshal the specified type.</source>
        <target state="translated">對於來源產生的 P/Invokes 不支援的類型，產生的 P/Invoke 將依賴基礎運行時間來封送指定的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterCom">
        <source>The type '{0}' is not supported by source-generated COM. The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">来源產生的 COM 不支援類型 '{0}'。產生的来源將不會處理參數 '{1}' 的封送處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterLibraryImport">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">来源產生的 P/Invokes 不支援類型 '{0}'。產生的来源將不會處理參數 '{1}' 的排列。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterWithDetails">
        <source>{0} The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">{0} 產生的来源将不會處理參數 '{1}' 的排列。</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the parameter</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnCom">
        <source>The type '{0}' is not supported by source-generated COM. The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">来源產生的 COM 不支援類型 '{0}'。產生的來源將不會處理方法 '{1}' 的傳回值之封送處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnLibraryImport">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">来源產生的 P/Invokes 不支援類型 '{0}'。產生的來源將不會處理方法 '{1}' 的傳回值排列。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnWithDetails">
        <source>{0} The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">{0} 產生的來源將不會處理方法 '{1}' 之傳回值的排列。</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the method</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedTitle">
        <source>Specified type is not supported by source-generated P/Invokes</source>
        <target state="translated">来源產生的 P/Invokes 不支援指定的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedTitleCom">
        <source>Specified type is not supported by source-generated COM</source>
        <target state="translated">来源產生的 COM 不支援指定的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnmanagedToManagedMissingRequiredMarshaller">
        <source>The specified parameter needs to be marshalled from unmanaged to managed, but the marshaller type '{0}' does not support it.</source>
        <target state="translated">指定的參數必須從非受控封送處理到受控，但封送處理程式類型 '{0}' 不支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryMarshallingInfoDescription">
        <source>Unnecesssary marshalling info was provided. This marshalling information can be removed without any change in behavior to the application.</source>
        <target state="translated">已提供不必要的封送資訊。您可以移除此封送資訊，而不會對應用程式進行任何行為變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryMarshallingInfoTitle">
        <source>Unnecessary marshalling info was provided and can be removed.</source>
        <target state="translated">已提供不必要的封送資訊，而且可以移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryParameterMarshallingInfoMessage">
        <source>Unnecessary marshalling info '{0}' was provided for parameter '{1}'. {2}</source>
        <target state="translated">已為參數 '{0}' 提供了不必要的封送資訊 '{1}'。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryReturnMarshallingInfoMessage">
        <source>Unnecessary marshalling info '{0}' was provided for the return type of method '{1}'. {2}</source>
        <target state="translated">已為方法 '{0}' 的傳回類型提供了不必要的封送資訊 '{1}'。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'Value'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a two-parameter constructor taking the managed type and a 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">支援 'CallerAllocatedBuffer' 功能的 'Value'-kind 原生類型必須提供接受受管理類型的雙參數建構函示，以及以 'unmanaged' 類型的 'Span' 作為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a two-parameter constructor that takes a '{1}' and 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">類型 '{0}' 指定其支援使用 'CallerAllocatedBuffer' 功能為 '{1}' 的 'In' 封送處理，但不提供接受 '{1}' 的二參數構建函式，以及以 'unmanaged' 類型的 'Span' 作為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorDescription">
        <source>A 'Value'-kind native type must provide a one-parameter constructor taking the managed type as a parameter</source>
        <target state="translated">'Value'-kind 原生類型必須提供以 Managed 類型作為參數的單一參數構建函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling of '{1}' but does not provide a one-parameter constructor that takes a '{1}' as a parameter</source>
        <target state="translated">類型 '{0}'指定它支援 'In' 封送'{1}'，但不提供以'{1}'作為參數的單一參數建構函式</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>