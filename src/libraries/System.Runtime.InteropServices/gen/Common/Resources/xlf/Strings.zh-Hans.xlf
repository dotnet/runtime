<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
    <body>
      <trans-unit id="AddGeneratedComClassAddUnsafe">
        <source>Add 'GeneratedComClassAttribute' to enable passing objects of this type to COM and allow unsafe code</source>
        <target state="translated">添加“GeneratedComClassAttribute”以启用将此类对象传递到 COM，并允许不安全代码</target>
        <note />
      </trans-unit>
      <trans-unit id="AddGeneratedComClassAttributeDescription">
        <source>This type implements at least one type with the 'GeneratedComInterfaceAttribute' attribute. Add the 'GeneratedComClassAttribute' to enable passing this type to COM and exposing the COM interfaces for the types with the 'GeneratedComInterfaceAttribute' from objects of this type.</source>
        <target state="translated">此类型至少实现一个具有“GeneratedComInterfaceAttribute”属性的类型。添加“GeneratedComClassAttribute”以允许将此类型传递到 COM，并公开具有此类型的对象的“GeneratedComInterfaceAttribute”的类型的 COM 接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddGeneratedComClassAttributeMessage">
        <source>Add the 'GeneratedComClassAttribute' to '{0}' to enable passing objects of type '{0}' to COM</source>
        <target state="translated">将“GeneratedComClassAttribute”添加到“{0}”以启用将“{0}”类型的对象传递到 COM</target>
        <note />
      </trans-unit>
      <trans-unit id="AddGeneratedComClassAttributeTitle">
        <source>Add 'GeneratedComClassAttribute' to enable passing objects of this type to COM</source>
        <target state="translated">添加“GeneratedComClassAttribute”以启用将此类型的对象传递到 COM</target>
        <note />
      </trans-unit>
      <trans-unit id="AddMissingCustomTypeMarshallerMembers">
        <source>Add missing custom type marshaller members</source>
        <target state="translated">添加缺少的自定义类型封送程序成员</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedDescription">
        <source>The analysis required to generate code for this interface or method has failed due to an unexpected code pattern. If you are using new or unconventional syntax, consider using other syntax.</source>
        <target state="translated">由于意外的代码模式，为此接口或方法生成代码所需的分析失败。如果你使用的是新语法或非常规语法，请考虑使用其他语法。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedInterfaceMessage">
        <source>Analysis of interface '{0}' has failed. ComInterfaceGenerator will not generate code for this interface.</source>
        <target state="translated">接口“{0}”的分析失败。ComInterfaceGenerator 将不会为此接口生成代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedMethodMessage">
        <source>Analysis of method '{0}' has failed. ComInterfaceGenerator will not generate code for this method.</source>
        <target state="translated">方法“{0}”的分析失败。ComInterfaceGenerator 将不会为此方法生成代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalysisFailedTitle">
        <source>Analysis for COM interface generation has failed.</source>
        <target state="translated">COM 接口生成分析失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArraySizeMustBeSpecified">
        <source>Marshalling an array from unmanaged to managed requires either the 'SizeParamIndex' or 'SizeConst' fields to be set on a 'MarshalAsAttribute' or the 'ConstantElementCount' or 'CountElementName' properties to be set on a 'MarshalUsingAttribute'.</source>
        <target state="translated">对从非托管到托管的数组进行封送需要在 “MarshalAsAttribute” 或 “ConstantElementCount” 或 “CountElementName” 属性上设置 “SizeParamIndex” 或 “SizeConst” 字段。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceCannotBeGeneratedDescription">
        <source>COM interface source generation requires all base COM interfaces to be valid interfaces. Fix any issues on the base interface to resolve this diagnostic.</source>
        <target state="translated">COM 接口源生成要求所有基本 COM 接口都是有效接口。修复基本接口上的任何问题以解决此诊断。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceCannotBeGeneratedMessage">
        <source>COM interface {0} inherits from {1}, which has errors. ComInterfaceGenerator will not generate source for {0}.</source>
        <target state="translated">COM 接口 {0} 继承自 {1}，具有错误。ComInterfaceGenerator 不会为 {0} 生成源。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceCannotBeGeneratedTitle">
        <source>The base COM interface failed to generate source. Code will not be generated for this interface.</source>
        <target state="translated">基本 COM 接口无法生成源。不会为此接口生成代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseInterfaceMustGenerateAtLeastSameWrappers">
        <source>A 'GeneratedComInterface' cannot specify 'ComInterfaceOptions.ManagedObjectWrapper' or 'ComInterfaceOptions.ComObjectWrapper' unless the base interface type did not specify options or specified at least the same options.</source>
        <target state="translated">"GeneratedComInterface" 不能指定 "ComInterfaceOptions.ManagedObjectWrapper" 或 "ComInterfaceOptions.ComObjectWrapper"，除非基接口类型未指定选项或至少指定了相同的选项。</target>
        <note />
      </trans-unit>
      <trans-unit id="BidirectionalMissingRequiredMarshaller">
        <source>The specified parameter needs to be marshalled from managed to unmanaged and unmanaged to managed, but the marshaller type '{0}' does not support it.</source>
        <target state="translated">需要将指定的参数从托管封送到非托管和从非托管封送到托管，但封送程序类型“{0}”不支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing a 'FromManaged' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">如果通过提供从封送处理程序类型提取“Span&lt;T&gt;”的“FromManaged”方法来使用“Managed to Unmanaged with Caller-Allocated Buffer”形状，则该类型必须提供一个静态的“BufferSize”属性才能提供已分配调用方缓冲。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has a FromManaged method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">封送处理程序类型“{0}”必须拥有静态的只读“int”“BufferSize”属性，才能指定已分配调用方缓冲的大小，因为它具有提取已分配调用方“Span&lt;{1}&gt;”的 FromManaged 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportDescription">
        <source>The generated 'DllImportAttribute' will not have a value corresponding to '{0}'.</source>
        <target state="translated">生成的 “DllImportAttribute” 将不具有与“{0}”对应的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportMessage">
        <source>'{0}' has no equivalent in 'DllImportAttribute' and will not be forwarded</source>
        <target state="translated">"{0}" 在 "DllImportAtttribute" 中没有等效项，并且将不会被转发</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportTitle">
        <source>Specified 'LibraryImportAttribute' arguments cannot be forwarded to 'DllImportAttribute'</source>
        <target state="translated">指定的 “LibraryImportAttribute” 参数无法转发到 “DllImportAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="CastsBetweenRuntimeComAndSourceGeneratedComNotSupportedDescription">
        <source>Casting between a 'ComImport' type and a source-generated COM type is not supported and will fail at runtime</source>
        <target state="translated">不支持在“ComImport”类型和源生成的 COM 类型之间强制转换，并且会在运行时失败</target>
        <note />
      </trans-unit>
      <trans-unit id="CastsBetweenRuntimeComAndSourceGeneratedComNotSupportedMessage">
        <source>Casting between a 'ComImport' type and a source-generated COM type is not supported</source>
        <target state="translated">不支持在“ComImport”类型和源生成的 COM 类型之间强制转换</target>
        <note />
      </trans-unit>
      <trans-unit id="CastsBetweenRuntimeComAndSourceGeneratedComNotSupportedTitle">
        <source>Casting between a 'ComImport' type and a source-generated COM type is not supported</source>
        <target state="translated">不支持在“ComImport”类型和源生成的 COM 类型之间强制转换</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassDoesNotImplementAnyGeneratedComInterfacesDescription">
        <source>A class with 'GeneratedComClassAttribute' must implement at least one interface with 'GeneratedComInterfaceAttribute' or else the generated code with not have an effect.</source>
        <target state="translated">具有“GeneratedComClassAttribute”的类必须至少实现一个具有“GeneratedComInterfaceAttribute”的接口，否则生成的代码不起作用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassDoesNotImplementAnyGeneratedComInterfacesMessage">
        <source>Class '{0}' with 'GeneratedComClassAttribute' does not implement any interfaces with 'GeneratedComInterfaceAttribute'. Source will not be generated for '{0}'.</source>
        <target state="translated">具有“GeneratedComClassAttribute”的类 {0} 不实现具有“GeneratedComInterfaceAttribute”的任何接口。不会为“{0}”生成源。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionSizeParamTypeMustBeIntegral">
        <source>The specified collection size parameter for an collection must be an integer type. If the size information is applied to a nested collection, the size parameter must be a collection of one less level of nesting with an integral element.</source>
        <target state="translated">为集合指定的集合大小参数必须是整数类型。如果大小信息应用于嵌套集合，则大小参数必须是具有整数元素的嵌套级别少一个层次的集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComHostingDoesNotSupportGeneratedComInterfaceDescription">
        <source>.NET COM hosting with 'EnableComHosting' only supports built-in COM interop. It does not support source-generated COM interop with 'GeneratedComInterfaceAttribute'.</source>
        <target state="translated">具有“EnableComHosting”的 .NET COM 托管仅支持内置 COM 互操作。它不支持源生成的 COM 与“GeneratedComInterfaceAttribute”的互操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComHostingDoesNotSupportGeneratedComInterfaceMessage">
        <source>.NET COM hosting with 'EnableComHosting' does not support interfaces with the 'GeneratedComInterfaceAttribute'. Change any COM exposed interfaces implemented by '{0}' to use the 'System.Runtime.InteropServices.ComVisibleAttribute' instead</source>
        <target state="translated">具有“EnableComHosting”的 .NET COM 托管不支持具有“GeneratedComInterfaceAttribute”的接口。将“{0}”实现的任何 COM 公开接口更改为改用“System.Runtime.InteropServices.ComVisibleAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="ComHostingDoesNotSupportGeneratedComInterfaceTitle">
        <source>.NET COM hosting with 'EnableComHosting' does not support interfaces with the 'GeneratedComInterfaceAttribute'</source>
        <target state="translated">具有“EnableComHosting”的 .NET COM 托管不支持具有“GeneratedComInterfaceAttribute”的接口</target>
        <note />
      </trans-unit>
      <trans-unit id="ComInterfaceUsageDoesNotFollowBestPracticesMessageWithDetails">
        <source>The usage of 'GeneratedComInterfaceAttribute' does not follow recommendations. {0}</source>
        <target state="translated">“GeneratedComInterfaceAttribute”的使用未遵循建议。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ComInterfaceUsageDoesNotFollowBestPracticesTitle">
        <source>The usage of 'GeneratedComInterfaceAttribute' does not follow recommendations.</source>
        <target state="translated">“GeneratedComInterfaceAttribute”的使用未遵循建议。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComMethodReturningIntWillBeOutParameterMessage">
        <source>The return value in the managed definition will be converted to an 'out' parameter when calling the unmanaged COM method. If the return value is intended to be the HRESULT code returned by the unmanaged COM method, use '[PreserveSig]' on the method.</source>
        <target state="translated">调用非托管 COM 方法时，托管定义中的返回值将转换为 "out" 参数。如果返回值是非托管 COM 方法返回的 HRESULT 代码，请对方法使用 "[PreserveSig]"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComMethodReturningIntWillBeOutParameterTitle">
        <source>The return value in the managed definition will be converted to an additional 'out' parameter at the end of the parameter list when calling the unmanaged COM method.</source>
        <target state="translated">调用非托管 COM 方法时，托管定义中的返回值将转换为参数列表末尾的附加 "out" 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedDescriptionCom">
        <source>Source-generated COM will ignore any configuration that is not supported.</source>
        <target state="translated">源生成的 COM 将忽略任何不受支持的配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedDescriptionLibraryImport">
        <source>Source-generated P/Invokes will ignore any configuration that is not supported.</source>
        <target state="translated">源生成的 P/Invoke 将忽略任何不受支持的配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageCom">
        <source>The '{0}' configuration is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">源生成的 COM 不支持 "{0}" 配置。如果需要指定的配置，请改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageLibraryImport">
        <source>The '{0}' configuration is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">源生成的 P/Invoke 不支持“{0}”配置。如果需要指定配置，请改用常规的“DllImport”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageMarshallingInfoCom">
        <source>The specified marshalling configuration is not supported by source-generated COM. {0}.</source>
        <target state="translated">源生成的 COM 不支持指定的封送配置。{0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageMarshallingInfoLibraryImport">
        <source>The specified marshalling configuration is not supported by source-generated P/Invokes. {0}.</source>
        <target state="translated">源生成的 P/Invoke 不支持指定的封送配置。{0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageParameterCom">
        <source>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">源生成的 COM 不支持方法“{0}”参数“{1}”配置。如果需要指定配置，请改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageParameterLibraryImport">
        <source>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">源生成的 P/Invoke 不支持参数“{1}”的指定“{0}”配置。如果需要指定配置，请改用常规的“DllImport”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageReturnCom">
        <source>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">源生成的 COM 不支持方法“{0}”返回值的指定“{1}”配置。如果需要指定配置，请改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageReturnLibraryImport">
        <source>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">源生成的 P/Invoke 不支持方法“{1}”返回值的指定“{0}”配置。如果需要指定配置，请改用常规的“DllImport”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageValueCom">
        <source>The specified value '{0}' for '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">源生成的 COM 不支持为 "{1}" 指定的值 "{0}"。如果需要指定的配置，请改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageValueLibraryImport">
        <source>The specified value '{0}' for '{1}' is not supported by source-generated P/Invokes. If the specified value is required, use a regular 'DllImport' instead.</source>
        <target state="translated">源生成的 P/Invoke 不支持“{1}”的指定值“{0}”。如果需要指定值，请改用常规的“DllImport”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedTitleCom">
        <source>Specified configuration is not supported by source-generated COM.</source>
        <target state="translated">源生成的 COM 不支持指定的配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedTitleLibraryImport">
        <source>Specified configuration is not supported by source-generated P/Invokes.</source>
        <target state="translated">源生成的 P/Invoke 不支持指定的配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantAndElementCountInfoDisallowed">
        <source>Only one of 'ConstantElementCount' or 'ElementCountInfo' may be used in a 'MarshalUsingAttribute' for a given 'ElementIndirectionDepth'</source>
        <target state="translated">对于给定的 “ElementIndirectionDepth”，在 “MarshalUsingAttribute” 中只能使用 “ConstantElementCount” 或 “ElementCountInfo” 中的一个</target>
        <note />
      </trans-unit>
      <trans-unit id="ContainingTypeAccessibilityDetails">
        <source>Containing type '{0}' has accessibility '{1}'.</source>
        <target state="translated">包含类型“{0}”具有可访问性“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertComInterfaceMayProduceInvalidCode">
        <source>Converting this interface to use 'GeneratedComInterfaceAttribute' may produce invalid code and may require additional work</source>
        <target state="translated">将此接口转换为使用“GeneratedComInterfaceAttribute”可能会产生无效代码，并且可能需要执行其他工作</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertNoPreserveSigDllImportToGeneratedMayProduceInvalidCode">
        <source>Automatically converting a P/Invoke with 'PreserveSig' set to 'false' to a source-generated P/Invoke may produce invalid code</source>
        <target state="translated">将 “PreserveSig” 设置为 “false” 的 P/Invoke 自动转换为源生成的 P/Invoke 可能会产生无效代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceAddUnsafe">
        <source>Convert to 'GeneratedComInterface' and allow unsafe code</source>
        <target state="translated">转换为“GeneratedComInterface”并允许不安全的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceDescription">
        <source>Use 'GeneratedComInterfaceAttribute' instead of 'ComImportAttribute' to generate COM marshalling code at compile time</source>
        <target state="translated">使用“GeneratedComInterfaceAttribute”而不是“ComImportAttribute”以在编译时生成 COM 封送代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceMayRequireCustomMarshalling">
        <source>Converting this API to 'GeneratedComInterfaceAttribute' will require additional code to provide custom marshallers for some parameters.</source>
        <target state="translated">将此 API 转换为“GeneratedComInterfaceAttribute”将需要其他代码来为某些参数提供自定义封送程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceMessage">
        <source>Mark the type '{0}' with 'GeneratedComInterfaceAttribute' instead of 'ComImportAttribute' to generate COM marshalling code at compile time</source>
        <target state="translated">使用“GeneratedComInterfaceAttribute”而不是“ComImportAttribute”标记类型“{0}”，以便在编译时生成 COM 封送代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToGeneratedComInterfaceTitle">
        <source>Convert to 'GeneratedComInterface'</source>
        <target state="translated">转换为“GeneratedComInterface”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImport">
        <source>Convert to 'LibraryImport'</source>
        <target state="translated">转换为 “LibraryImport”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportAddUnsafe">
        <source>Convert to 'LibraryImport' and enable unsafe code</source>
        <target state="translated">转换为 “LibraryImport” 并启用不安全代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportDescription">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">使用 “LibraryImportAttribute” 而不是 “DllImportAttribute” 在编译时生成 P/Invoke 封送代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMayRequireCustomMarshalling">
        <source>Converting this API to 'LibraryImport' will require additional code to provide custom marshallers for some parameters.</source>
        <target state="translated">将此 API 转换为 “LibraryImport” 将需要额外的代码来为某些参数提供自定义封送程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMessage">
        <source>Mark the method '{0}' with 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">使用 “LibraryImportAttribute” 而不是 “DllImportAttribute” 标记方法“{0}”，以便在编译时生成 P/Invoke 封送代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportTitle">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">使用 “LibraryImportAttribute” 而不是 “DllImportAttribute” 在编译时生成 P/Invoke 封送代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffix">
        <source>Convert to 'LibraryImport' with '{0}' suffix</source>
        <target state="translated">转换为带“{0}”后缀的 “LibraryImport”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffixAddUnsafe">
        <source>Convert to 'LibraryImport' with '{0}' suffix and enable unsafe code</source>
        <target state="translated">转换为具有“{0}”后缀的 “LibraryImport” 并启用不安全的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomMarshallerTypeMustHaveRequiredShapeTitle">
        <source>Marshaller type does not have the required shape</source>
        <target state="translated">封送程序类型没有必需的形状</target>
        <note />
      </trans-unit>
      <trans-unit id="CyclicalCountInfo">
        <source>This element cannot depend on '{0}' for collection size information without creating a dependency cycle</source>
        <target state="translated">在不创建依赖关系循环的情况下，此元素无法依赖于集合大小信息的“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCountInfo">
        <source>Count information for a given element at a given indirection level can only be specified once</source>
        <target state="translated">给定间接级别的给定元素的计数信息只能指定一次</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMarshallingInfo">
        <source>Multiple marshalling attributes per element per indirection level is unsupported, but duplicate information was provided for indirection level {0}</source>
        <target state="translated">不支持每个间接级别每个元素有多个封送属性，但为间接级别 {0} 提供了重复的信息</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulDescription">
        <source>A marshaller for an element scenario cannot be stateful.</source>
        <target state="translated">元素方案的封送程序不能是监控状态的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulMessage">
        <source>The specified marshaller type '{0}' is a stateful marshaller, but stateful marshallers are not allowed in the provided marshal mode '{1}'</source>
        <target state="translated">指定的封送程序类型“{0}”是监控状态的封送程序，但在提供的封送模式“{1}”中不允许使用监控状态的封送程序</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchDescription">
        <source>The element type of the span returned by the first method must be the same type as the element type of the span returned by the second method.</source>
        <target state="translated">第一个方法返回的跨度的元素类型必须与第二个方法返回的跨度的元素类型为相同的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchMessage">
        <source>The element type of the span returned by '{0}' must be the same type as the element type of the span returned by '{1}'.</source>
        <target state="translated">“{0}”返回的跨度的元素类型必须与“{1}”返回的跨度的元素类型为相同的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullDescription">
        <source>An entry-point type for marshalling a given type must not be 'null'.</source>
        <target state="translated">用于封送给定类型的入口点类型不能为“null”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullMessage">
        <source>The entry-point marshaller type for the type '{0}' must be not 'null'</source>
        <target state="translated">类型“{0}”的入口点封送处理程序类型不能为“null”</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeDescription">
        <source>An entry-point type for marshalling a given type must have a 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type.</source>
        <target state="translated">对给定类型进行封送处理的入口点类型必须具有将此类型指定为托管类型的 “System.Runtime.InteropServices.CustomMarshallerAttribute”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeMessage">
        <source>The entry-point marshaller type '{0}' for the type '{1}' must be a type with at least one 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type</source>
        <target state="translated">适用于类型“{1}”的入口点封送处理程序类型“{0}”必须是至少具有一个指定此类型为托管类型的 “System.Runtime.InteropServices.CustomMarshallerAttribute”的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraneousMarshallingInfo">
        <source>Marshalling info was specified for 'ElementIndirectionDepth' {0}, but marshalling info was only needed for {1} level(s) of indirection</source>
        <target state="translated">为 “ElementIndirectionDepth” {0} 指定了封送信息，但只有间接的 {1} 级别需要封送信息</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeDescription">
        <source>The first parameter of the first method must be the same type as the return types of the second method.</source>
        <target state="translated">第一个方法的第一个参数必须与第二个方法的返回类型为相同的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeMessage">
        <source>The first parameter of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">“{0}”的第一个参数必须与“{1}”的返回类型为相同的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchDescription">
        <source>The first parameters of the two methods must be the same type.</source>
        <target state="translated">这两种方法的第一个参数必须为相同的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchMessage">
        <source>The first parameter of '{0}' and '{1}' must be the same type</source>
        <target state="translated">“{0}”和“{1}”的第一个参数必须为相同的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedDescription">
        <source>Overloading the 'FromUnmanaged' method is unuspported as some shapes are unable to distinguish between overloads.</source>
        <target state="translated">不支持重载“FromUnmanaged”方法，因为某些形状无法区分重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedMessage">
        <source>The type '{0}' overloads the 'FromUnmanaged' method, which is not supported in custom marshallers</source>
        <target state="translated">类型“{0}”重载 “FromUnmanaged” 方法，这在自定义封送程序中不受支持</target>
        <note />
      </trans-unit>
      <trans-unit id="GeneratedComInterfaceStringMarshallingMustMatchBase">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' must match the base COM interface.</source>
        <target state="translated">"StringMarshalling" 和 "StringMarshallingCustomType" 的配置必须与基本 COM 接口匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">封送处理程序类型必须是封闭泛型或具有与托管类型相同数目的泛型参数，以便发出的代码可以使用特定实例化。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' for managed type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">适用于托管类型“{1}”的封送处理程序类型“{0}”必须是封闭式泛型类型，如果托管类型是值封送处理程序，则该类型必须与托管类型具有相同的 arity；如果托管类型是集合封送处理程序，则它多具有一个泛型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableDescription">
        <source>The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable.</source>
        <target state="translated">“GetPinnableReference” 的返回类型(考虑到 “ref” 之后)必须是 blittable 的。</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableMessage">
        <source>The dereferenced type of the return type of the 'GetPinnableReference' method must be blittable</source>
        <target state="translated">“GetPinnableReference” 方法的返回类型的取消引用类型必须是 blittable</target>
        <note />
      </trans-unit>
      <trans-unit id="GraphHasCycles">
        <source>The provided graph has cycles and cannot be topologically sorted.</source>
        <target state="translated">提供的图形具有循环，并且无法按拓扑顺序排序。</target>
        <note />
      </trans-unit>
      <trans-unit id="HResultTypeWillBeTreatedAsStructMessage">
        <source>The type '{0}' will be treated as a struct in the native signature, not as a native HRESULT. To treat this as an HRESULT, add '[return:MarshalAs(UnmanagedType.Error)]' to the method.</source>
        <target state="translated">类型“{0}”将被视为本机签名中的结构，而不是本机 HRESULT。若要将其视为 HRESULT，请将“[return:MarshalAs(UnmanagedType.Error)]”添加到方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="HResultTypeWillBeTreatedAsStructTitle">
        <source>This type will be treated as a struct in the native signature, not as a native HRESULT</source>
        <target state="translated">此类型将被视为本机签名中的结构，而不是本机 HRESULT</target>
        <note />
      </trans-unit>
      <trans-unit id="InAttributeNotSupportedOnByValueParameters">
        <source>The '[In]' attribute is only supported on array parameters. By-value parameters are considered read-only by default.</source>
        <target state="translated">“[In]”特性仅在数组参数上受支持。默认情况下，按值参数视为只读。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAttributeNotSupportedWithoutOutBlittableArray">
        <source>The '[In]' attribute is not supported unless the '[Out]' attribute is also used. Blittable arrays cannot be marshalled as '[In]' only.</source>
        <target state="translated">不支持“[In]”属性，除非也使用“[Out]”属性。不能仅将 Blittable 数组封送为“[In]”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAttributeOnlyIsDefault">
        <source>The '[In]' attribute is not necessary unless the '[Out]' attribute is also used. The behavior of the '[In]' attribute without the '[Out]' attribute is the same as the default behavior.</source>
        <target state="translated">不需要 “[In]” 属性，除非同时使用 “[Out]” 属性。没有 “[Out]” 属性的情况下，“[In]” 属性的行为与默认行为相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributeByRefNotSupported">
        <source>The '[In]' and '[Out]' attributes are unsupported on parameters passed by reference. Use the 'in', 'ref', or 'out' keywords instead.</source>
        <target state="translated">引用传递的参数不支持 “[In]” 和 “[Out]” 属性。请改用 “in”、“ref” 或 “out” 关键字。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributeMarshalerNotSupported">
        <source>The provided '[In]' and '[Out]' attributes on this parameter are unsupported on this parameter.</source>
        <target state="translated">此参数上提供的 “[In]” 和 “[Out]” 属性在此参数上不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributeNotSupportedOnByValueParameters">
        <source>The '[In]' and '[Out]' attributes are only supported on array parameters. Consider using the 'ref' keyword to make the parameter mutable.</source>
        <target state="translated">“[In]”和“[Out]”属性仅在数组参数上受支持。请考虑使用“ref”关键字使参数可变。</target>
        <note />
      </trans-unit>
      <trans-unit id="InOutAttributes">
        <source>[In] and [Out] attributes</source>
        <target state="translated">[In] 和 [Out] 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="InstanceEventDeclaredInInterfaceDescription">
        <source>Events are not a concept in COM, so no interop code will be source generated for instance events on source-generated COM interfaces.</source>
        <target state="translated">事件不是 COM 的概念，因此不会为源生成的 COM 接口上的实例事件生成互操作代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstanceEventDeclaredInInterfaceMessage">
        <source>The instance event '{0}' is declared in the interface '{1}', which has the 'GeneratedComInterfaceAttribute' applied</source>
        <target state="translated">实例事件“{0}”在接口“{1}”中声明，该接口应用了“GeneratedComInterfaceAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="InstanceEventDeclaredInInterfaceTitle">
        <source>Declaring an instance event in a type with the 'GeneratedComInterfaceAttribute' is not supported</source>
        <target state="translated">不支持在具有“GeneratedComInterfaceAttribute”的类型中声明实例事件</target>
        <note />
      </trans-unit>
      <trans-unit id="InstancePropertyDeclaredInInterfaceDescription">
        <source>Properties are not a concept in COM, so no interop code will be source generated for instance properties on source-generated COM interfaces.</source>
        <target state="translated">属性在 COM 中不是概念，因此不会为源生成的 COM 接口上的实例属性生成互操作代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstancePropertyDeclaredInInterfaceMessage">
        <source>The instance property '{0}' is declared in the interface '{1}', which has the 'GeneratedComInterfaceAttribute' applied</source>
        <target state="translated">实例属性“{0}”在接口“{1}”中声明，该接口应用了“GeneratedComInterfaceAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="InstancePropertyDeclaredInInterfaceTitle">
        <source>Declaring an instance property in a type with the 'GeneratedComInterfaceAttribute' is not supported</source>
        <target state="translated">不支持在具有“GeneratedComInterfaceAttribute”的类型中声明实例属性</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceTypeNotSupportedMessage">
        <source>Using 'GeneratedComInterfaceAttribute' and 'InterfaceTypeAttribute' is not supported with 'ComInterfaceType' value '{0}'.</source>
        <target state="translated">“ComInterfaceType”值“{0}”不支持使用“GeneratedComInterfaceAttribute”和“InterfaceTypeAttribute”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceTypeNotSupportedTitle">
        <source>'GeneratedComInterfaceType' does not support the 'ComInterfaceType' value supplied to 'InterfaceTypeAttribute' on the same type.</source>
        <target state="translated">“GeneratedComInterfaceType”不支持提供给同一类型的“InterfaceTypeAttribute”的“ComInterfaceType”值。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingModifiersMessageCom">
        <source>Method '{0}' is contained in a type '{1}' that is not marked 'partial'. COM source generation will ignore method '{0}'.</source>
        <target state="translated">方法 "{0}" 包含在未标记为 "partial" 的类型 "{1}" 中。COM 源生成将忽略方法 "{0}"。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingModifiersMessageLibraryImport">
        <source>Method '{0}' is contained in a type '{1}' that is not marked 'partial'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">方法“{0}”包含在未标记为 “partial” 的类型“{1}”中。P/Invoke 源生成将忽略方法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingUnmanagedObjectUnwrapperAttributeMessage">
        <source>Containing type of method with VirtualMethodIndexAttribute does not have a UnmanagedObjectUnwrapperAttribute. </source>
        <target state="translated">包含 VirtualMethodIndexAttribute 的方法类型没有 UnmanagedObjectUnwrapperAttribute。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodDescriptionCom">
        <source>Methods on interfaces marked with 'GeneratedComInterfaceAttribute' should be non-generic. COM source generation will ignore methods that are generic.</source>
        <target state="translated">标记为 "GeneratedComInterfaceAttribute" 的接口上的方法应为非泛型。COM 源生成将忽略泛型方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodDescriptionLibraryImport">
        <source>Methods marked with 'LibraryImportAttribute' should be 'static', 'partial', and non-generic. P/Invoke source generation will ignore methods that are non-'static', non-'partial', or generic.</source>
        <target state="translated">标记为 “LibraryImportAttribute” 的方法应为 “static”、“partial” 和非泛型。P/Invoke 源生成将忽略非“static”、“non--partial” 或泛型的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodSignatureMessageCom">
        <source>Method '{0}' should be non-generic when on interfaces marked with the 'GeneratedComInterfaceAttribute'. COM source generation will ignore method '{0}'.</source>
        <target state="translated">在标记为 "GeneratedComInterfaceAttribute" 的接口上时，方法 "{0}" 应为非泛型。COM 源生成将忽略方法 "{0}"。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodSignatureMessageLibraryImport">
        <source>Method '{0}' should be 'static', 'partial', and non-generic when marked with 'LibraryImportAttribute'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">在标记为 “LibraryImportAttribute” 时，方法“{0}”应为 “static”、“partial” 和非泛型。P/Invoke 源生成将忽略方法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCustomMarshallerAttributeUsageTitle">
        <source>Invalid 'CustomMarshallerAttribute' usage</source>
        <target state="translated">“CustomMarshallerAttribute”用法无效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationDescription">
        <source>The configuration of 'ExceptionMarshalling' and 'ExceptionMarshallingCustomType' is invalid.</source>
        <target state="translated">“ExceptionMarshalling” 和 “ExceptionMarshallingCustomType” 的配置无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationMessage">
        <source>The configuration of 'ExceptionMarshalling' and 'ExceptionMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">方法“{0}”上的 “ExceptionMarshalling” 和 “ExceptionMarshallingCustomType” 配置无效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationMissingCustomType">
        <source>'ExceptionMarshallingCustomType' must be specified when 'ExceptionMarshalling' is set to 'ExceptionMarshalling.Custom'.</source>
        <target state="translated">当 “ExceptionMarshalling” 设置为 “ExceptionMarshalling.Custom” 时，必须指定 “ExceptionMarshallingCustomType”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingConfigurationNotCustom">
        <source>'ExceptionMarshalling' should be set to 'ExceptionMarshalling.Custom' when 'ExceptionMarshallingCustomType' is specified.</source>
        <target state="translated">指定 “ExceptionMarshallingCustomType” 时，应将 “ExceptionMarshalling” 设置为 “ExceptionMarshalling.Custom”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidExceptionMarshallingValue">
        <source>The provided value is not a known flag of the 'ExceptionMarshalling' enum.</source>
        <target state="translated">提供的值不是 “ExceptionMarshalling” 枚举的已知标志。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComClassAttributeUsageDescription">
        <source>Classes with 'GeneratedComClassAttribute' must implement one or more interfaces with 'GeneratedComInterfaceAttribute', be marked partial, and be non-generic.</source>
        <target state="translated">具有“GeneratedComClassAttribute”的类必须执行一个或多个具有“GeneratedComInterfaceAttribute”的接口，并标记为部分和非泛型。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComClassAttributeUsageMissingPartialModifier">
        <source>Class '{0}' with 'GeneratedComClassAttribute' or one of its containing types is not marked 'partial'.</source>
        <target state="translated">具有“GeneratedComClassAttribute”或其包含类型之一的类“{0}”未标记为“部分”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComClassAttributeUsageTitle">
        <source>Invalid 'GeneratedComClassAttribute' usage</source>
        <target state="translated">“GeneratedComClassAttribute”用法无效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageDescription">
        <source>Interfaces attributed with 'GeneratedComInterfaceAttribute' must have 'public' or 'internal' accessibility and be partial, non-generic, and must specify a GUID with 'System.Runtime.InteropServices.GuidAttribute'.</source>
        <target state="translated">通过 "GeneratedComInterfaceAttribute" 特性化的接口必须具有 "public" 或 "internal" 可访问性，必须是部分的、非泛型的，并且必须使用 "System.Runtime.InteropServices.GuidAttribute" 指定 GUID。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageInterfaceIsGeneric">
        <source>Interface '{0}' is attributed with 'GeneratedComInterfaceAttribute' but is generic.</source>
        <target state="translated">“{0}”接口通过 "GeneratedComInterfaceAttribute" 特性化，但为泛型接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageInterfaceNotAccessible">
        <source>Interface '{0}' is attributed with 'GeneratedComInterfaceAttribute' but is not accessible by generated code. The interface and all containing types must have accessibility 'internal' or 'public' for generated code to access it. {1}</source>
        <target state="translated">接口 "GeneratedComInterfaceAttribute" 通过“{0}”进行特性化，但生成的代码无法访问它。该接口和所有包含类型必须具有 "internal" 或 "public" 可访问下，生成的代码才能访问它。{1}</target>
        <note>{1} is details about which type/containing type is not accessible</note>
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageMissingGuidAttribute">
        <source>Interface '{0}' is attributed with 'GeneratedComInterfaceAttribute' but is missing 'System.Runtime.InteropServices.GuidAttribute'.</source>
        <target state="translated">接口“{0}”会通过 “GeneratedComInterfaceAttribute” 特性化，但缺少“System.Runtime.InteropServices.GuidAttribute”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceAttributeUsageTitle">
        <source>Invalid 'GeneratedComInterfaceAttribute' usage.</source>
        <target state="translated">“GeneratedComInterfaceAttribute” 使用无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGeneratedComInterfaceUsageMissingPartialModifier">
        <source>The interface '{0}' or one of its containing types is missing the 'partial' keyword. Code will not be generated for '{0}'.</source>
        <target state="translated">接口“{0}”或其包含类型之一缺少“partial”关键字。不会为“{0}”生成代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLibraryImportAttributeUsageTitle">
        <source>Invalid 'LibraryImportAttribute' usage</source>
        <target state="translated">“LibraryImportAttribute” 用法无效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidManagedTypeTitle">
        <source>Specified managed type is invalid</source>
        <target state="translated">指定的托管类型无效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMarshalModeTitle">
        <source>Invalid 'MarshalMode' value.</source>
        <target state="translated">“MarshalMode”值无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMarshallerTypeTitle">
        <source>Specified marshaller type is invalid</source>
        <target state="translated">指定的封送处理程序类型无效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNativeMarshallingAttributeUsageTitle">
        <source>Invalid 'NativeMarshallingAttribute' usage</source>
        <target state="translated">“NativeMarshallingAttribute”用法无效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidOptionsOnInterfaceDescription">
        <source>The specified 'ComInterfaceOptions' are invalid.</source>
        <target state="translated">指定的 "ComInterfaceOptions" 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidOptionsOnInterfaceMessage">
        <source>The specified 'ComInterfaceOptions' on '{0}' are invalid. {1}</source>
        <target state="translated">“{0}”上指定的 "ComInterfaceOptions" 无效。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSignaturesInMarshallerShapeTitle">
        <source>Marshaller type has incompatible method signatures</source>
        <target state="translated">封送程序类型具有不兼容的方法签名</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationDescription">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' is invalid.</source>
        <target state="translated">“StringMarshalling” 和 “StringMarshallingCustomType” 的配置无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMessageCom">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on interface '{0}' is invalid. {1}</source>
        <target state="translated">接口 "{0}" 上的 "StringMarshalling" 和 "StringMarshallingCustomType" 的配置无效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMessageLibraryImport">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">方法“{0}”上的 “StringMarshalling” 和 “StringMarshallingCustomType” 的配置无效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMissingCustomType">
        <source>'StringMarshallingCustomType' must be specified when 'StringMarshalling' is set to 'StringMarshalling.Custom'.</source>
        <target state="translated">在 “StringMarshalling” 设置为 “StringMarshalling.Custom” 时，必须指定 “StringMarshallingCustomType”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationNotCustom">
        <source>'StringMarshalling' should be set to 'StringMarshalling.Custom' when 'StringMarshallingCustomType' is specified.</source>
        <target state="translated">在指定 “StringMarshallingCustomType” 时，应将 “StringMarshalling” 设置为 “StringMarshalling.Custom”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationOnInterfaceMessage">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on interface '{0}' is invalid. {1}</source>
        <target state="translated">接口 "{0}" 上的 "StringMarshalling" 和 "StringMarshallingCustomType" 的配置无效。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationOnMethodMessage">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">方法“{0}”上的 “StringMarshalling” 和 “StringMarshallingCustomType” 的配置无效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidVirtualMethodIndexAttributeUsage">
        <source>Invalid 'VirtualMethodIndexAttribute' usage</source>
        <target state="translated">“VirtualMethodIndexAttribute” 使用情况无效</target>
        <note />
      </trans-unit>
      <trans-unit id="LibraryImportUsageDoesNotFollowBestPracticesMessageWithDetails">
        <source>The usage of 'LibraryImportAttribute' does not follow recommendations. {0}</source>
        <target state="translated">“LibraryImportAttribute”的使用未遵循建议。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="LibraryImportUsageDoesNotFollowBestPracticesTitle">
        <source>The usage of 'LibraryImportAttribute' does not follow recommendations.</source>
        <target state="translated">“LibraryImportAttribute”的使用未遵循建议。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchDescription">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'.</source>
        <target state="translated">“GetManagedValuesSource” 返回的 “ReadOnlySpan” 的元素类型必须与 “GetManagedValuesDestination” 返回的元素类型相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchMessage">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'</source>
        <target state="translated">“GetManagedValuesSource” 返回的 “ReadOnlySpan” 的元素类型必须与 “GetManagedValuesDestination” 返回的元素类型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'LinearCollection'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a three-parameter constructor taking the managed type as the first parameter, a 'Span&lt;byte&gt;' as the second parameter, and the native size of the element as the third parameter</source>
        <target state="translated">支持 “CallerAllocatedBuffer” 功能的 “LinearCollection” 种类本机类型必须提供一个三参数构造函数，该构造函数将托管类型作为第一个参数、“Span&lt;byte&gt;” 作为第二个参数，并将元素本机大小作为第三个参数</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a three-parameter constructor that takes a '{1}' , a 'Span&lt;byte&gt;', and an 'int'</source>
        <target state="translated">类型“{0}”指定它支持使用 “CallerAllocatedBuffer” 功能对“{1}”进行 “In” 封送，但不提供采用“{1}”、“Span&lt;byte&gt;” 和 “int” 的三参数构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'.</source>
        <target state="translated">支持从托管到非托管的封送的连续集合封送程序必须提供返回“ReadOnlySpan&lt;&gt;”的“GetManagedValuesSource”和返回“Span&lt;&gt;”的“GetUnmanagedValuesDestination”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'</source>
        <target state="translated">类型“{0}”指定它支持“{1}”封送模式，但不提供返回“ReadOnlySpan&lt;&gt;”的“GetManagedValuesSource”和返回“Span&lt;&gt;”的“GetUnmanagedValuesDestination”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">支持从非托管封送封送到托管的连续集合封送程序必须提供采用“int”并返回“Span&lt;&gt;”的“GetManagedValuesDestination”和采用“int”并返回“ReadOnlySpan&lt;&gt;”的“GetUnmanagedValuesSource”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">类型“{0}”指定它支持“{1}”封送模式，但不提供采用“int”并返回“Span&lt;&gt;”的“GetManagedValuesDestination”和采用“int”并返回“ReadOnlySpan&lt;&gt;”的“GetUnmanagedValuesSource”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedToUnmanagedMissingRequiredMarshaller">
        <source>The specified parameter needs to be marshalled from managed to unmanaged, but the marshaller type '{0}' does not support it.</source>
        <target state="translated">需要将指定的参数从托管封送到非托管，但封送程序类型“{0}”不支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the generator can determine which methods are available on the specific marshaller types.</source>
        <target state="translated">封送处理程序类型必须是封闭泛型或具有与托管类型相同的泛型参数，以便生成器可以确定哪些方法可用于特定封送处理程序类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityMessage">
        <source>The managed type '{0}' for entry-point marshaller type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">适用于入口点封送处理程序类型“{1}”的托管类型“{0}”必须是封闭式泛型类型，如果托管类型是值封送处理程序，则该类型必须与托管类型具有相同的 arity；如果托管类型是集合封送处理程序，则它多具有一个泛型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullDescription">
        <source>The managed type for a custom marshaller must be non-null.</source>
        <target state="translated">自定义封送处理程序的托管类型必须为非 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullMessage">
        <source>The managed type for the entry-point marshaller type '{0}' must not be 'null'</source>
        <target state="translated">入口点封送处理程序类型“{0}”的托管类型不能为“null”</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageParameterCom">
        <source>The specified 'MarshalAsAttribute' configuration for parameter '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">源生成的 COM 不支持参数“{1}”的指定“MarshalAsAttribute”配置。如果需要指定配置，请改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageParameterLibraryImport">
        <source>The specified 'MarshalAsAttribute' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">源生成的 P/Invoke 不支持参数“{1}”的指定“MarshalAsAttribute”配置。如果需要指定配置，请改用常规的“DllImport”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageReturnCom">
        <source>The specified 'MarshalAsAttribute' configuration for the return value of method '{1}' is not supported by source-generated COM. If the specified configuration is required, use `ComImport` instead.</source>
        <target state="translated">源生成的 COM 不支持方法“{1}”返回值的指定“MarshalAsAttribute”配置。如果需要指定配置，请改用 `ComImport`。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalAsConfigurationNotSupportedMessageReturnLibraryImport">
        <source>The specified 'MarshalAsAttribute' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">源生成的 P/Invoke 不支持方法“{1}”返回值的指定“MarshalAsAttribute”配置。如果需要指定配置，请改用常规的“DllImport”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshalModeMustBeValidEnumValue">
        <source>The 'marshalMode' argument of 'CustomMarshallerAttribute' must be a valid enum value of 'MarshalMode'.</source>
        <target state="translated">“CustomMarshallerAttribute”的“marshalMode”参数必须是“MarshalMode”的有效枚举值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerEntryPointTypeMustMatchArity">
        <source>The marshaller entry point type '{0}' for managed type '{1}' must have an arity of one greater than the managed type.</source>
        <target state="translated">托管类型“{1}”的封送程序入口点类型“{0}”必须具有大于托管类型的 arity。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerInNativeReturnPositionMustMatchNativeReturnType">
        <source>All marshallers for values that are passed as the unmanaged return value must have the same unmanaged type.</source>
        <target state="translated">作为非托管返回值传递的值的所有封送程序必须具有相同的非托管类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">封送处理程序类型必须是封闭泛型或具有与托管类型相同数目的泛型参数，以便发出的代码可以使用特定实例化。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' pointed to by the entry-point marshaller type '{1}' must be a closed generic type or have the same arity as the managed type</source>
        <target state="translated">入口点封送程序类型“{1}”指向的封送程序类型“{0}”必须是闭合泛型类型或与托管类型具有相同的 arity</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullDescription">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'.</source>
        <target state="translated">“System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute”中的“marshallerType”参数不能为“null”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullMessage">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'</source>
        <target state="translated">“System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute”中的“marshallerType”参数不能为“null”</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStruct">
        <source>The marshaller type '{0}' for managed type '{1}' must be a static class or a struct.</source>
        <target state="translated">托管类型 "{1}" 的封送程序类型 "{0}" 必须为静态类或结构。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructDescription">
        <source>A marshaller type must either be a stateless static class or a stateful value type. A non-static class is not allowed.</source>
        <target state="translated">封送程序类型必须为无状态静态类或有状态值类型。不允许使用非静态类。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructMessage">
        <source>The type '{0}' must be a static class or a value type</source>
        <target state="translated">类型“{0}”必须为静态类或值类型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeDescription">
        <source>A type with a 'System.Runtime.InteropServices.CustomMarshallerAttribute' must specify a non-'null' managed type</source>
        <target state="translated">具有“System.Runtime.InteropServices.CustomMarshallerAttribute”的类型必须指定非空的托管类型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeMessage">
        <source>The type '{0}' does not specify a managed type in the 'System.Runtime.InteropServices.CustomMarshallerAttribute' applied to the type</source>
        <target state="translated">类型“{0}”未在应用于该类型的 “System.Runtime.InteropServices.CustomMarshallerAttribute”中指定托管类型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingBoolAsUndefinedNotSupported">
        <source>Marshalling bool without explicit marshalling information is not supported. Specify either 'MarshalUsingAttribute' or 'MarshalAsAttribute'.</source>
        <target state="translated">不支持在没有显式封送信息的情况下封送布尔值。请指定 “MarshalUsingAttribute” 或 “MarshalAsAttribute”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingCharAsSpecifiedStringMarshallingNotSupported">
        <source>Marshalling char with 'StringMarshalling.{0}' is not supported. Instead, manually convert the char type to the desired byte representation and pass to the source-generated P/Invoke.</source>
        <target state="translated">不支持使用 \"StringMarshalling.{0}\" 封送字符。请改用手动方式将字符类型转换为所需的字节表示形式，并传递到源生成的 P/Invoke。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingCharAsStringMarshallingCustomNotSupported">
        <source>Marshalling char with 'StringMarshalling.Custom' is not supported. To use a custom type marshaller, specify 'MarshalUsingAttribute'.</source>
        <target state="translated">不支持使用 \"StringMarscharing.Custom\" 封送 char。若要使用自定义类型封送程序，请指定 \"MarshalUsingAttribute\"。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallingStringOrCharAsUndefinedNotSupported">
        <source>Marshalling string or char without explicit marshalling information is not supported. Specify '{0}.StringMarshalling', '{0}.StringMarshallingCustomType', 'MarshalUsingAttribute' or 'MarshalAsAttribute'.</source>
        <target state="translated">不支持没有明确封送信息的封送字符串或字符。请指定“{0}.StringMarshalling”、“{0}.StringMarshallingCustomType”、“MarshalUsingAttribute”或“MarshalAsAttribute”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodNotDeclaredInAttributedInterfaceDescription">
        <source>All methods must be declared in the same partial definition of a 'GeneratedComInterface'-attributed interface type to ensure reliable calculation for virtual method table offsets.</source>
        <target state="translated">所有方法都必须在 “GeneratedComInterface” 特性化接口类型的同一部分定义中声明，以确保对虚拟方法表偏移进行可靠的计算。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodNotDeclaredInAttributedInterfaceMessage">
        <source>The method '{0}' is declared on a different partial definition of the interface '{1}' than the definition that has the 'GeneratedComInterface' attribute</source>
        <target state="translated">方法“{0}”是在接口“{1}”的不同部分定义上声明的，而不是在具有 “GeneratedComInterface” 属性的定义上声明的</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodNotDeclaredInAttributedInterfaceTitle">
        <source>Method is declared in different partial declaration than the 'GeneratedComInterface' attribute.</source>
        <target state="translated">方法是在不同于 “GeneratedComInterface” 属性的部分声明中声明的。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleComInterfaceBaseTypesDescription">
        <source>A 'GeneratedComInterfaceAttribute'-attributed interface can only derive from at most one other 'GeneratedComInterfaceAttribute'-attributed interface.</source>
        <target state="translated">“GeneratedComInterfaceAttribute”特性化接口最多只能从另一个“GeneratedComInterfaceAttribute”特性化接口派生。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleComInterfaceBaseTypesMessage">
        <source>Interface '{0}' is derived from two or more interfaces attributed with 'GeneratedComInterfaceAttribute'.</source>
        <target state="translated">接口“{0}”派生自使用 “GeneratedComInterfaceAttribute”特性化的两个或更多接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleComInterfaceBaseTypesTitle">
        <source>Specified interface derives from two or more 'GeneratedComInterfaceAttribute'-attributed interfaces.</source>
        <target state="translated">指定的接口派生自两个或更多“GeneratedComInterfaceAttribute”特性化接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWrapperMustBeGenerated">
        <source>Either 'ComInterfaceOptions.ManagedObjectWrapper' or 'ComInterfaceOptions.ComObjectWrapper' must be specified.</source>
        <target state="translated">必须指定 "ComInterfaceOptions.ManagedObjectWrapper" 或 "ComInterfaceOptions.ComObjectWrapper"。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutAttributeNotSupportedOnByValueParameters">
        <source>The '[Out]' attribute is only supported on array parameters. Consider using 'out' or 'ref' keywords to make the parameter mutable.</source>
        <target state="translated">"[Out]" 属性仅在数组参数上受支持。请考虑使用“out”或“ref”关键字使参数可变。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedDescription">
        <source>A 'Value' or 'LinearCollection'-kind native type that supports marshalling in the 'Out' direction must provide a 'ToManaged' method that returns the managed type.</source>
        <target state="translated">支持在 “Out” 方向进行封送处理的 “Value” 或 “LinearCollection” 种类的本机类型必须提供返回托管类型的 “ToManaged” 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedMessage">
        <source>The type '{0}' specifies it supports marshalling in the 'Out' direction, but it does not provide a 'ToManaged' method that returns the managed type</source>
        <target state="translated">类型“{0}”指定它支持按 “Out” 方向进行封送，但不提供返回托管类型的 “ToManaged” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferExplicitInOutAttributesOnArrays">
        <source>It is recommended to use explicit '[In]' and '[Out]' attributes on array parameters.</source>
        <target state="translated">建议对数组参数使用显式“[In]”和“[Out]”属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksDescriptionCom">
        <source>'GeneratedComInterfaceAttribute' and 'GeneratedComClassAttribute' require unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">“GeneratedComInterfaceAttribute”和“GeneratedComClassAttribute”需要不安全代码。必须将项目更新为“&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksDescriptionLibraryImport">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的代码。必须使用 “&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;”更新项目。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksMessageCom">
        <source>'GeneratedComInterfaceAttribute' and 'GeneratedComClassAttribute' require unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">“GeneratedComInterfaceAttribute”和“GeneratedComClassAttribute”需要不安全代码。必须将项目更新为“&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksMessageLibraryImport">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的代码。必须使用 “&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;”更新项目。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksTitleCom">
        <source>'GeneratedComInterfaceAttribute' and 'GeneratedComClassAttribute' require unsafe code.</source>
        <target state="translated">“GeneratedComInterfaceAttribute”和“GeneratedComClassAttribute”需要不安全代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksTitleLibraryImport">
        <source>LibraryImportAttribute requires unsafe code.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeDescription">
        <source>The return type the two method must be the expected type.</source>
        <target state="translated">这两种方法的返回类型必须为预期类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeMessage">
        <source>The return type of '{0}' must be '{1}'</source>
        <target state="translated">“{0}”的返回类型必须为“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchDescription">
        <source>The return types of the two methods must be the same type.</source>
        <target state="translated">这两种方法的返回类型必须为相同的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchMessage">
        <source>The return type of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">“{0}”的返回类型必须与“{1}”的返回类型为相同的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeComApisDoNotSupportSourceGeneratedComDescription">
        <source>COM Interop APIs on 'System.Runtime.InteropServices.Marshal' do not support source-generated COM and will fail at runtime</source>
        <target state="translated">“System.Runtime.InteropServices.Marshal”上的 COM 互操作 API 不支持源生成的 COM，并且将在运行时失败</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeComApisDoNotSupportSourceGeneratedComMessage">
        <source>The method '{0}' only supports runtime-based COM interop and will not work with type '{1}'</source>
        <target state="translated">方法“{0}”仅支持基于运行时的 COM 互操作，并且不适用于类型“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeComApisDoNotSupportSourceGeneratedComTitle">
        <source>COM Interop APIs on 'System.Runtime.InteropServices.Marshal' do not support source-generated COM</source>
        <target state="translated">“System.Runtime.InteropServices.Marshal”上的 COM 互操作 API 不支持源生成的 COM</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeMarshallingMustBeDisabled">
        <source>Runtime marshalling must be disabled in this project by applying the 'System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute' to the assembly to enable marshalling this type.</source>
        <target state="translated">必须通过将 \"System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute\" 应用到程序集来在此项目中禁用运行时封送，以启用此类型的封送处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="SafeHandleByRefMustBeConcrete">
        <source>An abstract type derived from 'SafeHandle' cannot be marshalled by reference. The provided type must be concrete.</source>
        <target state="translated">无法通过引用封送派生自 “SafeHandle” 的抽象类型。提供的类型必须是具体的。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeOfCollectionMustBeKnownAtMarshalTimeMessageOutParam">
        <source>The size of parameter '{0}' that is marshalled to the callee must be defined when the method is called, but count parameter '{1}' is an 'out' parameter.</source>
        <target state="translated">调用方法时，必须定义封送给被调用方的参数“{0}”的大小，但计数参数“{1}”是一个 "out" 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeOfCollectionMustBeKnownAtMarshalTimeMessageReturnValue">
        <source>The size of parameter '{0}' that is marshalled to the callee must be defined when the method is called, but the return value is used as the size of the collection.</source>
        <target state="translated">调用方法时，必须定义封送给被调用方的参数“{0}”的大小，但返回值用作集合的大小。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeOfCollectionMustBeKnownAtMarshalTimeTitle">
        <source>The size of a collection that is marshalled to the callee must be defined when the method is called.</source>
        <target state="translated">调用方法时，必须定义封送给被调用方的集合的大小。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeDescription">
        <source>A stateful marshaller must have a zero-parameter void-returning instance method named 'Free'.</source>
        <target state="translated">监控状态的封送程序必须具有名为 “Free” 的零参数 void 返回实例方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeMessage">
        <source>The type '{0}' is a stateful marshaller and does not have a zero-parameter void-returning instance method named 'Free'</source>
        <target state="translated">类型“{0}”是监控状态的封送程序，并且不具有名为 “Free” 的零参数 void 返回实例方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'FromManaged' instance method that takes the managed value as a parameter and returns 'void'.</source>
        <target state="translated">支持从托管到非管理的封送的监控状态封送程序必须提供 “FromManaged” 实例方法，该方法将托管值作为参数并返回 “void”。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromManaged' that takes a '{2}' as a parameter and returns 'void'</source>
        <target state="translated">类型“{0}”指定它支持“{2}”的“{1}”封送模式，但它不提供名为 “FromUnmanaged”，且将“{2}”作为参数并返回 “void” 的单参数实例方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'FromUnmanaged' instance method that takes the unmanaged value as a parameter and returns 'void'.</source>
        <target state="translated">支持从非管理到托管的封送的监控状态封送程序必须提供 “FromUnmanaged” 实例方法，该方法将非管理的值作为参数并返回 “void”。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromUnmanaged' that takes the 'unmanaged' value as a parameter and returns 'void'</source>
        <target state="translated">类型“{0}”指定它支持“{2}”的“{1}”封送模式，但它不提供名为 “FromUnmanaged”，且将“非管理”的值作为参数并返回 “void” 的单参数实例方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'ToManaged' instance method that takes no parameters and returns the managed type.</source>
        <target state="translated">支持从非管理到托管的封送的监控状态封送程序必须提供不采用任何参数并返回托管类型的“ToManaged”实例方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToManaged' that returns '{2}'</source>
        <target state="translated">类型“{0}”指定它支持“{2}”的“{1}”封送模式，但它不提供名为 “Tomanaged”，且返回“{2}”的零参数实例方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'ToUnmanaged' instance method that takes no parameters and returns the 'unmanaged' type.</source>
        <target state="translated">支持从托管到非管理的封送的监控状态封送程序必须提供 “ToUnmanaged” 实例方法，该方法不使用参数并返回“非管理”类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToUnmanaged' that returns the 'unmanaged' type for the marshaller</source>
        <target state="translated">类型“{0}”指定它支持“{2}”的“{1}”封送模式，但它不提供名为 “ToUnmanaged”，且为封送程序返回“非管理”类型的零参数实例方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing an 'AllocateContainerForUnmanagedElements' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">如果在封送程序类型上提供采用“Span&lt;T&gt;”的“AllocateContainerForUnmanagedElements”方法以使用“通过调用方分配的缓冲区从托管到非托管”形状，则该类型必须提供静态“BufferSize”属性以提供调用方分配的缓冲区中的元素数。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has an 'AllocateContainerForUnmanagedElements' method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">封送程序类型“{0}”必须具有静态只读“int”“BufferSize”属性以指定调用方分配的缓冲区的大小，因为它具有采用调用方分配的“Span&lt;{1}&gt;”的“AllocateContainerForUnmanagedElements”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that takes the managed value as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">支持从托管到非托管的封送的连续集合封送程序必须提供将托管值用作参数并返回“ReadOnlySpan&lt;&gt;”的“GetManagedValuesSource”和将非托管值用作参数并返回“Span&lt;&gt;”的“GetUnmanagedValuesDestination”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that takes '{2}' as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">类型“{0}”指定它支持“{1}”封送模式，但不提供将“{2}”用作参数并返回“ReadOnlySpan&lt;&gt;”的“GetManagedValuesSource 和将非托管值用作参数并返回“Span&lt;&gt;”的“GetUnmanagedValuesDestination”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes the managed value and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">支持从非托管到托管的封送的连续集合封送程序必须提供采用托管值并返回“Span&lt;&gt;”的“GetManagedValuesDestination”以及采用非托管值和“int”并返回“ReadOnlySpan&lt;&gt;”的“GetUnmanagedValuesSource”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes '{2}' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">类型“{0}”指定它支持“{1}”封送模式，但不提供采用“{2}”并返回“Span&lt;&gt;”的“GetManagedValuesDestination”以及采用非托管值和“int”并返回“ReadOnlySpan&lt;&gt;”的“GetManagedValuesSource”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForManagedElements' method taking the unmanaged type as the first parameter and the number of elements as an 'int' parameter</source>
        <target state="translated">支持从托管到非托管的封送的无状态连续集合封送程序必须提供将非托管类型用作第一个参数并将元素数用作 “int” 参数的“AllocateContainerForManagedElements” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForManagedElements' method that takes the unmanaged type as the first parameter and an 'int' as the second parameter</source>
        <target state="translated">类型“{0}”指定它支持“{2}”的“{1}”封送模式，但不提供将非托管类型用作第一个参数并将“int”用作第二个参数的双参数“AllocateContainerForManagedElements”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForUnmanagedElements' method taking the managed type as the first parameter and providing the number of elements as an 'out int' parameter</source>
        <target state="translated">支持从托管到非托管的封送的无状态连续集合封送程序必须提供将托管类型用作第一个参数并将元素数作为 “out int” 参数提供的“AllocateContainerForUnmanagedElements” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForUnmanagedElements' method that takes a '{2}' as the first parameter and an 'out int' as the second parameter</source>
        <target state="translated">类型“{0}”指定它支持“{2}”的“{1}”封送模式，但不提供将“{2}”用作第一个参数并将“out int”用作第二个参数的双参数“AllocateContainerForUnmanagedElements”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedDescription">
        <source>A stateless value marshaller that supports marshalling from unmanaged to managed must provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns the the managed type.</source>
        <target state="translated">支持从非托管到托管的封送的无状态值封送程序必须提供将非托管类型用作参数并返回托管类型的“ConvertToManaged”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedMessage">
        <source>The type '{0}' specifies it supports the '{1}' marshal mode, but it does not provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns '{2}'</source>
        <target state="translated">类型“{0}”指定它支持“{1}”封送模式，但不提供将非托管类型用作参数并返回“{2}”的“ConvertToManaged”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedDescription">
        <source>A stateless value marshaller that supports marshalling from managed to unmanaged must provide a one-parameter 'ConvertToUnmanaged' method that takes the managed value as the parameter and returns a value of the 'unmanaged' type.</source>
        <target state="translated">支持从托管到非托管的封送的无状态值封送程序必须提供将托管值用作参数并返回“非托管”类型的值的单参数“ConvertToUnmanaged”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a one-parameter 'ConvertToUnmanaged' method that takes a '{2}' as a parameter and returns a value of an 'unmanaged' type</source>
        <target state="translated">类型“{0}”指定它支持“{2}”的“{1}”封送模式，但不提供将“{2}”用作参数并返回“非托管”类型的值的单参数“ConvertToUnmanaged”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StringMarshallingCustomTypeNotAccessibleByGeneratedCode">
        <source>The type '{0}' specified as 'GeneratedComInterfaceAttribute.StringMarshallingCustomType' is not accessible by generated code. The type must have at least 'internal' accessibility. {1}</source>
        <target state="translated">生成的代码无法访问指定为 "GeneratedComInterfaceAttribute.StringMarshallingCustomType" 的“{0}”类型。该类型必须至少具有 "internal" 可访问性。{1}</target>
        <note>{1} is details about which type/containing type is not accessible</note>
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchDescription">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same.</source>
        <target state="translated">“ToUnmanaged”的返回类型和“FromUnmanaged”的参数类型必须相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchMessage">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same</source>
        <target state="translated">“ToUnmanaged”的返回类型和“FromUnmanaged”的参数类型必须相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchDescription">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same.</source>
        <target state="translated">“ConvertToUnmanaged”的返回类型和“ConvertToManaged”的参数类型必须相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchMessage">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same</source>
        <target state="translated">“ConvertToUnmanaged”的返回类型和“ConvertToManaged”的参数类型必须相同</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeAccessibilityDetails">
        <source>'{0}' has accessibility '{1}'.</source>
        <target state="translated">“{0}”具有可访问性“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedDescription">
        <source>The unmanaged type for a custom marshaller must be a C# unmanaged type.</source>
        <target state="translated">自定义封送程序的非托管类型必须为 C# 非托管类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedMessage">
        <source>The return type of '{0}' must be unmanaged</source>
        <target state="translated">“{0}”的返回类型必须为非托管</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerDescription">
        <source>'void*' must be castable to the type so the pinned result of the static 'GetPinnableReference' method can be passed to the native context after being pinned.</source>
        <target state="translated">必须将“void*”强制转换为类型，这样静态“GetPinnableReference”方法的固定结果才能在固定后传递到本机上下文。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerMessage">
        <source>'void*' must be castable to the type '{0}' because the managed type '{1}' has a static 'GetPinnableReference' method</source>
        <target state="translated">“void*”必须可转换为类型“{0}”，因为托管类型“{1}”具有静态“GetPinnableReference”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedDescriptionCom">
        <source>For types that are not supported by source-generated COM, the resulting function pointer will rely on the underlying runtime to marshal the specified type.</source>
        <target state="translated">对于源生成的 COM 不支持的类型，生成的函数指针将依赖基础运行时来封送指定的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedDescriptionLibraryImport">
        <source>For types that are not supported by source-generated P/Invokes, the resulting P/Invoke will rely on the underlying runtime to marshal the specified type.</source>
        <target state="translated">对于源生成的 P/Invoke 不支持的类型，生成的 P/Invoke 将依赖基础运行时来封送指定的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterCom">
        <source>The type '{0}' is not supported by source-generated COM. The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">源生成的 COM 不支持“{0}”类型。生成的源将不处理参数“{1}”的封送。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterLibraryImport">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">源生成的 P/Invoke 不支持“{0}”类型。生成的源将不处理参数“{1}”的封送。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterWithDetails">
        <source>{0} The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">{0} 生成的源将不处理参数“{1}”的封送。</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the parameter</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnCom">
        <source>The type '{0}' is not supported by source-generated COM. The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">源生成的 COM 不支持 "{0}" 类型。生成的源将不处理方法 "{1}" 的返回值的封送。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnLibraryImport">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">源生成的 P/Invoke 不支持“{0}”类型。生成的源将不处理方法“{1}”的返回值的封送。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnWithDetails">
        <source>{0} The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">{0} 生成的源将不处理方法“{1}”的返回值的封送。</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the method</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedTitle">
        <source>Specified type is not supported by source-generated P/Invokes</source>
        <target state="translated">源生成的 P/Invoke 不支持指定的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedTitleCom">
        <source>Specified type is not supported by source-generated COM</source>
        <target state="translated">源生成的 COM 不支持指定的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="UnmanagedToManagedMissingRequiredMarshaller">
        <source>The specified parameter needs to be marshalled from unmanaged to managed, but the marshaller type '{0}' does not support it.</source>
        <target state="translated">需要将指定的参数从非托管封送到托管，但封送程序类型“{0}”不支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryMarshallingInfoDescription">
        <source>Unnecesssary marshalling info was provided. This marshalling information can be removed without any change in behavior to the application.</source>
        <target state="translated">提供了不必要的封送信息。可移除此封装信息，而不对应用程序的行为进行任何更改。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryMarshallingInfoTitle">
        <source>Unnecessary marshalling info was provided and can be removed.</source>
        <target state="translated">提供了不必要的封送信息，可将此信息移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryParameterMarshallingInfoMessage">
        <source>Unnecessary marshalling info '{0}' was provided for parameter '{1}'. {2}</source>
        <target state="translated">为参数“{0}”提供了不必要的封送信息“{1}”。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="UnnecessaryReturnMarshallingInfoMessage">
        <source>Unnecessary marshalling info '{0}' was provided for the return type of method '{1}'. {2}</source>
        <target state="translated">为方法“{0}”的返回类型提供了不必要的封送信息“{1}”。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'Value'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a two-parameter constructor taking the managed type and a 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">支持 \"CallerAllocatedBuffer\" 功能的 \"Value\" 种类本机类型必须提供以托管类型和“非管理”类型的 \"Span\" 作为参数的双参数构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a two-parameter constructor that takes a '{1}' and 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">类型“{0}”指定它支持使用“{1}”的 “CallerAllocatedBuffer” 功能进行 “In” 封送，但不提供以“{1}”和“非管理”类型的 “Span” 作为参数的双参数构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorDescription">
        <source>A 'Value'-kind native type must provide a one-parameter constructor taking the managed type as a parameter</source>
        <target state="translated">“Value” 种类本机类型必须提供一个以托管类型作为参数的单参数构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling of '{1}' but does not provide a one-parameter constructor that takes a '{1}' as a parameter</source>
        <target state="translated">类型“{0}”指定它支持“{1}”的 “In” 封送，但不提供将“{1}”作为参数的单参数构造函数</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>