<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BlittableTypeMustBeBlittableDescription" xml:space="preserve">
    <value>A type marked with 'BlittableTypeAttribute' must be blittable.</value>
  </data>
  <data name="BlittableTypeMustBeBlittableMessage" xml:space="preserve">
    <value>Type '{0}' is marked with 'BlittableTypeAttribute' but is not blittable</value>
  </data>
  <data name="CannotHaveMultipleMarshallingAttributesDescription" xml:space="preserve">
    <value>The 'BlittableTypeAttribute' and 'NativeMarshallingAttribute' attributes are mutually exclusive.</value>
  </data>
  <data name="CannotHaveMultipleMarshallingAttributesMessage" xml:space="preserve">
    <value>Type '{0}' is marked with 'BlittableTypeAttribute' and 'NativeMarshallingAttribute'. A type can only have one of these two attributes.</value>
  </data>
  <data name="CollectionNativeTypeMustHaveRequiredShapeDescription" xml:space="preserve">
    <value>A native type with the 'GenericContiguousCollectionMarshallerAttribute' must have at least one of the two marshalling methods as well as a 'ManagedValues' property of type 'Span&lt;T&gt;' for some 'T' and a 'NativeValueStorage' property of type 'Span&lt;byte&gt;' to enable marshalling the managed type.</value>
  </data>
  <data name="CollectionNativeTypeMustHaveRequiredShapeMessage" xml:space="preserve">
    <value>The native type '{0}' must be a value type and have a constructor that takes two parameters, one of type '{1}' and an 'int', or have a parameterless instance method named 'ToManaged' that returns '{1}' as well as a 'ManagedValues' property of type 'Span&lt;T&gt;' for some 'T' and a 'NativeValueStorage' property of type 'Span&lt;byte&gt;'</value>
  </data>
  <data name="ConfigurationNotSupportedDescription" xml:space="preserve">
    <value>Source-generated P/Invokes will ignore any configuration that is not supported.</value>
  </data>
  <data name="ConfigurationNotSupportedMessage" xml:space="preserve">
    <value>The '{0}' configuration is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular `DllImport` instead.</value>
  </data>
  <data name="ConfigurationNotSupportedMessageMarshallingInfo" xml:space="preserve">
    <value>The specified marshalling configuration is not supported by source-generated P/Invokes. {0}.</value>
  </data>
  <data name="ConfigurationNotSupportedMessageParameter" xml:space="preserve">
    <value>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular `DllImport` instead.</value>
  </data>
  <data name="ConfigurationNotSupportedMessageReturn" xml:space="preserve">
    <value>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular `DllImport` instead.</value>
  </data>
  <data name="ConfigurationNotSupportedMessageValue" xml:space="preserve">
    <value>The specified value '{0}' for '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular `DllImport` instead.</value>
  </data>
  <data name="ConfigurationNotSupportedTitle" xml:space="preserve">
    <value>Specified configuration is not supported by source-generated P/Invokes.</value>
  </data>
  <data name="ConstantAndElementCountInfoDisallowed" xml:space="preserve">
    <value>Only one of 'ConstantElementCount' or 'ElementCountInfo' may be used in a 'MarshalUsingAttribute' for a given 'ElementIndirectionLevel'</value>
  </data>
  <data name="ConvertToGeneratedDllImportDescription" xml:space="preserve">
    <value>Use 'GeneratedDllImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</value>
  </data>
  <data name="ConvertToGeneratedDllImportMessage" xml:space="preserve">
    <value>Mark the method '{0}' with 'GeneratedDllImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</value>
  </data>
  <data name="ConvertToGeneratedDllImportNoPreprocessor" xml:space="preserve">
    <value>Convert to 'GeneratedDllImport'</value>
  </data>
  <data name="ConvertToGeneratedDllImportTitle" xml:space="preserve">
    <value>Use 'GeneratedDllImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</value>
  </data>
  <data name="ConvertToGeneratedDllImportWarning" xml:space="preserve">
    <value>Conversion to 'GeneratedDllImport' may change behavior and compatibility. See {0} for more information.</value>
    <comment>{0} is a documentation link</comment>
  </data>
  <data name="ConvertToGeneratedDllImportWithPreprocessor" xml:space="preserve">
    <value>Convert to 'GeneratedDllImport' under a preprocessor define</value>
  </data>
  <data name="CustomTypeMarshallingManagedToNativeUnsupported" xml:space="preserve">
    <value>The specified parameter needs to be marshalled from managed to native, but the native type '{0}' does not support it.</value>
  </data>
  <data name="CustomTypeMarshallingNativeToManagedUnsupported" xml:space="preserve">
    <value>The specified parameter needs to be marshalled from native to managed, but the native type '{0}' does not support it.</value>
  </data>
  <data name="GeneratedDllImportContainingTypeMissingModifiersDescription" xml:space="preserve">
    <value>Types that contain methods marked with 'GeneratedDllImportAttribute' must be 'partial'. P/Invoke source generation will ignore methods contained within non-partial types.</value>
  </data>
  <data name="GeneratedDllImportContainingTypeMissingModifiersMessage" xml:space="preserve">
    <value>Type '{0}' contains methods marked with 'GeneratedDllImportAttribute' and should be 'partial'. P/Invoke source generation will ignore methods contained within non-partial types.</value>
  </data>
  <data name="GeneratedDllImportContainingTypeMissingModifiersTitle" xml:space="preserve">
    <value>Types that contain methods marked with 'GeneratedDllImportAttribute' must be 'partial'.</value>
  </data>
  <data name="GeneratedDllImportMissingModifiersDescription" xml:space="preserve">
    <value>Methods marked with 'GeneratedDllImportAttribute' should be 'static' and 'partial'. P/Invoke source generation will ignore methods that are not 'static' and 'partial'.</value>
  </data>
  <data name="GeneratedDllImportMissingModifiersMessage" xml:space="preserve">
    <value>Method '{0}' should be 'static' and 'partial' when marked with 'GeneratedDllImportAttribute'. P/Invoke source generation will ignore methods that are not 'static' and 'partial'.</value>
  </data>
  <data name="GeneratedDllImportMissingModifiersTitle" xml:space="preserve">
    <value>Method marked with 'GeneratedDllImportAttribute' should be 'static' and 'partial'</value>
  </data>
  <data name="GetPinnableReferenceReturnTypeBlittableDescription" xml:space="preserve">
    <value>The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable.</value>
  </data>
  <data name="GetPinnableReferenceReturnTypeBlittableMessage" xml:space="preserve">
    <value>The dereferenced type of the return type of the 'GetPinnableReference' method must be blittable</value>
  </data>
  <data name="GetPinnableReferenceShouldSupportAllocatingMarshallingFallbackDescription" xml:space="preserve">
    <value>A type that supports marshalling from managed to native by pinning should also support marshalling from managed to native where pinning is impossible.</value>
  </data>
  <data name="GetPinnableReferenceShouldSupportAllocatingMarshallingFallbackMessage" xml:space="preserve">
    <value>Type '{0}' has a 'GetPinnableReference' method but its native type does not support marshalling in scenarios where pinning is impossible</value>
  </data>
  <data name="MarshallerGetPinnableReferenceRequiresValuePropertyDescription" xml:space="preserve">
    <value>The use cases for 'GetPinnableReference' are not applicable in any scenarios where a 'Value' property is not also required.</value>
  </data>
  <data name="MarshallerGetPinnableReferenceRequiresValuePropertyMessage" xml:space="preserve">
    <value>The 'GetPinnableReference' method cannot be provided on the native type '{0}' unless a 'Value' property is also provided</value>
  </data>
  <data name="NativeGenericTypeMustBeClosedDescription" xml:space="preserve">
    <value>The native type '{0}' must be a closed generic so the emitted code can use a specific instantiation.</value>
  </data>
  <data name="NativeGenericTypeMustBeClosedOrMatchArityDescription" xml:space="preserve">
    <value>The native type '{0}' must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</value>
  </data>
  <data name="NativeGenericTypeMustBeClosedOrMatchArityMessage" xml:space="preserve">
    <value>The native type '{0}' for managed type '{1}' must be a closed generic type or have the same arity as the managed type.</value>
  </data>
  <data name="NativeTypeMustBeBlittableDescription" xml:space="preserve">
    <value>A native type for a given type must be blittable.</value>
  </data>
  <data name="NativeTypeMustBeBlittableMessage" xml:space="preserve">
    <value>The native type '{0}' for the type '{1}' is not blittable</value>
  </data>
  <data name="NativeTypeMustBeNonNullDescription" xml:space="preserve">
    <value>A native type for a given type must be non-null.</value>
  </data>
  <data name="NativeTypeMustBeNonNullMessage" xml:space="preserve">
    <value>The native type for the type '{0}' is null</value>
  </data>
  <data name="NativeTypeMustBePointerSizedDescription" xml:space="preserve">
    <value>The native type must be pointer sized so the pinned result of 'GetPinnableReference' can be cast to the native type.</value>
  </data>
  <data name="NativeTypeMustBePointerSizedMessage" xml:space="preserve">
    <value>The native type '{0}' must be pointer sized because the managed type '{1}' has a 'GetPinnableReference' method</value>
  </data>
  <data name="NativeTypeMustHaveRequiredShapeDescription" xml:space="preserve">
    <value>The native type must have at least one of the two marshalling methods to enable marshalling the managed type.</value>
  </data>
  <data name="NativeTypeMustHaveRequiredShapeMessage" xml:space="preserve">
    <value>The native type '{0}' must be a value type and have a constructor that takes one parameter of type '{1}' or a parameterless instance method named 'ToManaged' that returns '{1}'</value>
  </data>
  <data name="RefValuePropertyUnsupportedDescription" xml:space="preserve">
    <value>The 'Value' property must not be a 'ref' or 'readonly ref' property.</value>
  </data>
  <data name="RefValuePropertyUnsupportedMessage" xml:space="preserve">
    <value>The 'Value' property on the native type '{0}' must not be a 'ref' or 'readonly ref' property.</value>
  </data>
  <data name="SafeHandleByRefMustBeConcrete" xml:space="preserve">
    <value>An abstract type derived from 'SafeHandle' cannot be marshalled by reference. The provided type must be concrete.</value>
  </data>
  <data name="StackallocConstructorMustHaveStackBufferSizeConstantDescription" xml:space="preserve">
    <value>When constructor taking a Span&lt;byte&gt; is specified on the native type, the type must also have a public integer constant named StackBufferSize to provide the size of the stack-allocated buffer.</value>
  </data>
  <data name="StackallocConstructorMustHaveStackBufferSizeConstantMessage" xml:space="preserve">
    <value>The native type '{0}' must have a 'public const int StackBufferSize' field that specifies the size of the stack buffer because it has a constructor that takes a stack-allocated Span&lt;byte&gt;</value>
  </data>
  <data name="StackallocMarshallingShouldSupportAllocatingMarshallingFallbackDescription" xml:space="preserve">
    <value>A type that supports marshalling from managed to native by stack allocation should also support marshalling from managed to native where stack allocation is impossible.</value>
  </data>
  <data name="StackallocMarshallingShouldSupportAllocatingMarshallingFallbackMessage" xml:space="preserve">
    <value>Native type '{0}' has a stack-allocating constructor does not support marshalling in scenarios where stack allocation is impossible</value>
  </data>
  <data name="TargetFrameworkNotSupportedDescription" xml:space="preserve">
    <value>P/Invoke source generation is not supported on unknown target framework v{0}. The generated source will not be compatible with other frameworks.</value>
    <comment>{0} is a version number</comment>
  </data>
  <data name="TargetFrameworkNotSupportedMessage" xml:space="preserve">
    <value>'GeneratedDllImportAttribute' cannot be used for source-generated P/Invokes on an unknown target framework v{0}.</value>
    <comment>{0} is a version number</comment>
  </data>
  <data name="TargetFrameworkNotSupportedTitle" xml:space="preserve">
    <value>Current target framework is not supported by source-generated P/Invokes</value>
  </data>
  <data name="TypeNotSupportedDescription" xml:space="preserve">
    <value>For types that are not supported by source-generated P/Invokes, the resulting P/Invoke will rely on the underlying runtime to marshal the specified type.</value>
  </data>
  <data name="TypeNotSupportedMessageParameter" xml:space="preserve">
    <value>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of parameter '{1}'.</value>
  </data>
  <data name="TypeNotSupportedMessageParameterWithDetails" xml:space="preserve">
    <value>{0} The generated source will not handle marshalling of parameter '{1}'.</value>
    <comment>{0} is a message containing additional details about what is not supported
{1} is the name of the parameter</comment>
  </data>
  <data name="TypeNotSupportedMessageReturn" xml:space="preserve">
    <value>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of the return value of method '{1}'.</value>
  </data>
  <data name="TypeNotSupportedMessageReturnWithDetails" xml:space="preserve">
    <value>{0} The generated source will not handle marshalling of the return value of method '{1}'.</value>
    <comment>{0} is a message containing additional details about what is not supported
{1} is the name of the method</comment>
  </data>
  <data name="TypeNotSupportedTitle" xml:space="preserve">
    <value>Specified type is not supported by source-generated P/Invokes</value>
  </data>
  <data name="ValuePropertyMustHaveGetterDescription" xml:space="preserve">
    <value>The native type's 'Value' property must have a getter to support marshalling from managed to native.</value>
  </data>
  <data name="ValuePropertyMustHaveGetterMessage" xml:space="preserve">
    <value>The 'Value' property on the native type '{0}' must have a getter</value>
  </data>
  <data name="ValuePropertyMustHaveSetterDescription" xml:space="preserve">
    <value>The native type's 'Value' property must have a setter to support marshalling from native to managed.</value>
  </data>
  <data name="ValuePropertyMustHaveSetterMessage" xml:space="preserve">
    <value>The 'Value' property on the native type '{0}' must have a setter</value>
  </data>
</root>