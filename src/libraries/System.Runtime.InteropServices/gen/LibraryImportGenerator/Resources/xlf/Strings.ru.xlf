<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
    <body>
      <trans-unit id="AddMissingCustomTypeMarshallerMembers">
        <source>Add missing custom type marshaller members</source>
        <target state="translated">Добавить отсутствующие элементы маршалатора настраиваемого типа</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing a 'FromManaged' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">Если фигура "Из управляемого в неуправляемый с буфером, выделяемым вызывающим объектом" используется путем предоставления метода "FromManaged", выполняющего "Span&lt;T&gt;" для типа маршалера, этот тип должен предоставлять статическое свойство "BufferSize", чтобы предоставить количество элементов в буфере, выделенном вызывающим объектом.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has a FromManaged method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">У типа маршалера "{0}" должно быть статическое доступное только для чтения свойство "BufferSize" со значением типа "int", чтобы указывать размер буфера, выделенного вызывающим объектом, поскольку у этого типа есть метод FromManaged, выполняющий "Span&lt;{1}&gt;", выделяемый вызывающим объектом.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportDescription">
        <source>The generated 'DllImportAttribute' will not have a value corresponding to '{0}'.</source>
        <target state="translated">Созданный атрибут \"DllImportAttribute\" не будет иметь значения, соответствующего \"{0}\".</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportMessage">
        <source>'{0}' has no equivalent in 'DllImportAttribute' and will not be forwarded</source>
        <target state="translated">"{0}" не имеет эквивалента в "DllImportAtttribute" и не будет перенаправляться</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportTitle">
        <source>Specified 'LibraryImportAttribute' arguments cannot be forwarded to 'DllImportAttribute'</source>
        <target state="translated">Указанные аргументы \"LibraryImportAttribute\" не могут быть перенаправлены в \"DllImportAttribute\"</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedDescription">
        <source>Source-generated P/Invokes will ignore any configuration that is not supported.</source>
        <target state="translated">P/Invoke с созданием источника будут игнорировать все неподдерживаемые конфигурации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessage">
        <source>The '{0}' configuration is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">Конфигурация "{0}" не поддерживается P/Invokes, созданными источником. Если требуется указанная конфигурация, используйте вместо нее обычный "DllImport".</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageMarshallingInfo">
        <source>The specified marshalling configuration is not supported by source-generated P/Invokes. {0}.</source>
        <target state="translated">Указанная конфигурация маршализации не поддерживается в P/Invoke с созданием источника. {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageParameter">
        <source>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">Указанная конфигурация "{0}" для параметра "{1}" не поддерживается P/Invokes, созданными источником. Если требуется указанная конфигурация, используйте вместо нее обычный "DllImport".</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageReturn">
        <source>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">Указанная конфигурация "{0}" для возвращаемого значения метода "{1}" не поддерживается созданным источником P/Invokes. Если указанная конфигурация обязательна, используйте обычный метод "DllImport".</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageValue">
        <source>The specified value '{0}' for '{1}' is not supported by source-generated P/Invokes. If the specified value is required, use a regular 'DllImport' instead.</source>
        <target state="translated">Указанное значение "{0}" для "{1}" не поддерживается P/Invokes, сгенерированными источником. Если требуется указанное значение, используйте вместо него обычный "DllImport".</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedTitle">
        <source>Specified configuration is not supported by source-generated P/Invokes.</source>
        <target state="translated">Указанная конфигурация не поддерживается в P/Invoke с созданием источника.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertNoPreserveSigDllImportToGeneratedMayProduceInvalidCode">
        <source>Automatically converting a P/Invoke with 'PreserveSig' set to 'false' to a source-generated P/Invoke may produce invalid code</source>
        <target state="translated">Автоматическое преобразование P/Invoke с параметром \"PreserveSig\" со значением \"false\" в P/Invoke с созданием источника может привести к неправильному коду</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImport">
        <source>Convert to 'LibraryImport'</source>
        <target state="translated">Преобразовать в \"LibraryImport\"</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportAddUnsafe">
        <source>Convert to 'LibraryImport' and enable unsafe code</source>
        <target state="translated">Преобразование в "LibraryImport" и включение небезопасного кода</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportDescription">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">Используйте \"LibraryImportAttribute\" вместо \"DllImportAttribute\" для генерирования кода маршализации P/Invoke во время компиляции</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMayRequireCustomMarshalling">
        <source>Converting this API to 'LibraryImport' will require additional code to provide custom marshallers for some parameters.</source>
        <target state="translated">Преобразование этого API в "LibraryImport" потребует дополнительного кода для предоставления настраиваемых маршалеров для некоторых параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMessage">
        <source>Mark the method '{0}' with 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">Пометьте метод \"{0}\" атрибутом \"LibraryImportAttribute\" вместо \"DllImportAttribute\", чтобы генерировать код маршализации P/Invoke во время компиляции</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportTitle">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">Используйте \"LibraryImportAttribute\" вместо \"DllImportAttribute\" для генерирования кода маршализации P/Invoke во время компиляции</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffix">
        <source>Convert to 'LibraryImport' with '{0}' suffix</source>
        <target state="translated">Преобразовать в \"LibraryImport\" с суффиксом \"{0}\"</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffixAddUnsafe">
        <source>Convert to 'LibraryImport' with '{0}' suffix and enable unsafe code</source>
        <target state="translated">Преобразование в "LibraryImport" с суффиксом "{0}" и включение небезопасного кода</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomMarshallerTypeMustHaveRequiredShapeTitle">
        <source>Marshaller type does not have the required shape</source>
        <target state="translated">Тип маршалера не имеет требуемой фигуры</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulDescription">
        <source>A marshaller for an element scenario cannot be stateful.</source>
        <target state="translated">Маршалер для сценария элемента не может иметь отслеживание состояния.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulMessage">
        <source>The specified marshaller type '{0}' is a stateful marshaller, but stateful marshallers are not allowed in the provided marshal mode '{1}'</source>
        <target state="translated">Указанный тип маршалера "{0}" является маршалером с отслеживанием состояния, но маршалер с отслеживанием состояния в предоставленном режиме "{1}" не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchDescription">
        <source>The element type of the span returned by the first method must be the same type as the element type of the span returned by the second method.</source>
        <target state="translated">Тип элемента диапазона, возвращаемого первым методом, должен быть того же типа, что и тип элемента диапазона, возвращаемого вторым методом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchMessage">
        <source>The element type of the span returned by '{0}' must be the same type as the element type of the span returned by '{1}'.</source>
        <target state="translated">Тип диапазона, возвращаемого "{0}", должен быть того же типа, что и тип диапазона, возвращаемого "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullDescription">
        <source>An entry-point type for marshalling a given type must not be 'null'.</source>
        <target state="translated">Тип точки входа для маршалирования заданного типа должен отличаться от "NULL".</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullMessage">
        <source>The entry-point marshaller type for the type '{0}' must be not 'null'</source>
        <target state="translated">Тип маршалера точки входа для типа '{0}' должен отличаться от "NULL"</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeDescription">
        <source>The first parameter of the first method must be the same type as the return types of the second method.</source>
        <target state="translated">Первый параметр первого метода должен иметь тот же тип, что и возвращаемые типы второго метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeMessage">
        <source>The first parameter of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">Первый параметр "{0}" должен иметь тот же тип, что и тип возвращаемого значения "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchDescription">
        <source>The first parameters of the two methods must be the same type.</source>
        <target state="translated">Первые параметры двух методов должны быть одного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchMessage">
        <source>The first parameter of '{0}' and '{1}' must be the same type</source>
        <target state="translated">Первый параметр "{0}" и "{1}" должны быть одного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedDescription">
        <source>Overloading the 'FromUnmanaged' method is unuspported as some shapes are unable to distinguish between overloads.</source>
        <target state="translated">Перегрузка метода FromUnmanaged не поддерживается, поскольку некоторые фигуры не могут различать перегрузки.</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedMessage">
        <source>The type '{0}' overloads the 'FromUnmanaged' method, which is not supported in custom marshallers</source>
        <target state="translated">Тип "{0}" перегружает метод FromUnmanaged, не поддерживаемый в настраиваемых маршалерах.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableDescription">
        <source>The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable.</source>
        <target state="translated">Тип возвращаемого значения \"GetPinnableReference\" (после учета \"ref\") должен быть непреобразуемым.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableMessage">
        <source>The dereferenced type of the return type of the 'GetPinnableReference' method must be blittable</source>
        <target state="translated">Разыменованный тип возвращаемого типа метода \"GetPinnableReference\" должен быть непреобразуемым</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingModifiersMessage">
        <source>Method '{0}' is contained in a type '{1}' that is not marked 'partial'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">Метод \"{0}\" содержится в типе \"{1}\", который не помечен как \"partial\". Метод \"{0}\" будет игнорироваться при создании источника в P/Invoke.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodDescription">
        <source>Methods marked with 'LibraryImportAttribute' should be 'static', 'partial', and non-generic. P/Invoke source generation will ignore methods that are non-'static', non-'partial', or generic.</source>
        <target state="translated">Методы, помеченные атрибутом \"LibraryImportAttribute\", должны быть \"static\", \"partial\" и неуниверсальными. При создании источника в P/Invoke будут игнорироваться методы, отличные от \"static\", \"partial\" или универсальные.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodSignatureMessage">
        <source>Method '{0}' should be 'static', 'partial', and non-generic when marked with 'LibraryImportAttribute'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">Метод \"{0}\" должен быть \"static\", \"partial\" и неуниверсальным, если он имеет атрибут \"LibraryImportAttribute\". При создании источника в P/Invoke метод \"{0}\" игнорируется.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCustomMarshallerAttributeUsageTitle">
        <source>Invalid 'CustomMarshallerAttribute' usage</source>
        <target state="translated">Недопустимое использование "CustomMarshallerAttribute"</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLibraryImportAttributeUsageTitle">
        <source>Invalid 'LibraryImportAttribute' usage</source>
        <target state="translated">Недопустимое использование \"LibraryImportAttribute\"</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidManagedTypeTitle">
        <source>Specified managed type is invalid</source>
        <target state="translated">Указан недопустимый управляемый тип</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMarshallerTypeTitle">
        <source>Specified marshaller type is invalid</source>
        <target state="translated">Указан недопустимый тип маршалера</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNativeMarshallingAttributeUsageTitle">
        <source>Invalid 'NativeMarshallingAttribute' usage</source>
        <target state="translated">Недопустимое использование "NativeMarsingAttribute"</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSignaturesInMarshallerShapeTitle">
        <source>Marshaller type has incompatible method signatures</source>
        <target state="translated">Тип маршалер имеет несовместимые сигнатуры методов</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationDescription">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' is invalid.</source>
        <target state="translated">Конфигурация \"StringMarshalling\" и \"StringMarshallingCustomType\" недопустима.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMessage">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">Конфигурация \"StringMarshalling\" и \"StringMarshallingCustomType\" в методе \"{0}\" недопустима. {1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMissingCustomType">
        <source>'StringMarshallingCustomType' must be specified when 'StringMarshalling' is set to 'StringMarshalling.Custom'.</source>
        <target state="translated">Если для \"StringMarshalling\" задано значение \"StringMarshalling.Custom\", необходимо указать \"StringMarshallingCustomType\".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationNotCustom">
        <source>'StringMarshalling' should be set to 'StringMarshalling.Custom' when 'StringMarshallingCustomType' is specified.</source>
        <target state="translated">Если указано \"StringMarshallingCustomType\", для \"StringMarshalling\" следует задать значение \"StringMarshalling.Custom\".</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchDescription">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'.</source>
        <target state="translated">Тип элемента \"ReadOnlySpan\", возвращенный методом \"GetManagedValuesSource\", должен совпадать с типом элемента, возвращаемым методом \"GetManagedValuesDestination\".</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchMessage">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'</source>
        <target state="translated">Тип элемента \"ReadOnlySpan\", возвращаемый методом \"GetManagedValuesSource\", должен совпадать с типом элемента, возвращаемым методом \"GetManagedValuesDestination\"</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'LinearCollection'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a three-parameter constructor taking the managed type as the first parameter, a 'Span&lt;byte&gt;' as the second parameter, and the native size of the element as the third parameter</source>
        <target state="translated">Собственный тип вида \"LinearCollection\", который поддерживает функцию CallerAllocatedBuffer, должен предоставлять конструктор с тремя параметрами, управляемый тип, \"Span&lt;byte&gt;\" и собственный размер элемента</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a three-parameter constructor that takes a '{1}' , a 'Span&lt;byte&gt;', and an 'int'</source>
        <target state="translated">\"{0}\" указывает, что поддерживает маршализацию в направлении \"внутрь\" с функцией \"CallerAllocatedBuffer\" для \"{1}\", но не предоставляет конструктор, принимающий три параметра: \"{1}\", \"Span&lt;byte&gt;\" и \"int\"</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'.</source>
        <target state="translated">Непрерывный маршалер коллекции, поддерживающий маршалинг из управляемого в неуправляемый, должен предоставлять метод "GetManagedValuesSource", который возвращает "ReadOnlySpan&lt;&gt;" и метод "GetUnmanagedValuesDestination", возвращающий "Span&lt;&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает режим маршалирования "{1}", но не предоставляет метод "GetManagedValuesSource", возвращающий "ReadOnlySpan&lt;&gt;", и метод GetUnmanagedValuesDestination, возвращающий "Span&lt;&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">Непрерывный маршалер коллекции, поддерживающий маршалинг из управляемого в неуправляемый, должен предоставлять метод "GetManagedValuesDestination", который принимает "int" и возвращает "Span"&lt;&gt;, и метод "GetUnmanagedValuesSource", который принимает "int" и возвращает "ReadOnlySpan&lt;&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршализацию "{1}"l, но не предоставляет "GetManagedValuesDestination", принимающий "int" и возвращающий "Span&lt;&gt;", и метод "GetUnmanagedValuesSource", принимающий "int" и возвращающий "ReadOnlySpan&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the generator can determine which methods are available on the specific marshaller types.</source>
        <target state="translated">Тип маршалера должен быть закрытым универсальным типом или у него должно быть столько же универсальных параметров, как у управляемого типа, чтобы генератор мог определить, какие методы доступны для определенных типов маршалеров.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityMessage">
        <source>The managed type '{0}' for entry-point marshaller type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">Управляемый тип "{0}" для типа маршалера точки входа "{1}" должен быть закрытым универсальным типом, его арность должна быть такой же, как у управляемого типа, если это маршалер значений, либо у него должен быть один дополнительный универсальный параметр, если это маршалер коллекций.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullDescription">
        <source>The managed type for a custom marshaller must be non-null.</source>
        <target state="translated">Управляемый тип для настраиваемого маршалера должен отличаться от "NULL".</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullMessage">
        <source>The managed type for the entry-point marshaller type '{0}' must not be 'null'</source>
        <target state="translated">Управляемый тип для типа маршалера точки входа "{0}" должен отличаться от "NULL"</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">Тип маршалера должен быть закрытым универсальным или иметь то же количество универсальных параметров, что и управляемый тип, чтобы создаваемый код мог использовать конкретный экземпляр.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' pointed to by the entry-point marshaller type '{1}' must be a closed generic type or have the same arity as the managed type</source>
        <target state="translated">Тип маршалера "{0}", на который ссылается тип маршалера точки входа "{1}", должен быть закрытым универсальным или иметь такую же арность, что и управляемый тип</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullDescription">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'.</source>
        <target state="translated">У параметра "marshallerType" в "System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute" не может быть значение "NULL".</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullMessage">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'</source>
        <target state="translated">У параметра "marshallerType" в "System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute" не может быть значение "NULL"</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructDescription">
        <source>A marshaller type must either be a stateless static class or a stateful value type. A non-static class is not allowed.</source>
        <target state="translated">Тип маршалера должен быть статическим классом без сохранения состояния или типом значения с отслеживанием состояния. Нестатический класс не допускается.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructMessage">
        <source>The type '{0}' must be a static class or a value type</source>
        <target state="translated">Тип "{0}" должен быть статическим классом или типом значения</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeDescription">
        <source>A type with a 'System.Runtime.InteropServices.CustomMarshallerAttribute' must specify a non-'null' managed type</source>
        <target state="translated">Тип с атрибутом "System.Runtime.InteropServices.CustomMarshallerAttribute" должен указывать управляемый тип, отличный от "NULL"</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeMessage">
        <source>The type '{0}' does not specify a managed type in the 'System.Runtime.InteropServices.CustomMarshallerAttribute' applied to the type</source>
        <target state="translated">Тип "{0}" не указывает управляемый тип в примененном к нему атрибуте "System.Runtime.InteropServices.CustomMarshallerAttribute"</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">Тип маршалера должен быть закрытым универсальным или иметь то же количество универсальных параметров, что и управляемый тип, чтобы создаваемый код мог использовать конкретный экземпляр.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' for managed type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">Управляемый тип "{0}" для управляемого типа "{1}" должен быть закрытым универсальным типом, его арность должна быть такой же, как у управляемого типа, если это маршалер значений, либо у него должен быть один дополнительный универсальный параметр, если это маршалер коллекций.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksDescription">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">Для LibraryImportAttribute требуется небезопасный код. Проект необходимо обновить с использованием значения "&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksMessage">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">Для LibraryImportAttribute требуется небезопасный код. Проект необходимо обновить с использованием значения "&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksTitle">
        <source>LibraryImportAttribute requires unsafe code.</source>
        <target state="translated">Для LibraryImportAttribute требуется небезопасный код.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeDescription">
        <source>The return type the two method must be the expected type.</source>
        <target state="translated">Тип возвращаемого значения метода two должен быть ожидаемым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeMessage">
        <source>The return type of '{0}' must be '{1}'</source>
        <target state="translated">Тип возвращаемого значения "{0}" должен быть "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchDescription">
        <source>The return types of the two methods must be the same type.</source>
        <target state="translated">Типы возвращаемого метода должны быть одинаковыми.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchMessage">
        <source>The return type of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">Тип возвращаемого значения "{0}" должен быть тем же, что и тип возвращаемого значения "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeDescription">
        <source>A stateful marshaller must have a zero-parameter void-returning instance method named 'Free'.</source>
        <target state="translated">Маршалер с отслеживанием состояния должен иметь метод экземпляра с нулевым параметром, возвращающий void, с именем "Free".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeMessage">
        <source>The type '{0}' is a stateful marshaller and does not have a zero-parameter void-returning instance method named 'Free'</source>
        <target state="translated">Тип "{0}" является маршалером с отслеживанием состояния и не имеет метода экземпляра с нулевым параметром, возвращающего void, с именем "Free"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'FromManaged' instance method that takes the managed value as a parameter and returns 'void'.</source>
        <target state="translated">Маршалер с отслеживанием состояния, поддерживающий маршалинг от управляемого к неуправляемому, должен предоставить метод экземпляра FromManaged, принимающий управляемое значение в качестве параметра и возвращающий значение "void".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromManaged' that takes a '{2}' as a parameter and returns 'void'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает режим маршалинга "{1}" для "{2}", но не предоставляет метод экземпляра с одним параметром с именем "FromManaged", принимающим в качестве параметра "{2}" и возвращающим "void"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'FromUnmanaged' instance method that takes the unmanaged value as a parameter and returns 'void'.</source>
        <target state="translated">Маршалер с отслеживанием состояния, поддерживающий маршалинг от неуправляемого к управляемому, должен предоставить метод экземпляра "FromUnmanaged", принимающий неуправляемое значение в качестве параметра и возвращающий "void".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromUnmanaged' that takes the 'unmanaged' value as a parameter and returns 'void'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршалинг "{1}" для "{2}", но не предоставляет метод экземпляра с одним параметром с именем "FromUnmanaged", принимающий значение "unmanaged" в качестве параметра и возвращающий "void"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'ToManaged' instance method that takes no parameters and returns the managed type.</source>
        <target state="translated">Маршалер с отслеживанием состояния, поддерживающий маршалинг от неуправляемого к управляемому, должен предоставить метод экземпляра "ToManaged", не принимающий параметров и возвращающий управляемый тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToManaged' that returns '{2}'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает режим маршалинга "{1}" для "{2}", но не предоставляет метод экземпляра с нулевым параметром с именем "ToManaged", возвращающим "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'ToUnmanaged' instance method that takes no parameters and returns the 'unmanaged' type.</source>
        <target state="translated">Маршалер с отслеживанием состояния, поддерживающий маршалинг от управляемого к неуправляемому, должен предоставить метод экземпляра "ToUnmanaged", не принимающий параметров и возвращающий тип "unmanaged".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToUnmanaged' that returns the 'unmanaged' type for the marshaller</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает "{1}" режим маршалинга для "{2}", но не предоставляет метод экземпляра с нулевым параметром с именем "ToUnmanaged", возвращающим тип "unmanaged" для маршалера</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing an 'AllocateContainerForUnmanagedElements' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">Когда форма "Управляемый в неуправляемый с буфером, выделенным вызывающим объектом" используется путем предоставления метода "AllocateContainerForUnmanagedElements", принимающим "Span&lt;T&gt;" для типа маршаллера, тип должен предоставлять статическое свойство "BufferSize", чтобы предоставить число элементов в выделенном вызывающей стороне буфере.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has an 'AllocateContainerForUnmanagedElements' method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">У типа маршалера "{0}" должно быть статическое свойство "int" "BufferSize" только для чтения, чтобы указать размер буфера, выделенного вызывающей стороной, поскольку он имеет метод "AllocateContainerForUnmanagedElements", принимающий выделенную вызывающей стороной область "Span&lt;{1}&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that takes the managed value as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">Непрерывный маршалер коллекций, поддерживающий маршаллинг от управляемого к неуправляемому, должен предоставить метод "GetManagedValuesSource", принимающий управляемое значение в качестве параметра и возвращающий метод ReadOnlySpan&lt;&gt;, и метод "GetUnmanagedValuesDestination", принимающий неуправляемое значение в качестве параметра и возвращающий "Span&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that takes '{2}' as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршалинг "{1}", но не предоставляет "GetManagedValuesSource", принимающий "{2}" в качестве параметра и возвращающий "ReadOnlySpan&lt;&gt;", а также метод "GetUnmanagedValuesDestination", принимающий неуправляемое значение как параметр и возвращающий "Span&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes the managed value and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">Непрерывный маршалер коллекции, поддерживающий маршалирование из управляемого в неуправляемый, должен предоставить метод "GetManagedValuesDestination", принимающий управляемое значение и возвращающий "Span&lt;&gt;", и метод "GetUnmanagedValuesSource", принимающий неуправляемое значение и целое число и возвращающий значение "ReadOnlySpan&lt;&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes '{2}' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршалинг "{1}", но он не предоставляет "GetManagedValuesDestination", принимающий "{2}" и возвращающий "Span&lt;&gt;", а также метод "GetUnmanagedValuesSource", принимающий неуправляемое значение и "int" и возвращающий "ReadOnlySpan&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForManagedElements' method taking the unmanaged type as the first parameter and the number of elements as an 'int' parameter</source>
        <target state="translated">Непрерывный маршаллер коллекций без сохранения состояния, который поддерживает маршалирование от управляемого к неуправляемому, должен предоставить метод "AllocateContainerForManagedElements", принимающий неуправляемый тип в качестве первого параметра и количество элементов в качестве параметра "int".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForManagedElements' method that takes the unmanaged type as the first parameter and an 'int' as the second parameter</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршалирование "{1}" для {2}"', но не предоставляет метод с двумя параметрами "AllocateContainerForManagedElements", принимающий неуправляемый тип в качестве первого параметра и "int" в качестве второго параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForUnmanagedElements' method taking the managed type as the first parameter and providing the number of elements as an 'out int' parameter</source>
        <target state="translated">Непрерывный маршаллер коллекций без сохранения состояния, который поддерживает маршалинг от управляемого к неуправляемому, должен предоставить метод "AllocateContainerForUnmanagedElements", принимающий управляемый тип в качестве первого параметра и предоставляющий количество элементов в качестве параметра "out int".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForUnmanagedElements' method that takes a '{2}' as the first parameter and an 'out int' as the second parameter</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршалирование "{1}" для "{2}"но не предоставляет метод "AllocateContainerForUnmanagedElements" с двумя параметрами, который принимает "{2}" в качестве первого параметра и "out int" в качестве второго параметра.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedDescription">
        <source>A stateless value marshaller that supports marshalling from unmanaged to managed must provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns the the managed type.</source>
        <target state="translated">Маршалер значений без отслеживания состояния, поддерживающий маршаллинг от управляемого к неуправляемому, должен предоставить метод с одним параметром "ConvertToManaged", принимающий неуправляемый тип в качестве параметра и возвращающий управляемый тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedMessage">
        <source>The type '{0}' specifies it supports the '{1}' marshal mode, but it does not provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns '{2}'</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршалирование "{1}", но он не предоставляет метод "ConvertToManaged", принимающий неуправляемый тип в качестве параметра и возвращающий "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedDescription">
        <source>A stateless value marshaller that supports marshalling from managed to unmanaged must provide a one-parameter 'ConvertToUnmanaged' method that takes the managed value as the parameter and returns a value of the 'unmanaged' type.</source>
        <target state="translated">Маршалер значений без отслеживания состояния, поддерживающий маршаллинг от управляемого к неуправляемому, должен предоставить метод с одним параметром "ConvertToUnmanaged", принимающий управляемое значение в качестве параметра и возвращающий значение типа "unmanaged'".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a one-parameter 'ConvertToUnmanaged' method that takes a '{2}' as a parameter and returns a value of an 'unmanaged' type</source>
        <target state="translated">Тип "{0}" указывает, что он поддерживает маршалинг "{1}" для "{2}", но не предоставляет метод "ConvertToUnmanaged" с одним параметром, который принимает "{2}" в качестве параметра и возвращает значение типа "unmanaged"</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchDescription">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same.</source>
        <target state="translated">Тип возвращаемого значения "ConvertToUnmanaged" и тип параметра "ConvertToManaged" должны совпадать.</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchMessage">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same</source>
        <target state="translated">Тип возвращаемого значения "ConvertToUnmanaged" и тип параметра "ConvertToManaged" должны совпадать</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedDescription">
        <source>The unmanaged type for a custom marshaller must be a C# unmanaged type.</source>
        <target state="translated">Неуправляемый тип для пользовательского маршаллера должен быть неуправляемым типом C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedMessage">
        <source>The return type of '{0}' must be unmanaged</source>
        <target state="translated">Тип возвращаемого значения "{0}" должен быть неуправляемым</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerDescription">
        <source>'void*' must be castable to the type so the pinned result of the static 'GetPinnableReference' method can be passed to the native context after being pinned.</source>
        <target state="translated">"void*" должен быть приводимым к типу, чтобы закрепленный результат статического метода "GetPinnableReference" можно было передавать в собственный контекст после закрепления.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerMessage">
        <source>'void*' must be castable to the type '{0}' because the managed type '{1}' has a static 'GetPinnableReference' method</source>
        <target state="translated">"void*" должен быть приводимым к типу "{0}", поскольку у управляемого типа "{1}" есть статический метод "GetPinnableReference"</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeDescription">
        <source>An entry-point type for marshalling a given type must have a 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type.</source>
        <target state="translated">У типа точки входа для маршалирования указанного типа должен быть атрибут "System.Runtime.InteropServices.CustomMarshallerAttribute", указывающий этот тип в качестве управляемого.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeMessage">
        <source>The entry-point marshaller type '{0}' for the type '{1}' must be a type with at least one 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type</source>
        <target state="translated">Тип маршалера точки входа "{0}" для типа "{1}" должен содержать хотя бы один атрибут "System.Runtime.InteropServices.CustomMarshallerAttribute", указывающий этот тип в качестве управляемого типа</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedDescription">
        <source>A 'Value' or 'LinearCollection'-kind native type that supports marshalling in the 'Out' direction must provide a 'ToManaged' method that returns the managed type.</source>
        <target state="translated">Собственный тип вида \"Value\" или \"LinearCollection\", поддерживающий маршализацию в направлении \"наружу\", должен предоставлять метод \"ToManaged\", который возвращает управляемый тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedMessage">
        <source>The type '{0}' specifies it supports marshalling in the 'Out' direction, but it does not provide a 'ToManaged' method that returns the managed type</source>
        <target state="translated">Тип \"{0}\" указывает, что поддерживает маршализацию в направлении \"наружу\", но не предоставляет метод \"ToManaged\", который возвращает управляемый тип</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchDescription">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same.</source>
        <target state="translated">Тип возвращаемого значения "ToUnmanaged" и тип параметра "FromUnmanaged" должны совпадать.</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchMessage">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same</source>
        <target state="translated">Тип возвращаемого значения "ToUnmanaged" и тип параметра "FromUnmanaged" должны совпадать</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedDescription">
        <source>For types that are not supported by source-generated P/Invokes, the resulting P/Invoke will rely on the underlying runtime to marshal the specified type.</source>
        <target state="translated">Для типов, которые не поддерживаются в P/Invoke с созданием источника, в полученном P/Invoke для маршализации указанного типа будет использоваться среда выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameter">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">Тип \"{0}\" не поддерживается в P/Invoke с созданием источника. Созданный источник не будет обрабатывать маршализацию параметра \"{1}\".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterWithDetails">
        <source>{0} The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">{0} Созданный источник не будет обрабатывать маршализацию параметра \"{1}\".</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the parameter</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturn">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">Тип \"{0}\" не поддерживается в P/Invoke с созданием источника. Созданный источник не будет обрабатывать маршализацию возвращаемого значения метода \"{1}\".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnWithDetails">
        <source>{0} The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">{0} Созданный источник не будет обрабатывать маршализацию возвращаемого значения метода \"{1}\".</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the method</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedTitle">
        <source>Specified type is not supported by source-generated P/Invokes</source>
        <target state="translated">Указанный тип не поддерживается в P/Invoke с созданием источника.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'Value'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a two-parameter constructor taking the managed type and a 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">Собственный тип вида \"Value\", который поддерживает функцию \"CallerAllocatedBuffer\", должен предоставлять конструктор с двумя параметрами: управляемый тип и \"Span неуправляемого типа\"</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a two-parameter constructor that takes a '{1}' and 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">Тип ''{0}'' указывает, что он поддерживает сортировку ''In'' с функцией ''CallerAllocatedBuffer'' для ''{1}'', но не предоставляет конструктор с двумя параметрами, который принимает ''{1}'' и 'Span' типа ''unmanaged'' в качестве параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorDescription">
        <source>A 'Value'-kind native type must provide a one-parameter constructor taking the managed type as a parameter</source>
        <target state="translated">Собственный тип вида \"Value\" должен предоставлять конструктор с одним параметром: управляемый тип</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling of '{1}' but does not provide a one-parameter constructor that takes a '{1}' as a parameter</source>
        <target state="translated">Тип \"{0}\" указывает, что поддерживает маршализацию \"{1}\" в направлении \"внутрь, но не предоставляет конструктор, принимающий один параметр \"{1}\"</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>