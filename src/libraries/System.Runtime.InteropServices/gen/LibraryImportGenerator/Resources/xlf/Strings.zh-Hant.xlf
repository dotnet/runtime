<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
    <body>
      <trans-unit id="AddMissingCustomTypeMarshallerMembers">
        <source>Add missing custom type marshaller members</source>
        <target state="translated">新增遺漏的自訂類型排列器成員</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing a 'FromManaged' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">當透過提供在封送處理器類型上採用 'Span&lt;T&gt;' 的 'FromManaged' 方法來使用 'Managed to Unmanaged with Caller-Allocated Buffer' 圖形時，該類型必須提供靜態 'BufferSize' 屬性以提供 caller-allocated 緩衝區中的元素數字。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has a FromManaged method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">封送處理器類型 '{0}' 必須有靜態唯讀 'int' 'BufferSize' 屬性，以指定 caller-allocated 緩衝區的大小，因為它具有採用 caller-allocated 'Span&lt;{1}&gt;' 的 FromManaged 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportDescription">
        <source>The generated 'DllImportAttribute' will not have a value corresponding to '{0}'.</source>
        <target state="translated">產生的 'DllImportAttribute' 將不會有對應至 '{0}' 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportMessage">
        <source>'{0}' has no equivalent in 'DllImportAttribute' and will not be forwarded</source>
        <target state="translated">'{0}'在 'DllImportAttribute' 中没有相等項目，將不會轉寄</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportTitle">
        <source>Specified 'LibraryImportAttribute' arguments cannot be forwarded to 'DllImportAttribute'</source>
        <target state="translated">指定的 'LibraryImportAttribute' 自變量無法轉送到 'DllImportAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedDescription">
        <source>Source-generated P/Invokes will ignore any configuration that is not supported.</source>
        <target state="translated">来源產生的 P/Invokes 將會忽略任何不支援的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessage">
        <source>The '{0}' configuration is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援 '{0}' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageMarshallingInfo">
        <source>The specified marshalling configuration is not supported by source-generated P/Invokes. {0}.</source>
        <target state="translated">来源產生的 P/Invokes 不支援指定的排列設定。{0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageParameter">
        <source>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為參數 '{1}' 指定的 '{0}' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageReturn">
        <source>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為方法 '{1}' 的傳回值指定 '{0}' 設定。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageValue">
        <source>The specified value '{0}' for '{1}' is not supported by source-generated P/Invokes. If the specified value is required, use a regular 'DllImport' instead.</source>
        <target state="translated">來源產生的 P/Invokes 不支援為 '{1}' 指定的值 '{0}'。如果需要指定的設定，請改用一般 'DllImport'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedTitle">
        <source>Specified configuration is not supported by source-generated P/Invokes.</source>
        <target state="translated">来源產生的 P/Invokes 不支援指定的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertNoPreserveSigDllImportToGeneratedMayProduceInvalidCode">
        <source>Automatically converting a P/Invoke with 'PreserveSig' set to 'false' to a source-generated P/Invoke may produce invalid code</source>
        <target state="translated">將 'PreserveSig' 設為 'false' 的 P/Invoke 自動轉換來源產生的 P/Invoke 可能會產生無效的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImport">
        <source>Convert to 'LibraryImport'</source>
        <target state="translated">轉換為 'LibraryImport'</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportAddUnsafe">
        <source>Convert to 'LibraryImport' and enable unsafe code</source>
        <target state="translated">轉換為 'LibraryImport'，並啟用不安全的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportDescription">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">使用 'LibraryImportAttribute' 而非 'DllImportAttribute' 在編譯時間產生 P/Invoke 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMayRequireCustomMarshalling">
        <source>Converting this API to 'LibraryImport' will require additional code to provide custom marshallers for some parameters.</source>
        <target state="translated">將此 API 轉換為 'LibraryImport' 需要額外的程式碼，才能提供某些參數的自訂封送處理器。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMessage">
        <source>Mark the method '{0}' with 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">以 'LibraryImportAttribute' 代替 'DllImportAttribute' 標示方法'{0}'，以在編譯時間產生 P/Invoke 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportTitle">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">使用 'LibraryImportAttribute' 而非 'DllImportAttribute' 在編譯時間產生 P/Invoke 封送處理程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffix">
        <source>Convert to 'LibraryImport' with '{0}' suffix</source>
        <target state="translated">轉換為具有 '{0}'後綴的 'LibraryImport'</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffixAddUnsafe">
        <source>Convert to 'LibraryImport' with '{0}' suffix and enable unsafe code</source>
        <target state="translated">轉換為具有 '{0}' 尾碼的 'LibraryImport'，並啟用不安全的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomMarshallerTypeMustHaveRequiredShapeTitle">
        <source>Marshaller type does not have the required shape</source>
        <target state="translated">封送處理器類型沒有必要的圖形</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulDescription">
        <source>A marshaller for an element scenario cannot be stateful.</source>
        <target state="translated">元素案例的封送處理器不可為可設定狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMarshallerCannotBeStatefulMessage">
        <source>The specified marshaller type '{0}' is a stateful marshaller, but stateful marshallers are not allowed in the provided marshal mode '{1}'</source>
        <target state="translated">指定的封送處理器類型 '{0}' 是可設定狀態的封送處理器，但是在提供的封送處理模式 '{1}' 中不允許有狀態的封送處理器</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchDescription">
        <source>The element type of the span returned by the first method must be the same type as the element type of the span returned by the second method.</source>
        <target state="translated">第一個方法傳回之跨距的元素類型必須與第二個方法傳回之跨距的元素類型相同類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchMessage">
        <source>The element type of the span returned by '{0}' must be the same type as the element type of the span returned by '{1}'.</source>
        <target state="translated">'{0}' 傳回之跨距的元素類型必須與 '{1}' 傳回之跨距的元素類型相同類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullDescription">
        <source>An entry-point type for marshalling a given type must not be 'null'.</source>
        <target state="translated">封送處理指定類型的進入點類型不得為 'null'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullMessage">
        <source>The entry-point marshaller type for the type '{0}' must be not 'null'</source>
        <target state="translated">類型 '{0}' 的進入點封送處理器類型不能是 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeDescription">
        <source>The first parameter of the first method must be the same type as the return types of the second method.</source>
        <target state="translated">第一個方法的第一個參數必須與第二個方法的傳回類型相同類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeMessage">
        <source>The first parameter of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">'{0}' 的第一個參數必須與 '{1}' 的傳回類型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchDescription">
        <source>The first parameters of the two methods must be the same type.</source>
        <target state="translated">兩種方法的第一個參數必須是相同的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchMessage">
        <source>The first parameter of '{0}' and '{1}' must be the same type</source>
        <target state="translated">'{0}' 與 '{1}' 的第一個參數必須是相同的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedDescription">
        <source>Overloading the 'FromUnmanaged' method is unuspported as some shapes are unable to distinguish between overloads.</source>
        <target state="translated">不支援多載 'FromUnmanaged' 方法，因為某些圖形無法區分多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedMessage">
        <source>The type '{0}' overloads the 'FromUnmanaged' method, which is not supported in custom marshallers</source>
        <target state="translated">自訂封送處理器中不支援類型 '{0}' 多載 'FromUnmanaged' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableDescription">
        <source>The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable.</source>
        <target state="translated">('ref' 帳戶處理後的) 'GetPinnableReference' 傳回類型必須是 blittable。</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableMessage">
        <source>The dereferenced type of the return type of the 'GetPinnableReference' method must be blittable</source>
        <target state="translated">'GetPinnableReference' 方法傳回類型的解除参照類型必須是 blittable</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingModifiersMessage">
        <source>Method '{0}' is contained in a type '{1}' that is not marked 'partial'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">方法 '{0}' 包含在未標示為 'partial' 的類型'{1}'中。產生 P/Invoke 来源會忽略方法'{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodDescription">
        <source>Methods marked with 'LibraryImportAttribute' should be 'static', 'partial', and non-generic. P/Invoke source generation will ignore methods that are non-'static', non-'partial', or generic.</source>
        <target state="translated">以 'LibraryImportAttribute' 標示的方法應該是 'static'、'partial' 和非泛型。產生 P/Invoke 来源會忽略非'static'、non-'partial' 或一般的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodSignatureMessage">
        <source>Method '{0}' should be 'static', 'partial', and non-generic when marked with 'LibraryImportAttribute'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">以 'LibraryImportAttribute' 標示時，方法'{0}'應為 'static'、'partial' 和非泛型。產生 P/Invoke 来源會忽略方法'{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCustomMarshallerAttributeUsageTitle">
        <source>Invalid 'CustomMarshallerAttribute' usage</source>
        <target state="translated">`CustomMarshallerAttribute` 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLibraryImportAttributeUsageTitle">
        <source>Invalid 'LibraryImportAttribute' usage</source>
        <target state="translated">'LibraryImportAttribute' 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidManagedTypeTitle">
        <source>Specified managed type is invalid</source>
        <target state="translated">指定的受控類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMarshallerTypeTitle">
        <source>Specified marshaller type is invalid</source>
        <target state="translated">指定的封送處理器類型無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNativeMarshallingAttributeUsageTitle">
        <source>Invalid 'NativeMarshallingAttribute' usage</source>
        <target state="translated">'NativeMarshallingAttribute' 使用方式無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSignaturesInMarshallerShapeTitle">
        <source>Marshaller type has incompatible method signatures</source>
        <target state="translated">封送處理器類型有不相容的方法簽章</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationDescription">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' is invalid.</source>
        <target state="translated">'StringMarshalling' 和 'StringMarshallingCustomType' 的設定無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMessage">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">方法 '{0}' 上的 'StringMarshalling' 和 'StringMarshallingCustomType' 設定無效。{1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMissingCustomType">
        <source>'StringMarshallingCustomType' must be specified when 'StringMarshalling' is set to 'StringMarshalling.Custom'.</source>
        <target state="translated">當 'StringMarshalling' 設定為 'StringMarshalling.Custom' 時，必須指定 'StringMarshallingCustomType'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationNotCustom">
        <source>'StringMarshalling' should be set to 'StringMarshalling.Custom' when 'StringMarshallingCustomType' is specified.</source>
        <target state="translated">指定 'StringMarshallingCustomType' 時，'StringMarshalling' 應設定為 'StringMarshalling.Custom'。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchDescription">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'.</source>
        <target state="translated">'GetManagedValuesSource' 傳回的 'ReadOnlySpan' 元素類型必須與 'GetManagedValuesDestination' 傳回的元素類型相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchMessage">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'</source>
        <target state="translated">'GetManagedValuesSource' 傳回的 'ReadOnlySpan' 元素類型必須與 'GetManagedValuesDestination' 傳回的元素類型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'LinearCollection'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a three-parameter constructor taking the managed type as the first parameter, a 'Span&lt;byte&gt;' as the second parameter, and the native size of the element as the third parameter</source>
        <target state="translated">支援 'CallerAllocatedBuffer' 功能的 'LinearCollection'-kind 原生類型必須提供以 Managed 類型作為第一個參數的三個參數建構函式、將 'Span&lt;byte&gt;' 作為第二個參數，以及元素的原生大小作為第三個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a three-parameter constructor that takes a '{1}' , a 'Span&lt;byte&gt;', and an 'int'</source>
        <target state="translated">類型 '{0}' 指定其支援 'In' 封送處理，且'{1}'的 'CallerAllocatedBuffer' 功能，但不提供接受'{1}'、'Span&lt;byte&gt;' 和 'int' 的三個參數建構函示</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'.</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesSource' 和傳回 'Span&lt;&gt;' 的 'GetNativeValuesDestination' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesSource' 和傳回 'Span&lt;&gt;' 的 'GetNativeValuesDestination' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供接受 'int' 和傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受 'int' 和傳回 'ReadOnlySpan&lt;&gt;' 的 'GetNativeValuesSource' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供接受 'int' 和傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受 'int' 和傳回 'ReadOnlySpan&lt;&gt;' 的 'GetNativeValuesSource' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the generator can determine which methods are available on the specific marshaller types.</source>
        <target state="translated">封送處理器類型必須是封閉的泛型或具有與受控類型相同的泛型參數數目，以便產生器可以判斷哪些方法可用於特定的封送處理器類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityMessage">
        <source>The managed type '{0}' for entry-point marshaller type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">進入點封送處理器類型 '{1}' 的受控類型 '{0}' 必須是封閉的泛型類型、如果是值封送處理器，則其 arity 必須與受控類型相同，如果是集合封送處理器，則必須有另一個泛型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullDescription">
        <source>The managed type for a custom marshaller must be non-null.</source>
        <target state="translated">自訂封送處理器的受控類型必須是非 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullMessage">
        <source>The managed type for the entry-point marshaller type '{0}' must not be 'null'</source>
        <target state="translated">進入點封送處理器類型 '{0}' 的受控類型不得為 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">封送處理器類型必須是封閉式泛型或具有與受控類型相同的泛型參數數目，因此發出的程式碼可以使用特定的具現化。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' pointed to by the entry-point marshaller type '{1}' must be a closed generic type or have the same arity as the managed type</source>
        <target state="translated">進入點封送處理器類型 '{1}' 指向的封送處理器類型 '{0}' 必須是封閉的泛型類型或與受控類型具有相同的 Arity</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullDescription">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'.</source>
        <target state="translated">'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' 中的 'marshallerType' 參數不可以是 'null'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullMessage">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'</source>
        <target state="translated">'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' 中的 'marshallerType' 參數不可以是 'null'</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructDescription">
        <source>A marshaller type must either be a stateless static class or a stateful value type. A non-static class is not allowed.</source>
        <target state="translated">封送處理程式類型必須是無狀態靜態類型或具狀態的數值類型。不允許非靜態類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructMessage">
        <source>The type '{0}' must be a static class or a value type</source>
        <target state="translated">類型 '{0}' 必須是靜態類別或數值類型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeDescription">
        <source>A type with a 'System.Runtime.InteropServices.CustomMarshallerAttribute' must specify a non-'null' managed type</source>
        <target state="translated">具有 'System.Runtime.InteropServices.CustomMarshallerAttribute' 的類型必須指定非 Null 受控類型</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeMessage">
        <source>The type '{0}' does not specify a managed type in the 'System.Runtime.InteropServices.CustomMarshallerAttribute' applied to the type</source>
        <target state="translated">類型 '{0}' 未在套用至類型的 'System.Runtime.InteropServices.CustomMarshallerAttribute' 中指定受控類型</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">封送處理器類型必須是封閉式泛型或具有與受控類型相同的泛型參數數目，因此發出的程式碼可以使用特定的具現化。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' for managed type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">受控類型 '{1}' 的封送處理器類型 '{0}' 必須是封閉的泛型類型、如果是值封送處理器，則其 arity 必須與受控類型相同，如果是集合封送處理器，則必須有另一個泛型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksDescription">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的程式碼。專案必須以 '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;' 更新。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksMessage">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的程式碼。專案必須以 '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;' 更新。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksTitle">
        <source>LibraryImportAttribute requires unsafe code.</source>
        <target state="translated">LibraryImportAttribute 需要不安全的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeDescription">
        <source>The return type the two method must be the expected type.</source>
        <target state="translated">兩種方法的傳回類型必須是預期的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeMessage">
        <source>The return type of '{0}' must be '{1}'</source>
        <target state="translated">'{0}' 的傳回類型必須為 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchDescription">
        <source>The return types of the two methods must be the same type.</source>
        <target state="translated">兩種方法的傳回類型必須是相同的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchMessage">
        <source>The return type of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">'{0}' 的傳回類型必須與 '{1}' 的傳回類型相同</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeDescription">
        <source>A stateful marshaller must have a zero-parameter void-returning instance method named 'Free'.</source>
        <target state="translated">具狀態的封送處理常式必須有名稱為 'Free' 的零參數無效傳回執行個體方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFreeMessage">
        <source>The type '{0}' is a stateful marshaller and does not have a zero-parameter void-returning instance method named 'Free'</source>
        <target state="translated">類型 '{0}' 是具狀態的封送處理器，且沒有名為 'Free' 的零參數無效傳回執行個體方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'FromManaged' instance method that takes the managed value as a parameter and returns 'void'.</source>
        <target state="translated">支援從受控到未受控封送處理的具狀態封送處理器必須提供 'FromManaged' 執行個體方法，該方法將受控值作為參數並傳回 'void'。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromManaged' that takes a '{2}' as a parameter and returns 'void'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但它不提供名為 'FromManaged' 的單一參數執行個體方法，該方法將 '{2}' 值作為參數並傳回 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'FromUnmanaged' instance method that takes the unmanaged value as a parameter and returns 'void'.</source>
        <target state="translated">支援從未受控到受控封送處理的具狀態封送處理器必須提供 'FromUnmanaged' 執行個體方法，該方法將未受控值作為參數並傳回 'void'。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresFromUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a one-parameter instance method named 'FromUnmanaged' that takes the 'unmanaged' value as a parameter and returns 'void'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但它不提供名為 'FromUnmanaged' 的單一參數執行個體方法，該方法將 'unmanaged' 值作為參數並傳回 'void'</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedDescription">
        <source>A stateful marshaller that supports marshalling from unmanaged to managed must provide a 'ToManaged' instance method that takes no parameters and returns the managed type.</source>
        <target state="translated">支援從未受控到受控封送處理的具狀態封送處理器必須提供 'ToManaged' 執行個體方法，該方法沒有參數並傳回受控類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToManagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToManaged' that returns '{2}'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但不提供名為 'ToManaged' 的零參數執行個體方法，該方法會傳回 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedDescription">
        <source>A stateful marshaller that supports marshalling from managed to unmanaged must provide a 'ToUnmanaged' instance method that takes no parameters and returns the 'unmanaged' type.</source>
        <target state="translated">支援從受控到未受控封送處理的具狀態封送處理器必須提供 'ToUnmanaged' 執行個體方法，該方法沒有參數並傳回 'unmanaged' 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulMarshallerRequiresToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but it does not provide a zero-parameter instance method named 'ToUnmanaged' that returns the 'unmanaged' type for the marshaller</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 的 '{2}' 封送處理模式，但不提供名為 'ToUnmanaged' 的零參數執行個體方法，該方法會傳回封送處理器的 'unmanaged' 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing an 'AllocateContainerForUnmanagedElements' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">當透過提供在封送處理程式類型上採用 'Span&lt;T&gt;' 的 'AllocateContainerForUnmanagedElements' 方法來使用 'Managed to Unmanaged with Caller-Allocated Buffer' 圖形時，該類型必須提供靜態 'BufferSize' 屬性以提供 caller-allocated 緩衝區中的元素數目。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocFromManagedMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has an 'AllocateContainerForUnmanagedElements' method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">封送處理程式類型 '{0}' 必須有靜態唯讀 'int' 'BufferSize' 屬性，以指定 caller-allocated 緩衝區的大小，因為它具有採用 caller-allocated 'Span&lt;{1}&gt;' 的 'AllocateContainerForUnmanagedElements' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that takes the managed value as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供接受受控值為參數並傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesDestination'，和接受非受控值為參數並傳回 'Span&lt;&gt;' 的 'GetUnmanagedValuesSource' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that takes '{2}' as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供接受 '{2}' 為參數並傳回 'ReadOnlySpan&lt;&gt;' 的 'GetManagedValuesSource' ，和接受未受控值為參數並傳回 'Span&lt;&gt;' 的 'GetUnmanagedValuesDestination' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes the managed value and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">支援從非受控到受控封送處理的連續集合封送處理程式必須提供接受受控值並傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受非受控值及 'int' 並傳回 'ReadOnlySpan&lt;&gt;' 的 'GetUnmanagedValuesSource' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes '{2}' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供接受 '{2}' 和傳回 'Span&lt;&gt;' 的 'GetManagedValuesDestination'，和接受未受控值和傳回 'ReadOnlySpan&lt;&gt;' 的 'GetUnmanagedValuesSource' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForManagedElements' method taking the unmanaged type as the first parameter and the number of elements as an 'int' parameter</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態連續集合封送處理程式必須提供 'AllocateContainerForManagedElements' 方法，將未受控的類型作為第一個參數，以及元素數目作為 'int' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForManagedElements' method that takes the unmanaged type as the first parameter and an 'int' as the second parameter</source>
        <target state="translated">類型 '{0}' 指定它支援 '{2}' 的 '{1}' 封送處理模式，但不提供接受未受控類型作爲第一個參數和 'int' 作為第二個參數的雙參數 'AllocateContainerForManagedElements' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForUnmanagedElements' method taking the managed type as the first parameter and providing the number of elements as an 'out int' parameter</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態連續集合封送處理程式必須提供 'AllocateContainerForManagedElements' 方法，將受控類型作為第一個參數，以及提供元素數目作為 'out int' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForUnmanagedElements' method that takes a '{2}' as the first parameter and an 'out int' as the second parameter</source>
        <target state="translated">類型 '{0}' 指定它支援 '{2}' 的 '{1}' 封送處理模式，但不提供接受 '{2}' 作爲第一個參數和 'out int' 作為第二個參數的雙參數 'AllocateContainerForUnmanagedElements' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedDescription">
        <source>A stateless value marshaller that supports marshalling from unmanaged to managed must provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns the the managed type.</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態值封送處理程式必須提供接受未受控類型作為參數，並傳回受控類型的 'ConvertToManaged' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedMessage">
        <source>The type '{0}' specifies it supports the '{1}' marshal mode, but it does not provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns '{2}'</source>
        <target state="translated">類型 '{0}' 指定它支援 '{1}' 封送處理模式，但未提供將未受控的類型當做參數並傳回 '{2}' 的 'ConvertToManaged' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedDescription">
        <source>A stateless value marshaller that supports marshalling from managed to unmanaged must provide a one-parameter 'ConvertToUnmanaged' method that takes the managed value as the parameter and returns a value of the 'unmanaged' type.</source>
        <target state="translated">支援從受控到未受控封送處理的無狀態值封送處理程式必須提供單一參數 'ConvertToUnmanaged' 方法，將受控值作為參數，並傳回 'unmanaged' 類型的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a one-parameter 'ConvertToUnmanaged' method that takes a '{2}' as a parameter and returns a value of an 'unmanaged' type</source>
        <target state="translated">類型 '{0}' 指定它支援 '{2}' 的 '{1}' 封送處理模式，但不提供以 '{2}' 為參數的單一參數 'ConvertToUnmanaged' 方法，並傳回 'unmanaged' 類型的值</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchDescription">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same.</source>
        <target state="translated">'ConvertToUnmanaged' 的傳回類型與 'ConvertToManaged' 的參數類型必須相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchMessage">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same</source>
        <target state="translated">'ConvertToUnmanaged' 的傳回類型與 'ConvertToManaged' 的參數類型必須相同</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedDescription">
        <source>The unmanaged type for a custom marshaller must be a C# unmanaged type.</source>
        <target state="translated">自訂封送處理程式的未受控類型必須是 C# 未受控類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedMessage">
        <source>The return type of '{0}' must be unmanaged</source>
        <target state="translated">'{0}' 的傳回類型必須為不受控</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerDescription">
        <source>'void*' must be castable to the type so the pinned result of the static 'GetPinnableReference' method can be passed to the native context after being pinned.</source>
        <target state="translated">'void*' 必須可轉換為類型，以致靜態 'GetPinnableReference' 方法的釘選結果可在釘選之後傳遞至原生內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerMessage">
        <source>'void*' must be castable to the type '{0}' because the managed type '{1}' has a static 'GetPinnableReference' method</source>
        <target state="translated">'void*' 必須轉換為類型 '{0}'，因為受控類型 '{1}' 具有靜態 'GetPinnableReference' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeDescription">
        <source>An entry-point type for marshalling a given type must have a 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type.</source>
        <target state="translated">指定類型的封送處理進入點類型必須有 'System.Runtime.InteropServices.CustomMarshallerAttribute'，指定此類型為受控類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeMessage">
        <source>The entry-point marshaller type '{0}' for the type '{1}' must be a type with at least one 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type</source>
        <target state="translated">類型 '{1}' 的進入點封送處理器類型 '{0}' 必須是具有至少一個 'System.Runtime.InteropServices.CustomMarshallerAttribute' 的類型，指定此類型為受控類型</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedDescription">
        <source>A 'Value' or 'LinearCollection'-kind native type that supports marshalling in the 'Out' direction must provide a 'ToManaged' method that returns the managed type.</source>
        <target state="translated">支援在 'Out' 方向排列的 'Value' 或 'LinearCollection'-kind 原生類型必須提供傳回 Managed 類型的 'ToManaged' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedMessage">
        <source>The type '{0}' specifies it supports marshalling in the 'Out' direction, but it does not provide a 'ToManaged' method that returns the managed type</source>
        <target state="translated">類型 '{0}' 指定它支援以 'Out' 方向排列，但未提供傳回受管理類型的 'ToManaged' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchDescription">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same.</source>
        <target state="translated">'ToUnmanaged' 的傳回類型與 'FromUnmanaged' 的參數類型必須相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchMessage">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same</source>
        <target state="translated">'ToUnmanaged' 的傳回類型與 'FromUnmanaged' 的參數類型必須相同</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedDescription">
        <source>For types that are not supported by source-generated P/Invokes, the resulting P/Invoke will rely on the underlying runtime to marshal the specified type.</source>
        <target state="translated">對於來源產生的 P/Invokes 不支援的類型，產生的 P/Invoke 將依賴基礎運行時間來封送指定的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameter">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">来源產生的 P/Invokes 不支援類型 '{0}'。產生的来源將不會處理參數 '{1}' 的排列。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterWithDetails">
        <source>{0} The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">{0} 產生的来源将不會處理參數 '{1}' 的排列。</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the parameter</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturn">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">来源產生的 P/Invokes 不支援類型 '{0}'。產生的來源將不會處理方法 '{1}' 的傳回值排列。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnWithDetails">
        <source>{0} The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">{0} 產生的來源將不會處理方法 '{1}' 之傳回值的排列。</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the method</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedTitle">
        <source>Specified type is not supported by source-generated P/Invokes</source>
        <target state="translated">来源產生的 P/Invokes 不支援指定的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'Value'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a two-parameter constructor taking the managed type and a 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">支援 'CallerAllocatedBuffer' 功能的 'Value'-kind 原生類型必須提供接受受管理類型的雙參數建構函示，以及以 'unmanaged' 類型的 'Span' 作為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a two-parameter constructor that takes a '{1}' and 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">類型 '{0}' 指定其支援使用 'CallerAllocatedBuffer' 功能為 '{1}' 的 'In' 封送處理，但不提供接受 '{1}' 的二參數構建函式，以及以 'unmanaged' 類型的 'Span' 作為參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorDescription">
        <source>A 'Value'-kind native type must provide a one-parameter constructor taking the managed type as a parameter</source>
        <target state="translated">'Value'-kind 原生類型必須提供以 Managed 類型作為參數的單一參數構建函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling of '{1}' but does not provide a one-parameter constructor that takes a '{1}' as a parameter</source>
        <target state="translated">類型 '{0}'指定它支援 'In' 封送'{1}'，但不提供以'{1}'作為參數的單一參數建構函式</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>