<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
    <body>
      <trans-unit id="AddMissingCustomTypeMarshallerMembers">
        <source>Add missing custom type marshaller members</source>
        <target state="translated">Agregue los miembros de serializador de tipo personalizado que faltan</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocConstructorMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing a 'FromManaged' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">Cuando la forma "Administrado a no administrado con búfer asignado por el llamador" se usa con un método "FromManaged" que toma un "Span&lt;T&gt;" en el tipo de serializador, el tipo debe proporcionar una propiedad estática "BufferSize" para proporcionar el número de elementos en el búfer asignado por el llamador.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallerAllocConstructorMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has a FromManaged method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">El tipo de serializador "{0}" debe tener una propiedad "int" "BufferSize" estática de solo lectura para especificar el tamaño del búfer asignado por el autor de la llamada porque tiene un método FromManaged que toma una propiedad "Span&lt;{1}&gt;" asignada por el autor de la llamada.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportDescription">
        <source>The generated 'DllImportAttribute' will not have a value corresponding to '{0}'.</source>
        <target state="translated">El “DllImportAttribute” generado no tendrá un valor correspondiente a “{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportMessage">
        <source>'{0}' has no equivalent in 'DllImportAttribute' and will not be forwarded</source>
        <target state="translated">“{0}” no tiene equivalente en “DllImportAttribute” y no se reenviará</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotForwardToDllImportTitle">
        <source>Specified 'LibraryImportAttribute' arguments cannot be forwarded to 'DllImportAttribute'</source>
        <target state="translated">Los argumentos “LibraryImportAttribute” especificados no se pueden reenviar a “DllImportAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedDescription">
        <source>Source-generated P/Invokes will ignore any configuration that is not supported.</source>
        <target state="translated">Los P/Invoke de un generador de código fuente omitirán cualquier configuración que no esté admitida.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessage">
        <source>The '{0}' configuration is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">La configuración de "{0}" no está admitida por P/Invokes de un generador de código fuente. Si se requiere la configuración, use un "DllImport" normal en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageMarshallingInfo">
        <source>The specified marshalling configuration is not supported by source-generated P/Invokes. {0}.</source>
        <target state="translated">La configuración de serialización especificada no está admitida por P/Invokes de un generador de código fuente. {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageParameter">
        <source>The specified '{0}' configuration for parameter '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">La configuración de "{0}" especificada para el parámetro "{1}" no es compatible con P/Invokes de un generador de código fuente. Si se requiere la configuración especificada, use un "DllImport" normal en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageReturn">
        <source>The specified '{0}' configuration for the return value of method '{1}' is not supported by source-generated P/Invokes. If the specified configuration is required, use a regular 'DllImport' instead.</source>
        <target state="translated">La configuración de "{0}" especificada para el valor devuelto del método "{1}" no es compatible con P/Invokes generados por origen. Si se requiere la configuración especificada, use un "DllImport" normal en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedMessageValue">
        <source>The specified value '{0}' for '{1}' is not supported by source-generated P/Invokes. If the specified value is required, use a regular 'DllImport' instead.</source>
        <target state="translated">El valor especificado de "{0}" para "{1}" no es compatible con P/Invokes de un generador de código fuente. Si se requiere el valor especificado, use un "DllImport" normal en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationNotSupportedTitle">
        <source>Specified configuration is not supported by source-generated P/Invokes.</source>
        <target state="translated">La configuración especificada no está admitida por P/Invokes de un generador de código fuente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertNoPreserveSigDllImportToGeneratedMayProduceInvalidCode">
        <source>Automatically converting a P/Invoke with 'PreserveSig' set to 'false' to a source-generated P/Invoke may produce invalid code</source>
        <target state="translated">Convertir automáticamente un P/Invoke con “PreserveSig” establecido en “false” en un P/Invoke de un generador de código fuente puede producir código no válido</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImport">
        <source>Convert to 'LibraryImport'</source>
        <target state="translated">Convertir en “LibraryImport”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportDescription">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">Use “LibraryImportAttribute” en lugar de “DllImportAttribute” para generar código de serialización P/Invoke en el tiempo de compilación</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportMessage">
        <source>Mark the method '{0}' with 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">Marque el método “{0}” con “LibraryImportAttribute” en lugar de “DllImportAttribute” para generar código de serialización P/Invoke en el tiempo de compilación</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportTitle">
        <source>Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time</source>
        <target state="translated">Use “LibraryImportAttribute” en lugar de “DllImportAttribute” para generar código de serialización P/Invoke en el tiempo de compilación</target>
        <note />
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWarning">
        <source>Conversion to 'LibraryImport' may change behavior and compatibility. See {0} for more information.</source>
        <target state="translated">La conversión a “LibraryImport” debe cambiar de comportamiento y compatibilidad. Vea {0} para obtener más información.</target>
        <note>{0} is a documentation link</note>
      </trans-unit>
      <trans-unit id="ConvertToLibraryImportWithSuffix">
        <source>Convert to 'LibraryImport' with '{0}' suffix</source>
        <target state="translated">Convertir a “LibraryImport” con sufijo “{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomMarshallerTypeMustHaveRequiredShapeTitle">
        <source>Marshaller type does not have the required shape</source>
        <target state="translated">El tipo de serializador no tiene la forma necesaria</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchDescription">
        <source>The element type of the span returned by the first method must be the same type as the element type of the span returned by the second method.</source>
        <target state="translated">El tipo de elemento del intervalo devuelto por el primer método debe ser del mismo tipo que el tipo de elemento del intervalo devuelto por el segundo método.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementTypesOfReturnTypesMustMatchMessage">
        <source>The element type of the span returned by '{0}' must be the same type as the element type of the span returned by '{1}'.</source>
        <target state="translated">El tipo de elemento del intervalo devuelto por "{0}" debe ser del mismo tipo que el tipo de elemento del intervalo devuelto por "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullDescription">
        <source>An entry-point type for marshalling a given type must not be 'null'.</source>
        <target state="translated">Un tipo de punto de entrada para serializar un tipo determinado no debe ser "null".</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustBeNonNullMessage">
        <source>The entry-point marshaller type for the type '{0}' must be not 'null'</source>
        <target state="translated">El tipo de serializador de punto de entrada para el tipo "{0}" no debe ser "null"</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeDescription">
        <source>The first parameter of the first method must be the same type as the return types of the second method.</source>
        <target state="translated">El primer parámetro del primer método debe ser del mismo tipo que los tipos devueltos del segundo método.</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParameterMustMatchReturnTypeMessage">
        <source>The first parameter of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">El primer parámetro de "{0}" debe ser del mismo tipo que el tipo de valor devuelto de "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchDescription">
        <source>The first parameters of the two methods must be the same type.</source>
        <target state="translated">Los primeros parámetros de los dos métodos deben ser del mismo tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="FirstParametersMustMatchMessage">
        <source>The first parameter of '{0}' and '{1}' must be the same type</source>
        <target state="translated">El primer parámetro de "{0}" y "{1}" deben ser del mismo tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedDescription">
        <source>Overloading the 'FromUnmanaged' method is unuspported as some shapes are unable to distinguish between overloads.</source>
        <target state="translated">No se puede sobrecargar el método "FromUnmanaged" porque algunas formas no pueden distinguir entre sobrecargas.</target>
        <note />
      </trans-unit>
      <trans-unit id="FromUnmanagedOverloadsNotSupportedMessage">
        <source>Overloading the 'FromUnmanaged' method is not supported in custom marshallers</source>
        <target state="translated">No se admite la sobrecarga del método "FromUnmanaged" en los serializadores personalizados</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableDescription">
        <source>The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable.</source>
        <target state="translated">El tipo de valor devuelto de “GetPinnableReference” (tras pasar por “ref”) debe poder transferirse en bloques de bits.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetPinnableReferenceReturnTypeBlittableMessage">
        <source>The dereferenced type of the return type of the 'GetPinnableReference' method must be blittable</source>
        <target state="translated">El tipo desreferenciado del tipo de valor devuelto del método “GetPinnableReference” debe poder transferirse en bloques de bits</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodContainingTypeMissingModifiersMessage">
        <source>Method '{0}' is contained in a type '{1}' that is not marked 'partial'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">El método “{0}” está contenido en un tipo “{1}” que no está marcado como “partial”. La generación de código fuente P/Invoke omitirá el método “{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodDescription">
        <source>Methods marked with 'LibraryImportAttribute' should be 'static', 'partial', and non-generic. P/Invoke source generation will ignore methods that are non-'static', non-'partial', or generic.</source>
        <target state="translated">Los métodos marcados con “LibraryImportAttribute” deben ser “static”, “partial” y no genéricos. La generación de código fuente P/Invoke omitirá los métodos que no sean “static”, “partial” ni genéricos.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAttributedMethodSignatureMessage">
        <source>Method '{0}' should be 'static', 'partial', and non-generic when marked with 'LibraryImportAttribute'. P/Invoke source generation will ignore method '{0}'.</source>
        <target state="translated">El método “{0}” debe ser “static”, “partial”, y no genérico cuando está marcado con “LibraryImportAttribute”. La generación del código fuente P/Invoke omitirá el método “{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCustomMarshallerAttributeUsageTitle">
        <source>Invalid 'CustomMarshallerAttribute' usage</source>
        <target state="translated">Uso de "CustomMarshallerAttribute" no válido</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLibraryImportAttributeUsageTitle">
        <source>Invalid 'LibraryImportAttribute' usage</source>
        <target state="translated">Uso de “LibraryImportAttribute” no válido</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidManagedTypeTitle">
        <source>Specified managed type is invalid</source>
        <target state="translated">El tipo administrado especificado no es válido</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMarshallerTypeTitle">
        <source>Specified marshaller type is invalid</source>
        <target state="translated">El tipo de serializador especificado no es válido</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNativeMarshallingAttributeUsageTitle">
        <source>Invalid 'NativeMarshallingAttribute' usage</source>
        <target state="translated">Uso de "NativeMarshallingAttribute" no válido</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSignaturesInMarshallerShapeTitle">
        <source>Marshaller type has incompatible method signatures</source>
        <target state="translated">El tipo de serializador tiene firmas de método incompatibles</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationDescription">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' is invalid.</source>
        <target state="translated">La configuración de “StringMarshalling” y “StringMarshallingCustomType” no es válida.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMessage">
        <source>The configuration of 'StringMarshalling' and 'StringMarshallingCustomType' on method '{0}' is invalid. {1}</source>
        <target state="translated">La configuración de “StringMarshalling” y “StringMarshallingCustomType” en el método “{0}” no es válida. {1}</target>
        <note>{1} is a message containing additional details about what is not valid</note>
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationMissingCustomType">
        <source>'StringMarshallingCustomType' must be specified when 'StringMarshalling' is set to 'StringMarshalling.Custom'.</source>
        <target state="translated">Se debe especificar “StringMarshallingCustomType” cuando “StringMarshalling” esté establecido en “StringMarshalling.Custom”.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStringMarshallingConfigurationNotCustom">
        <source>'StringMarshalling' should be set to 'StringMarshalling.Custom' when 'StringMarshallingCustomType' is specified.</source>
        <target state="translated">“StringMarshalling” debe establecerse en “StringMarshalling.Custom” cuando “StringMarshallingCustomType” esté especificado.</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchDescription">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'.</source>
        <target state="translated">El tipo de elemento del “ReadOnlySpan” devuelto por “GetManagedValuesSource” debe ser el mismo que el tipo de elemento devuelto por “GetManagedValuesDestination”.</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionElementTypesMustMatchMessage">
        <source>The element type of the 'ReadOnlySpan' returned by 'GetManagedValuesSource' must be the same as the element type returned by 'GetManagedValuesDestination'</source>
        <target state="translated">El tipo de elemento de “ReadOnlySpan” devuelto por “GetManagedValuesSource” debe ser el mismo que el tipo de elemento devuelto por “GetManagedValuesDestination”</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'LinearCollection'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a three-parameter constructor taking the managed type as the first parameter, a 'Span&lt;byte&gt;' as the second parameter, and the native size of the element as the third parameter</source>
        <target state="translated">Un tipo nativo de variante “LinearCollection” que admita la característica “CallerAllocatedBuffer” debe proporcionar un constructor de tres parámetros que tome el tipo administrado como primer parámetro, un “Span&lt;byte&gt;” como segundo parámetro y el tamaño nativo del elemento como tercer parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a three-parameter constructor that takes a '{1}' , a 'Span&lt;byte&gt;', and an 'int'</source>
        <target state="translated">El tipo “{0}” especifica que admite serializar “In” con la característica “CallerAllocatedBuffer” para “{1}” pero no provee un constructor de tres parámetros que incluya un “{1}”, un “Span&lt;byte&gt;”, y un “int”</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'.</source>
        <target state="translated">Un serializador de colección contigua que admita la serialización de administrado a no administrado debe proporcionar un "GetManagedValuesSource" que devuelva un valor de "ReadOnlySpan&lt;&gt;" y un método "GetUnmanagedValuesDestination" que devuelva un valor de "Span&lt;&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that returns a 'Span&lt;&gt;'</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}", pero no proporciona un "GetManagedValuesSource" que devuelva un "ReadOnlySpan&lt;&gt;" y un método "GetNativeValuesDestination" que devuelva un "Span&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">Un serializador de colección contigua que admita serializaciones de no administrado a administrado debe proporcionar un método 'GetManagedValuesDestination' que tome "int" y devuelva un "Span&lt;&gt;" y un método "GetUnmanagedValuesSource" que tome "int" y devuelva "ReadOnlySpan&lt;&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="LinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes an 'int' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}", pero no proporciona un "GetManagedValuesDestination" que tome un "int" y devuelva un "Span&lt;&gt;" y un método "GetUnmanagedValuesSource" que tome un "int" y devuelva un "ReadOnlySpan&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the generator can determine which methods are available on the specific marshaller types.</source>
        <target state="translated">El tipo de serializador debe ser un genérico cerrado o tener el mismo número de parámetros genéricos que el tipo administrado para que el generador pueda determinar qué métodos están disponibles en los tipos de serializador específicos.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeClosedOrMatchArityMessage">
        <source>The managed type '{0}' for entry-point marshaller type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">El tipo administrado "{0}" para el tipo de serializador de punto de entrada "{1}" debe ser un tipo genérico cerrado, tener la misma aridad que el tipo administrado si es un serializador de valores o tener un parámetro genérico adicional si es un serializador de colección.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullDescription">
        <source>The managed type for a custom marshaller must be non-null.</source>
        <target state="translated">El tipo administrado de un serializador personalizado no debe ser nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManagedTypeMustBeNonNullMessage">
        <source>The managed type for the entry-point marshaller type '{0}' must not be 'null'</source>
        <target state="translated">El tipo administrado para el tipo de serializador de punto de entrada "{0}" no debe ser "null"</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">El tipo serializador debe ser un genérico cerrado o tener el mismo número de parámetros genéricos que el tipo administrado para que el código emitido pueda usar una creación de instancia específica.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' pointed to by the entry-point marshaller type '{1}' must be a closed generic type or have the same arity as the managed type</source>
        <target state="translated">El tipo de serializador "{0}" al que apunta el tipo de serializador de punto de entrada "{1}" debe ser un tipo genérico cerrado o tener la misma aridad que el tipo administrado</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullDescription">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'.</source>
        <target state="translated">El parámetro "marshallerType" de "System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute" no puede ser "null".</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeNonNullMessage">
        <source>The 'marshallerType' parameter in the 'System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute' cannot be 'null'</source>
        <target state="translated">El parámetro "marshallerType" de "System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute" no puede ser "null"</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructDescription">
        <source>A marshaller type must either be a stateless static class or a stateful value type. A non-static class is not allowed.</source>
        <target state="translated">Un tipo de serializador debe ser una clase estática sin estado o un tipo de valor con estado. No se permite una clase no estática.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustBeStaticClassOrStructMessage">
        <source>The type '{0}' must be a static class or a value type</source>
        <target state="translated">El tipo "{0}" debe ser una clase estática o un tipo de valor</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeDescription">
        <source>A type with a 'System.Runtime.InteropServices.CustomMarshallerAttribute' must specify a non-'null' managed type</source>
        <target state="translated">Un tipo con un "System.Runtime.InteropServices.CustomMarshallerAttribute" debe especificar un tipo administrado no nulo</target>
        <note />
      </trans-unit>
      <trans-unit id="MarshallerTypeMustSpecifyManagedTypeMessage">
        <source>The type '{0}' does not specify a managed type in the 'System.Runtime.InteropServices.CustomMarshallerAttribute' applied to the type</source>
        <target state="translated">El tipo "{0}" no especifica un tipo administrado en el "System.Runtime.InteropServices.CustomMarshallerAttribute" aplicado al tipo</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityDescription">
        <source>The marshaller type must be a closed generic or have the same number of generic parameters as the managed type so the emitted code can use a specific instantiation.</source>
        <target state="translated">El tipo serializador debe ser un genérico cerrado o tener el mismo número de parámetros genéricos que el tipo administrado para que el código emitido pueda usar una creación de instancia específica.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericEntryPointMarshallerTypeMustBeClosedOrMatchArityMessage">
        <source>The marshaller type '{0}' for managed type '{1}' must be a closed generic type, have the same arity as the managed type if it is a value marshaller, or have one additional generic parameter if it is a collection marshaller.</source>
        <target state="translated">El tipo de serializador "{0}" para el tipo administrado "{1}" debe ser un tipo genérico cerrado, tener la misma aridad que el tipo administrado si es un serializador de valores o tener un parámetro genérico adicional si es un serializador de colección.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksDescription">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute requiere código no seguro. El proyecto debe actualizarse con '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksMessage">
        <source>LibraryImportAttribute requires unsafe code. Project must be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</source>
        <target state="translated">LibraryImportAttribute requiere código no seguro. El proyecto debe actualizarse con '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiresAllowUnsafeBlocksTitle">
        <source>LibraryImportAttribute requires unsafe code.</source>
        <target state="translated">LibraryImportAttribute requiere código no seguro.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeDescription">
        <source>The return type the two method must be the expected type.</source>
        <target state="translated">El tipo de valor devuelto por el que ambos métodos deben ser del tipo esperado.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypeMustBeExpectedTypeMessage">
        <source>The return type of '{0}' must be '{1}'</source>
        <target state="translated">El tipo de valor devuelto de "{0}" debe ser "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchDescription">
        <source>The return types of the two methods must be the same type.</source>
        <target state="translated">Los tipos devueltos de los dos métodos deben ser del mismo tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReturnTypesMustMatchMessage">
        <source>The return type of '{0}' must be the same type as the return type of '{1}'</source>
        <target state="translated">El tipo de valor devuelto de "{0}" debe ser del mismo tipo que el tipo de valor devuelto de "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocConstructorMustHaveBufferSizeDescription">
        <source>When the 'Managed to Unmanaged with Caller-Allocated Buffer' shape is used by providing an 'AllocateContainerForUnmanagedElements' method that takes a 'Span&lt;T&gt;' on the marshaller type, the type must provide a static 'BufferSize' property to provide the number of elements in the caller-allocated buffer.</source>
        <target state="translated">Cuando la forma "Administrado a no administrado con búfer asignado por el llamador" se usa con un método "AllocateContainerForUnmanagedElements" que toma un "Span&lt;T&gt;" en el tipo de serializador, el tipo debe proporcionar una propiedad estática "BufferSize" para proporcionar el número de elementos en el búfer asignado por el llamador.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionCallerAllocConstructorMustHaveBufferSizeMessage">
        <source>The marshaller type '{0}' must have a static read-only 'int' 'BufferSize' property to specify the size of the caller-allocated buffer because it has an 'AllocateContainerForUnmanagedElements' method that takes a caller-allocated 'Span&lt;{1}&gt;'</source>
        <target state="translated">El tipo de serializador "{0}" debe tener una propiedad "int" "BufferSize" estática de solo lectura para especificar el tamaño del búfer asignado por el autor de la llamada porque tiene un método "AllocateContainerForUnmanagedElements" que toma una propiedad "Span&lt;{1}&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from managed to unmanaged must provide a 'GetManagedValuesSource' that takes the managed value as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">Un serializador de colección contigua que admita serializaciones de administrado a administrado debe proporcionar un método "GetManagedValuesSource" que tome el valor administrado y devuelva un "'ReadOnlySpan&lt;&gt;" y un método "GetUnmanagedValuesDestination" que tome el valor no administrado como perámetro y devuelva "Span&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionInRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesSource' that takes '{2}' as a parameter and returns a 'ReadOnlySpan&lt;&gt;' and a 'GetUnmanagedValuesDestination' method that takes the unmanaged value as a parameter and returns a 'Span&lt;&gt;'</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}", pero no proporciona un "GetManagedValuesSource" que tome como parámetro un "{2}" y devuelva un "ReadOnlySpan&lt;&gt;" y un método "GetUnmanagedValuesDestination" que tome como parámetro un valor no administrado y devuelva un "Span&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsDescription">
        <source>A contiguous collection marshaller that supports marshalling from unmanaged to managed must provide a 'GetManagedValuesDestination' that takes the managed value and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'.</source>
        <target state="translated">Un serializador de colección contigua que admita serializaciones de no administrado a administrado debe proporcionar un método "GetManagedValuesDestination" que tome el valor administrado y devuelva un "Span&lt;&gt;" y un método "GetUnmanagedValuesSource" que tome el valor no administrado y "int" y devuelva "ReadOnlySpan&lt;&gt;".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionOutRequiresCollectionMethodsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode, but it does not provide a 'GetManagedValuesDestination' that takes '{2}' and returns a 'Span&lt;&gt;' and a 'GetUnmanagedValuesSource' method that takes the unmanaged value and an 'int' and returns a 'ReadOnlySpan&lt;&gt;'</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}", pero no proporciona un "GetManagedValuesDestination" que tome un "{2}" y devuelva un "Span&lt;&gt;" y un método "GetUnmanagedValuesSource" que tome el valor no administrado y un "int" y devuelva un "ReadOnlySpan&lt;&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForManagedElements' method taking the unmanaged type as the first parameter and the number of elements as an 'int' parameter</source>
        <target state="translated">Un serializador de colección contigua sin estado que admita serializaciones de administrado a no administrado debe proporcionar un método "AllocateContainerForManagedElements" que tome el tipo no administrado como primer parámetro y el número de elementos como parámetro "int"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForManagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForManagedElements' method that takes the unmanaged type as the first parameter and an 'int' as the second parameter</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}" para "{2}", pero no proporciona un método "AllocateContainerForUnmanagedElements" de dos parámetros que toma el tipo no administrado como primer parámetro y "int" como segundo parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsDescription">
        <source>A stateless contiguous collection marshaller that supports marshalling from managed to unmanaged must provide an 'AllocateContainerForUnmanagedElements' method taking the managed type as the first parameter and providing the number of elements as an 'out int' parameter</source>
        <target state="translated">Un serializador de colección contigua sin estado que admita serializaciones de administrado a no administrado debe proporcionar un método "AllocateContainerForManagedElements" que tome el tipo administrado como primer parámetro y que proporcione el número de elementos como parámetro "out int"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessLinearCollectionRequiresTwoParameterAllocateContainerForUnmanagedElementsMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a two-parameter 'AllocateContainerForUnmanagedElements' method that takes a '{2}' as the first parameter and an 'out int' as the second parameter</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}" para "{2}", pero no proporciona un método "AllocateContainerForUnmanagedElements" de dos parámetros que toma "{2}" como primer parámetro y "out int" como segundo parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedDescription">
        <source>A stateless value marshaller that supports marshalling from unmanaged to managed must provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns the the managed type.</source>
        <target state="translated">Un serializador de valores sin estado que admita la serialización de no administrado a administrado debe proporcionar un método "ConvertToManaged" que tome el tipo no administrado como parámetro y devuelva el tipo administrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessRequiresConvertToManagedMessage">
        <source>The type '{0}' specifies it supports the '{1}' marshal mode, but it does not provide a 'ConvertToManaged' method that takes the unmanaged type as a parameter and returns '{2}'</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}", pero no proporciona un método "ConvertToManaged" que toma el tipo no administrado como parámetro y devuelve "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedDescription">
        <source>A stateless value marshaller that supports marshalling from managed to unmanaged must provide a one-parameter 'ConvertToUnmanaged' method that takes the managed value as the parameter and returns a value of the 'unmanaged' type.</source>
        <target state="translated">Un serializador de valores sin estado que admita la serialización de administrado a no administrado debe proporcionar un método "ConvertToUnmanaged" de un parámetro que tome el valor administrado como parámetro y devuelva un valor del tipo "no administrado".</target>
        <note />
      </trans-unit>
      <trans-unit id="StatelessValueInRequiresConvertToUnmanagedMessage">
        <source>The type '{0}' specifies that it supports the '{1}' marshal mode for '{2}' but does not provide a one-parameter 'ConvertToUnmanaged' method that takes a '{2}' as a parameter and returns a value of an 'unmanaged' type</source>
        <target state="translated">El tipo "{0}" especifica que admite el modo de serialización "{1}" para "{2}" pero no proporciona un método "ConvertToUnmanaged" de un solo parámetro que toma un "{2}" como parámetro y devuelve un valor de un tipo "no administrado".</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchDescription">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same.</source>
        <target state="translated">El tipo de valor devuelto de "ConvertToUnmanaged" y el tipo de parámetro de "ConvertToManaged" deben coincidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="ToUnmanagedFromManagedTypesMustMatchMessage">
        <source>The return type of 'ConvertToUnmanaged' and the parameter type of 'ConvertToManaged' must be the same</source>
        <target state="translated">El tipo de valor devuelto de "ConvertToUnmanaged" y el tipo de parámetro de "ConvertToManaged" deben coincidir</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedDescription">
        <source>The unmanaged type for a custom marshaller must be a C# unmanaged type.</source>
        <target state="translated">El tipo no administrado de un serializador personalizado debe ser un tipo no administrado de C#.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeUnmanagedMessage">
        <source>The return type of '{0}' must be unmanaged</source>
        <target state="translated">El tipo de valor devuelto de "{0}" debe ser no administrado</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerDescription">
        <source>'void*' must be castable to the type so the pinned result of the static 'GetPinnableReference' method can be passed to the native context after being pinned.</source>
        <target state="translated">"void*" debe poder convertirse al tipo para que el resultado anclado del método "GetPinnableReference" estático se pueda pasar al contexto nativo después de anclarse.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustHaveExplicitCastFromVoidPointerMessage">
        <source>'void*' must be castable to the type '{0}' because the managed type '{1}' has a static 'GetPinnableReference' method</source>
        <target state="translated">"void*" debe poder convertirse al tipo "{0}" porque el tipo administrado "{1}" tiene un método "GetPinnableReference" estático</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeDescription">
        <source>An entry-point type for marshalling a given type must have a 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type.</source>
        <target state="translated">Un tipo de punto de entrada para serializar un tipo determinado debe tener un "System.Runtime.InteropServices.CustomMarshallerAttribute" que especifique este tipo como el tipo administrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntryPointTypeMustHaveCustomMarshallerAttributeWithMatchingManagedTypeMessage">
        <source>The entry-point marshaller type '{0}' for the type '{1}' must be a type with at least one 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type</source>
        <target state="translated">El tipo de serializador de punto de entrada "{0}" para el tipo "{1}" debe ser un tipo con al menos un "System.Runtime.InteropServices.CustomMarshallerAttribute" que especifique este tipo como el tipo administrado</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedDescription">
        <source>A 'Value' or 'LinearCollection'-kind native type that supports marshalling in the 'Out' direction must provide a 'ToManaged' method that returns the managed type.</source>
        <target state="translated">Un tipo nativo de variante “Value” o “LinearCollection” que admita serialización en la dirección “Out” debe proporcionar un método “ToManaged” que devuelva el tipo administrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutRequiresToManagedMessage">
        <source>The type '{0}' specifies it supports marshalling in the 'Out' direction, but it does not provide a 'ToManaged' method that returns the managed type</source>
        <target state="translated">El tipo “{0}” especifica que admite la serialización en la dirección “Out”, pero no proporciona un método “ToManaged” que devuelva el tipo administrado</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchDescription">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same.</source>
        <target state="translated">El tipo de valor devuelto de "ToUnmanaged" y el tipo de parámetro de "FromUnmanaged" deben coincidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="ToFromUnmanagedTypesMustMatchMessage">
        <source>The return type of 'ToUnmanaged' and the parameter type of 'FromUnmanaged' must be the same</source>
        <target state="translated">El tipo de valor devuelto de "ToUnmanaged" y el tipo de parámetro de "FromUnmanaged" deben ser el mismo</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedDescription">
        <source>For types that are not supported by source-generated P/Invokes, the resulting P/Invoke will rely on the underlying runtime to marshal the specified type.</source>
        <target state="translated">Para los tipos que no son compatibles con P/Invokes de un generador de código fuente, el P/Invoke resultante se basará en el entorno de ejecución subyacente para serializar las referencias del tipo especificado.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameter">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">El tipo “{0}” no es compatible con P/Invokes de un generador de código fuente. El código fuente generado no controlará la serialización del parámetro “{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageParameterWithDetails">
        <source>{0} The generated source will not handle marshalling of parameter '{1}'.</source>
        <target state="translated">{0} El origen generado no controlará la serialización del parámetro “{1}”.</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the parameter</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturn">
        <source>The type '{0}' is not supported by source-generated P/Invokes. The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">El tipo “{0}” no es compatible con P/Invokes de un generador de código fuente. El código fuente generado no controlará la serialización del valor devuelto del método “{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSupportedMessageReturnWithDetails">
        <source>{0} The generated source will not handle marshalling of the return value of method '{1}'.</source>
        <target state="translated">{0} El código fuente generado no controlará la serialización del valor devuelto del método “{1}”.</target>
        <note>{0} is a message containing additional details about what is not supported
{1} is the name of the method</note>
      </trans-unit>
      <trans-unit id="TypeNotSupportedTitle">
        <source>Specified type is not supported by source-generated P/Invokes</source>
        <target state="translated">El tipo especificado no está admitido por P/Invokes de un generador de código fuente</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorDescription">
        <source>A 'Value'-kind native type that supports the 'CallerAllocatedBuffer' feature must provide a two-parameter constructor taking the managed type and a 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">Un tipo nativo de tipo \"Value\" que admita la característica \"CallerAllocatedBuffer\" debe proporcionar un constructor de dos parámetros que tome el tipo administrado y un \"Span\" de un tipo \"no administrado\" como parámetros</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInCallerAllocatedBufferRequiresSpanConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling with the 'CallerAllocatedBuffer' feature for '{1}' but does not provide a two-parameter constructor that takes a '{1}' and 'Span' of an 'unmanaged' type as parameters</source>
        <target state="translated">El tipo “{0}” especifica que admite serializar “In” con la característica “CallerAllocatedBuffer” para “{1}” pero no provee un constructor de dos parámetro que tome un “{1}” y un “Span” de un tipo “no administrado” como parámetros</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorDescription">
        <source>A 'Value'-kind native type must provide a one-parameter constructor taking the managed type as a parameter</source>
        <target state="translated">Un tipo nativo de variante “Value” debe proporcionar un constructor de un solo parámetro tomando el tipo administrado como parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueInRequiresOneParameterConstructorMessage">
        <source>The type '{0}' specifies that it supports 'In' marshalling of '{1}' but does not provide a one-parameter constructor that takes a '{1}' as a parameter</source>
        <target state="translated">El tipo “{0}” especifica que admite la serialización “In” de “{1}” pero no proporciona un constructor de un solo parámetro que tome un “{1}” como parámetro</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>