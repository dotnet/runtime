<Project>
  <!-- not really meant to be used w/o WasmApp.targets -->

  <UsingTask TaskName="Microsoft.WebAssembly.Build.Tasks.ManagedToNativeGenerator" AssemblyFile="$(WasmAppBuilderTasksAssemblyPath)" />
  <UsingTask TaskName="Microsoft.WebAssembly.Build.Tasks.EmccCompile" AssemblyFile="$(WasmAppBuilderTasksAssemblyPath)" />
  <UsingTask TaskName="MonoTargetsTasks.MarshalingPInvokeScanner" AssemblyFile="$(MonoTargetsTasksAssemblyPath)" />

  <PropertyGroup>
    <_WasmBuildNativeCoreDependsOn>
      _ScanAssembliesDecideLightweightMarshaler;
      _WasmAotCompileApp;
      _WasmStripAOTAssemblies;
      _PrepareForWasmBuildNative;
      _GenerateDriverGenC;
      _GenerateManagedToNative;
      _WasmCompileNativeFiles;
      _WasmLinkDotNet;
      _CompleteWasmBuildNative
    </_WasmBuildNativeCoreDependsOn>

    <_BeforeWasmBuildAppDependsOn>
      $(_BeforeWasmBuildAppDependsOn);
      _SetupEmscripten;
      _SetWasmBuildNativeDefaults;
      _ReadEmccProps
    </_BeforeWasmBuildAppDependsOn>

    <_EmccDefaultFlags Condition="'$(WasmEnableSIMD)' == 'true'">-msimd128</_EmccDefaultFlags>
    <_ExeExt Condition="$([MSBuild]::IsOSPlatform('WINDOWS'))">.exe</_ExeExt>
    <WasmUseEMSDK_PATH Condition="'$(WasmUseEMSDK_PATH)' == '' and '$(EMSDK_PATH)' != '' and Exists('$(MSBuildThisFileDirectory)WasmApp.InTree.targets')">true</WasmUseEMSDK_PATH>
    <!-- compare versions only when emsdk is not from the workload -->
    <_WasmStrictVersionMatch Condition="'$(WasmUseEMSDK_PATH)' == 'true'">true</_WasmStrictVersionMatch>
  </PropertyGroup>

  <ItemGroup>
    <UpToDateCheckInput Include="@(NativeFileReference)" />
  </ItemGroup>

  <ItemGroup Condition="'$(Configuration)' == 'Debug' and '@(_MonoComponent->Count())' == 0">
    <_MonoComponent Include="hot_reload;debugger" />
  </ItemGroup>

  <Import Project="$(MSBuildThisFileDirectory)EmSdkRepo.Defaults.props" Condition="'$(WasmUseEMSDK_PATH)' == 'true'" />

  <Target Name="_SetupEmscripten">
    <PropertyGroup>
      <_EMSDKMissingPaths Condition="'$(_EMSDKMissingPaths)' == '' and ('$(EmscriptenSdkToolsPath)' == '' or !Exists('$(EmscriptenSdkToolsPath)'))">%24(EmscriptenSdkToolsPath)=$(EmscriptenSdkToolsPath) </_EMSDKMissingPaths>
      <_EMSDKMissingPaths Condition="'$(_EMSDKMissingPaths)' == '' and ('$(EmscriptenNodeToolsPath)' == '' or !Exists('$(EmscriptenNodeToolsPath)'))">%24(EmscriptenNodeToolsPath)=$(EmscriptenNodeToolsPath) </_EMSDKMissingPaths>
      <_EMSDKMissingPaths Condition="'$(_EMSDKMissingPaths)' == '' and ('$(EmscriptenUpstreamBinPath)' == '' or !Exists('$(EmscriptenUpstreamBinPath)'))">%24(EmscriptenUpstreamBinPath)=$(EmscriptenUpstreamBinPath) </_EMSDKMissingPaths>
    </PropertyGroup>

    <PropertyGroup>
      <_EMSDKMissingErrorMessage Condition="'$(EMSDK_PATH)' == '' and '$(EmscriptenSdkToolsPath)' == ''">Could not find emscripten sdk. Either set %24(EMSDK_PATH), or use workloads to get the sdk.</_EMSDKMissingErrorMessage>

      <_EMSDKMissingErrorMessage Condition="'$(_EMSDKMissingErrorMessage)' == '' and '$(_UsingEMSDK_PATH)' != 'true' and '$(_EMSDKMissingPaths)' != ''">Emscripten from the workload is missing some paths: $(_EMSDKMissingPaths).</_EMSDKMissingErrorMessage>
      <_EMSDKMissingErrorMessage Condition="'$(_EMSDKMissingErrorMessage)' == '' and '$(_UsingEMSDK_PATH)' == 'true' and !Exists($(EMSDK_PATH))">Could not find Emscripten sdk at %24(EMSDK_PATH)=$(EMSDK_PATH) .</_EMSDKMissingErrorMessage>
      <_EMSDKMissingErrorMessage Condition="'$(_EMSDKMissingErrorMessage)' == '' and '$(_UsingEMSDK_PATH)' == 'true' and '$(_EMSDKMissingPaths)' != ''">Specified Emscripten sdk at %24(EMSDK_PATH)=$(EMSDK_PATH) is missing some paths: $(_EMSDKMissingPaths).</_EMSDKMissingErrorMessage>

      <_IsEMSDKMissing Condition="'$(_EMSDKMissingErrorMessage)' != ''">true</_IsEMSDKMissing>
    </PropertyGroup>

    <PropertyGroup>
      <EmscriptenSdkToolsPath    Condition="'$(EmscriptenSdkToolsPath)' != ''"   >$([MSBuild]::NormalizeDirectory($(EmscriptenSdkToolsPath)))</EmscriptenSdkToolsPath>
      <EmscriptenNodeToolsPath   Condition="'$(EmscriptenNodeToolsPath)' != ''"  >$([MSBuild]::NormalizeDirectory($(EmscriptenNodeToolsPath)))</EmscriptenNodeToolsPath>
      <EmscriptenUpstreamBinPath Condition="'$(EmscriptenUpstreamBinPath)' != ''">$([MSBuild]::NormalizeDirectory($(EmscriptenUpstreamBinPath)))</EmscriptenUpstreamBinPath>
    </PropertyGroup>

    <!-- Environment variables required for running emsdk commands like `emcc` -->
    <ItemGroup Condition="'$(EmscriptenSdkToolsPath)' != ''">
      <EmscriptenEnvVars Include="DOTNET_EMSCRIPTEN_LLVM_ROOT=$(EmscriptenSdkToolsPath)bin" />
      <EmscriptenEnvVars Include="DOTNET_EMSCRIPTEN_BINARYEN_ROOT=$(EmscriptenSdkToolsPath)" />
      <EmscriptenEnvVars Include="DOTNET_EMSCRIPTEN_NODE_JS=$([MSBuild]::NormalizePath($(EmscriptenNodeToolsPath), 'bin', 'node$(_ExeExt)'))" />
    </ItemGroup>

    <ItemGroup>
      <_EmscriptenPrependPATHTrimmed Include="$([MSBuild]::ValueOrDefault('%(EmscriptenPrependPATH.Identity)\', '').TrimEnd('\/'))" />
      <EmscriptenPrependPATH Remove="@(EmscriptenPrependPATH)" />
      <EmscriptenPrependPATH Include="@(_EmscriptenPrependPATHTrimmed)" />
    </ItemGroup>

    <PropertyGroup>
      <!-- semicolon is a msbuild property separator. It is also the path separator on windows.
           So, we need to escape it here, so the paths don't get split up when converting
           to string[] for passing to Exec task -->
      <_PathSeparator Condition="'$(OS)' == 'Windows_NT'">%3B</_PathSeparator>
      <_PathSeparator Condition="'$(OS)' != 'Windows_NT'">:</_PathSeparator>

      <_EmscriptenPrependPATHProperty>@(EmscriptenPrependPATH -> '%(Identity)', '$(_PathSeparator)')</_EmscriptenPrependPATHProperty>
    </PropertyGroup>

    <ItemGroup>
      <EmscriptenEnvVars Include="PATH=$(_EmscriptenPrependPATHProperty)$(_PathSeparator)$([MSBuild]::Escape($(PATH)))" />

      <!--
        Python defaults to the system charset, and thus expects the files it's reading to
        match that. But that might not always be true. Eg. system charset=gbk, failing to read
        utf-8 files

        See https://github.com/dotnet/runtime/issues/53367 for the motivating issue
      -->
      <EmscriptenEnvVars Include="PYTHONUTF8=1" />
      <EmscriptenEnvVars Include="EM_WORKAROUND_PYTHON_BUG_34780=1" />
    </ItemGroup>
  </Target>

  <Target Name="_SetWasmBuildNativeDefaults">
    <!-- if already set, maybe by a user projects, then a missing emsdk is an error -->
    <Error Condition="'$(WasmBuildNative)' == 'true' and '$(_IsEMSDKMissing)' == 'true'"
           Text="$(_EMSDKMissingErrorMessage) Emscripten SDK is required for building native files." />

    <Error Condition="'$(RunAOTCompilation)' == 'true' and '$(_IsEMSDKMissing)' == 'true'"
           Text="$(_EMSDKMissingErrorMessage) Emscripten SDK is required for AOT'ing assemblies." />

    <ItemGroup>
      <_BoolPropertiesThatTriggerRelinking Include="WasmEnableLegacyJsInterop" DefaultValueInRuntimePack="true" />
      <_BoolPropertiesThatTriggerRelinking Include="WasmEnableSIMD" DefaultValueInRuntimePack="true" />
      <_BoolPropertiesThatTriggerRelinking Include="WasmEnableExceptionHandling" DefaultValueInRuntimePack="true" />
      <_BoolPropertiesThatTriggerRelinking Include="InvariantTimezone" DefaultValueInRuntimePack="false" />
      <_BoolPropertiesThatTriggerRelinking Include="InvariantGlobalization" DefaultValueInRuntimePack="false" />
      <_BoolPropertiesThatTriggerRelinking Include="WasmNativeStrip" DefaultValueInRuntimePack="true" />
      <!--<_BoolPropertiesThatTriggerRelinking Include="WasmNativeDebugSymbols" DefaultValueInRuntimePack="true" />-->
    </ItemGroup>

    <PropertyGroup>
      <WasmBuildNative Condition="'$(WasmBuildNative)' == '' and
                          '$(%(_BoolPropertiesThatTriggerRelinking.Identity))' != '' and
                          '$(%(_BoolPropertiesThatTriggerRelinking.Identity))' != '%(_BoolPropertiesThatTriggerRelinking.DefaultValueInRuntimePack)'">true</WasmBuildNative>
    </PropertyGroup>

    <!-- When Building -->
    <PropertyGroup Condition="'$(WasmBuildingForNestedPublish)' != 'true'">
      <!-- build AOT, only if explicitly requested -->
      <WasmBuildNative Condition="'$(RunAOTCompilation)' == 'true' and '$(RunAOTCompilationAfterBuild)' == 'true'">true</WasmBuildNative>

      <WasmBuildNative Condition="'$(WasmBuildNative)' == '' and @(NativeFileReference->Count()) > 0" >true</WasmBuildNative>
    </PropertyGroup>

    <!-- When Publishing -->
    <PropertyGroup Condition="'$(WasmBuildingForNestedPublish)' == 'true'">
      <!-- AOT==true overrides WasmBuildNative -->
      <WasmBuildNative Condition="'$(RunAOTCompilation)' == 'true'">true</WasmBuildNative>
      <WasmBuildNative Condition="'$(WasmBuildNative)' == '' and @(NativeFileReference->Count()) > 0" >true</WasmBuildNative>

      <!-- not aot, not trimmed app, no reason to relink -->
      <WasmBuildNative Condition="'$(WasmBuildNative)' == '' and '$(PublishTrimmed)' != 'true'">false</WasmBuildNative>

      <!-- default to relinking in Release config -->
      <WasmBuildNative Condition="'$(WasmBuildNative)' == '' and '$(Configuration)' == 'Release'">true</WasmBuildNative>
    </PropertyGroup>

    <PropertyGroup>
      <WasmBuildNative Condition="'$(WasmBuildNative)' == ''">false</WasmBuildNative>
    </PropertyGroup>

    <!-- Default with nothing set: Build+relink+config=debug -->
    <PropertyGroup Condition="'$(WasmNativeDebugSymbols)' == '' and '$(WasmNativeStrip)' == '' and '$(WasmBuildingForNestedPublish)' != 'true' and '$(WasmBuildNative)' == 'true' and '$(Configuration)' == 'Debug'">
      <WasmNativeDebugSymbols>true</WasmNativeDebugSymbols>
      <WasmNativeStrip>false</WasmNativeStrip>
    </PropertyGroup>

    <PropertyGroup>
      <WasmNativeDebugSymbols Condition="'$(WasmNativeDebugSymbols)' == ''">true</WasmNativeDebugSymbols>
      <WasmNativeStrip Condition="'$(WasmNativeStrip)' == ''">true</WasmNativeStrip>
    </PropertyGroup>

    <!-- If we want to default to true, and sdk is missing, then just warn, and set it to false -->
    <Warning Condition="'$(WasmBuildNative)' == 'true' and '$(_IsEMSDKMissing)' == 'true'"
             Text="$(_EMSDKMissingErrorMessage) Emscripten SDK is required for building native files." />

    <PropertyGroup>
      <WasmBuildNative Condition="'$(WasmBuildNative)' == 'true' and '$(_IsEMSDKMissing)' == 'true'">false</WasmBuildNative>
    </PropertyGroup>
  </Target>

  <Target Name="_WasmBuildNativeCore" DependsOnTargets="$(_WasmBuildNativeCoreDependsOn)"  Condition="'$(WasmBuildNative)' == 'true'" />

  <Target Name="_PrepareForWasmBuildNative">
    <Error Condition="'$(_IsEMSDKMissing)' == 'true'"
           Text="$(_EMSDKMissingErrorMessage) Emscripten SDK is required for building native files." />

    <PropertyGroup>
      <_MonoAotCrossCompilerPath>@(MonoAotCrossCompiler->WithMetadataValue('RuntimeIdentifier','browser-wasm'))</_MonoAotCrossCompilerPath>
      <_EmccDefaultFlagsRsp>$([MSBuild]::NormalizePath($(_WasmRuntimePackSrcDir), 'emcc-default.rsp'))</_EmccDefaultFlagsRsp>
      <_EmccDefaultLinkFlagsRsp>$([MSBuild]::NormalizePath($(_WasmRuntimePackSrcDir), 'emcc-link.rsp'))</_EmccDefaultLinkFlagsRsp>
      <WasmLinkIcalls Condition="'$(WasmLinkIcalls)' == ''">$(WasmBuildNative)</WasmLinkIcalls>

      <_WasmICallTablePath>$(_WasmIntermediateOutputPath)icall-table.h</_WasmICallTablePath>
      <_WasmRuntimeICallTablePath>$(_WasmIntermediateOutputPath)runtime-icall-table.h</_WasmRuntimeICallTablePath>
      <_WasmPInvokeTablePath>$(_WasmIntermediateOutputPath)pinvoke-table.h</_WasmPInvokeTablePath>
      <_WasmInterpToNativeTablePath>$(_WasmIntermediateOutputPath)wasm_m2n_invoke.g.h</_WasmInterpToNativeTablePath>
      <_WasmM2NCachePath>$(_WasmIntermediateOutputPath)m2n_cache.txt</_WasmM2NCachePath>
      <_WasmPInvokeHPath>$(_WasmRuntimePackIncludeDir)wasm\pinvoke.h</_WasmPInvokeHPath>
      <_DriverGenCPath>$(_WasmIntermediateOutputPath)driver-gen.c</_DriverGenCPath>
      <DisableParallelAot Condition="'$(DisableParallelAot)' == ''">false</DisableParallelAot>
      <DisableParallelEmccCompile Condition="'$(DisableParallelEmccCompile)' == ''">$(DisableParallelAot)</DisableParallelEmccCompile>

      <_DriverGenCNeeded Condition="'$(_DriverGenCNeeded)' == '' and '$(_WasmShouldAOT)' == 'true'">true</_DriverGenCNeeded>

      <_WasmDevel Condition="'$(_WasmDevel)' == '' and '$(WasmBuildNative)' == 'true' and '$(Configuration)' == 'Debug' and '$(WasmBuildingForNestedPublish)' != 'true'">true</_WasmDevel>

      <_EmccOptimizationFlagDefault Condition="'$(_WasmDevel)' == 'true'">-O0</_EmccOptimizationFlagDefault>
      <_EmccOptimizationFlagDefault Condition="'$(_EmccOptimizationFlagDefault)' == '' and '$(Configuration)' == 'Debug' and '$(WasmBuildingForNestedPublish)' != 'true'">-O1</_EmccOptimizationFlagDefault>
      <_EmccOptimizationFlagDefault Condition="'$(_EmccOptimizationFlagDefault)' == ''">-Oz</_EmccOptimizationFlagDefault>

      <EmccCompileOptimizationFlag Condition="'$(EmccCompileOptimizationFlag)' == ''">$(_EmccOptimizationFlagDefault)</EmccCompileOptimizationFlag>
      <EmccLinkOptimizationFlag    Condition="'$(EmccLinkOptimizationFlag)' == '' and '$(Configuration)' == 'Release'">-O2</EmccLinkOptimizationFlag>
      <EmccLinkOptimizationFlag    Condition="'$(EmccLinkOptimizationFlag)' == ''"   >$(EmccCompileOptimizationFlag)</EmccLinkOptimizationFlag>

      <_EmccCompileRsp>$(_WasmIntermediateOutputPath)emcc-compile.rsp</_EmccCompileRsp>
      <_EmccCompileOutputMessageImportance Condition="'$(EmccVerbose)' == 'true'">Normal</_EmccCompileOutputMessageImportance>
      <_EmccCompileOutputMessageImportance Condition="'$(EmccVerbose)' != 'true'">Low</_EmccCompileOutputMessageImportance>

      <_EmccCompileBitcodeRsp>$(_WasmIntermediateOutputPath)emcc-compile-bc.rsp</_EmccCompileBitcodeRsp>
      <_EmccLinkRsp>$(_WasmIntermediateOutputPath)emcc-link.rsp</_EmccLinkRsp>

      <EmccInitialHeapSize Condition="'$(EmccInitialHeapSize)' == ''">$(EmccTotalMemory)</EmccInitialHeapSize>
      <EmccStackSize Condition="'$(EmccStackSize)' == ''">5MB</EmccStackSize>
      <WasmAllowUndefinedSymbols Condition="'$(WasmAllowUndefinedSymbols)' == ''">false</WasmAllowUndefinedSymbols>
      <WasmEnableLegacyJsInterop Condition="'$(WasmEnableLegacyJsInterop)' == ''">true</WasmEnableLegacyJsInterop>
    </PropertyGroup>

    <ItemGroup>
      <_WasmLinkDependencies Remove="@(_WasmLinkDependencies)" />

      <_EmccCommonFlags Include="$(_DefaultEmccFlags)" />
      <_EmccCommonFlags Include="$(EmccFlags)" />
      <_EmccCommonFlags Include="-g"                                       Condition="'$(WasmNativeStrip)' == 'false'" />
      <_EmccCommonFlags Include="-v"                                       Condition="'$(EmccVerbose)' != 'false'" />
      <_EmccCommonFlags Include="-s DISABLE_EXCEPTION_CATCHING=0"          Condition="'$(WasmEnableExceptionHandling)' == 'false'" />
      <_EmccCommonFlags Include="-fwasm-exceptions"                        Condition="'$(WasmEnableExceptionHandling)' == 'true'" />
      <_EmccCommonFlags Include="-s MAXIMUM_MEMORY=$(EmccMaximumHeapSize)" Condition="'$(EmccMaximumHeapSize)' != ''" />

      <_EmccIncludePaths Include="$(_WasmIntermediateOutputPath.TrimEnd('\/'))" />
      <_EmccIncludePaths Include="$(_WasmRuntimePackIncludeDir)mono-2.0" />
      <_EmccIncludePaths Include="$(_WasmRuntimePackIncludeDir)wasm" />

      <!-- Adding optimization flag at the top, so it gets precedence -->
      <_EmccCFlags Include="$(EmccCompileOptimizationFlag)" />
      <_EmccCFlags Include="@(_EmccCommonFlags)" />

      <_EmccCFlags Include="-DDISABLE_PERFTRACING_LISTEN_PORTS=1" />
      <_EmccCFlags Include="-DENABLE_AOT=1"                    Condition="'$(_WasmShouldAOT)' == 'true'" />
      <_EmccCFlags Include="-DDRIVER_GEN=1"                    Condition="'$(_WasmShouldAOT)' == 'true'" />
      <_EmccCFlags Include="-DINVARIANT_GLOBALIZATION=1"       Condition="'$(InvariantGlobalization)' == 'true'" />
      <_EmccCFlags Include="-DINVARIANT_TIMEZONE=1"            Condition="'$(InvariantTimezone)' == 'true'" />
      <_EmccCFlags Include="-DLINK_ICALLS=1"                   Condition="'$(WasmLinkIcalls)' == 'true'" />
      <_EmccCFlags Include="-DENABLE_AOT_PROFILER=1"           Condition="$(WasmProfilers.Contains('aot'))" />
      <_EmccCFlags Include="-DENABLE_BROWSER_PROFILER=1"       Condition="$(WasmProfilers.Contains('browser'))" />
      <_EmccCFlags Include="-DDISABLE_LEGACY_JS_INTEROP=1"     Condition="'$(WasmEnableLegacyJsInterop)' == 'false'" />

      <_EmccCFlags Include="-DGEN_PINVOKE=1" />
      <_EmccCFlags Include="-emit-llvm" />

      <_EmccCFlags Include="&quot;-I%(_EmccIncludePaths.Identity)&quot;" />
      <_EmccCFlags Include="-g"                                Condition="'$(WasmNativeDebugSymbols)' == 'true'" />

      <!-- Adding optimization flag at the top, so it gets precedence -->
      <_EmccLDFlags Include="$(EmccLinkOptimizationFlag)" />
      <_EmccLDFlags Include="@(_EmccCommonFlags)" />
      <_EmccLDFlags Include="-s EXPORT_ES6=1" />

      <_DriverCDependencies Include="$(_WasmPInvokeHPath);$(_WasmICallTablePath)" />
      <_DriverCDependencies Include="$(_DriverGenCPath)" Condition="'$(_DriverGenCNeeded)' == 'true'" />

      <_WasmRuntimePackSrcFile Include="$(_WasmRuntimePackSrcDir)pinvoke.c"
                               Dependencies="$(_WasmPInvokeHPath);$(_WasmPInvokeTablePath)" />
      <_WasmRuntimePackSrcFile Include="$(_WasmRuntimePackSrcDir)driver.c"
                               Dependencies="@(_DriverCDependencies)" />
      <_WasmRuntimePackSrcFile Include="$(_WasmRuntimePackSrcDir)corebindings.c" />

      <_WasmRuntimePackSrcFile ObjectFile="$(_WasmIntermediateOutputPath)%(FileName).o" />

      <!-- See src\mono\wasm\runtime\modularize-dotnet.md -->
      <JSFileType Include="extpre.js"  Kind="extern-pre-js" />
      <JSFileType Include="iffe.js"    Kind="extern-pre-js" />
      <JSFileType Include="pre.js"     Kind="pre-js" />
      <JSFileType Include="lib.js"     Kind="js-library" />
      <JSFileType Include="post.js"    Kind="post-js" />
      <JSFileType Include="extpost.js" Kind="extern-post-js" />

      <_WasmExtraJSFile Include="$(_WasmRuntimePackSrcDir)\*.%(JSFileType.Identity)"     Kind="%(JSFileType.Kind)" />
      <_WasmExtraJSFile Include="$(_WasmRuntimePackSrcDir)\es6\*.%(JSFileType.Identity)" Kind="%(JSFileType.Kind)" />

      <_WasmNativeFileForLinking Include="@(NativeFileReference)" />

      <EmscriptenEnvVars Include="EMSDK_PYTHON=$(EmscriptenPythonToolsPath)python.exe" Condition="'$(OS)' == 'Windows_NT'" />
      <EmscriptenEnvVars Include="PYTHONPATH=$(EmscriptenPythonToolsPath)" Condition="'$(OS)' == 'Windows_NT'" />
      <EmscriptenEnvVars Include="PYTHONHOME=" Condition="'$(OS)' == 'Windows_NT'" />
      <EmscriptenEnvVars Include="EM_CACHE=$(WasmCachePath)" Condition="'$(WasmCachePath)' != ''" />
      <EmscriptenEnvVars Include="EM_FROZEN_CACHE=True" />
      <EmscriptenEnvVars Include="DISABLE_LEGACY_JS_INTEROP=1" Condition="'$(WasmEnableLegacyJsInterop)' == 'false'" />
      <EmscriptenEnvVars Include="DISABLE_LEGACY_JS_INTEROP=0" Condition="'$(WasmEnableLegacyJsInterop)' != 'false'" />
      <EmscriptenEnvVars Include="WASM_ENABLE_SIMD=1" Condition="'$(WasmEnableSIMD)' != 'false'" />
      <EmscriptenEnvVars Include="WASM_ENABLE_SIMD=0" Condition="'$(WasmEnableSIMD)' == 'false'" />
      <EmscriptenEnvVars Include="WASM_ENABLE_EH=1" Condition="'$(WasmEnableExceptionHandling)' != 'false'" />
      <EmscriptenEnvVars Include="WASM_ENABLE_EH=0" Condition="'$(WasmEnableExceptionHandling)' == 'false'" />
      <EmscriptenEnvVars Include="ENABLE_AOT_PROFILER=$([System.Convert]::ToInt32($(WasmProfilers.Contains('aot'))))" />
      <EmscriptenEnvVars Include="ENABLE_BROWSER_PROFILER=$([System.Convert]::ToInt32($(WasmProfilers.Contains('browser'))))" />
    </ItemGroup>

    <ItemGroup Condition="'$(WasmAllowUndefinedSymbols)' == 'true'">
      <_EmccLDSFlags Include="-Wl,--allow-undefined" />
      <_EmccLDSFlags Include="-s ERROR_ON_UNDEFINED_SYMBOLS=0" />
    </ItemGroup>
    <ItemGroup Condition="'$(WasmAllowUndefinedSymbols)' != 'true'">
      <_EmccLDSFlags Include="-s LLD_REPORT_UNDEFINED" />
      <_EmccLDSFlags Include="-s ERROR_ON_UNDEFINED_SYMBOLS=1" />
    </ItemGroup>

    <Error Text="Could not find NativeFileReference %(NativeFileReference.Identity)" Condition="'%(NativeFileReference.Identity)' != '' and !Exists(%(NativeFileReference.Identity))" />
  </Target>

  <Target Name="_GenerateManagedToNative">
    <ItemGroup>
      <_WasmPInvokeModules Include="%(_WasmNativeFileForLinking.FileName)" Condition="'%(_WasmNativeFileForLinking.ScanForPInvokes)' != 'false'" />

      <_WasmPInvokeModules Include="libSystem.Native" />
      <_WasmPInvokeModules Include="libSystem.IO.Compression.Native" />
      <_WasmPInvokeModules Include="libSystem.Globalization.Native" />
    </ItemGroup>

    <PropertyGroup>
      <_HasMscorlib Condition="'%(_WasmAssembliesInternal.FileName)%(_WasmAssembliesInternal.Extension)' == 'mscorlib.dll'">true</_HasMscorlib>
      <_MscorlibPath Condition="'$(_HasMscorlib)' != 'true'">$([System.IO.Path]::Combine($(MicrosoftNetCoreAppRuntimePackRidLibTfmDir), 'mscorlib.dll'))</_MscorlibPath>
    </PropertyGroup>

    <Error Condition="'$(_HasMscorlib)' != 'true' and !Exists($(_MscorlibPath))" Text="Could not find 'mscorlib.dll' in the runtime pack at $(_MscorlibPath)" />
    <Error Condition="'$(_MonoAotCrossCompilerPath)' == '' or !Exists('$(_MonoAotCrossCompilerPath)')"
           Text="Could not find AOT cross compiler at %24(_MonoAotCrossCompilerPath)=$(_MonoAotCrossCompilerPath)" />

    <Exec Command='"$(_MonoAotCrossCompilerPath)" --print-icall-table > "$(_WasmRuntimeICallTablePath)"' Condition="!Exists($(_WasmRuntimeICallTablePath))" />
    <ItemGroup>
      <FileWrites Include="$(_WasmRuntimeICallTablePath)" />
    </ItemGroup>

    <MakeDir Directories="$(_WasmIntermediateOutputPath)" Condition="!Exists('$(_WasmIntermediateOutputPath)')"  />

    <ManagedToNativeGenerator
      Assemblies="@(_WasmAssembliesInternal);$(_MscorlibPath)"
      RuntimeIcallTableFile="$(_WasmRuntimeICallTablePath)"
      IcallOutputPath="$(_WasmICallTablePath)"
      PInvokeModules="@(_WasmPInvokeModules)"
      PInvokeOutputPath="$(_WasmPInvokeTablePath)"
      InterpToNativeOutputPath="$(_WasmInterpToNativeTablePath)"
      CacheFilePath="$(_WasmM2NCachePath)">
      <Output TaskParameter="FileWrites" ItemName="FileWrites" />
    </ManagedToNativeGenerator>
  </Target>

  <Target Name="_WasmSelectRuntimeComponentsForLinking" Condition="'$(WasmNativeWorkload)' == 'true'" DependsOnTargets="_MonoSelectRuntimeComponents" />

  <Target Name="_WasmCompileNativeFiles" DependsOnTargets="_CheckEmccIsExpectedVersion">
    <ItemGroup>
      <_EmccCFlags Include="$(EmccExtraCFlags)" />
    </ItemGroup>

    <WriteLinesToFile Lines="@(_EmccCFlags)" File="$(_EmccCompileRsp)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(_EmccCompileRsp)" />
    </ItemGroup>

    <ItemGroup>
      <_WasmSourceFileToCompile Remove="@(_WasmSourceFileToCompile)" />
      <_WasmSourceFileToCompile Include="@(_WasmRuntimePackSrcFile)" Dependencies="%(_WasmRuntimePackSrcFile.Dependencies);$(_EmccDefaultFlagsRsp);$(_EmccCompileRsp)" />
    </ItemGroup>
    <EmccCompile
          SourceFiles="@(_WasmSourceFileToCompile)"
          Arguments='"@$(_EmccDefaultFlagsRsp)" $(_EmccDefaultFlags) "@$(_EmccCompileRsp)"'
          EnvironmentVariables="@(EmscriptenEnvVars)"
          DisableParallelCompile="$(DisableParallelEmccCompile)"
          MessageToIndicateCompiling="Compiling native assets with emcc with $(EmccCompileOptimizationFlag). This may take a while ..."
          OutputMessageImportance="$(_EmccCompileOutputMessageImportance)">
      <Output TaskParameter="OutputFiles" ItemName="FileWrites" />
    </EmccCompile>
  </Target>

  <Target Name="_WasmCompileAssemblyBitCodeFilesForAOT"
          Inputs="@(_BitcodeFile);$(_EmccDefaultFlagsRsp);$(_EmccCompileBitcodeRsp)"
          Outputs="@(_BitcodeFile->'%(ObjectFile)')"
          Condition="'$(_WasmShouldAOT)' == 'true' and @(_BitcodeFile->Count()) > 0"
          DependsOnTargets="_CheckEmccIsExpectedVersion;_WasmWriteRspForCompilingBitcode"
          Returns="@(FileWrites)">

    <ItemGroup>
      <_BitCodeFile Dependencies="%(_BitCodeFile.Dependencies);$(_EmccDefaultFlagsRsp);$(_EmccCompileBitcodeRsp)" />
    </ItemGroup>

    <EmccCompile
          SourceFiles="@(_BitCodeFile)"
          Arguments="&quot;@$(_EmccDefaultFlagsRsp)&quot; $(_EmccDefaultFlags) &quot;@$(_EmccCompileBitcodeRsp)&quot;"
          EnvironmentVariables="@(EmscriptenEnvVars)"
          DisableParallelCompile="$(DisableParallelEmccCompile)"
          MessageToIndicateCompiling="Compiling assembly bitcode files with $(EmccLinkOptimizationFlag) ..."
          OutputMessageImportance="$(_EmccCompileOutputMessageImportance)">
      <Output TaskParameter="OutputFiles" ItemName="FileWrites" />
    </EmccCompile>
  </Target>

  <Target Name="_WasmWriteRspForCompilingBitcode">
    <ItemGroup>
      <_BitcodeLDFlags Include="@(_EmccLDFlags)" />
      <_BitcodeLDFlags Include="$(EmccExtraBitcodeLDFlags)" />
    </ItemGroup>
    <WriteLinesToFile Lines="@(_BitcodeLDFlags)" File="$(_EmccCompileBitcodeRsp)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(_EmccCompileBitcodeRsp)" />
    </ItemGroup>
  </Target>

  <Target Name="_WasmCalculateInitialHeapSize"
      Condition="'$(EmccInitialHeapSize)' == ''"
      DependsOnTargets="_CheckEmccIsExpectedVersion">
    <ItemGroup>
      <_AOTObjectFile Include="%(_BitcodeFile.ObjectFile)" />
    </ItemGroup>

    <!-- for AOT builds we use llvm-size tool to collect size of the DATA segment in each object file -->
    <Exec Command="llvm-size$(_ExeExt) -d --format=sysv @(_AOTObjectFile, ' ')"
          Condition="'$(_WasmShouldAOT)' == 'true'"
          IgnoreStandardErrorWarningFormat="true"
          ConsoleToMsBuild="true"
          StandardOutputImportance="low" StandardErrorImportance="low"
          EnvironmentVariables="@(EmscriptenEnvVars)" >
      <Output TaskParameter="ConsoleOutput" ItemName="LlvmAotSizeOutput" />
    </Exec>
    <ItemGroup Condition="'$(_WasmShouldAOT)' == 'true'">
      <_AOTDataSegmentSize Condition="$([System.String]::Copy('%(LlvmAotSizeOutput.Identity)').StartsWith('DATA '))"
        Include="$([System.String]::Copy('%(LlvmAotSizeOutput.Identity)').Replace(&quot;DATA &quot;, &quot;&quot;).Replace(&quot; 0&quot;, &quot;&quot;).Trim())" />
    </ItemGroup>

    <WasmCalculateInitialHeapSize
        Assemblies="@(WasmAssembliesToBundle)"
        AOTDataSegmentSizes="@(_AOTDataSegmentSize)">
      <Output TaskParameter="InitialHeapSize" PropertyName="_WasmCalculatedInitialHeapSize" />
    </WasmCalculateInitialHeapSize>
    <PropertyGroup>
      <EmccInitialHeapSize Condition="'$(EmccInitialHeapSize)' == '' and '$(_WasmCalculatedInitialHeapSize)' != '' and $(_WasmCalculatedInitialHeapSize) > 16777216">$(_WasmCalculatedInitialHeapSize)</EmccInitialHeapSize>
      <EmccInitialHeapSize Condition="'$(EmccInitialHeapSize)' == ''">16777216</EmccInitialHeapSize>
    </PropertyGroup>
  </Target>

  <Target Name="_WasmWriteRspFilesForLinking" DependsOnTargets="_CheckEmccIsExpectedVersion;_WasmCalculateInitialHeapSize">
    <PropertyGroup>
      <_WasmEHLib Condition="'$(WasmEnableExceptionHandling)' == 'true'">libmono-wasm-eh-wasm.a</_WasmEHLib>
      <_WasmEHLib Condition="'$(WasmEnableExceptionHandling)' != 'true'">libmono-wasm-eh-js.a</_WasmEHLib>
      <_WasmEHLibToExclude Condition="'$(WasmEnableExceptionHandling)' == 'true'">libmono-wasm-eh-js.a</_WasmEHLibToExclude>
      <_WasmEHLibToExclude Condition="'$(WasmEnableExceptionHandling)' != 'true'">libmono-wasm-eh-wasm.a</_WasmEHLibToExclude>
      <_WasmSIMDLib Condition="'$(WasmEnableSIMD)' == 'true'">libmono-wasm-simd.a</_WasmSIMDLib>
      <_WasmSIMDLib Condition="'$(WasmEnableSIMD)' != 'true'">libmono-wasm-nosimd.a</_WasmSIMDLib>
      <_WasmSIMDLibToExclude Condition="'$(WasmEnableSIMD)' != 'true'">libmono-wasm-simd.a</_WasmSIMDLibToExclude>
      <_WasmSIMDLibToExclude Condition="'$(WasmEnableSIMD)' == 'true'">libmono-wasm-nosimd.a</_WasmSIMDLibToExclude>
      <_EmccExportedLibraryFunction>&quot;[@(EmccExportedLibraryFunction -> '%27%(Identity)%27', ',')]&quot;</_EmccExportedLibraryFunction>
      <_EmccExportedRuntimeMethods>&quot;[@(EmccExportedRuntimeMethod -> '%27%(Identity)%27', ',')]&quot;</_EmccExportedRuntimeMethods>
      <_EmccExportedFunctions>@(EmccExportedFunction -> '%(Identity)',',')</_EmccExportedFunctions>
    </PropertyGroup>
    <ItemGroup>
      <!-- order matters -->
      <!-- some flags will be duplicated on the commandline and in the .rsp file. The last wins. -->
      <_EmccLDSFlags Include="-s INITIAL_MEMORY=$(EmccInitialHeapSize)" />
      <_EmccLDSFlags Include="-s STACK_SIZE=$(EmccStackSize)" />
      <_EmccLDSFlags Include="-s WASM_BIGINT=1" />
      <_EmccLDSFlags Condition="'$(EmccEnvironment)' != ''" Include="-s ENVIRONMENT=&quot;$(EmccEnvironment)&quot;" />
      <_EmccLDSFlags Condition="'$(EmccEnableAssertions)' == 'true'" Include="-s ASSERTIONS=1" />

      <_WasmNativeFileForLinking Include="%(_BitcodeFile.ObjectFile)" />
      <_WasmNativeFileForLinking Include="%(_WasmSourceFileToCompile.ObjectFile)" />

      <_WasmNativeFileForLinking
          Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)*.a"
          Exclude="@(_MonoRuntimeComponentDontLink->'$(MicrosoftNetCoreAppRuntimePackRidNativeDir)%(Identity)')" />
      <_WasmNativeFileForLinking Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)$(_WasmEHLib)" />
      <_WasmNativeFileForLinking Condition="'$(_WasmSIMDLib)' != ''" Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)$(_WasmSIMDLib)" />
      <_WasmNativeFileForLinking Remove="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)$(_WasmEHLibToExclude)" />
      <_WasmNativeFileForLinking Remove="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)$(_WasmSIMDLibToExclude)" />

      <_WasmExtraJSFile Include="@(Content)" Condition="'%(Content.Extension)' == '.js'" />

      <_EmccLinkStepArgs Include="@(_EmccLDFlags)" />
      <_EmccLinkStepArgs Include="@(_EmccLDSFlags)" />
      <_EmccLinkStepArgs Include="--emit-symbol-map" Condition="'$(WasmEmitSymbolMap)' == 'true'" />

      <_EmccLinkStepArgs Include="--%(_WasmExtraJSFile.Kind) &quot;%(_WasmExtraJSFile.Identity)&quot;" Condition="'%(_WasmExtraJSFile.Kind)' != ''" />
      <_WasmLinkDependencies Include="@(_WasmExtraJSFile)" />

      <_EmccLinkStepArgs Include="&quot;%(_WasmNativeFileForLinking.Identity)&quot;" />
      <_WasmLinkDependencies Include="@(_WasmNativeFileForLinking)" />

      <_EmccLinkStepArgs Include="-o &quot;$(_WasmIntermediateOutputPath)dotnet.native.js&quot;" />
      <_WasmLinkDependencies Include="$(_EmccLinkRsp)" />

      <_EmccLinkStepArgs Include="-s DEFAULT_LIBRARY_FUNCS_TO_INCLUDE=$(_EmccExportedLibraryFunction)" Condition="'$(_EmccExportedLibraryFunction)' != ''" />
      <_EmccLinkStepArgs Include="-s EXPORTED_RUNTIME_METHODS=$(_EmccExportedRuntimeMethods)" />
      <_EmccLinkStepArgs Include="-s EXPORTED_FUNCTIONS=$(_EmccExportedFunctions)" />

      <_EmccLinkStepArgs Include="$(EmccExtraLDFlags)" />
    </ItemGroup>

    <WriteLinesToFile Lines="@(_EmccLinkStepArgs)" File="$(_EmccLinkRsp)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(_EmccLinkRsp)" />
    </ItemGroup>
  </Target>

  <Target Name="_WasmLinkDotNet"
          Inputs="@(_WasmLinkDependencies);$(_EmccDefaultFlagsRsp);$(_EmccDefaultLinkFlagsRsp);$(_EmccLinkRsp)"
          Outputs="$(_WasmIntermediateOutputPath)dotnet.native.js;$(_WasmIntermediateOutputPath)dotnet.native.wasm"
          DependsOnTargets="_CheckEmccIsExpectedVersion;_WasmSelectRuntimeComponentsForLinking;_WasmCompileAssemblyBitCodeFilesForAOT;_WasmWriteRspFilesForLinking"
          Returns="@(FileWrites)" >

    <Message Text="Linking for initial memory %24(EmccInitialHeapSize)=$(EmccInitialHeapSize) bytes. Set this msbuild property to change the value." Importance="High" />
    <Message Text="Linking with emcc with $(EmccLinkOptimizationFlag). This may take a while ..." Importance="High" />
    <Message Text="Running emcc with @(_EmccLinkStepArgs->'%(Identity)', ' ')" Importance="Low" />
    <Exec Command='emcc "@$(_EmccDefaultFlagsRsp)" $(_EmccDefaultFlags) "@$(_EmccDefaultLinkFlagsRsp)" "@$(_EmccLinkRsp)"' EnvironmentVariables="@(EmscriptenEnvVars)" ConsoleToMSBuild="true">
      <Output TaskParameter="ConsoleOutput" PropertyName="_EmccLinkStepConsoleOutput" />
      <Output TaskParameter="ExitCode" PropertyName="_EmccLinkStepExitCode" />
    </Exec>
    <ItemGroup>
      <FileWrites Include="$(_WasmIntermediateOutputPath)dotnet.native.wasm" />
      <FileWrites Include="$(_WasmIntermediateOutputPath)dotnet.native.js" />
      <FileWrites Include="$(_WasmIntermediateOutputPath)dotnet.native.js.symbols" Condition="'$(WasmEmitSymbolMap)' == 'true'" />
    </ItemGroup>

    <ItemGroup>
      <!-- WasmOptConfigurationFlags property is set by reading from emcc-props.json -->
      <WasmOptConfigurationFlags Condition="'$(WasmOptConfigurationFlags)' != ''" Include="$(WasmOptConfigurationFlags)" />
    </ItemGroup>

    <Message Text="Stripping symbols from dotnet.native.wasm ..." Importance="High" Condition="'$(WasmNativeStrip)' == 'true'" />
    <Exec Command="wasm-opt$(_ExeExt) --enable-simd --enable-exception-handling @(WasmOptConfigurationFlags, ' ') --strip-dwarf &quot;$(_WasmIntermediateOutputPath)dotnet.native.wasm&quot; -o &quot;$(_WasmIntermediateOutputPath)dotnet.native.wasm&quot;"
          Condition="'$(WasmNativeStrip)' == 'true'"
          IgnoreStandardErrorWarningFormat="true"
          EnvironmentVariables="@(EmscriptenEnvVars)" />

    <OnError ExecuteTargets="_OnError_WasmLinkDotNet_UndefinedSymbols"
             Condition="'$(WasmAllowUndefinedSymbols)' != 'true' and '$(_EmccLinkStepExitCode)' != '0' and $([System.Text.RegularExpressions.Regex]::IsMatch($(_EmccLinkStepConsoleOutput), 'wasm-ld *: *error *:.*undefined symbol:'))" />
  </Target>
  <Target Name="_OnError_WasmLinkDotNet_UndefinedSymbols">
    <Error Text="Use '-p:WasmAllowUndefinedSymbols=true' to allow undefined symbols" />
  </Target>

  <Target Name="_CompleteWasmBuildNative">
    <ItemGroup>
      <WasmNativeAsset Include="$(_WasmIntermediateOutputPath)dotnet.native.wasm" />
      <WasmNativeAsset Include="$(_WasmIntermediateOutputPath)dotnet.native.js" />
      <WasmNativeAsset Include="$(_WasmIntermediateOutputPath)dotnet.native.worker.js" Condition="Exists('$(_WasmIntermediateOutputPath)dotnet.native.worker.js')" />
      <WasmNativeAsset Include="$(_WasmIntermediateOutputPath)dotnet.native.js.symbols" Condition="'$(WasmEmitSymbolMap)' == 'true' and Exists('$(_WasmIntermediateOutputPath)dotnet.native.js.symbols')" />
      <_WasmAssembliesInternal Remove="$(_WasmDedupAssembly)"/>
    </ItemGroup>
  </Target>

  <Target Name="_GenerateDriverGenC" Condition="'$(_WasmShouldAOT)' != 'true'">
  </Target>

  <Target Name="_ReadEmccProps" Condition="'$(_IsEMSDKMissing)' != 'true'">
    <ReadEmccProps JsonFilePath="$(_WasmRuntimePackSrcDir)emcc-props.json">
      <Output TaskParameter="EmccProperties" ItemName="_EmccPropItems" />
      <Output TaskParameter="WasmOptConfigurationFlags" ItemName="_WasmOptConfigurationFlagsItems" />
      <Output TaskParameter="EmccDefaultExportedFunctions" ItemName="EmccExportedFunction" />
      <Output TaskParameter="EmccDefaultExportedRuntimeMethods" ItemName="EmccExportedRuntimeMethod" />
    </ReadEmccProps>

    <CreateProperty Value="%(_EmccPropItems.Value)">
      <Output TaskParameter="Value" PropertyName="%(_EmccPropItems.Identity)" />
    </CreateProperty>

    <CreateProperty Value="%(_WasmOptConfigurationFlagsItems.Value)">
      <Output TaskParameter="Value" PropertyName="%(_WasmOptConfigurationFlagsItems.Identity)" />
    </CreateProperty>
  </Target>

  <Target Name="_CheckEmccIsExpectedVersion" Condition="'$(_WasmStrictVersionMatch)' == 'true'">
    <Error Condition="'$(_IsEMSDKMissing)' == 'true'"
           Text="$(_EMSDKMissingErrorMessage) Emscripten SDK is required for building native files." />
    <Error Condition="'$(RuntimeEmccVersionRaw)' == ''"
           Text="%24(RuntimeEmccVersionRaw) is not set. '$(_EmccPropsPath)' should have set that."/>

    <PropertyGroup>
      <_EmccVersionCommand>emcc --version</_EmccVersionCommand>
    </PropertyGroup>

    <Exec Command="$(_EmccVersionCommand)" WorkingDirectory="$(_WasmIntermediateOutputPath)" EnvironmentVariables="@(EmscriptenEnvVars)" ConsoleToMsBuild="true" StandardOutputImportance="Low" IgnoreExitCode="true">
      <Output TaskParameter="ConsoleOutput" ItemName="_VersionLines" />
      <Output TaskParameter="ExitCode" PropertyName="_EmccVersionExitCode" />
    </Exec>

    <!-- If `emcc -version` failed, then run it again, so we can surface the output as *Errors*. This allows the errors to show up correctly,
         versus trying to use the output lines with the Error task -->
    <Exec Condition="$(_EmccVersionExitCode) != '0'"
          Command="$(_EmccVersionCommand)"
          WorkingDirectory="$(_WasmIntermediateOutputPath)"
          EnvironmentVariables="@(EmscriptenEnvVars)"
          CustomErrorRegularExpression=".*"
          />

    <!-- we want to get the first line from the output, which has the version.
         Rest of the lines are the license -->
    <ItemGroup>
      <_ReversedVersionLines Include="@(_VersionLines->Reverse())" />
    </ItemGroup>
    <PropertyGroup>
      <ActualEmccVersionRaw>%(_ReversedVersionLines.Identity)</ActualEmccVersionRaw>
      <_VersionMismatchMessage>Emscripten version mismatch. The runtime pack in $(MicrosoftNetCoreAppRuntimePackDir) expects '$(RuntimeEmccVersionRaw)', but emcc being used has version '$(ActualEmccVersionRaw)'. This might cause build failures.</_VersionMismatchMessage>
    </PropertyGroup>

    <Warning Condition="'$(RuntimeEmccVersionRaw)' != '$(ActualEmccVersionRaw)'" Text="$(_VersionMismatchMessage)" />
    <Error Condition="'$(RuntimeEmccVersionRaw)' != '$(ActualEmccVersionRaw)'" Text="$(_VersionMismatchMessage)" />
  </Target>

  <!--
      *******************************
      ************ AOT **************
      *******************************
  -->

  <Target Name="_WasmAotCompileApp" Condition="'$(_WasmShouldAOT)' == 'true'">
    <PropertyGroup>
      <!-- FIXME: do it once -->
      <_MonoAotCrossCompilerPath>@(MonoAotCrossCompiler->WithMetadataValue('RuntimeIdentifier','browser-wasm'))</_MonoAotCrossCompilerPath>
    </PropertyGroup>

    <Error Condition="'@(_WasmAssembliesInternal)' == ''" Text="Item _WasmAssembliesInternal is empty" />
    <Error Condition="'$(_IsEMSDKMissing)' == 'true'"
           Text="$(_EMSDKMissingErrorMessage) Emscripten SDK is required for AOT'ing assemblies." />
    <Error Condition="'$(_MonoAotCrossCompilerPath)' == '' or !Exists('$(_MonoAotCrossCompilerPath)')"
           Text="Could not find AOT cross compiler at %24(_MonoAotCrossCompilerPath)=$(_MonoAotCrossCompilerPath)" />

    <ItemGroup>
      <MonoAOTCompilerDefaultAotArguments Include="no-opt" />
      <MonoAOTCompilerDefaultAotArguments Include="static" />
      <MonoAOTCompilerDefaultAotArguments Include="direct-icalls" />
      <MonoAOTCompilerDefaultAotArguments Include="deterministic" />
      <MonoAOTCompilerDefaultAotArguments Include="mattr=simd" Condition="'$(WasmEnableSIMD)' == 'true'" />
      <MonoAOTCompilerDefaultProcessArguments Include="-v" Condition="'$(WasmAOTCompilerVerbose)' == 'true'" />
      <MonoAOTCompilerDefaultProcessArguments Include="--wasm-exceptions" Condition="'$(WasmEnableExceptionHandling)' == 'true'" />
      <MonoAOTCompilerDefaultProcessArguments Include="--wasm-gc-safepoints" Condition="'$(WasmEnableThreads)' == 'true'" />
      <AotProfilePath Include="$(WasmAotProfilePath)"/>
    </ItemGroup>
    <ItemGroup>
      <_AotInputAssemblies Include="@(_WasmAssembliesInternal)">
        <AotArguments>@(MonoAOTCompilerDefaultAotArguments, ';')</AotArguments>
        <ProcessArguments>@(MonoAOTCompilerDefaultProcessArguments, ';')</ProcessArguments>
      </_AotInputAssemblies>

      <_WasmAssembliesInternal Remove="@(_WasmAssembliesInternal)" />

      <_WasmAOTSearchPaths Include="$(MicrosoftNetCoreAppRuntimePackRidNativeDir)" />
      <_WasmAOTSearchPaths Include="$(MicrosoftNetCoreAppRuntimePackRidLibTfmDir)" />
    </ItemGroup>

    <ItemGroup>
      <!-- Skip known-huge assemblies specified in csproj -->
      <_AotInputAssemblies Condition="'%(Filename)' != '' and '@(_AotInputAssemblies->Metadata(`Filename`))' != '' and '@(_AOT_InternalForceInterpretAssemblies->Metadata(`Filename`))' != ''">
        <AOT_InternalForceToInterpret>true</AOT_InternalForceToInterpret>
      </_AotInputAssemblies>
    </ItemGroup>

    <PropertyGroup>
      <!--<AOTMode Condition="'$(AOTMode)' == '' and '$(AOTProfilePath)' != ''">LLVMOnlyInterp</AOTMode>-->
      <AOTMode Condition="'$(AOTMode)' == ''">LLVMOnlyInterp</AOTMode>
      <_AOTCompilerCacheFile>$(_WasmIntermediateOutputPath)aot_compiler_cache.json</_AOTCompilerCacheFile>
    </PropertyGroup>

    <Message Text="AOT'ing @(_AotInputAssemblies->Count()) assemblies" Importance="High" />

    <!-- Dedup -->
    <PropertyGroup Condition="'$(WasmDedup)' == 'true'">
      <_WasmDedupAssembly>$(_WasmIntermediateOutputPath)\aot-instances.dll</_WasmDedupAssembly>
    </PropertyGroup>
    <WriteLinesToFile Condition="'$(WasmDedup)' == 'true'" File="$(_WasmIntermediateOutputPath)/aot-instances.cs" Overwrite="true" Lines="" WriteOnlyWhenDifferent="true" />
    <Csc
      Condition="'$(WasmDedup)' == 'true'"
      Sources="$(_WasmIntermediateOutputPath)\aot-instances.cs"
      OutputAssembly="$(_WasmDedupAssembly)"
      TargetType="library"
      Deterministic="true"
      References="@(ReferencePath)"
      ToolExe="$(CscToolExe)"
      ToolPath="$(CscToolPath)" />
    <ItemGroup Condition="'$(WasmDedup)' == 'true'">
      <_AotInputAssemblies Include="$(_WasmDedupAssembly)">
        <AotArguments>@(MonoAOTCompilerDefaultAotArguments, ';')</AotArguments>
        <ProcessArguments>@(MonoAOTCompilerDefaultProcessArguments, ';')</ProcessArguments>
      </_AotInputAssemblies>
    </ItemGroup>

    <MonoAOTCompiler
      CompilerBinaryPath="$(_MonoAotCrossCompilerPath)"
      OutputDir="$(_WasmIntermediateOutputPath)"
      Mode="$(AOTMode)"
      OutputType="AsmOnly"
      Assemblies="@(_AotInputAssemblies)"
      AdditionalAssemblySearchPaths="@(_WasmAOTSearchPaths)"
      UseAotDataFile="false"
      AOTProfilePath="$(AOTProfilePath)"
      AotModulesTablePath="$(_DriverGenCPath)"
      UseLLVM="true"
      Profilers="$(WasmProfilers)"
      DisableParallelAot="$(DisableParallelAot)"
      DedupAssembly="$(_WasmDedupAssembly)"
      CacheFilePath="$(_AOTCompilerCacheFile)"
      LLVMDebug="dwarfdebug"
      LLVMPath="$(EmscriptenUpstreamBinPath)"
      CollectTrimmingEligibleMethods="$(WasmStripILAfterAOT)"
      TrimmingEligibleMethodsOutputDirectory="$(_WasmIntermediateOutputPath)tokens"
      IntermediateOutputPath="$(_WasmIntermediateOutputPath)"
      AotProfilePath="@(AotProfilePath)">

      <Output TaskParameter="CompiledAssemblies" ItemName="_WasmAssembliesInternal" />
      <Output TaskParameter="FileWrites" ItemName="FileWrites" />
    </MonoAOTCompiler>
    <ILStrip
        Condition=" '$(WasmStripILAfterAOT)' == 'true' "
        TrimIndividualMethods="true"
        Assemblies="@(_WasmAssembliesInternal)">
      <Output TaskParameter="TrimmedAssemblies" ItemName="_ILStripTrimmedAssemblies" />
    </ILStrip>
    <Move
        Condition=" '$(WasmStripILAfterAOT)' == 'true' "
        SourceFiles="@(_ILStripTrimmedAssemblies->'%(TrimmedAssemblyFileName)')"
        DestinationFiles="@(_ILStripTrimmedAssemblies)"
    />

    <ItemGroup>
      <_BitcodeFile Include="%(_WasmAssembliesInternal.LlvmBitcodeFile)" />
      <_BitcodeFile ObjectFile="$(_WasmIntermediateOutputPath)%(FileName).o" />

      <!-- Add the skipped assemblies -->
      <_WasmAssembliesInternal Include="@(_AotInputAssemblies->WithMetadataValue('AOT_InternalForceToInterpret', 'true'))" />
    </ItemGroup>
  </Target>

  <Target Name="_ScanAssembliesDecideLightweightMarshaler">
     <ItemGroup>
      <_AssembliesToScan Include="@(_WasmAssembliesInternal)" />
    </ItemGroup>

    <MarshalingPInvokeScanner Assemblies ="@(_AssembliesToScan)">
      <Output TaskParameter="IncompatibleAssemblies" ItemName="MonoLightweightMarshallerIncompatibleAssemblies" />
    </MarshalingPInvokeScanner>

    <ItemGroup Condition="@(MonoLightweightMarshallerIncompatibleAssemblies->Count()) > 0">
      <_MonoComponent Include="marshal-ilgen" />
    </ItemGroup>
  </Target>

  <!-- '$(ArchiveTests)' != 'true' is to skip on CI for now -->
  <Target Name="_WasmStripAOTAssemblies" Condition="'$(_WasmShouldAOT)' == 'true' and '$(WasmStripAOTAssemblies)' == 'true' and '$(AOTMode)' != 'LLVMOnlyInterp' and '$(ArchiveTests)' != 'true'">
    <PropertyGroup>
      <_WasmStrippedAssembliesPath>$([MSBuild]::NormalizeDirectory($(_WasmIntermediateOutputPath), 'stripped-assemblies'))</_WasmStrippedAssembliesPath>
    </PropertyGroup>

    <ItemGroup>
      <_AOTedAssemblies Include="@(_WasmAssembliesInternal)" />
      <_WasmStrippedAssemblies
              Include="@(_AOTedAssemblies)"
              OriginalPath="%(_WasmAssembliesInternal.Identity)" />
    </ItemGroup>

    <!-- Run mono-cil-strip on the assemblies -->
    <!-- TODO: replace this with a linker task -->
    <MakeDir Directories="$(_WasmStrippedAssembliesPath)" />
    <Exec Command='mono-cil-strip -q "%(_WasmStrippedAssemblies.OriginalPath)" "%(_WasmStrippedAssemblies.Identity)"' />

    <ItemGroup>
      <_WasmAssembliesInternal Remove="@(_WasmAssembliesInternal)" />
      <_WasmAssembliesInternal Include="@(_WasmStrippedAssemblies)" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="ReadEmccProps" AssemblyFile="$(MonoTargetsTasksAssemblyPath)"
             TaskFactory="JsonToItemsTaskFactory.JsonToItemsTaskFactory">
    <ParameterGroup>
      <EmccProperties ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="false" Output="true" />
      <WasmOptConfigurationFlags ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="false" Output="true" />
      <EmccDefaultExportedFunctions ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="false" Output="true" />
      <EmccDefaultExportedRuntimeMethods ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="false" Output="true" />
    </ParameterGroup>
  </UsingTask>
</Project>
