#include <glib.h>
#include <stdio.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>

#define MBTREE_TYPE  MBTree

typedef struct _MBTree MBTree;
struct _MBTree {
	guint16 op;
	MBTree *left, *right;
	gpointer state;

	int reg;
	MonoTypeEnum type;

	union {
		int i;
	} data;
};

gboolean same_tree (MBTree *t1, MBTree *t2);

%%

#
# terminal definitions
#

# constatnts
%term CONST LDLOC LDARG STLOC BR RET RETV ARG CALL
%term ADD SUB MUL
%term BLT BEQ BGE 
#
# we start at stmt
#
%start stmt

#
# tree definitions
#

con: CONST

reg: LDLOC {
	switch (tree->type) {
	case MONO_TYPE_I4:
		printf ("\tmov     dword ptr %d[%%ebp], R%d\n", 
			tree->data.i, tree->reg);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

reg: LDARG {
	switch (tree->type) {
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		printf ("\tmov     dword ptr %d[%%ebp], R%d\n", 
			-tree->data.i, tree->reg);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

reg: MUL (reg, reg) {
	printf ("\tmov     R%d, R%d\n\timul     R%d, R%d\n", 
		tree->left->reg, tree->reg,
		tree->right->reg, tree->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: ADD (reg, con) {
	printf ("\tmov     R%d, R%d\n\t    add R%d, %d\n", 
		tree->left->reg, tree->reg, 
		tree->right->data.i, tree->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: ADD (reg, reg) {
	printf ("\tmov     R%d, R%d\n\tadd     R%d, R%d\n",
		tree->left->reg,  tree->reg, 
		tree->right->reg, tree->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: SUB (reg, con) {
	printf ("\tmov     R%d, R%d\n\tsub     R%d, %d\n", 
		tree->left->reg, tree->reg, 
		tree->right->data.i, tree->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: SUB (reg, reg) {
	printf ("\tmov     R%d, R%d\n\tsub     R%d, R%d\n", 
		tree->left->reg,  tree->reg, 
		tree->right->reg, tree->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

stmt: STLOC (con) {
	printf ("\tmov     %d, dword ptr %d[EBP]\n", 
		tree->left->data.i, tree->data.i);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4);
	return 0;
}

stmt: STLOC (reg) {	
	switch (tree->type) {
	case MONO_TYPE_I4:
		printf ("\tmov     R%d, dword ptr %d[EBP]\n", 
			tree->left->reg, tree->data.i);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: BR {

	printf ("\tjmp     %d[EIP]\n", tree->data.i);
}

stmt: BLT (reg, con) {

	printf ("\tcmp     R%d, %d\n"
		"\tjl      label_%d\n", 
		tree->left->reg, tree->right->data.i, tree->data.i);
}

stmt: BEQ (reg, con) {
	printf ("\tcmp     R%d, %d\n"
		"\tje      label_%d\n", 
		tree->left->reg, tree->right->data.i, tree->data.i);
}

stmt: BGE (reg, con) {

	printf ("\tcmp     R%d, %d\n"
		"\tjae     label_%d\n", 
		tree->left->reg, tree->right->data.i, tree->data.i);
}

stmt: RETV (reg) {
	
	printf ("\tjmp     epilog ; Return value on R%d\n", tree->left->reg);
}

stmt: RET {

	printf ("\tret\n");
}

stmt: ARG (con) {
       
      printf ("\tpush     %d\n", tree->left->data.i);
}

stmt: ARG (reg) {
      printf ("\tpush    R%d\n", tree->left->reg);
}

reg: CALL {
	switch (tree->type) {
	case MONO_TYPE_I4:
		printf ("\tR%d = call\n", tree->reg);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: CALL {
     printf ("\tcall    $0x%x\n", tree->data.i);
}

%% 

gboolean 
same_tree (MBTree *t1, MBTree *t2)
{
	if (t1 == t2)
		return TRUE;
	if (!t1 || !t2)
		return FALSE;

	if (t1->op == t2->op &&
	    t1->type == t2->type &&
	    t1->data.i == t2->data.i) {
		if (!same_tree (t1->left, t2->left))
			return FALSE;
		return same_tree (t1->right, t2->right);
	}
	return FALSE;
}
