#include <glib.h>
#include <stdio.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/loader.h>
#include <mono/arch/x86/x86-codegen.h>

#include "regset.h"
#include "jit.h"

#define MBTREE_TYPE  MBTree
#define MBCGEN_TYPE  MBCodeGenStatus
#define MBCOST_DATA  MBCodeGenStatus
#define MBALLOC_STATE mono_mempool_alloc (data->mp, sizeof (MBState))

typedef struct _MBTree MBTree;
struct _MBTree {
	guint16 op;
	MBTree *left, *right;
	gpointer state;
	gpointer emit;

	guint is_jump:1;
	guint last_instr:1;
	guint jump_target:1;
	guint exclude_edx:1;

	gint32 cli_addr;   /* virtual cli address */
	gint32 addr;       /* address of emitted instruction */
	gint32 first_addr; /* first code address of a tree */ 

	gint8 reg1;
	gint8 reg2;
	MonoTypeEnum type;
	gint32 size;

	union {
		gint32 i;
		gint64 l;
		gpointer p;
	} data;
};

gboolean same_tree (MBTree *t1, MBTree *t2);

gint64 mono_llmult (gint64 a, gint64 b);
gint64 mono_lldiv  (gint64 a, gint64 b);

#define MB_OPT_LEVEL 1

#if MB_OPT_LEVEL == 0
#define MB_USE_OPT1(c) 65535
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL == 1
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL >= 2
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) c
#endif

%%

#
# terminal definitions
#

# constatnts
%term CONST_I4 CONST_I8 CONST_R4 CONST_R8
%term LDLOC LDARG STLOC BR RET RETV ARG CALL BREAK
%term ADD SUB MUL DIV AND OR XOR
%term BLT BLT_UN BEQ BNE_UN BRTRUE BRFALSE BGE BGE_UN BLE BLE_UN BGT BGT_UN 
%term CONV_I4 CONV_I1 CONV_I2 CONV_I8

#
# we start at stmt
#
%start stmt

#
# tree definitions
#

locaddr: LDLOC {
	/* nothing do do */;
}

locaddr: LDARG {
	tree->data.i = tree->data.i + 8;
}

reg: CONV_I1 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xff);
}

reg: CONV_I2 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xffff);
}

reg: CONST_I4 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.i);
}

# do nothing
reg: CONV_I4 (reg) 

reg: LDLOC {
	switch (tree->type) {
	case MONO_TYPE_I1:
		x86_widen_membase (s->code, tree->reg1, X86_EBP,
				   tree->data.i, TRUE, FALSE);
		break;
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
		x86_widen_membase (s->code, tree->reg1, X86_EBP,
				   tree->data.i, FALSE, FALSE);
		break;
	case MONO_TYPE_I2:
		x86_widen_membase (s->code, tree->reg1, X86_EBP,
				   tree->data.i, TRUE, TRUE);
		break;
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
		x86_widen_membase (s->code, tree->reg1, X86_EBP,
				   tree->data.i, FALSE, TRUE);
		break;

	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_membase (s->code, tree->reg1, X86_EBP,
				     tree->data.i, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
} cost {
	MBCOND (tree->type != MONO_TYPE_R4 &&
		tree->type != MONO_TYPE_R8 &&
		tree->type != MONO_TYPE_I8 &&
		tree->type != MONO_TYPE_U8);

	return 1;
}

reg: LDARG {
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_membase (s->code, tree->reg1, X86_EBP,
				     tree->data.i + 8, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
} cost {
	MBCOND (tree->type != MONO_TYPE_R4 &&
		tree->type != MONO_TYPE_R8 &&
		tree->type != MONO_TYPE_I8 &&
		tree->type != MONO_TYPE_U8);

	return 1;
}


reg: MUL (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_imul_reg_reg (s->code, tree->reg1, tree->right->reg1);
}

reg: DIV (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, TRUE);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: ADD (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, tree->right->data.i);
}

reg: ADD (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
}

reg: SUB (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_SUB, tree->reg1, tree->right->data.i);
}

reg: SUB (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
}

reg: AND (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg1, tree->right->reg1);
}

reg: OR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg1, tree->right->reg1);
}

reg: XOR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg1, tree->right->reg1);
}

stmt: STLOC (CONST_I4) "MB_USE_OPT1(0)" {
	x86_mov_membase_imm (s->code, X86_EBP, tree->data.i,
			     tree->left->data.i, 4);
}

stmt: STLOC (reg) {	
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
		x86_mov_membase_reg (s->code, X86_EBP, tree->data.i,
				     tree->left->reg1, 1);
		break;
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
		x86_mov_membase_reg (s->code, X86_EBP, tree->data.i,
				     tree->left->reg1, 2);
		break;
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_membase_reg (s->code, X86_EBP, tree->data.i,
				     tree->left->reg1, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: BR {
	tree->is_jump = 1;    

	x86_jump32 (s->code, tree->data.i - 5); 
}

stmt: BLT (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, TRUE); 
}

stmt: BLT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, TRUE); 
}

stmt: BLT_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, FALSE); 
}

stmt: BLT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, FALSE); 
}

stmt: BGT (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, TRUE); 
}

stmt: BGT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, TRUE); 
}

stmt: BGT_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, FALSE); 
}

stmt: BGT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, FALSE); 
}

stmt: BEQ (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BEQ (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BNE_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, FALSE);
}

stmt: BNE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, FALSE);
}

stmt: BGE (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, TRUE);
}

stmt: BGE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, TRUE);
}

stmt: BGE_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, FALSE);
}

stmt: BGE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, FALSE);
}

stmt: BLE (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, TRUE);
}

stmt: BLE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, TRUE);
}

stmt: BLE_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, FALSE);
}

stmt: BLE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, FALSE);
}

stmt: BRTRUE (reg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, TRUE);
}

stmt: BRFALSE (reg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BREAK {
	x86_breakpoint (s->code);
}

stmt: RETV (reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}
}

stmt: RET {
	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);
	} 
}

stmt: ARG (reg) 1 {
	x86_push_reg (s->code, tree->left->reg1);
}

stmt: ARG (CONST_I4) "MB_USE_OPT1(0)" {
	x86_push_imm (s->code, tree->left->data.i);
}

reg: CALL {
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
		x86_call_membase (s->code, X86_EAX, 
				  G_STRUCT_OFFSET (MonoMethod, addr));
		if (tree->size)
			x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);

		g_assert (tree->reg1 == X86_EAX);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
} cost {
	MBCOND (tree->type != MONO_TYPE_R4 &&
		tree->type != MONO_TYPE_R8 &&
		tree->type != MONO_TYPE_I8 &&
		tree->type != MONO_TYPE_U8);

	return 1;
}


stmt: CALL {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, G_STRUCT_OFFSET (MonoMethod, addr));
	if (tree->size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);
}

#
# 64 bit integers
#

lreg: CONST_I8 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.i);
	x86_mov_reg_imm (s->code, tree->reg2, *(gint32 *)(&tree->data.p + 4));
}

lreg: CONV_I8 (CONST_I4) 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);

	if (tree->left->data.i >= 0)
		x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
	else 
		x86_mov_reg_imm (s->code, tree->reg1, -1);		
}

stmt: STLOC (lreg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->data.i,
			     tree->left->reg1, 4);
	x86_mov_membase_reg (s->code, X86_EBP, tree->data.i + 4,
			     tree->left->reg2, 4);
}

lreg: LDARG {
	x86_mov_reg_membase (s->code, tree->reg1, X86_EBP,
			     tree->data.i + 8, 4);
	x86_mov_reg_membase (s->code, tree->reg2, X86_EBP,
			     tree->data.i + 8 + 4, 4);
} cost {
	MBCOND (tree->type == MONO_TYPE_I8 ||
		tree->type == MONO_TYPE_U8);
	return 0;
}

lreg: LDLOC {
	x86_mov_reg_membase (s->code, tree->reg1, X86_EBP,
			     tree->data.i, 4);
	x86_mov_reg_membase (s->code, tree->reg2, X86_EBP,
			     tree->data.i + 4, 4);
} cost {
	MBCOND (tree->type == MONO_TYPE_I8 ||
		tree->type == MONO_TYPE_U8);
	return 0;
}

lreg: SUB (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg2, tree->right->reg2);
}

lreg: ADD (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_ADC, tree->reg2, tree->right->reg2);
}

lreg: MUL (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llmult);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: DIV (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_lldiv);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: CALL {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, 
			  G_STRUCT_OFFSET (MonoMethod, addr));
	if (tree->size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);
} cost {
	MBCOND (tree->type == MONO_TYPE_I8 ||
		tree->type == MONO_TYPE_U8);
	return 0;
}

stmt: RETV (lreg) {
	if (tree->left->reg1 != X86_EAX) {
		if (tree->left->reg2 != X86_EAX) {
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			if (tree->left->reg2 != X86_EDX)
				x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
		} else { 
			x86_mov_reg_reg (s->code, X86_ECX, tree->left->reg2, 4);
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			x86_mov_reg_reg (s->code, X86_EDX, X86_ECX, 4);
		}
	} else if (tree->left->reg2 != X86_EDX) {
		x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
	}

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}
}


stmt: ARG (lreg) {
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
}

stmt: BEQ (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		o1 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, o2 - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_EQ, tree->data.i - o2, TRUE);
	}
}
stmt: BGE (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GT,  tree->data.i - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GE, tree->data.i - oe, FALSE);
	}
}

#
# floating point 

freg: CONST_R4 {
	x86_fld (s->code, tree->data.p, FALSE);
}

freg: CONST_R8 {
	x86_fld (s->code, tree->data.p, TRUE);
}

freg: LDLOC {
	x86_fld_membase (s->code, X86_EBP, tree->data.i, 
			 tree->type == MONO_TYPE_R8);
} cost {
	MBCOND (tree->type == MONO_TYPE_R4 ||
		tree->type == MONO_TYPE_R8);
	return 0;
}

freg: LDARG {
	x86_fld_membase (s->code, X86_EBP, tree->data.i + 8, 
			 tree->type == MONO_TYPE_R8);
} cost {
	MBCOND (tree->type == MONO_TYPE_R4 ||
		tree->type == MONO_TYPE_R8);
	return 0;
}

freg: ADD (freg, freg) {
	x86_fp_op_reg (s->code, X86_FADD, 1, TRUE);
}

stmt: STLOC (freg) {
	g_assert (tree->type == MONO_TYPE_R4 ||
		  tree->type == MONO_TYPE_R8);

	x86_fst_membase (s->code, X86_EBP, tree->data.i, 
			 (tree->type == MONO_TYPE_R8), TRUE);	
}

stmt: ARG (freg) {
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 8);
	x86_fst_membase (s->code, X86_ESP, 0, TRUE, TRUE);
}

stmt: BEQ (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

freg: CALL {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, 
			  G_STRUCT_OFFSET (MonoMethod, addr));
	if (tree->size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);
} cost {
	MBCOND (tree->type == MONO_TYPE_R4 ||
		tree->type == MONO_TYPE_R8);
	return 0;
}

stmt: RETV (freg) {

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}
}


#
# just some optimizazions
#

reg: ADD (locaddr, reg) {
	if (tree->reg1 != tree->right->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->right->reg1, 4);
	x86_alu_reg_membase (s->code, X86_ADD, tree->reg1, X86_EBP, 
			     tree->left->data.i);	
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return MB_USE_OPT2 (0);
}

reg: ADD (reg, locaddr) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_membase (s->code, X86_ADD, tree->reg1, X86_EBP, 
			     tree->right->data.i);	
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4 ||
		tree->right->type == MONO_TYPE_U4);
	return MB_USE_OPT2 (0);
}

reg: MUL (locaddr, reg) {
	if (tree->reg1 != tree->right->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->right->reg1, 4);
	x86_imul_reg_membase (s->code, tree->reg1, X86_EBP, tree->left->data.i);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return MB_USE_OPT2 (0);
}

stmt: BEQ (locaddr, CONST_I4) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_membase_imm (s->code, X86_CMP, X86_EBP, tree->left->data.i, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return MB_USE_OPT2 (0);
}

stmt: BGE (locaddr, CONST_I4) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_membase_imm (s->code, X86_CMP, X86_EBP, tree->left->data.i, 
			     tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, TRUE);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return MB_USE_OPT2 (0);
}

stmt: STLOC (ADD (LDLOC, CONST_I4)) {
	x86_alu_membase_imm (s->code, X86_ADD, X86_EBP, tree->data.i, 
			     tree->left->right->data.i);
} cost {
	MBCOND (tree->type == MONO_TYPE_I4 &&
		tree->left->left->type == MONO_TYPE_I4 &&
		tree->data.i == tree->left->left->data.i);
	return MB_USE_OPT2 (0);
}

stmt: ARG (CONV_I8 (CONST_I4)) "MB_USE_OPT2 (0)" {
	x86_push_imm (s->code, tree->left->left->data.i);

	if (tree->left->data.i >= 0)
		x86_push_imm (s->code, 0);
	else 
		x86_push_imm (s->code, -1);
}

%% 

gboolean 
same_tree (MBTree *t1, MBTree *t2)
{
	if (t1 == t2)
		return TRUE;
	if (!t1 || !t2)
		return FALSE;

	if (t1->op == t2->op &&
	    t1->type == t2->type &&
	    t1->data.i == t2->data.i) {
		if (!same_tree (t1->left, t2->left))
			return FALSE;
		return same_tree (t1->right, t2->right);
	}
	return FALSE;
}

gint64 
mono_llmult (gint64 a, gint64 b)
{
	return a * b;
}

gint64 
mono_lldiv (gint64 a, gint64 b)
{
	printf ("TEST %lld %lld %lld\n",a, b, a/b);
	return a / b;
}
