/*
 * x86.brg: X86 code generator
 *
 * Author:
 *   Dietmar Maurer (dietmar@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 */

#include <glib.h>
#include <stdio.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/loader.h>
#include <mono/arch/x86/x86-codegen.h>

#include "regset.h"
#include "mempool.h"

#define MBTREE_TYPE  MBTree
#define MBCGEN_TYPE  MBCodeGenStatus
#define MBCOST_DATA  MBCodeGenStatus
#define MBALLOC_STATE mono_mempool_alloc (data->mp, sizeof (MBState))

typedef	struct {
	int offset;
	unsigned int has_basereg:1;
	unsigned int has_indexreg:1;
	unsigned int has_offset:1;		
	unsigned int shift:2;
	gint8 basereg;
	gint8 indexreg;
} X86AddressInfo;

typedef struct {
	MonoMemPool *mp;
	guint8 *start;
	guint8 *code;
	gint32 locals_size;
	GPtrArray *forest;
	MonoRegSet *rs;
	guint32 epilog;
} MBCodeGenStatus;

typedef struct _MBTree MBTree;
struct _MBTree {
	guint16 op;
	MBTree *left, *right;
	gpointer state;
	gpointer emit;

	guint is_jump:1;
	guint last_instr:1;
	guint jump_target:1;

	guint8 exclude_mask;

	gint32 cli_addr;   /* virtual cli address */
	gint32 addr;       /* address of emitted instruction */
	gint32 first_addr; /* first code address of a tree */ 

	gint8 reg1;
	gint8 reg2;
	
	gint32 size;

	union {
		gint32 i;
		gint64 l;
		gpointer p;
		X86AddressInfo ainfo;
	} data;
};

gint64  mono_llmult    (gint64 a, gint64 b);
gint64  mono_lldiv     (gint64 a, gint64 b);
gint64  mono_llrem     (gint64 a, gint64 b);
guint64 mono_lldiv_un  (guint64 a, guint64 b);
guint64 mono_llrem_un  (guint64 a, guint64 b);

#define MB_OPT_LEVEL 1

#if MB_OPT_LEVEL == 0
#define MB_USE_OPT1(c) 65535
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL == 1
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL >= 2
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) c
#endif

%%

#
# terminal definitions
#

# constatnts
%term CONST_I4 CONST_I8 CONST_R4 CONST_R8
%term LDIND_I1 LDIND_U1 LDIND_I2 LDIND_U2 LDIND_I4 LDIND_I8 LDIND_R4 LDIND_R8
%term LDIND_U4
%term STIND_I1 STIND_I2 STIND_I4 STIND_I8 STIND_R4 STIND_R8
%term ADDR_L ADDR_A ADDR_G ARG CALL_I4 CALL_I8 CALL_R8
%term BREAK SWITCH BR RET RETV 
%term ADD SUB MUL DIV DIV_UN REM REM_UN AND OR XOR SHL SHR SHR_UN NEG NOT
%term BLT BLT_UN BEQ BNE_UN BRTRUE BRFALSE BGE BGE_UN BLE BLE_UN BGT BGT_UN 
%term CONV_I4 CONV_I1 CONV_I2 CONV_I8 CONV_R8

#
# we start at stmt
#
%start stmt

#
# tree definitions
#

#
# x86 adressing mode
#

acon: CONST_I4 {
	tree->data.ainfo.offset = tree->data.i;
	tree->data.ainfo.has_offset = 1;
}

acon: ADDR_G {
	tree->data.ainfo.offset = tree->data.i;
	tree->data.ainfo.has_offset = 1;
}

base: acon

base: reg {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.has_offset = 0;
	tree->data.ainfo.basereg = tree->reg1;
	tree->data.ainfo.has_basereg = 1;
}

base: ADD (reg, acon) {
	tree->data.ainfo.offset = tree->right->data.i;
	tree->data.ainfo.has_offset = 1;
	tree->data.ainfo.basereg = tree->left->reg1;
	tree->data.ainfo.has_basereg = 1;
}

base: ADDR_L {
	tree->data.ainfo.offset = tree->data.i;
	tree->data.ainfo.has_offset = 1;
	tree->data.ainfo.basereg = X86_EBP;
	tree->data.ainfo.has_basereg = 1;
}

base: ADDR_A {
	tree->data.ainfo.offset = tree->data.i + 8;
	tree->data.ainfo.has_offset = 1;
	tree->data.ainfo.basereg = X86_EBP;
	tree->data.ainfo.has_basereg = 1;
}

index: reg {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.has_offset = 1;
	tree->data.ainfo.has_indexreg = 1;
	tree->data.ainfo.indexreg = tree->left->reg1;
	tree->data.ainfo.shift = 0;
}

index: SHL (reg, CONST_I4) {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.has_offset = 1;
	tree->data.ainfo.has_indexreg = 1;
	tree->data.ainfo.indexreg = tree->left->reg1;
	tree->data.ainfo.shift = tree->right->data.i;
} cost {
	MBCOND (tree->right->data.i == 0 ||
		tree->right->data.i == 1 ||
		tree->right->data.i == 2 ||
		tree->right->data.i == 3);

	return 0;
}

index: MUL (reg, CONST_I4) {
	static int fast_log2 [] = { 1, 0, 1, -1, 2, -1, -1, -1, 3 };
  
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.has_offset = 1;
	tree->data.ainfo.has_indexreg = 1;
	tree->data.ainfo.indexreg = tree->left->reg1;
	tree->data.ainfo.shift = fast_log2 [tree->right->data.i];
} cost {
	MBCOND (tree->right->data.i == 1 ||
		tree->right->data.i == 2 ||
		tree->right->data.i == 4 ||
		tree->right->data.i == 8);

	return 0;
}

addr: base

addr: index

addr: ADD (index, base) {
	tree->data.ainfo.offset = tree->right->data.ainfo.offset;
	tree->data.ainfo.basereg = tree->right->data.ainfo.basereg;
	tree->data.ainfo.has_basereg = tree->right->data.ainfo.has_basereg;
	tree->data.ainfo.has_offset = tree->right->data.ainfo.has_offset;

	tree->data.ainfo.shift = tree->left->data.ainfo.shift;
	tree->data.ainfo.indexreg = tree->left->data.ainfo.indexreg;
	tree->data.ainfo.has_indexreg = tree->left->data.ainfo.has_indexreg;
}

stmt: STIND_I4 (addr, reg) {
	int d;

	d = (tree->left->data.ainfo.has_offset << 2 |
	     tree->left->data.ainfo.has_indexreg << 1 |
	     tree->left->data.ainfo.has_basereg);

	switch (d) {

	case 1:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 0, tree->right->reg1, 4);
		break;		
	case 2:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, 0,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		break;		
	case 3:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, 0,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		break;		
	case 6:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		break;		
	case 4:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 4);
		break;
		
	case 5:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg,
				     tree->left->data.ainfo.offset, tree->right->reg1, 4);
		break;		
	case 7:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);

		break;		
	default:
		g_assert_not_reached ();
		break;
	}
}

reg: LDIND_I4 (addr) {
	int d;

	d = (tree->left->data.ainfo.has_offset << 2 |
	     tree->left->data.ainfo.has_indexreg << 1 |
	     tree->left->data.ainfo.has_basereg);

	switch (d) {

	case 1:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 0, 4);
		break;		
	case 2:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, 0, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	case 3:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 0,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 4);
		break;		
	case 6:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	case 4:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 4);
		break;
		
	case 5:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg,
				     tree->left->data.ainfo.offset, 4);
		break;		
	case 7:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	default:
		g_assert_not_reached ();
		break;
	}
}

locaddr: ADDR_L 10

locaddr: ADDR_A 10 {
	tree->data.i = tree->data.i + 8;
}

reg: ADDR_L 1 {
     x86_mov_reg_reg (s->code, tree->reg1, X86_EBP, 4);
     x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, tree->data.i); 
}

reg: CONV_I1 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xff);
}

reg: CONV_I2 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xffff);
}

reg: CONST_I4 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.i);
}

# do nothing
reg: CONV_I4 (reg) 

reg: LDIND_I4 (reg) {
	x86_mov_reg_membase (s->code, tree->reg1, tree->left->reg1, 0, 4);
}

reg: LDIND_I1 (locaddr) {
	x86_widen_membase (s->code, tree->reg1, X86_EBP, tree->left->data.i, TRUE, FALSE);
}

reg: LDIND_U1 (locaddr) {
	x86_widen_membase (s->code, tree->reg1, X86_EBP, tree->left->data.i, FALSE, FALSE);
}

reg: LDIND_I2 (locaddr) {
	x86_widen_membase (s->code, tree->reg1, X86_EBP, tree->left->data.i, TRUE, TRUE);
}

reg: LDIND_U2 (locaddr) {
	x86_widen_membase (s->code, tree->reg1, X86_EBP, tree->left->data.i, FALSE, TRUE);
}

reg: LDIND_I4 (locaddr) {
	x86_mov_reg_membase (s->code, tree->reg1, X86_EBP, tree->left->data.i, 4);
}

reg: LDIND_U4 (locaddr) {
	x86_mov_reg_membase (s->code, tree->reg1, X86_EBP, tree->left->data.i, 4);
}

reg: LDIND_I4 (ADDR_G) {
	x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.p, 4);
}

reg: MUL (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_imul_reg_reg (s->code, tree->reg1, tree->right->reg1);
}

reg: DIV (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, TRUE);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: DIV_UN (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, FALSE);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: REM (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, TRUE);
	x86_mov_reg_reg (s->code, X86_EAX, X86_EDX, 4);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: REM_UN (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, FALSE);
	x86_mov_reg_reg (s->code, X86_EAX, X86_EDX, 4);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: ADD (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, tree->right->data.i);
}

reg: ADD (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
}

reg: SUB (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_SUB, tree->reg1, tree->right->data.i);
}

reg: SUB (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
}

reg: AND (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg1, tree->right->reg1);
}

reg: OR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg1, tree->right->reg1);
}

reg: XOR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg1, tree->right->reg1);
}

reg: NEG (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	 x86_neg_reg (s->code, tree->reg1);
}

reg: NOT (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	 x86_not_reg (s->code, tree->reg1);
}

reg: SHL (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SHL, tree->reg1, tree->right->data.i);
}

reg: SHL (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SHL, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

reg: SHR (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SAR, tree->reg1, tree->right->data.i);
}

reg: SHR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SAR, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

reg: SHR_UN (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SHR, tree->reg1, tree->right->data.i);
}

reg: SHR_UN (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SHR, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

stmt: STIND_I4 (reg, CONST_I4) "MB_USE_OPT1(0)" {
	x86_mov_membase_imm (s->code, tree->left->reg1, 0,
			     tree->right->data.i, 4);
}

stmt: STIND_I4 (reg, reg) {
	printf ("STIND %d %d\n", tree->left->reg1, tree->right->reg1);
	x86_mov_membase_reg (s->code, tree->left->reg1, 0,
			     tree->right->reg1, 4);
}

stmt: STIND_I4 (locaddr, CONST_I4) "MB_USE_OPT1(0)" {
	x86_mov_membase_imm (s->code, X86_EBP, tree->left->data.i,
			     tree->right->data.i, 4);
}

stmt: STIND_I1 (locaddr, reg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 1);
}

stmt: STIND_I2 (locaddr, reg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 2);
}

stmt: STIND_I4 (locaddr, reg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 4);
}

stmt: STIND_I4 (ADDR_G, reg) {
	x86_mov_mem_reg (s->code, tree->left->data.p,
			 tree->right->reg1, 4);
}

stmt: BR {
	tree->is_jump = 1;    

	x86_jump32 (s->code, tree->data.i - 5); 
}

stmt: BLT (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, TRUE); 
}

stmt: BLT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, TRUE); 
}

stmt: BLT_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, FALSE); 
}

stmt: BLT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, FALSE); 
}

stmt: BGT (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, TRUE); 
}

stmt: BGT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, TRUE); 
}

stmt: BGT_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, FALSE); 
}

stmt: BGT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.i - offset, FALSE); 
}

stmt: BEQ (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BEQ (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BNE_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, FALSE);
}

stmt: BNE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, FALSE);
}

stmt: BGE (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, TRUE);
}

stmt: BGE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, TRUE);
}

stmt: BGE_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, FALSE);
}

stmt: BGE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, FALSE);
}

stmt: BLE (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, TRUE);
}

stmt: BLE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, TRUE);
}

stmt: BLE_UN (reg, reg) 1 {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, FALSE);
}

stmt: BLE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.i - offset, FALSE);
}

stmt: BRTRUE (reg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, TRUE);
}

stmt: BRFALSE (reg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BREAK {
	x86_breakpoint (s->code);
}

stmt: RETV (reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}
}

stmt: RET {
	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);
	} 
}

stmt: ARG (reg) 1 {
	x86_push_reg (s->code, tree->left->reg1);
}

stmt: ARG (CONST_I4) "MB_USE_OPT1(0)" {
	x86_push_imm (s->code, tree->left->data.i);
}

reg: CALL_I4 {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, 
			  G_STRUCT_OFFSET (MonoMethod, addr));
	if (tree->size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);

	g_assert (tree->reg1 == X86_EAX);
}

stmt: CALL_I4 {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, G_STRUCT_OFFSET (MonoMethod, addr));
	if (tree->size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);
}

stmt: SWITCH (reg) {
	guint8 *start = s->code;
	gint32 offset;
	guint32 *jt = (guint32 *)tree->data.p;

	tree->is_jump = 1;

	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, jt [0]);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, jt [jt [0] + 1] - offset, FALSE);

	my_x86_mov_reg_memindex (s->code, X86_EAX, tree->data.i + 4, 
				 tree->left->reg1, 2, 4);	
	x86_jump_reg (s->code, X86_EAX);
}

#
# 64 bit integers
#

reg: CONV_I4 (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
} 

lreg: CONST_I8 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.i);
	x86_mov_reg_imm (s->code, tree->reg2, *(gint32 *)(&tree->data.p + 4));
}

lreg: CONV_I8 (CONST_I4) 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);

	if (tree->left->data.i >= 0)
		x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
	else 
		x86_mov_reg_imm (s->code, tree->reg2, -1);		
}

stmt: STIND_I8 (locaddr, lreg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 4);
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i + 4,
			     tree->right->reg2, 4);
}

lreg: LDIND_I8 (locaddr) {
	x86_mov_reg_membase (s->code, tree->reg1, X86_EBP,
			     tree->left->data.i, 4);
	x86_mov_reg_membase (s->code, tree->reg2, X86_EBP,
			     tree->left->data.i + 4, 4);
}

lreg: ADD (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_ADC, tree->reg2, tree->right->reg2);
}

lreg: SUB (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg2, tree->right->reg2);
}

lreg: AND (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg2, tree->right->reg2);
}

lreg: OR (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg2, tree->right->reg2);
}

lreg: NEG (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_neg_reg (s->code, tree->reg1);
	x86_alu_reg_imm (s->code, X86_ADC, tree->reg2, 0);
	x86_neg_reg (s->code, tree->reg2);
}

lreg: NOT (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	 x86_not_reg (s->code, tree->reg1);
	 x86_not_reg (s->code, tree->reg2);
}

lreg: MUL (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llmult);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: DIV (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_lldiv);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: REM (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llrem);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: DIV_UN (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_lldiv_un);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: REM_UN (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llrem_un);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: CALL_I8 {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, 
			  G_STRUCT_OFFSET (MonoMethod, addr));
	if (tree->size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);

	g_assert (tree->reg1 == X86_EAX);
	g_assert (tree->reg2 == X86_EDX);
}

stmt: RETV (lreg) {
	if (tree->left->reg1 != X86_EAX) {
		if (tree->left->reg2 != X86_EAX) {
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			if (tree->left->reg2 != X86_EDX)
				x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
		} else { 
			x86_mov_reg_reg (s->code, X86_ECX, tree->left->reg2, 4);
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			x86_mov_reg_reg (s->code, X86_EDX, X86_ECX, 4);
		}
	} else if (tree->left->reg2 != X86_EDX) {
		x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
	}

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}
}


stmt: ARG (lreg) {
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
}

stmt: BEQ (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		o1 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, o2 - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_EQ, tree->data.i - o2, TRUE);
	}
}

stmt: BNE_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;

	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - start;
	x86_branch8 (s->code, X86_CC_NE, tree->data.i - offset, FALSE);
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, FALSE);
}

stmt: BGE (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GT,  tree->data.i - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GE, tree->data.i - oe, FALSE);
	}
}

stmt: BGE_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GT,  tree->data.i - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GE, tree->data.i - oe, FALSE);
	}
}

stmt: BGT (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GT,  tree->data.i - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.i - oe, FALSE);
	}
}

stmt: BGT_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GT,  tree->data.i - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.i - oe, FALSE);
	}
}

stmt: BLT (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LT,  tree->data.i - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.i - oe, FALSE);
	}
}

stmt: BLT_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LT,  tree->data.i - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.i - oe, FALSE);
	}
}

stmt: BLE (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LT,  tree->data.i - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LE, tree->data.i - oe, FALSE);
	}
}

stmt: BLE_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LT,  tree->data.i - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - start;
		x86_branch32 (s->code, X86_CC_LE, tree->data.i - oe, FALSE);
	}
}

#
# floating point 

#stmt: STLOC (CONV_I4 (freg)) {
#	// fixme: set CW
#	x86_fist_pop_membase (s->code, X86_EBP, tree->data.i, FALSE);
#} 

freg: CONV_R8 (LDIND_I4 (ADDR_G)) {
	x86_fild (s->code, tree->left->left->data.p, FALSE);
}

freg: CONST_R4 {
	x86_fld (s->code, tree->data.p, FALSE);
}

freg: CONST_R8 {
	x86_fld (s->code, tree->data.p, TRUE);
}

freg: LDIND_R4 (locaddr) {
	x86_fld_membase (s->code, X86_EBP, tree->left->data.i, FALSE);
}

freg: LDIND_R8 (locaddr) {
	x86_fld_membase (s->code, X86_EBP, tree->left->data.i, TRUE);
}

freg: ADD (freg, freg) {
	x86_fp_op_reg (s->code, X86_FADD, 1, TRUE);
}

freg: SUB (freg, freg) {
	x86_fp_op_reg (s->code, X86_FSUB, 1, TRUE);
}

freg: MUL (freg, freg) {
	x86_fp_op_reg (s->code, X86_FMUL, 1, TRUE);
}

freg: DIV (freg, freg) {
	x86_fp_op_reg (s->code, X86_FDIV, 1, TRUE);
}

#freg: REM (freg, freg) {
# this does not work, since it does not pop a value from the stack,
# and we need to test if the instruction is ready
#	x86_fprem1 (s->code);
#}

freg: NEG (freg) {
	x86_fchs (s->code);
}

stmt: STIND_R4 (locaddr, freg) {
	x86_fst_membase (s->code, X86_EBP, tree->left->data.i, FALSE, TRUE);
}

stmt: STIND_R8 (locaddr, freg) {
	x86_fst_membase (s->code, X86_EBP, tree->left->data.i, TRUE, TRUE);
}

stmt: ARG (freg) {
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 8);
	x86_fst_membase (s->code, X86_ESP, 0, TRUE, TRUE);
}

stmt: BEQ (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BNE_UN (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, TRUE);
}

stmt: BLT_UN (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x0100);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BGE_UN (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x0100);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, TRUE);
}

stmt: BGT_UN (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BLE_UN (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, TRUE);
}

freg: CALL_R8 {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, 
			  G_STRUCT_OFFSET (MonoMethod, addr));
	if (tree->size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->size);
}

stmt: RETV (freg) {

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}
}

%% 

#include "jit.h"

gint64 
mono_llmult (gint64 a, gint64 b)
{
	return a * b;
}

gint64 
mono_lldiv (gint64 a, gint64 b)
{
	return a / b;
}

gint64 
mono_llrem (gint64 a, gint64 b)
{
	return a % b;
}

guint64 
mono_lldiv_un (guint64 a, guint64 b)
{
	return a / b;
}

guint64 
mono_llrem_un (guint64 a, guint64 b)
{
	return a % b;
}

MBTree *
mono_ctree_new (MonoMemPool *mp, int op, MBTree *left, MBTree *right)
{
	MBTree *t = mono_mempool_alloc0 (mp, sizeof (MBTree));

	t->op = op;
	t->left = left;
	t->right = right;
	t->reg1 = -1;
	t->reg2 = -1;
	t->cli_addr = -1;
	return t;
}

MBTree *
mono_ctree_new_leaf (MonoMemPool *mp, int op)
{
	return mono_ctree_new (mp, op, NULL, NULL);
}
