/*
 * x86.brg: X86 code generator
 *
 * Author:
 *   Dietmar Maurer (dietmar@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 */

#include <glib.h>
#include <stdio.h>
#include <string.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/loader.h>
#include <mono/metadata/object.h>
#include <mono/arch/x86/x86-codegen.h>

#include "regset.h"
#include "mempool.h"
#include "jit.h"

#define MBTREE_TYPE  MBTree
#define MBCGEN_TYPE  MonoFlowGraph
#define MBCOST_DATA  MonoFlowGraph
#define MBALLOC_STATE mono_mempool_alloc (data->mp, sizeof (MBState))

typedef enum {
	AMImmediate       = 0,  // ptr
	AMBase            = 1,  // V[REG]  
	AMIndex           = 2,  // V[REG*X] 
	AMBaseIndex       = 3,  // V[REG*X][REG] 
} X86AddMode;

typedef	struct {
	int           offset;
	X86AddMode    amode:2;
	unsigned int  shift:2;
	gint8         basereg;
	gint8         indexreg;
} X86AddressInfo;

struct _MBTree {
	guint16   op;
	MBTree   *left, *right;
	gpointer  state;
	gpointer  emit;

	gint32    addr;

	unsigned      is_jump:1;
	unsigned      last_instr:1;
	
	MonoValueType svt;

	guint8    exclude_mask;


	gint8     reg1;
	gint8     reg2;
	
	union {
		gint32 i;
		gint64 l;
		gpointer p;
		MonoBBlock *bb;
		MonoMethod *m;
		X86AddressInfo ainfo;
	} data;
};

gint64  mono_llmult    (gint64 a, gint64 b);
gint64  mono_lldiv     (gint64 a, gint64 b);
gint64  mono_llrem     (gint64 a, gint64 b);
guint64 mono_lldiv_un  (guint64 a, guint64 b);
guint64 mono_llrem_un  (guint64 a, guint64 b);

#define MB_OPT_LEVEL 1

#if MB_OPT_LEVEL == 0
#define MB_USE_OPT1(c) 65535
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL == 1
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL >= 2
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) c
#endif

//#define DEBUG

#ifdef DEBUG
#define MEMCOPY debug_memcpy
void *MEMCOPY (void *dest, const void *src, size_t n);

#define PRINT_REG(text,reg) \
g_assert (reg >= 0); \
x86_push_reg (s->code, X86_EAX); \
x86_push_reg (s->code, X86_EDX); \
x86_push_reg (s->code, X86_ECX); \
x86_push_reg (s->code, reg); \
x86_push_imm (s->code, reg); \
x86_push_imm (s->code, text " %d %p\n"); \
x86_call_code (s->code, printf); \
x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 3*4); \
x86_pop_reg (s->code, X86_ECX); \
x86_pop_reg (s->code, X86_EDX); \
x86_pop_reg (s->code, X86_EAX); 
#else

#define MEMCOPY memcpy

#define PRINT_REG(x,y)

#endif

/* The call instruction for virtual functions must have a known
 * size (used by x86_magic_trampoline)
 */
#define x86_call_virtual(inst,basereg,disp)	               \
	do {	                                               \
		*(inst)++ = (unsigned char)0xff;               \
		x86_address_byte ((inst), 2, 2, (basereg));    \
		x86_imm_emit32 ((inst), (disp));	       \
	} while (0)

%%

#
# terminal definitions
#

# constatnts
%term CONST_I4 CONST_I8 CONST_R4 CONST_R8
%term LDIND_I1 LDIND_U1 LDIND_I2 LDIND_U2 LDIND_I4 LDIND_I8 LDIND_R4 LDIND_R8
%term LDIND_U4 LDIND_OBJ
%term STIND_I1 STIND_I2 STIND_I4 STIND_I8 STIND_R4 STIND_R8 STIND_OBJ
%term ADDR_L ADDR_G ARG CALL_I4 CALL_I8 CALL_R8
%term BREAK SWITCH BR RET RETV 
%term ADD SUB MUL DIV DIV_UN REM REM_UN AND OR XOR SHL SHR SHR_UN NEG NOT
%term BLT BLT_UN BEQ BNE_UN BRTRUE BRFALSE BGE BGE_UN BLE BLE_UN BGT BGT_UN 
%term CEQ CLT
%term CONV_I4 CONV_I1 CONV_I2 CONV_I8 CONV_U8 CONV_R8
%term INTF_ADDR VFUNC_ADDR NOP NEWARR NEWOBJ CPOBJ POP INITOBJ VTYPE
%term LDLEN

#
# we start at stmt
#
%start stmt

#
# tree definitions
#

#
# x86 adressing mode
#

acon: CONST_I4 {
	tree->data.ainfo.offset = tree->data.i;
	tree->data.ainfo.amode = AMImmediate;
}

acon: ADDR_G {
	tree->data.ainfo.offset = tree->data.i;
	tree->data.ainfo.amode = AMImmediate;
}

acon: ADD (ADDR_G, CONST_I4) {
	tree->data.ainfo.offset = (unsigned)tree->left->data.p + tree->right->data.i;
	tree->data.ainfo.amode = AMImmediate;
}

base: acon

base: reg {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.basereg = tree->reg1;
	tree->data.ainfo.amode = AMBase;
}

base: ADD (reg, acon) {
	tree->data.ainfo.offset = tree->right->data.i;
	tree->data.ainfo.basereg = tree->left->reg1;
	tree->data.ainfo.amode = AMBase;
}

base: ADDR_L {
	tree->data.ainfo.offset = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;
	tree->data.ainfo.basereg = X86_EBP;
	tree->data.ainfo.amode = AMBase;
}

index: reg {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.indexreg = tree->reg1;
	tree->data.ainfo.shift = 0;
	tree->data.ainfo.amode = AMIndex;
}

index: SHL (reg, CONST_I4) {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.amode = AMIndex;
	tree->data.ainfo.indexreg = tree->left->reg1;
	tree->data.ainfo.shift = tree->right->data.i;
} cost {
	MBCOND (tree->right->data.i == 0 ||
		tree->right->data.i == 1 ||
		tree->right->data.i == 2 ||
		tree->right->data.i == 3);

	return 0;
}

index: MUL (reg, CONST_I4) {
	static int fast_log2 [] = { 1, 0, 1, -1, 2, -1, -1, -1, 3 };
  
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.amode = AMIndex;
	tree->data.ainfo.indexreg = tree->left->reg1;
	tree->data.ainfo.shift = fast_log2 [tree->right->data.i];
} cost {
	MBCOND (tree->right->data.i == 1 ||
		tree->right->data.i == 2 ||
		tree->right->data.i == 4 ||
		tree->right->data.i == 8);

	return 0;
}

addr: base

addr: index

addr: ADD (index, base) {
	tree->data.ainfo.offset = tree->right->data.ainfo.offset;
	tree->data.ainfo.basereg = tree->right->data.ainfo.basereg;
	tree->data.ainfo.amode = tree->left->data.ainfo.amode | 
		tree->right->data.ainfo.amode;
	tree->data.ainfo.shift = tree->left->data.ainfo.shift;
	tree->data.ainfo.indexreg = tree->left->data.ainfo.indexreg;
}

stmt: STIND_I4 (addr, reg) {
	PRINT_REG ("STIND_I4", tree->right->reg1);

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 4);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 4);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		break;		
	}
}

stmt: STIND_I1 (addr, reg) {
	PRINT_REG ("STIND_I1", tree->right->reg1);

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 1);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 1);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 1);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 1);
		break;		
	}
}

stmt: STIND_I2 (addr, reg) {
	PRINT_REG ("STIND_I2", tree->right->reg1);

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 2);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 2);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 2);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 2);
		break;		
	}
}

reg: LDIND_I1 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 1);
		break;

	case AMBase:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, 1);
		break;		
	case AMIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 1);
		break;		
	case AMBaseIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 1);
		break;		
	}

	PRINT_REG ("LDIND_I1", tree->reg1);
}

reg: LDIND_I2 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 2);
		break;

	case AMBase:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, 2);
		break;		
	case AMIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 2);
		break;		
	case AMBaseIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 2);
		break;		
	}

	PRINT_REG ("LDIND_I2", tree->reg1);
}

reg: LDIND_I4 (addr) {

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 4);
		break;

	case AMBase:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, 4);
		break;		
	case AMIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 4);
		break;		
	case AMBaseIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	}

	PRINT_REG ("LDIND_I4", tree->reg1);
}

reg: LDIND_U1 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_widen_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, FALSE, FALSE);
		break;

	case AMBase:
		x86_widen_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				   tree->left->data.ainfo.offset, FALSE, FALSE);
		break;		
	case AMIndex:
		x86_widen_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				    tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, FALSE, FALSE);
		break;		
	case AMBaseIndex:
		x86_widen_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				    tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				    tree->left->data.ainfo.shift, FALSE, FALSE);
		break;		
	}

	PRINT_REG ("LDIND_U1", tree->reg1);
}

reg: LDIND_U2 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_widen_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, FALSE, TRUE);
		break;

	case AMBase:
		x86_widen_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				   tree->left->data.ainfo.offset, FALSE, TRUE);
		break;		
	case AMIndex:
		x86_widen_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				    tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, FALSE, TRUE);
		break;		
	case AMBaseIndex:
		x86_widen_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				    tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				    tree->left->data.ainfo.shift, FALSE, TRUE);
		break;		
	}

	PRINT_REG ("LDIND_U2", tree->reg1);
}

reg: LDIND_U4 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 4);
		break;

	case AMBase:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, 4);
		break;		
	case AMIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 4);
		break;		
	case AMBaseIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	}

	PRINT_REG ("LDIND_U4", tree->reg1);
}

locaddr: ADDR_L 10 {
	tree->data.i = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;
}

reg: ADDR_L 1 {
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;  
	x86_lea_membase (s->code, tree->reg1, X86_EBP, offset);
}

reg: CONV_I1 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xff);
}

reg: CONV_I2 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xffff);
}

reg: CONST_I4 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.i);
}

reg: CONV_I4 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	PRINT_REG ("CONV_I4", tree->left->reg1);
} 


reg: MUL (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_imul_reg_reg (s->code, tree->reg1, tree->right->reg1);
}

reg: DIV (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, TRUE);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: DIV_UN (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, FALSE);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: REM (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, TRUE);
	x86_mov_reg_reg (s->code, X86_EAX, X86_EDX, 4);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: REM_UN (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, FALSE);
	x86_mov_reg_reg (s->code, X86_EAX, X86_EDX, 4);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: ADD (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, tree->right->data.i);
}

reg: ADD (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
}

reg: SUB (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_SUB, tree->reg1, tree->right->data.i);
}

reg: SUB (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
}

reg: CEQ (reg, reg) {
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	x86_set_reg (s->code, X86_CC_EQ, tree->reg1, TRUE);
	x86_widen_reg (s->code, tree->reg1, tree->reg1, FALSE, FALSE);
}

reg: CLT (reg, reg) {
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	x86_set_reg (s->code, X86_CC_LT, tree->reg1, TRUE);
	x86_widen_reg (s->code, tree->reg1, tree->reg1, FALSE, FALSE);
}

reg: AND (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg1, tree->right->reg1);
}

reg: OR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg1, tree->right->reg1);
}

reg: XOR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg1, tree->right->reg1);
}

reg: NEG (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	 x86_neg_reg (s->code, tree->reg1);
}

reg: NOT (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	 x86_not_reg (s->code, tree->reg1);
}

reg: SHL (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SHL, tree->reg1, tree->right->data.i);
}

reg: SHL (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SHL, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

reg: SHR (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SAR, tree->reg1, tree->right->data.i);
}

reg: SHR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SAR, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

reg: SHR_UN (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SHR, tree->reg1, tree->right->data.i);
}

reg: SHR_UN (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SHR, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

# array support
reg: LDLEN (reg) {
	x86_mov_reg_membase (s->code, tree->reg1, tree->left->reg1,  
			     G_STRUCT_OFFSET (MonoArray, bounds), 4);
	x86_mov_reg_membase (s->code, tree->reg1, tree->reg1,  
			     G_STRUCT_OFFSET (MonoArrayBounds, length), 4);
}

#reg: LDELEMA (reg, reg) {
#	x86_imul_reg_reg_imm (s->code, tree->right->reg1, tree->right->reg1, tree->data.i);
#	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
#	x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, G_STRUCT_OFFSET (MonoArray, vector));
#}

reg: NEWARR (reg) {
	if (tree->reg1 != X86_EAX)
		x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_ECX);
	x86_push_reg (s->code, X86_EDX);

	x86_push_reg (s->code, tree->left->reg1);
	x86_push_imm (s->code, tree->data.p);
	x86_call_code (s->code, mono_array_new);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, sizeof (gpointer) + 4);

	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_ECX);
	if (tree->reg1 != X86_EAX) {
		x86_mov_reg_reg (s->code, tree->reg1, X86_EAX, 4);
		x86_pop_reg (s->code, X86_EAX);
	}
}

reg: NEWOBJ {
	if (tree->reg1 != X86_EAX)
		x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_ECX);
	x86_push_reg (s->code, X86_EDX);

	x86_push_imm (s->code, tree->data.p);
	x86_call_code (s->code, mono_object_new);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, sizeof (gpointer));

	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_ECX);
	if (tree->reg1 != X86_EAX) {
		x86_mov_reg_reg (s->code, tree->reg1, X86_EAX, 4);
		x86_pop_reg (s->code, X86_EAX);
	}
}

stmt: INITOBJ (reg) {
	int i, j;

	i = tree->data.i;

	if (i == 1 || i == 2 || i == 4) {
		int t = X86_ECX;

		if (tree->left->reg1 != X86_EAX) 
			t = X86_EAX;

		x86_push_reg (s->code, t);
		x86_alu_reg_reg (s->code, X86_XOR, t, t);

		switch (tree->data.i) {
		case 4:
			x86_mov_regp_reg (s->code, tree->left->reg1, t, 4);
			break;
		case 2:
			x86_mov_regp_reg (s->code, tree->left->reg1, t, 4);
			break;
		case 1:
			x86_mov_regp_reg (s->code, tree->left->reg1, t, 4);
			break;
		}
		x86_pop_reg (s->code, t);

		return;
	}

	i = tree->data.i / 4;
	j = tree->data.i % 4;

	x86_push_reg (s->code, X86_EAX);
	
	if (tree->left->reg1 != X86_EDI) {
		x86_push_reg (s->code, X86_EDI);
		x86_mov_reg_reg (s->code, X86_EDI, tree->left->reg1, 4);
	}

	if (i) {
		x86_push_reg (s->code, X86_ECX);
		x86_alu_reg_reg (s->code, X86_XOR, X86_EAX, X86_EAX);
		x86_mov_reg_imm (s->code, X86_ECX, i);
		x86_cld (s->code);
		x86_prefix (s->code, X86_REP_PREFIX);
		x86_stosl (s->code);
		x86_pop_reg (s->code, X86_ECX);
	}


	for (i = 0; i < j; i++)
		x86_stosb (s->code);

	if (tree->left->reg1 != X86_EDI)
		x86_pop_reg (s->code, X86_EDI);
	
	x86_pop_reg (s->code, X86_EAX);
}

stmt: NOP

stmt: POP (reg)

stmt: STIND_I4 (reg, CONST_I4) "MB_USE_OPT1(0)" {
	x86_mov_membase_imm (s->code, tree->left->reg1, 0,
			     tree->right->data.i, 4);
}

stmt: STIND_I4 (reg, reg) {
	x86_mov_membase_reg (s->code, tree->left->reg1, 0,
			     tree->right->reg1, 4);
}

stmt: STIND_I4 (locaddr, CONST_I4) "MB_USE_OPT1(0)" {
	x86_mov_membase_imm (s->code, X86_EBP, tree->left->data.i,
			     tree->right->data.i, 4);
}

stmt: STIND_I1 (locaddr, reg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 1);
}

stmt: STIND_I2 (locaddr, reg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 2);
}

stmt: STIND_I4 (locaddr, reg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 4);
}

stmt: STIND_I4 (ADDR_G, reg) {
	x86_mov_mem_reg (s->code, tree->left->data.p,
			 tree->right->reg1, 4);
}

stmt: BR {
	gint32 addr = tree->data.bb->addr - tree->addr - 5;
	tree->is_jump = 1;    
	
	x86_jump32 (s->code, addr); 
}

stmt: BLT (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BLT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BLT_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BLT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BGT (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BGT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BGT_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BGT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BEQ (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BEQ (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BNE_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BNE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, TRUE);
}

stmt: BGE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, TRUE);
}

stmt: BGE_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, FALSE);
}

stmt: BLE (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, TRUE);
}

stmt: BLE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, TRUE);
}

stmt: BLE_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, FALSE);
}

stmt: BLE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, FALSE);
}

stmt: BRTRUE (reg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, TRUE);
}

stmt: BRFALSE (reg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BREAK {
	x86_breakpoint (s->code);
}

stmt: RETV (reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}

stmt: RET {
	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);
	} 
}

stmt: ARG (reg) {
	x86_push_reg (s->code, tree->left->reg1);
}

stmt: ARG (ADDR_G) {
	x86_push_imm (s->code, tree->left->data.p);
}

stmt: ARG (CONST_I4) "MB_USE_OPT1(0)" {
	x86_push_imm (s->code, tree->left->data.i);
}

reg: CALL_I4 (CONST_I4) {
	
	x86_call_code (s->code, tree->left->data.p);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);
	
	g_assert (tree->reg1 == X86_EAX);
}

reg: CALL_I4 (LDIND_I4 (ADDR_G)) {
	
	x86_call_mem (s->code, tree->left->left->data.p);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);

	g_assert (tree->reg1 == X86_EAX);
}

reg: CALL_I4 (INTF_ADDR (reg)) {
	int reg1 = tree->left->left->reg1;

	x86_mov_reg_membase (s->code, reg1, reg1, 0, 4);
	x86_mov_reg_membase (s->code, reg1, reg1, 
	        G_STRUCT_OFFSET (MonoClass, interface_offsets), 4);
	x86_mov_reg_membase (s->code, reg1, reg1, tree->left->data.m->klass->interface_id << 2, 4);
	x86_call_virtual (s->code, reg1, tree->left->data.m->slot << 2);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);

	g_assert (tree->reg1 == X86_EAX);
}

reg: CALL_I4 (VFUNC_ADDR (reg)) {
	int reg1 = tree->left->left->reg1;

	x86_mov_reg_membase (s->code, reg1, reg1, 0, 4);
	x86_call_virtual (s->code, reg1, 
	        G_STRUCT_OFFSET (MonoClass, vtable) + (tree->left->data.m->slot << 2));

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);

	PRINT_REG ("CONV_I4(VIRTUAL)", tree->reg1);

	g_assert (tree->reg1 == X86_EAX);
}

stmt: CALL_I4 (LDIND_I4 (ADDR_G)) {
	x86_call_mem (s->code, tree->left->left->data.p);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);
}

stmt: CALL_I4 (INTF_ADDR (reg)) {
	int reg1 = tree->left->left->reg1;

	x86_mov_reg_membase (s->code, reg1, reg1, 0, 4);
	x86_mov_reg_membase (s->code, reg1, reg1, 
                G_STRUCT_OFFSET (MonoClass, interface_offsets), 4);
	x86_mov_reg_membase (s->code, reg1, reg1, tree->left->data.m->klass->interface_id << 2, 4);
	x86_call_virtual (s->code, reg1, tree->left->data.m->slot << 2);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);
}

stmt: CALL_I4 (VFUNC_ADDR (reg)) {
	int reg1 = tree->left->left->reg1;

	x86_mov_reg_membase (s->code, reg1, reg1, 0, 4);
	x86_call_virtual (s->code, reg1, 
                G_STRUCT_OFFSET (MonoClass, vtable) + (tree->left->data.m->slot << 2));

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);
}

stmt: SWITCH (reg) {
	guint32 offset;
	guint32 *jt = (guint32 *)tree->data.p;

	tree->is_jump = 1;

	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, jt [0]);
	offset = 6 + (guint32)s->code;
	x86_branch32 (s->code, X86_CC_GE, jt [jt [0] + 1] - offset, FALSE);

	x86_mov_reg_memindex (s->code, X86_EAX, X86_NOBASEREG, 
			      tree->data.i + 4, tree->left->reg1, 2, 4);	
	x86_jump_reg (s->code, X86_EAX);
}

#
# 64 bit integers
#

reg: CONV_I4 (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
} 

stmt: POP (lreg)

lreg: CONST_I8 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.i);
	x86_mov_reg_imm (s->code, tree->reg2, *(gint32 *)(&tree->data.p + 4));
}

lreg: CONV_I8 (CONST_I4) {
	x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);

	if (tree->left->data.i >= 0)
		x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
	else 
		x86_mov_reg_imm (s->code, tree->reg2, -1);		
}

lreg: CONV_I8 (reg) {
	guint8 *i1;

	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);

	// fixme: check if the branch8 is to the right location
	x86_breakpoint (s->code);

	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
	x86_branch8 (s->code, X86_CC_GE, 4, TRUE);
	i1 = s->code;
	x86_mov_reg_imm (s->code, tree->reg2, -1); 
	g_assert ((s->code - i1) == 4);
	g_assert_not_reached ();
}

lreg: CONV_U8 (CONST_I4) 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
}

stmt: STIND_I8 (locaddr, lreg) {
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i,
			     tree->right->reg1, 4);
	x86_mov_membase_reg (s->code, X86_EBP, tree->left->data.i + 4,
			     tree->right->reg2, 4);
}
stmt: STIND_I8 (addr, lreg) {
       
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 4);
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset + 4, tree->right->reg2, 4);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 4);
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset + 4, tree->right->reg2, 4);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset + 4,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg2, 4);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset + 4,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg2, 4);
		break;		
	}
}

lreg: LDIND_I8 (locaddr) {
	x86_mov_reg_membase (s->code, tree->reg1, X86_EBP,
			     tree->left->data.i, 4);
	x86_mov_reg_membase (s->code, tree->reg2, X86_EBP,
			     tree->left->data.i + 4, 4);
}

lreg: LDIND_I8 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 4);
		x86_mov_reg_mem (s->code, tree->reg2, tree->left->data.ainfo.offset + 4, 4);
		break;

	case AMBase:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, 4);
		x86_mov_reg_membase (s->code, tree->reg2, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset + 4, 4);
		break;		
	case AMIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 4);
		x86_mov_reg_memindex (s->code, tree->reg2, X86_NOBASEREG, tree->left->data.ainfo.offset + 4,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 4);
		break;		
	case AMBaseIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		x86_mov_reg_memindex (s->code, tree->reg2, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset + 4, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	}
}

lreg: ADD (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_ADC, tree->reg2, tree->right->reg2);
}

lreg: SUB (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg2, tree->right->reg2);
}

lreg: AND (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg2, tree->right->reg2);
}

lreg: OR (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg2, tree->right->reg2);
}

lreg: NEG (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_neg_reg (s->code, tree->reg1);
	x86_alu_reg_imm (s->code, X86_ADC, tree->reg2, 0);
	x86_neg_reg (s->code, tree->reg2);
}

lreg: NOT (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	 x86_not_reg (s->code, tree->reg1);
	 x86_not_reg (s->code, tree->reg2);
}

lreg: MUL (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llmult);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: DIV (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_lldiv);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: REM (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llrem);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: DIV_UN (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_lldiv_un);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: REM_UN (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llrem_un);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: CALL_I8 (LDIND_I4 (ADDR_G)) {
	
	x86_call_mem (s->code, tree->left->left->data.p);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);

	g_assert (tree->reg1 == X86_EAX);
	g_assert (tree->reg2 == X86_EDX);
}

stmt: RETV (lreg) {
	if (tree->left->reg1 != X86_EAX) {
		if (tree->left->reg2 != X86_EAX) {
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			if (tree->left->reg2 != X86_EDX)
				x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
		} else { 
			x86_mov_reg_reg (s->code, X86_ECX, tree->left->reg2, 4);
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			x86_mov_reg_reg (s->code, X86_EDX, X86_ECX, 4);
		}
	} else if (tree->left->reg2 != X86_EDX) {
		x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
	}

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}


stmt: ARG (lreg) {
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
}

stmt: BEQ (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		o1 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, o2 - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - o2, TRUE);
	}
}

stmt: BNE_UN (lreg, lreg) {
	gint32 offset;

	tree->is_jump = 1;

	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch8 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BGE_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BGT (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BGT_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLT (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLT_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLE (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLE_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - oe, FALSE);
	}
}

#
# floating point 

#stmt: STLOC (CONV_I4 (freg)) {
#	// fixme: set CW
#	x86_fist_pop_membase (s->code, X86_EBP, tree->data.i, FALSE);
#} 

freg: CONV_R8 (LDIND_I4 (ADDR_G)) {
	x86_fild (s->code, tree->left->left->data.p, FALSE);
}

freg: CONV_R8 (reg) {
	/* I found no direct way to move an integer register to 
	 * the floating point stack, so we need to store the register
	 * to memory
	 */
	x86_push_reg (s->code, tree->left->reg1);
	x86_fild_membase (s->code, X86_ESP, 0, FALSE);
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 4);
}

freg: CONST_R4 {
	float f = *(float *)tree->data.p;

	if (f == 0.0)
		x86_fldz (s->code);
	else if (f == 1.0)
		x86_fld1(s->code);
	else
		x86_fld (s->code, tree->data.p, FALSE);
}

freg: CONST_R8 {
	double d = *(double *)tree->data.p;
	printf ("TEST %f\n", d);

	if (d == 0.0)
		x86_fldz (s->code);
	else if (d == 1.0)
		x86_fld1(s->code);
	else
		x86_fld (s->code, tree->data.p, TRUE);
}

freg: LDIND_R4 (locaddr) {
	x86_fld_membase (s->code, X86_EBP, tree->left->data.i, FALSE);
}

freg: LDIND_R8 (locaddr) {
	x86_fld_membase (s->code, X86_EBP, tree->left->data.i, TRUE);
}

freg: ADD (freg, freg) {
	x86_fp_op_reg (s->code, X86_FADD, 1, TRUE);
}

freg: SUB (freg, freg) {
	x86_fp_op_reg (s->code, X86_FSUB, 1, TRUE);
}

freg: MUL (freg, freg) {
	x86_fp_op_reg (s->code, X86_FMUL, 1, TRUE);
}

freg: DIV (freg, freg) {
	x86_fp_op_reg (s->code, X86_FDIV, 1, TRUE);
}

#freg: REM (freg, freg) {
# this does not work, since it does not pop a value from the stack,
# and we need to test if the instruction is ready
#	x86_fprem1 (s->code);
#}

freg: NEG (freg) {
	x86_fchs (s->code);
}

stmt: POP (freg)

stmt: STIND_R4 (locaddr, freg) {
	x86_fst_membase (s->code, X86_EBP, tree->left->data.i, FALSE, TRUE);
}

stmt: STIND_R8 (locaddr, freg) {
	x86_fst_membase (s->code, X86_EBP, tree->left->data.i, TRUE, TRUE);
}

stmt: ARG (freg) {
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 8);
	x86_fst_membase (s->code, X86_ESP, 0, TRUE, TRUE);
}

stmt: BEQ (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BNE_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BLT (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BLT_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGT_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x0100);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, FALSE);
}

stmt: BLE_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

freg: CALL_R8 (LDIND_I4 (ADDR_G)) {
	
	x86_call_mem (s->code, tree->left->left->data.p);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);
}

freg: CALL_R8 (INTF_ADDR (reg)) {
	int reg1 = tree->left->left->reg1;

	x86_mov_reg_membase (s->code, reg1, reg1, 0, 4);
	x86_mov_reg_membase (s->code, reg1, reg1, 
	        G_STRUCT_OFFSET (MonoClass, interface_offsets), 4);
	x86_mov_reg_membase (s->code, reg1, reg1, tree->left->data.m->klass->interface_id << 2, 4);
	x86_call_virtual (s->code, reg1, tree->left->data.m->slot << 2);

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);
}

freg: CALL_R8 (VFUNC_ADDR (reg)) {
	int reg1 = tree->left->left->reg1;

	x86_mov_reg_membase (s->code, reg1, reg1, 0, 4);
	x86_call_virtual (s->code, reg1, 
	        G_STRUCT_OFFSET (MonoClass, vtable) + (tree->left->data.m->slot << 2));

	if (tree->data.i)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, tree->data.i);
}

stmt: RETV (freg) {

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}

# support for value types

vtype: VTYPE

vtype: LDIND_OBJ (reg) {
	int treg = X86_EAX;
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;
	int size = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).size;

	if (tree->left->reg1 == X86_EAX)
		treg = X86_ECX;

	x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_EDX);
	x86_push_reg (s->code, X86_ECX);

	x86_push_imm (s->code, size);
	x86_push_reg (s->code, tree->left->reg1);
	x86_lea_membase (s->code, treg, X86_EBP, offset);
	x86_push_reg (s->code, treg);
	x86_call_code (s->code, MEMCOPY);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 12);

	x86_pop_reg (s->code, X86_ECX);
	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_EAX);
}

stmt: STIND_OBJ (reg, vtype) {
	int treg = X86_EAX;
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->right->data.i).offset;
	int size = g_array_index (s->varinfo, MonoVarInfo, tree->right->data.i).size;

	if (tree->left->reg1 == X86_EAX)
		treg = X86_ECX;

	x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_EDX);
	x86_push_reg (s->code, X86_ECX);

	x86_push_imm (s->code, size);
	x86_lea_membase (s->code, treg, X86_EBP, offset);
	x86_push_reg (s->code, treg);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, MEMCOPY);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 12);

	x86_pop_reg (s->code, X86_ECX);
	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_EAX);
}

stmt: ARG (vtype) {
	int treg = X86_EAX;
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->left->data.i).offset;
	int size = g_array_index (s->varinfo, MonoVarInfo, tree->left->data.i).size;
	int sa;
	
	sa = size + 3;
	sa &= ~3;

	/* reserve space for the argument */
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, sa);

	x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_EDX);
	x86_push_reg (s->code, X86_ECX);

	x86_push_imm (s->code, size);

	x86_lea_membase (s->code, treg, X86_EBP, offset);
	x86_push_reg (s->code, treg);

	x86_lea_membase (s->code, treg, X86_ESP, 5*4);
	x86_push_reg (s->code, treg);

	x86_call_code (s->code, MEMCOPY);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 12);

	x86_pop_reg (s->code, X86_ECX);
	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_EAX);
}

stmt: RETV (vtype) {
	int treg = X86_EAX;
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->left->data.i).offset;
	int size = g_array_index (s->varinfo, MonoVarInfo, tree->left->data.i).size;

	x86_push_imm (s->code, size);
	x86_lea_membase (s->code, treg, X86_EBP, offset);
	x86_push_reg (s->code, treg);
	x86_push_membase (s->code, X86_EBP, 8);

	x86_call_code (s->code, MEMCOPY);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 12);

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}

%% 

#include "jit.h"

gint64 
mono_llmult (gint64 a, gint64 b)
{
	return a * b;
}

gint64 
mono_lldiv (gint64 a, gint64 b)
{
	return a / b;
}

gint64 
mono_llrem (gint64 a, gint64 b)
{
	return a % b;
}

guint64 
mono_lldiv_un (guint64 a, guint64 b)
{
	return a / b;
}

guint64 
mono_llrem_un (guint64 a, guint64 b)
{
	return a % b;
}

MBTree *
mono_ctree_new (MonoMemPool *mp, int op, MBTree *left, MBTree *right)
{
	MBTree *t = mono_mempool_alloc0 (mp, sizeof (MBTree));

	t->op = op;
	t->left = left;
	t->right = right;
	t->reg1 = -1;
	t->reg2 = -1;
	t->svt = VAL_UNKNOWN;
	return t;
}

MBTree *
mono_ctree_new_leaf (MonoMemPool *mp, int op)
{
	return mono_ctree_new (mp, op, NULL, NULL);
}

#ifdef DEBUG
void *
MEMCOPY (void *dest, const void *src, size_t n)
{
	int i, l = n;

	printf ("MEMCPY(%p to %p [%d]) ", src, dest, n);

	for (i = 0; i < l; i++)
		printf ("%02x ", *((guint8 *)src + i));
	printf ("\n");
	
	return memcpy (dest, src, n);
}
#endif
