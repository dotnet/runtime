.assembly iltests {}
.assembly extern TestDriver {}
.assembly extern mscorlib {}

.class public auto ansi sealed beforefieldinit Tests {

	.method static public int32 Main(string[] args) il managed {
		.entrypoint
		
		ldtoken Tests
		call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
		ldarg.0
		call       int32 [TestDriver]TestDriver::RunTests(class [mscorlib]System.Type, string[])
		ret
	}

	// make sure the register allocator works when the return value of
	// 'div' is discarded
	.method static public int32 test_0_div_regalloc () il managed {
		.locals init (
			int32 i
		)

		ldloc 0
		ldc.i4.s 0xa
		div
		pop
		ldc.i4.0
		ret
	}
	
	
	.method static public int32 test_1_ceq_to_i4 () il managed {
		.locals init (
			int32   foo
		)
		ldc.i4 500
		stloc foo
		ldloc foo
		ldc.i4 500
		ceq
		stloc foo
		ldloc foo
		ret
	}
	
	.method static public int32 test_3_shl_regvars () il managed {
		.locals init (
			int32	a,
			int32	b,
			int32	r1,
			int32	r2,
			int32	r3
		)
			
		ldc.i4.2
		stloc      a
		ldc.i4.1
		stloc      b
	
		ldloc      a
		ldloc      b
		shl 
		stloc      r1
		
		ldloc      a
		ldloc      b
		shl 
		stloc      r2
		
		ldloc      a
		ldloc      b
		shl 
		stloc      r3
		
		ldloc      r1
		ldc.i4.4
		ceq
		
		ldloc      r2
		ldc.i4.4
		ceq
		
		ldloc      r3
		ldc.i4.4
		ceq
		
		add
		add
		
		ret
	}
	
	.method static public int32 test_1_fceq_to_i4 () il managed {
	
		.locals init (
			float64	foo,
			int32   val
		)

		ldc.r8      2
		stloc       foo
		
		ldloc       foo
		ldc.r8      2
		ceq
		stloc       val
		
		ldloc       val
		ret
	}

	//
	// This should be manually checked. Basically under -O=linears,
	// you should not see tons of register spilling.
	//
	.method static public int32 test_1_bytedreg_free () il managed {
		.locals init (
			int32   foo
		)
		ldc.i4 500
		stloc foo
		ldloc foo
		ldc.i4 500
		ceq
		stloc foo
		
		ldloc foo
		ldc.i4 1
		ceq
		stloc foo

		ldloc foo
		ldc.i4 1
		ceq
		stloc foo

		ldloc foo
		ldc.i4 1
		ceq
		stloc foo
		
		ldloc foo
		ldc.i4 1
		ceq
		stloc foo
		
		ldloc foo
		ret
	}
	
	//
	// This should be manually checked. Basically under -O=linears,
	// you should not see tons of register spilling.
	//
	.method static public int32 test_0_bytesreg1_free () il managed {
		.locals init (
			unsigned int8	   dest,
			int32	           src,
			unsigned int8&	   pdest
		)

		ldloca     dest
		stloc      pdest
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldind.i1
		ret
	}
	
	.method static public int32 test_1_shift_regvar () il managed {
	
		.locals init (
			int32   v7FFFFFFF,
			int32   v1
		)
		
		ldc.i4	0x7FFFFFFF
		stloc   v7FFFFFFF
	
		ldc.i4.1
		stloc v1
		
		ldloc   v7FFFFFFF
		ldloc   v1
		shl
		ldc.i4	0xFFFFFFFE
		ceq
		ret
	}
	
	// this only happens with the managed pointer, not an unmanaged one.
	.method static public int32 test_0_foo () il managed {
	
		.locals init (
			int32&	buf
		)
		
		ldc.i4.5
		localloc
		
		stloc buf
		ldloc buf
		
		ldind.i4
		
		ret
	}

	.method static public int32 test_0_localloc () cil managed {
		.locals init (native int, native int, native int, native int, int32)

		ldc.i4 6
		localloc
		conv.i
		stloc.0

		ldc.i4 6
		localloc
		conv.i
		stloc.1

		ldc.i4 6
		localloc
		conv.i
		stloc.2

		// Variable length
		ldc.i4 128
		stloc.s 4
		ldloc.s 4
		localloc
		conv.i
		stloc.3

		// Check zero initialized
		ldloc.0
		ldind.i4
		ldc.i4.0
		beq OK1
		ldc.i4.1
		br FAIL

OK1:
		ldloc.3
		ldind.i4
		ldc.i4.0
		beq OK2
		ldc.i4.2
		br FAIL

OK2:
		ldloc.3
		ldc.i4.s 124
		add
		ldind.i4
		ldc.i4.0
		beq OK3
		ldc.i4.3
		br FAIL

OK3:
		ldloc.1
		ldc.i4 999999
		stind.i4
		ldloc.1
		ldind.i4
		ldc.i4 999999
		beq OK4
		ldc.i4.4
		br FAIL

OK4:
		ldloc.0
		ldc.i4 999999
		stind.i4
		ldloc.0
		ldind.i4
		ldc.i4 999999
		beq OK5
		ldc.i4.5
		br FAIL

OK5:
		// Try allocations bigger than one page
		ldc.i4 8196
		localloc
		conv.i
		stloc.3
		ldloc.3
		ldc.i4 8192
		add
		ldc.i4 99
		stind.i4
		ldloc.3
		ldc.i4 8192
		add
		ldind.i4
		ldc.i4 99
		beq PASS
		ldc.i4.6
		br FAIL

FAIL:
		ret

PASS:	ldc.i4.0
		ret
	}

    .method private static void do_localloc () cil managed {
        .maxstack 3
        .locals init (
                unsigned int8*  V_0)
        IL_0000:  ldc.i4.1
        IL_0001:  ldc.i4 131072
        IL_0006:  mul
        IL_0007:  localloc
        IL_0009:  stloc.0
        IL_000a:  ret
    }

	// Check that localloc can't be inlined
	.method static public int32 test_0_localloc_inline () cil managed {
		.maxstack 16
		.locals init (
			int32 i
		)

		ldc.i4.0
        stloc.0
        br COND

START:  call void class Tests::do_localloc()
        ldloc.0
        ldc.i4.1
        add
        stloc.0
COND:   ldloc.0
        ldc.i4 1000
        blt START

		ldc.i4.0
		ret
	}	
	
	.method static public int32 test_3_copy_used_bug () il managed {

		.locals init (
			int32 size,
			int32 res
		)

		ldc.i4 0
		stloc res

		ldc.i4 1
		stloc size

		ldloc size
		ldloc size
		ldloc size
		add
		stloc size
		ldloc size
		add
		stloc res

		ldloc res
		ret
	}

	// demonstrate that the copy_used_var is not a fix for the above bug
	.method static public int32 test_3_copy_used_indir_bug () il managed {

		.locals init (
			int32 size,
			int32 res
		)

		ldc.i4 0
		stloc res

		ldc.i4 1
		stloc size

		ldloc size
		ldloca size
		ldloc size
		ldloc size
		add
		stind.i4
		ldloc size
		add
		stloc res

		ldloc res
		ret
	}

	.method static public void do_nothing (int32 a) il managed {
		ret
	}
	
	// demonstrate the block_split failure: needs -O=inline
	// mini -O=inline --compile Tests:test_0_split_block_bug iltests.exe
	.method static public int32 test_0_split_block_bug () il managed {

		.locals init (
			int32 i1
		)

		ldc.i4 1
		stloc i1
 test_label:
		ldloc i1
		call void class Tests::do_nothing (int32)
		ldc.i4 0
		brtrue test_label
		
		ldc.i4 0
		ret
	}

	.method public void inline_do_nothing () il managed {
		ret
	}
	.method static public int32 test_1_checkthis_inlining () il managed {
		ldnull
		call instance void class Tests::inline_do_nothing ()
		ldc.i4 1
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TailCallStruct 
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
	}

	.method static valuetype Tests/TailCallStruct tail1 (valuetype Tests/TailCallStruct arg) {
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStruct::a
		ldc.i4.1
		add
		stfld int32 Tests/TailCallStruct::a
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStruct::a
		ldc.i4.2
		add
		stfld int32 Tests/TailCallStruct::a
		ldarg.0
		ret
	}

	.method static valuetype Tests/TailCallStruct tail2 (valuetype Tests/TailCallStruct arg) {
		ldarg.0
		tail.
		call valuetype Tests/TailCallStruct Tests::tail1 (valuetype Tests/TailCallStruct)
		ret
	}

#if arch != __ppc__
	//
	// Tail calls are not supported on PowerPC.
	// 
	.method static public int32 test_0_tail_calls () il managed {
		.maxstack 16
		.locals init (
			valuetype Tests/TailCallStruct arg
		)
		ldloca 0
		ldc.i4.2
		stfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldc.i4.4
		stfld int32 Tests/TailCallStruct::b
		ldloc.0
		call valuetype Tests/TailCallStruct Tests::tail2 (valuetype Tests/TailCallStruct)
		stloc.0
		ldloca 0
		ldfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldfld int32 Tests/TailCallStruct::b
		add
		ldc.i4 9
		sub
		ret
	}

	.method static public int32 tail3 (int32 i, int32 j) il managed {
		ldarg.0
		ldarg.1
		add
		ret
	}

	.method static public int32 tail4 (int32 i, int32 j) il managed {
		.maxstack 16
		.locals init (
			int32 k)

		// Test arg0 allocated to a register
		ldarg.0
		ldarg.0
		ldarg.0
		ldarg.0
		add
		add
		add
		starg 0

		// Test switched up argument variables as the actual arguments
		ldarg.1
		ldarg.0
		tail.
		call int32 Tests::tail3 (int32, int32)
		ret
	}

	.method static public int32 test_24_tail_calls2 () il managed {
		.maxstack 16
		.locals init (
			int32 i,
			int32 j)

		ldc.i4.4
		stloc.0
		ldc.i4.8
		stloc.1

		ldloc.0	
		ldloc.1
		call int32 Tests::tail4 (int32, int32)
		ret
	}
#endif

	.method public static int32 test_5_jmp () cil managed {
		jmp int32 Tests::jmp2 ()
		ldc.i4.0
		ret
	}

	.method public static int32 jmp2 () cil managed {
		ldc.i4.5
		ret
	}		

	.method static public int32 test_11_switch_with_nonempty_stack () il managed {
		.maxstack 16

		ldc.i4.5
		ldc.i4.6
		ldc.i4.1
		switch (L0, L1)
	L0: 
		add
		ret
	L1:
		add
		ret
	}
 
    .method public static int32 test_5_endfinally_with_nonempty_stack () il managed {
		.maxstack 16

        .try {
          leave IL_0
        }
        finally  {
          ldc.i4.0
          endfinally
        }
        IL_0:  ldc.i4.5
		ret
    }

	.method public static int32 test_0_conv_ovf_i8_neg () il managed {
		.maxstack 16

		ldc.i4.m1
		conv.ovf.i8
		conv.i4
		ldc.i4.m1
		beq L_OK
		ldc.i4.1
		ret
	L_OK:
		ldc.i4.0
		ret
	}		

	.method public static int32 test_1234_conv_u4 () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.u4
		conv.i4
		ret
	}

	.method public static int32 test_0_conv_ovf_i_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4 0x7fffffff
		conv.ovf.i.un
		conv.i4
		ldc.i4 0x7fffffff
		beq L2
		ldc.i4.2
		ret
	L2:
		sizeof [mscorlib]System.IntPtr
		ldc.i4 8
		beq L5
		.try {
			ldc.i4 0x80000000
			conv.ovf.i.un
			leave L4
		} catch [mscorlib]System.OverflowException {
			pop
			leave L5
		}
	L4: 
		ldc.i4.3
		ret
	L5:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_u_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.u.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_i () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_u () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.u
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_i () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_u () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_i_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_u_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_to_ovf_u8_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u8.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_2_lconv_to_ovf_i4_un () cil managed {
		.maxstack 16
		.locals init (int32 res)

		ldc.i4 0x7fffffff
		conv.u8
		conv.ovf.i4.un
		pop

		ldc.i4.2
		stloc res

        .try {
			ldc.i8 0x80000000
			conv.ovf.i4.un
			pop
			ldc.i4.0
			stloc res
			leave RET
		} catch [mscorlib]System.OverflowException {
			pop
			leave IL_0
		}

	IL_0:

        .try {
			ldc.i8 0xffffffff80000000
			conv.ovf.i4.un
			pop
			ldc.i4.1
			stloc res
			leave RET
		} catch [mscorlib]System.OverflowException {
			pop
			leave RET
		}

	RET:
		ldloc res
		ret
	}

    .method public static int32 test_1_lconv_to_ovf_i_un () cil managed {
		.maxstack 16
		.locals init (int32 res)

		ldc.i4 0x7fffffff
		conv.u8
		conv.ovf.i.un
		conv.i4
		pop

		ldc.i4.1
		ret
	}

	.method public static int32 test_32_lconv_to_u8 () cil managed
	{
		.maxstack 16

		ldc.i4 32
		conv.i8
		conv.u8
		conv.i4
		ret
	}				

	.method public static int32 test_32_lconv_to_i8 () cil managed
	{
		.maxstack 16

		ldc.i4 32
		conv.i8
		conv.i8
		conv.i4
		ret
	}				

	.method public static int32 test_15_lconv_to_u () cil managed
	{
     	ldc.i8 0x10000000f
		conv.u
		conv.i4
		ret
	}

	.method public static int32 test_0_get_type_from_handle_on_bblock_boundary () cil managed 
	{
		.maxstack 16
	
		ldc.i4.1
		brfalse OBJECT
	
		ldtoken [mscorlib]System.String
		br AFTER
	OBJECT:
		ldtoken [mscorlib]System.Object
	AFTER:
		call class [mscorlib]'System.Type' class [mscorlib]'System.Type'::'GetTypeFromHandle'(valuetype [mscorlib]'System.RuntimeTypeHandle')
		callvirt instance string class [mscorlib]System.Type::get_FullName ()
		ldstr "System.String"
		callvirt instance bool class [mscorlib]System.Object::Equals(object)
		ldc.i4.0
		ceq
		ret 
	}
		
	.method public static int32 test_0_bug59580  ()
	{
	        ldc.r4          float32(0x7FC00000)
	        ldc.r4          float32(0x7FC00000)
        	bge.un          pass
	        br              fail
	pass:
        	ldc.i4.0
	        ret
	fail:
        	ldc.i4.1
	        ret
	}
	
	.method public static int32 test_1_bug60056  () {
		.locals init (int32 m5)
			
		ldc.i4.m1
		stloc.0
		
		ldc.i4.1
		conv.u8
		
		ldloc.0
		conv.i8
		mul
		
		ldc.i4.m1
		conv.i8
		ceq
		ret
	}
	
	.method public static int32 test_1_conv_u8_cfold  () {
		ldc.i4.m1
		conv.u8
		
		ldc.i8 0x00000000ffffffff
		
		ceq
		ret
	}
	
	.method public static int32 test_1_array_type_mismatch_ldelema  () {
		.locals init (int32 r)
		
			ldc.i4.1
			newarr string
			ldc.i4.0 
			ldelema string
			pop
		
		.try {
			ldc.i4.1
			newarr string
			ldc.i4.0 
			ldelema object
			pop
			
			leave end
		} catch [mscorlib]System.ArrayTypeMismatchException {
			pop
			ldc.i4.1
			stloc.0
			leave end
		}
	end:
		ldloc.0
		ret
	}

	.method public static int32 test_1_conv_ovf_i8_with_i4 () {
			ldc.i4.m1 
			conv.ovf.i8
			conv.ovf.i4
			neg
			ret
	}

	// bug #72148
    .method public static int32 test_0_initlocals_float_ptr () {
	.maxstack 3
	.locals init (
		float32[]	V_0,
		float32& pinned	V_1,
		unsigned int32	V_2)
	  		ldc.i4.s 0x0f
	  		newarr [mscorlib]System.Single
	  		stloc.0 
	  		ldloc.0 
	  		ldc.i4.0 
	  		ldc.r4 1.13
	  		stelem.r4 
	  		ldloc.0 
	  		ldc.i4.0 
	  		ldelema [mscorlib]System.Single
	  		stloc.1 
	  		ldloc.1 
	  		conv.i 
	  		ldind.u4 
	  		stloc.2 
			ldc.i4.0
			ret
	}

	.method public static int32 test_7_conv_ovf_u8_un () {
    	.maxstack  2
        .locals    init (unsigned int64)

        ldc.i4.7
        conv.ovf.u8.un
        stloc.0
		ldloc.0
		conv.i4
        ret
	}

	.method public static int32 test_1_bug_74591 () {
		.maxstack 16
		.locals init (int32)

		ldc.i4.m1
		stloc.0
		ldloc.0
		conv.ovf.i8
		ldc.i4.m1
		conv.ovf.i8
		mul.ovf
		conv.i4
		ret
	}

	.class nested public auto ansi Integer
  		extends [mscorlib]System.Object {

		.field public bool n

	    .method public hidebysig  specialname  rtspecialname 
           instance default void .ctor (unsigned int64 i, bool n)  cil managed 
	    {
			.maxstack 8
			ldarg.0
			call instance void class [mscorlib]System.Object::.ctor()
			ldarg.0
			ldarg.2
			stfld bool Tests/Integer::n
			ret
		}
	}

	.method public static int32 test_1_bug_74726 () {
		.maxstack 16

		ldc.i4.2
		conv.ovf.u8
		ldc.i4.1
		conv.ovf.u8
		mul.ovf.un
		ldc.i4.1
		newobj instance void class Tests/Integer::.ctor(unsigned int64, bool)
		ldfld bool Tests/Integer::n
		ldc.i4.1
		ceq
		ret
	}

	.class nested private auto ansi sealed xxx
  	extends [mscorlib]System.ValueType
   {
     .field  public   object a

     .method public hidebysig  specialname  rtspecialname 
            instance default void .ctor ()  cil managed 
     {
		 .maxstack 8
		 ret 
     }
   } // end of class xxx

	.method public static int32 test_0_newobj_vtype () {
		.maxstack 6
		.locals init (
			valuetype Tests/xxx V_0
		)

		newobj instance void valuetype Tests/xxx::.ctor ()
		stloc.0
		ldloca.s 0
		ldfld object Tests/xxx::a
		brfalse OK
		ldc.i4.s 1
		ret
	OK:
		ldc.i4.s 0
		ret
	}

	.method public static int32 test_1_filters () {
		.maxstack 16
		.locals init (
			int32 res
		)

		.try { // 0
			.try {
			  	ldstr "OnErrorSub test Exception"
			  	newobj instance void class [mscorlib]System.Exception::.ctor(string)
		  		throw 
		  		leave.s IL_0033
			}
			filter {
				pop
				ldc.i4.0
				endfilter
			} {
				pop
				// Should not be called
				ldc.i4.2
				stloc res
				leave.s IL_0033
			}
		}
		filter {
			pop
		  	ldc.i4.1
			endfilter 
		} {
		  pop
		  ldc.i4.1
		  stloc res	  
		  leave.s IL_0033

		}
		IL_0033:
		ldloc res
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TheStruct
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
	}

	.method public static int32 test_5_cpobj () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloca v_1
		ldloca v_0
		cpobj Tests/TheStruct

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add

		ret
	}

	.method public static int32 test_5_ldobj_stloc_optimization () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloca v_0
		ldobj valuetype Tests/TheStruct
		stloc.s v_1

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add

		ret
	}

	.method public static int32 test_1_cpobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0, 
				object v_1
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloca v_1
		ldloca v_0
		cpobj object

		ldloc v_0
		ldloc v_1
		ceq
		ret
	}

	.method public static int32 test_1_initobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloca v_0
		initobj object

		ldloc v_0
		ldnull
		ceq
		ret
	}

	.method public static int32 test_1_ldobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloc v_0
		ldloca v_0
		ldobj object
		ceq
		ret
	}

	.method public static int32 test_5_vtype_on_bb_boundary () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloc v_0
		br L_0
	L_0: stloc v_1

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add
		ret
	}

	.method public static int32 test_5_different_in_stacks () cil managed {
		.maxstack 16

			ldc.i4.1
		 	ldc.i4.1
		 	beq L_0

		 	ldc.i4.3
		 	ldc.i4.3
		 	br L_1
		 	ldc.i4.3
		 	ldc.i4.3
		 	br L_2
	 L_0: 	ldc.i4.2
			ldc.i4.3
			ldc.i4.1
			ldc.i4.1
			beq L_2
	 L_1:	add
			ret
	 L_2:	add
			ret
	}

	.method public static int32 test_3_larray_get_set () {
		.locals init (
			int32[2]	V_0)
			  
			ldc.i4.2 
			newobj instance void int32[0...]::.ctor(int32)
			stloc.0 
			ldloc.0 
			ldc.i4.0 
			ldc.i4 1
			call instance void int32[0...]::Set(int32, int32)
		    ldloc.0 
		    ldc.i4.1 
			ldc.i4 2
			call instance void int32[0...]::Set(int32, int32)

			ldloc.0
			ldc.i4.0
			call instance int32 int32[0...]::Get(int32)
			ldloc.0
			ldc.i4.1
			call instance int32 int32[0...]::Get(int32)
			add
			ret
	}

	.method public static int32 test_0_pop_side_effects () {
		.try {
			ldc.r8 1
			ldc.r8 0
			div
			ckfinite
			pop
			leave FAIL
		}
		catch [mscorlib]System.ArithmeticException {
			pop
			leave L_0
		}
		L_0:
		ldc.i4.0
		ret
		FAIL:
		ldc.i4.1
		ret
	}

	.method public static void regalloc_regress_78314_helper (object o) cil managed
	{
		ret
	}

	.method public static int32 test_1_regalloc_regress_78314 () cil managed
	{
    // Code size       68 (0x44)
    .maxstack  6
    .locals init (int32 V_0, bool V_1)
    IL_0000:  ldc.i4.0
    IL_0001:  stloc.0
    IL_0002:  br.s       IL_003b

    IL_0004:
    IL_001e:  ldc.i4.s   10
    IL_0020:  ldloc.0
    IL_0021:  shl
    IL_0022:  ldc.i4.s   10
    IL_0024:  ldloc.0
    IL_0025:  shl
    IL_0026:  ceq
    IL_0028:  box        [mscorlib]System.Boolean
    IL_0032:  call       void Tests::regalloc_regress_78314_helper(object)
    IL_0037:  ldloc.0
    IL_0038:  ldc.i4.1
    IL_0039:  add
    IL_003a:  stloc.0
    IL_003b:  ldloc.0
    IL_003c:  ldc.i4.8
    IL_003f:  blt.s      IL_0004

	ldloc.0
	ldc.i4.8
	ceq
	conv.i4
	ret	
  }

	.method public static void try_block_end_remove_if_useless () cil managed {
	    .maxstack  8

	    T_START:
	        ldstr   "Start"
			pop
	        leave.s COMPLETE
	    T1_END:

	    COMPLETE:
	        ret

	    F1_START:
	        ldstr   "Finally1"
			pop
	        endfinally
	    F1_END:

	    .try T_START to T1_END finally handler F1_START to F1_END
	}

	.method public static int32 test_0_try_block_end_remove_if_useless () cil managed {
		call void class Tests::try_block_end_remove_if_useless ()
		ldc.i4.0
		ret
	}

   .method private static int32 test_0_regress_78629_switch_next_ins_target ()  cil managed
    {
        ldc.i4.0
        switch (target)
        target: ldstr "bar"
		pop
		ldc.i4.0
        ret
    }

	// This belongs to basic-float.cs, but its hard to tell mcs/csc to
	// generate the non .un version of the opcodes
    .method private static  hidebysig 
           default int32 test_4_float_branch_nan ()  cil managed 
    {
        // Method begins at RVA 0x27a4
	// Code size 74 (0x4a)
	.maxstack 2
	.locals init (
		float64	V_0,
		float64	V_1,
		int32	V_2)
	IL_0000:  ldc.r8 (00 00 00 00 00 00 f8 ff)
	IL_0009:  stloc.0 
	IL_000a:  ldc.r8 1.
	IL_0013:  stloc.1 
	IL_0014:  ldc.i4.0 
	IL_0015:  stloc.2 
	IL_0016:  ldloc.0 
	IL_0017:  ldloc.1 
	IL_0018:  bge.s IL_001a

				br L1
	IL_001a:  ldloc.2 
	IL_001b:  ret 
	L1:
	IL_001c:  ldloc.2 
	IL_001d:  ldc.i4.1 
	IL_001e:  add 
	IL_001f:  stloc.2 
	IL_0020:  ldloc.0 
	IL_0021:  ldloc.1 
	IL_0022:  ble.s IL_002e
				br L2
	IL_002e:  ldloc.2 
	IL_002f:  ret 
	L2:
	IL_0030:  ldloc.2 
	IL_0031:  ldc.i4.1 
	IL_0032:  add 
	IL_0033:  stloc.2 
	IL_0034:  ldloc.0 
	IL_0035:  ldloc.1 
	IL_0036:  blt.s IL_0038
				br L3		
	IL_0038:  ldloc.2 
	IL_0039:  ret 
	L3:
	IL_003a:  ldloc.2 
	IL_003b:  ldc.i4.1 
	IL_003c:  add 
	IL_003d:  stloc.2 
	IL_003e:  ldloc.0 
	IL_003f:  ldloc.1 
	IL_0040:  bgt.s IL_0042
				br L4
	IL_0042:  ldloc.2 
	IL_0043:  ret 
	L4:
	IL_0044:  ldloc.2 
	IL_0045:  ldc.i4.1 
	IL_0046:  add 
	IL_0047:  stloc.2 
	IL_0048:  ldloc.2 
	IL_0049:  ret 
    } // end of method Tests::test_5_float_branch_nan

    .method private static  hidebysig
           default void regress_80622_inner (object x)  cil managed
    {
		.locals (unsigned int8 i)
        // Method begins at RVA 0x2050
        // Code size 14 (0xe)
        .maxstack 8
        IL_1000:  ldarg.0
        IL_1001:  unbox unsigned int8
        IL_1006:  ldobj unsigned int8
        IL_000b:  conv.ovf.i4.un
        IL_000c:  pop
        IL_000d:  ret
    }

    // method line 2
    .method private static  hidebysig
           default int32 test_0_regress_80622 ()  cil managed
    {
        .maxstack 8
        IL_0000:  ldc.i4 255
        IL_0005:  box unsigned int8
        IL_000a:  call void class Tests::regress_80622_inner (object)
		ldc.i4.0
        IL_000f:  ret
    }

	.method private static default int32 test_0_regresss_80190 () cil managed
	{
	    .maxstack  2
	    .locals init (int32 V_0,
	             int32* V_1)
	    IL_0000:  nop
	    IL_0001:  nop
	    IL_0002:  ldloca.s   V_0
	    IL_0004:  conv.u
	    IL_0005:  stloc.1
	    IL_0006:  ldloc.1
	    IL_0007:  ldc.i4.3
	    IL_0008:  stind.i4
	    IL_0009:  nop
				  ldc.i4.0
				  ret
	}

	.class interface nested public auto ansi abstract IFaceWithStaticMethod
	{
	    .method public static  specialname 
    	       default void foo ()  cil managed noinlining 
	    {
		.maxstack 0
		IL_0000:  ret 
    	}
	}
	
	.class nested public auto ansi AClass extends [mscorlib]System.Object implements Tests/IFaceWithStaticMethod
	{
	    .method public hidebysig  specialname  rtspecialname 
           instance default void .ctor ()  cil managed 
	    {
			.maxstack 8
			ret
		}

	}

	// Test that static methods in interfaces are ignored during vtable construction
	.method private static default int32 test_0_ifaces_with_static_methods () cil managed
	{
		.maxstack 16

		newobj instance void class Tests/AClass::.ctor()
		pop
		ldc.i4.0
		ret
	}

	.method private static hidebysig default int32 Foo<T> (!!T n)  cil managed {
		ldarg.0
		box !!0
		brtrue HAS_VALUE
		ldc.i4.0
		ret
HAS_VALUE:	ldc.i4.1
		ret
	}

	// bug 78019
	.method static public int32 test_0_nullable_box_brtrue () cil managed {

		.locals init (valuetype [mscorlib]System.Nullable`1<int32> V_0)

		ldloc.0
		call int32 class Tests::Foo<valuetype [mscorlib]System.Nullable`1<int32>> (!!0)
		ret
	}

	//Bug 372410
	.method static public int32 test_0_ldelema_type_check () cil managed {
		.maxstack 16
		.locals init (object[] V_0,
					  object[,] V_1)

		ldc.i4.1
		newarr object
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			ldelema object
			leave L1
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR1
		}

	L1:
		ldc.i4.1
		newarr string
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			ldelema object
			leave ERROR2
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave L2
		}

	L2:
			ldc.i4.1
		newarr string
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			readonly. ldelema object
			leave L3
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR3
		}

	L3:
		ldc.i4.0
		ret


	ERROR1:
		ldc.i4.1
		ret

	ERROR2:
		ldc.i4.2
		ret

	ERROR3:
		ldc.i4.3
		ret
	}


	//Bug 372410
	.method static public int32 test_0_array_address_type_check () cil managed {
		.maxstack 16
		.locals init (object[] V_0,
					  object[,] V_1)

		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void object[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			call instance object&  object[,]::Address(int32, int32)
			leave L4
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR4
		}

	L4:
		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void string[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			call instance object&  object[,]::Address(int32, int32)
			leave ERROR5
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave L5
		}

	L5:
		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void string[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			readonly. call instance object&  object[,]::Address(int32, int32)
			leave L6
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR6
		}

	L6:
		ldc.i4.0
		ret
	ERROR4:
		ldc.i4.4
		ret

	ERROR5:
		ldc.i4.5
		ret

	ERROR6:
		ldc.i4.6
		ret
	}

	.field public  static unsigned int64 'ull'

	.field public  static int32 'shift2'

	.method public static int32 test_0_long_shift_regalloc () cil managed
	{
		.locals (unsigned int32 'cilsimp.28', unsigned int64 'cilsimp.27', int32 'cilsimp.26')

		.maxstack 4

		ldc.i8	81985529234382576
		stsfld	unsigned int64 Tests::ull
	    ldc.i4	60
		stsfld	int32 Tests::shift2

		ldsfld	unsigned int64 Tests::ull
		stloc	'cilsimp.27'
		ldsfld	int32 Tests::shift2
		stloc	'cilsimp.28'
		ldloc	'cilsimp.27'
		ldloc	'cilsimp.28'
		shr.un
		ldloc	'cilsimp.27'
		ldc.i4	64
		ldloc	'cilsimp.28'
		sub
		shl
		or
		ldc.i8	1311768467750121216
		ceq
		ldc.i4.1
		xor
		conv.u4
		ret
	}
}
