.assembly iltests {
  .custom instance void class [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::'.ctor'() =  (
		01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
		63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01       ) // ceptionThrows.
}
.assembly extern TestDriver {}
.assembly extern mscorlib {}

.class public auto ansi sealed beforefieldinit Tests {

	.method static public int32 Main(string[] args) il managed {
		.entrypoint
		
		ldtoken Tests
		call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
		ldarg.0
		call       int32 [TestDriver]TestDriver::RunTests(class [mscorlib]System.Type, string[])
		ret
	}

	// make sure the register allocator works when the return value of
	// 'div' is discarded
	.method static public int32 test_0_div_regalloc () il managed {
		.locals init (
			int32 i
		)

		ldloc 0
		ldc.i4.s 0xa
		div
		pop
		ldc.i4.0
		ret
	}
	
	
	.method static public int32 test_1_ceq_to_i4 () il managed {
		.locals init (
			int32   foo
		)
		ldc.i4 500
		stloc foo
		ldloc foo
		ldc.i4 500
		ceq
		stloc foo
		ldloc foo
		ret
	}
	
	.method static public int32 test_3_shl_regvars () il managed {
		.locals init (
			int32	a,
			int32	b,
			int32	r1,
			int32	r2,
			int32	r3
		)
			
		ldc.i4.2
		stloc      a
		ldc.i4.1
		stloc      b
	
		ldloc      a
		ldloc      b
		shl 
		stloc      r1
		
		ldloc      a
		ldloc      b
		shl 
		stloc      r2
		
		ldloc      a
		ldloc      b
		shl 
		stloc      r3
		
		ldloc      r1
		ldc.i4.4
		ceq
		
		ldloc      r2
		ldc.i4.4
		ceq
		
		ldloc      r3
		ldc.i4.4
		ceq
		
		add
		add
		
		ret
	}
	
	.method static public int32 test_1_fceq_to_i4 () il managed {
	
		.locals init (
			float64	foo,
			int32   val
		)

		ldc.r8      2
		stloc       foo
		
		ldloc       foo
		ldc.r8      2
		ceq
		stloc       val
		
		ldloc       val
		ret
	}

	//
	// This should be manually checked. Basically under -O=linears,
	// you should not see tons of register spilling.
	//
	.method static public int32 test_1_bytedreg_free () il managed {
		.locals init (
			int32   foo
		)
		ldc.i4 500
		stloc foo
		ldloc foo
		ldc.i4 500
		ceq
		stloc foo
		
		ldloc foo
		ldc.i4 1
		ceq
		stloc foo

		ldloc foo
		ldc.i4 1
		ceq
		stloc foo

		ldloc foo
		ldc.i4 1
		ceq
		stloc foo
		
		ldloc foo
		ldc.i4 1
		ceq
		stloc foo
		
		ldloc foo
		ret
	}
	
	//
	// This should be manually checked. Basically under -O=linears,
	// you should not see tons of register spilling.
	//
	.method static public int32 test_0_bytesreg1_free () il managed {
		.locals init (
			unsigned int8	   dest,
			int32	           src,
			unsigned int8&	   pdest
		)

		ldloca     dest
		stloc      pdest
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldind.i1
		ret
	}
	
	.method static public int32 test_1_shift_regvar () il managed {
	
		.locals init (
			int32   v7FFFFFFF,
			int32   v1
		)
		
		ldc.i4	0x7FFFFFFF
		stloc   v7FFFFFFF
	
		ldc.i4.1
		stloc v1
		
		ldloc   v7FFFFFFF
		ldloc   v1
		shl
		ldc.i4	0xFFFFFFFE
		ceq
		ret
	}
	
	// this only happens with the managed pointer, not an unmanaged one.
	.method static public int32 test_0_foo () il managed {
	
		.locals init (
			int32&	buf
		)
		
		ldc.i4.5
		localloc
		
		stloc buf
		ldloc buf
		
		ldind.i4
		
		ret
	}

	.method static public int32 test_0_localloc () cil managed {
		.locals init (native int, native int, native int, native int, int32)

		ldc.i4 6
		localloc
		conv.i
		stloc.0

		ldc.i4 6
		localloc
		conv.i
		stloc.1

		ldc.i4 6
		localloc
		conv.i
		stloc.2

		// Variable length
		ldc.i4 128
		stloc.s 4
		ldloc.s 4
		localloc
		conv.i
		stloc.3

		// Check zero initialized
		ldloc.0
		ldind.i4
		ldc.i4.0
		beq OK1
		ldc.i4.1
		br FAIL

OK1:
		ldloc.3
		ldind.i4
		ldc.i4.0
		beq OK2
		ldc.i4.2
		br FAIL

OK2:
		ldloc.3
		ldc.i4.s 124
		add
		ldind.i4
		ldc.i4.0
		beq OK3
		ldc.i4.3
		br FAIL

OK3:
		ldloc.1
		ldc.i4 999999
		stind.i4
		ldloc.1
		ldind.i4
		ldc.i4 999999
		beq OK4
		ldc.i4.4
		br FAIL

OK4:
		ldloc.0
		ldc.i4 999999
		stind.i4
		ldloc.0
		ldind.i4
		ldc.i4 999999
		beq OK5
		ldc.i4.5
		br FAIL

OK5:
		// Try allocations bigger than one page
		ldc.i4 8196
		localloc
		conv.i
		stloc.3
		ldloc.3
		ldc.i4 8192
		add
		ldc.i4 99
		stind.i4
		ldloc.3
		ldc.i4 8192
		add
		ldind.i4
		ldc.i4 99
		beq PASS
		ldc.i4.6
		br FAIL

FAIL:
		ret

PASS:	ldc.i4.0
		ret
	}

    .method private static void do_localloc () cil managed {
        .maxstack 3
        .locals init (
                unsigned int8*  V_0)
        IL_0000:  ldc.i4.1
        IL_0001:  ldc.i4 131072
        IL_0006:  mul
        IL_0007:  localloc
        IL_0009:  stloc.0
        IL_000a:  ret
    }

	// Check that localloc can't be inlined
	.method static public int32 test_0_localloc_inline () cil managed {
		.maxstack 16
		.locals init (
			int32 i
		)

		ldc.i4.0
        stloc.0
        br COND

START:  call void class Tests::do_localloc()
        ldloc.0
        ldc.i4.1
        add
        stloc.0
COND:   ldloc.0
        ldc.i4 1000
        blt START

		ldc.i4.0
		ret
	}	
	
	.method static public int32 test_3_copy_used_bug () il managed {

		.locals init (
			int32 size,
			int32 res
		)

		ldc.i4 0
		stloc res

		ldc.i4 1
		stloc size

		ldloc size
		ldloc size
		ldloc size
		add
		stloc size
		ldloc size
		add
		stloc res

		ldloc res
		ret
	}

	// demonstrate that the copy_used_var is not a fix for the above bug
	.method static public int32 test_3_copy_used_indir_bug () il managed {

		.locals init (
			int32 size,
			int32 res
		)

		ldc.i4 0
		stloc res

		ldc.i4 1
		stloc size

		ldloc size
		ldloca size
		ldloc size
		ldloc size
		add
		stind.i4
		ldloc size
		add
		stloc res

		ldloc res
		ret
	}

	.method static public void do_nothing (int32 a) il managed {
		ret
	}
	
	// demonstrate the block_split failure: needs -O=inline
	// mini -O=inline --compile Tests:test_0_split_block_bug iltests.exe
	.method static public int32 test_0_split_block_bug () il managed {

		.locals init (
			int32 i1
		)

		ldc.i4 1
		stloc i1
 test_label:
		ldloc i1
		call void class Tests::do_nothing (int32)
		ldc.i4 0
		brtrue test_label
		
		ldc.i4 0
		ret
	}

	.method public void inline_do_nothing () il managed {
		ret
	}
	.method static public int32 test_1_checkthis_inlining () il managed {
		ldnull
		call instance void class Tests::inline_do_nothing ()
		ldc.i4 1
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TailCallStruct 
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
	}

	.method static valuetype Tests/TailCallStruct tail1 (valuetype Tests/TailCallStruct arg) {
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStruct::a
		ldc.i4.1
		add
		stfld int32 Tests/TailCallStruct::a
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStruct::a
		ldc.i4.2
		add
		stfld int32 Tests/TailCallStruct::a
		ldarg.0
		ret
	}

	.method static valuetype Tests/TailCallStruct tail2 (valuetype Tests/TailCallStruct arg) {
		ldarg.0
		tail.
		call valuetype Tests/TailCallStruct Tests::tail1 (valuetype Tests/TailCallStruct)
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TailCallStructBig
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
		.field public int32 c
		.field public int32 d
		.field public int32 e
	}

	.method static valuetype Tests/TailCallStructBig tail_vret_by_addr_inner (valuetype Tests/TailCallStructBig arg) {
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStructBig::a
		ldc.i4.1
		add
		stfld int32 Tests/TailCallStructBig::a
		ldarg.0
		ret
	}

	.method static valuetype Tests/TailCallStructBig tail_vret_by_addr (valuetype Tests/TailCallStructBig arg) {
		ldarg.0
		tail.
		call valuetype Tests/TailCallStructBig Tests::tail_vret_by_addr_inner (valuetype Tests/TailCallStructBig)
		ret
	}

	.method static public int32 test_3_tail_call_vret_by_addr () il managed {
		.maxstack 16
		.locals init (
			valuetype Tests/TailCallStructBig arg2
		)

		ldloca 0
		ldc.i4.2
		stfld int32 Tests/TailCallStructBig::a
		ldloc.0
		call valuetype Tests/TailCallStructBig Tests::tail_vret_by_addr (valuetype Tests/TailCallStructBig)
		stloc.0

		ldloca 0
		ldfld int32 Tests/TailCallStructBig::a
		ret
	}

	.method static public int32 test_9_tail_call_vret_by_val () il managed {
		.maxstack 16
		.locals init (
			valuetype Tests/TailCallStruct arg
		)
		ldloca 0
		ldc.i4.2
		stfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldc.i4.4
		stfld int32 Tests/TailCallStruct::b
		ldloc.0
		call valuetype Tests/TailCallStruct Tests::tail2 (valuetype Tests/TailCallStruct)
		stloc.0

		ldloca 0
		ldfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldfld int32 Tests/TailCallStruct::b
		add
		ret
	}

	.method static public int32 tail3 (int32 i, int32 j) il managed {
		ldarg.0
		ldarg.1
		add
		ret
	}

	.method static public int32 tail4 (int32 i, int32 j) il managed {
		.maxstack 16
		.locals init (
			int32 k)

		// Test arg0 allocated to a register
		ldarg.0
		ldarg.0
		ldarg.0
		ldarg.0
		add
		add
		add
		starg 0

		// Test switched up argument variables as the actual arguments
		ldarg.1
		ldarg.0
		tail.
		call int32 Tests::tail3 (int32, int32)
		ret
	}

	.method static public int32 test_24_tail_calls2 () il managed {
		// Some platforms might not be able to AOT tail calls
		.custom instance void class [TestDriver]CategoryAttribute::'.ctor'(string) =  (01 00 08 21 46 55 4C 4C 41 4F 54 00 00 ) // ...!FULLAOT..

		.maxstack 16
		.locals init (
			int32 i,
			int32 j)

		ldc.i4.4
		stloc.0
		ldc.i4.8
		stloc.1

		ldloc.0	
		ldloc.1
		call int32 Tests::tail4 (int32, int32)
		ret
	}

	.method public static int32 test_5_jmp () cil managed {
		// Some platforms might not be able to AOT tail calls
		.custom instance void class [TestDriver]CategoryAttribute::'.ctor'(string) =  (01 00 08 21 46 55 4C 4C 41 4F 54 00 00 ) // ...!FULLAOT..

		ldc.i4.1
		ldc.i4.2
		call int32 Tests::jmp2 (int32, int32)
		ret
	}

	.method public static int32 jmp2 (int32, int32) cil managed {
		ldarg.0
		ldc.i4.1
		add
		starg.s 0
		ldarg.1
		ldc.i4.1
		add
		starg.s 1
		jmp int32 Tests::jmp3 (int32, int32)
		ldc.i4.0
		ret
	}		

	.method public static int32 jmp3 (int32 i, int32 j) cil managed {
		ldarg.0
		ldarg.1
		add
		ret
	}

	.method static public int32 test_11_switch_with_nonempty_stack () il managed {
		.maxstack 16

		ldc.i4.5
		ldc.i4.6
		ldc.i4.1
		switch (L0, L1)
	L0: 
		add
		ret
	L1:
		add
		ret
	}
 
    .method public static int32 test_5_endfinally_with_nonempty_stack () il managed {
		.maxstack 16

        .try {
          leave IL_0
        }
        finally  {
          ldc.i4.0
          endfinally
        }
        IL_0:  ldc.i4.5
		ret
    }

	.method public static int32 test_0_conv_ovf_i8_neg () il managed {
		.maxstack 16

		ldc.i4.m1
		conv.ovf.i8
		conv.i4
		ldc.i4.m1
		beq L_OK
		ldc.i4.1
		ret
	L_OK:
		ldc.i4.0
		ret
	}		

	.method public static int32 test_1234_conv_u4 () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.u4
		conv.i4
		ret
	}

	.method public static int32 test_0_conv_ovf_i_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4 0x7fffffff
		conv.ovf.i.un
		conv.i4
		ldc.i4 0x7fffffff
		beq L2
		ldc.i4.2
		ret
	L2:
		sizeof [mscorlib]System.IntPtr
		ldc.i4 8
		beq L5
		.try {
			ldc.i4 0x80000000
			conv.ovf.i.un
			leave L4
		} catch [mscorlib]System.OverflowException {
			pop
			leave L5
		}
	L4: 
		ldc.i4.3
		ret
	L5:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_u_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.u.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_i () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_u () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.u
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_1234_conv_ovf_i8_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i8.un
		conv.i4
		ret
	}

	.method public static int32 test_0_lconv_ovf_i () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_u () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_i_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_u_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_to_ovf_i8 () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i8
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_to_ovf_u8_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u8.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_2_lconv_to_ovf_i4_un () cil managed {
		.maxstack 16
		.locals init (int32 res)

		ldc.i4 0x7fffffff
		conv.u8
		conv.ovf.i4.un
		pop

		ldc.i4.2
		stloc res

        .try {
			ldc.i8 0x80000000
			conv.ovf.i4.un
			pop
			ldc.i4.0
			stloc res
			leave RET
		} catch [mscorlib]System.OverflowException {
			pop
			leave IL_0
		}

	IL_0:

        .try {
			ldc.i8 0xffffffff80000000
			conv.ovf.i4.un
			pop
			ldc.i4.1
			stloc res
			leave RET
		} catch [mscorlib]System.OverflowException {
			pop
			leave RET
		}

	RET:
		ldloc res
		ret
	}

    .method public static int32 test_1_lconv_to_ovf_i_un () cil managed {
		.maxstack 16
		.locals init (int32 res)

		ldc.i4 0x7fffffff
		conv.u8
		conv.ovf.i.un
		conv.i4
		pop

		ldc.i4.1
		ret
	}

	.method public static int32 test_32_lconv_to_u8 () cil managed
	{
		.maxstack 16

		ldc.i4 32
		conv.i8
		conv.u8
		conv.i4
		ret
	}				

	.method public static int32 test_32_lconv_to_i8 () cil managed
	{
		.maxstack 16

		ldc.i4 32
		conv.i8
		conv.i8
		conv.i4
		ret
	}				

	.method public static int32 test_15_lconv_to_u () cil managed
	{
     	ldc.i8 0x10000000f
		conv.u
		conv.i4
		ret
	}

	.method public static int32 test_0_get_type_from_handle_on_bblock_boundary () cil managed 
	{
		.maxstack 16
	
		ldc.i4.1
		brfalse OBJECT
	
		ldtoken [mscorlib]System.String
		br AFTER
	OBJECT:
		ldtoken [mscorlib]System.Object
	AFTER:
		call class [mscorlib]'System.Type' class [mscorlib]'System.Type'::'GetTypeFromHandle'(valuetype [mscorlib]'System.RuntimeTypeHandle')
		callvirt instance string class [mscorlib]System.Type::get_FullName ()
		ldstr "System.String"
		callvirt instance bool class [mscorlib]System.Object::Equals(object)
		ldc.i4.0
		ceq
		ret 
	}
		
	.method public static int32 test_0_bug59580  ()
	{
	        ldc.r4          float32(0x7FC00000)
	        ldc.r4          float32(0x7FC00000)
        	bge.un          pass
	        br              fail
	pass:
        	ldc.i4.0
	        ret
	fail:
        	ldc.i4.1
	        ret
	}
	
	.method public static int32 test_1_bug60056  () {
		.locals init (int32 m5)
			
		ldc.i4.m1
		stloc.0
		
		ldc.i4.1
		conv.u8
		
		ldloc.0
		conv.i8
		mul
		
		ldc.i4.m1
		conv.i8
		ceq
		ret
	}
	
	.method public static int32 test_1_conv_u8_cfold  () {
		ldc.i4.m1
		conv.u8
		
		ldc.i8 0x00000000ffffffff
		
		ceq
		ret
	}
	
	.method public static int32 test_1_array_type_mismatch_ldelema  () {
		.locals init (int32 r)
		
			ldc.i4.1
			newarr string
			ldc.i4.0 
			ldelema string
			pop
		
		.try {
			ldc.i4.1
			newarr string
			ldc.i4.0 
			ldelema object
			pop
			
			leave end
		} catch [mscorlib]System.ArrayTypeMismatchException {
			pop
			ldc.i4.1
			stloc.0
			leave end
		}
	end:
		ldloc.0
		ret
	}

	.method public static int32 test_1_conv_ovf_i8_with_i4 () {
			ldc.i4.m1 
			conv.ovf.i8
			conv.ovf.i4
			neg
			ret
	}

	// bug #72148
    .method public static int32 test_0_initlocals_float_ptr () {
	.maxstack 3
	.locals init (
		float32[]	V_0,
		float32& pinned	V_1,
		unsigned int32	V_2)
	  		ldc.i4.s 0x0f
	  		newarr [mscorlib]System.Single
	  		stloc.0 
	  		ldloc.0 
	  		ldc.i4.0 
	  		ldc.r4 1.13
	  		stelem.r4 
	  		ldloc.0 
	  		ldc.i4.0 
	  		ldelema [mscorlib]System.Single
	  		stloc.1 
	  		ldloc.1 
	  		conv.i 
	  		ldind.u4 
	  		stloc.2 
			ldc.i4.0
			ret
	}

	.method public static int32 test_7_conv_ovf_u8_un () {
    	.maxstack  2
        .locals    init (unsigned int64)

        ldc.i4.7
        conv.ovf.u8.un
        stloc.0
		ldloc.0
		conv.i4
        ret
	}

	.method public static int32 test_7_conv_ovf_u4_un () {
    	.maxstack  2
        .locals    init (unsigned int32)

        ldc.i4.7
        conv.ovf.u4.un
        stloc.0
		ldloc.0
		conv.i4
        ret
	}

	.method public static int32 test_1_bug_74591 () {
		.maxstack 16
		.locals init (int32)

		ldc.i4.m1
		stloc.0
		ldloc.0
		conv.ovf.i8
		ldc.i4.m1
		conv.ovf.i8
		mul.ovf
		conv.i4
		ret
	}

	.class nested public auto ansi Integer
  		extends [mscorlib]System.Object {

		.field public bool n

	    .method public hidebysig  specialname  rtspecialname 
           instance default void .ctor (unsigned int64 i, bool n)  cil managed 
	    {
			.maxstack 8
			ldarg.0
			call instance void class [mscorlib]System.Object::.ctor()
			ldarg.0
			ldarg.2
			stfld bool Tests/Integer::n
			ret
		}
	}

	.method public static int32 test_1_bug_74726 () {
		.maxstack 16

		ldc.i4.2
		conv.ovf.u8
		ldc.i4.1
		conv.ovf.u8
		mul.ovf.un
		ldc.i4.1
		newobj instance void class Tests/Integer::.ctor(unsigned int64, bool)
		ldfld bool Tests/Integer::n
		ldc.i4.1
		ceq
		ret
	}

	.class nested private auto ansi sealed xxx
  	extends [mscorlib]System.ValueType
   {
     .field  public   object a

     .method public hidebysig  specialname  rtspecialname 
            instance default void .ctor ()  cil managed 
     {
		 .maxstack 8
		 ret 
     }
   } // end of class xxx

	.method public static int32 test_0_newobj_vtype () {
		.maxstack 6
		.locals init (
			valuetype Tests/xxx V_0
		)

		newobj instance void valuetype Tests/xxx::.ctor ()
		stloc.0
		ldloca.s 0
		ldfld object Tests/xxx::a
		brfalse OK
		ldc.i4.s 1
		ret
	OK:
		ldc.i4.s 0
		ret
	}

	.method public static int32 test_0_newobj_vtype_primitive () {
		.maxstack 6
		.locals init (
			native int V_0
		)

		ldc.i4.s 10
		newobj instance void native int::'.ctor'(int32)
		stloc.0
		ldloc.0
		ldc.i4.s 10
		beq OK
		ldc.i4.s 1
		ret
	OK:
		ldc.i4.s 0
		ret
	}

	.method public static int32 test_1_filters () {
		.maxstack 16
		.locals init (
			int32 res
		)

		.try { // 0
			.try {
			  	ldstr "OnErrorSub test Exception"
			  	newobj instance void class [mscorlib]System.Exception::.ctor(string)
		  		throw 
		  		leave.s IL_0033
			}
			filter {
				pop
				ldc.i4.0
				endfilter
			} {
				pop
				// Should not be called
				ldc.i4.2
				stloc res
				leave.s IL_0033
			}
		}
		filter {
			pop
		  	ldc.i4.1
			endfilter 
		} {
		  pop
		  ldc.i4.1
		  stloc res	  
		  leave.s IL_0033

		}
		IL_0033:
		ldloc res
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TheStruct
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
	}

	.method public static int32 test_5_cpobj () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloca v_1
		ldloca v_0
		cpobj Tests/TheStruct

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add

		ret
	}

	.method public static int32 test_5_ldobj_stloc_optimization () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloca v_0
		ldobj valuetype Tests/TheStruct
		stloc.s v_1

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add

		ret
	}

	.method public static int32 test_1_cpobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0, 
				object v_1
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloca v_1
		ldloca v_0
		cpobj object

		ldloc v_0
		ldloc v_1
		ceq
		ret
	}

	.method public static int32 test_1_initobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloca v_0
		initobj object

		ldloc v_0
		ldnull
		ceq
		ret
	}

	.method public static int32 test_1_ldobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloc v_0
		ldloca v_0
		ldobj object
		ceq
		ret
	}

	.method public static int32 test_5_vtype_on_bb_boundary () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloc v_0
		br L_0
	L_0: stloc v_1

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add
		ret
	}

	.method public static int32 test_5_different_in_stacks () cil managed {
		.maxstack 16

			ldc.i4.1
		 	ldc.i4.1
		 	beq L_0

		 	ldc.i4.3
		 	ldc.i4.3
		 	br L_1
		 	ldc.i4.3
		 	ldc.i4.3
		 	br L_2
	 L_0: 	ldc.i4.2
			ldc.i4.3
			ldc.i4.1
			ldc.i4.1
			beq L_2
	 L_1:	add
			ret
	 L_2:	add
			ret
	}

	.method public static int32 test_3_larray_get_set () {
		.locals init (
			int32[2]	V_0)
			  
			ldc.i4.2 
			newobj instance void int32[0...]::.ctor(int32)
			stloc.0 
			ldloc.0 
			ldc.i4.0 
			ldc.i4 1
			call instance void int32[0...]::Set(int32, int32)
		    ldloc.0 
		    ldc.i4.1 
			ldc.i4 2
			call instance void int32[0...]::Set(int32, int32)

			ldloc.0
			ldc.i4.0
			call instance int32 int32[0...]::Get(int32)
			ldloc.0
			ldc.i4.1
			call instance int32 int32[0...]::Get(int32)
			add
			ret
	}

	.method public static int32 test_0_pop_side_effects () {
		.try {
			ldc.r8 1
			ldc.r8 0
			div
			ckfinite
			pop
			leave FAIL
		}
		catch [mscorlib]System.ArithmeticException {
			pop
			leave L_0
		}
		L_0:
		ldc.i4.0
		ret
		FAIL:
		ldc.i4.1
		ret
	}

	.method public static void regalloc_regress_78314_helper (object o) cil managed
	{
		ret
	}

	.method public static int32 test_1_regalloc_regress_78314 () cil managed
	{
    // Code size       68 (0x44)
    .maxstack  6
    .locals init (int32 V_0, bool V_1)
    IL_0000:  ldc.i4.0
    IL_0001:  stloc.0
    IL_0002:  br.s       IL_003b

    IL_0004:
    IL_001e:  ldc.i4.s   10
    IL_0020:  ldloc.0
    IL_0021:  shl
    IL_0022:  ldc.i4.s   10
    IL_0024:  ldloc.0
    IL_0025:  shl
    IL_0026:  ceq
    IL_0028:  box        [mscorlib]System.Boolean
    IL_0032:  call       void Tests::regalloc_regress_78314_helper(object)
    IL_0037:  ldloc.0
    IL_0038:  ldc.i4.1
    IL_0039:  add
    IL_003a:  stloc.0
    IL_003b:  ldloc.0
    IL_003c:  ldc.i4.8
    IL_003f:  blt.s      IL_0004

	ldloc.0
	ldc.i4.8
	ceq
	conv.i4
	ret	
  }

	.method public static void try_block_end_remove_if_useless () cil managed {
	    .maxstack  8

	    T_START:
	        ldstr   "Start"
			pop
	        leave.s COMPLETE
	    T1_END:

	    COMPLETE:
	        ret

	    F1_START:
	        ldstr   "Finally1"
			pop
	        endfinally
	    F1_END:

	    .try T_START to T1_END finally handler F1_START to F1_END
	}

	.method public static int32 test_0_try_block_end_remove_if_useless () cil managed {
		call void class Tests::try_block_end_remove_if_useless ()
		ldc.i4.0
		ret
	}

   .method private static int32 test_0_regress_78629_switch_next_ins_target ()  cil managed
    {
        ldc.i4.0
        switch (target)
        target: ldstr "bar"
		pop
		ldc.i4.0
        ret
    }

	// This belongs to basic-float.cs, but its hard to tell mcs/csc to
	// generate the non .un version of the opcodes
    .method private static  hidebysig 
           default int32 test_4_float_branch_nan ()  cil managed 
    {
        // Method begins at RVA 0x27a4
	// Code size 74 (0x4a)
	.maxstack 2
	.locals init (
		float64	V_0,
		float64	V_1,
		int32	V_2)
	IL_0000:  ldc.r8 (00 00 00 00 00 00 f8 ff)
	IL_0009:  stloc.0 
	IL_000a:  ldc.r8 1.
	IL_0013:  stloc.1 
	IL_0014:  ldc.i4.0 
	IL_0015:  stloc.2 
	IL_0016:  ldloc.0 
	IL_0017:  ldloc.1 
	IL_0018:  bge.s IL_001a

				br L1
	IL_001a:  ldloc.2 
	IL_001b:  ret 
	L1:
	IL_001c:  ldloc.2 
	IL_001d:  ldc.i4.1 
	IL_001e:  add 
	IL_001f:  stloc.2 
	IL_0020:  ldloc.0 
	IL_0021:  ldloc.1 
	IL_0022:  ble.s IL_002e
				br L2
	IL_002e:  ldloc.2 
	IL_002f:  ret 
	L2:
	IL_0030:  ldloc.2 
	IL_0031:  ldc.i4.1 
	IL_0032:  add 
	IL_0033:  stloc.2 
	IL_0034:  ldloc.0 
	IL_0035:  ldloc.1 
	IL_0036:  blt.s IL_0038
				br L3		
	IL_0038:  ldloc.2 
	IL_0039:  ret 
	L3:
	IL_003a:  ldloc.2 
	IL_003b:  ldc.i4.1 
	IL_003c:  add 
	IL_003d:  stloc.2 
	IL_003e:  ldloc.0 
	IL_003f:  ldloc.1 
	IL_0040:  bgt.s IL_0042
				br L4
	IL_0042:  ldloc.2 
	IL_0043:  ret 
	L4:
	IL_0044:  ldloc.2 
	IL_0045:  ldc.i4.1 
	IL_0046:  add 
	IL_0047:  stloc.2 
	IL_0048:  ldloc.2 
	IL_0049:  ret 
    } // end of method Tests::test_5_float_branch_nan

    .method private static  hidebysig
           default void regress_80622_inner (object x)  cil managed
    {
		.locals (unsigned int8 i)
        // Method begins at RVA 0x2050
        // Code size 14 (0xe)
        .maxstack 8
        IL_1000:  ldarg.0
        IL_1001:  unbox unsigned int8
        IL_1006:  ldobj unsigned int8
        IL_000b:  conv.ovf.i4.un
        IL_000c:  pop
        IL_000d:  ret
    }

    // method line 2
    .method private static  hidebysig
           default int32 test_0_regress_80622 ()  cil managed
    {
        .maxstack 8
        IL_0000:  ldc.i4 255
        IL_0005:  box unsigned int8
        IL_000a:  call void class Tests::regress_80622_inner (object)
		ldc.i4.0
        IL_000f:  ret
    }

	.method private static default int32 test_0_regresss_80190 () cil managed
	{
	    .maxstack  2
	    .locals init (int32 V_0,
	             int32* V_1)
	    IL_0000:  nop
	    IL_0001:  nop
	    IL_0002:  ldloca.s   V_0
	    IL_0004:  conv.u
	    IL_0005:  stloc.1
	    IL_0006:  ldloc.1
	    IL_0007:  ldc.i4.3
	    IL_0008:  stind.i4
	    IL_0009:  nop
				  ldc.i4.0
				  ret
	}

	.class interface nested public auto ansi abstract IFaceWithStaticMethod
	{
	    .method public static  specialname 
    	       default void foo ()  cil managed noinlining 
	    {
		.maxstack 0
		IL_0000:  ret 
    	}
	}
	
	.class nested public auto ansi AClass extends [mscorlib]System.Object implements Tests/IFaceWithStaticMethod
	{
	    .method public hidebysig  specialname  rtspecialname 
           instance default void .ctor ()  cil managed 
	    {
			.maxstack 8
			ret
		}

	}

	// Test that static methods in interfaces are ignored during vtable construction
	.method private static default int32 test_0_ifaces_with_static_methods () cil managed
	{
		.maxstack 16

		newobj instance void class Tests/AClass::.ctor()
		pop
		ldc.i4.0
		ret
	}

	.method private static hidebysig default int32 Foo<T> (!!T n)  cil managed {
		ldarg.0
		box !!0
		brtrue HAS_VALUE
		ldc.i4.0
		ret
HAS_VALUE:	ldc.i4.1
		ret
	}

	// bug 78019
	.method static public int32 test_0_nullable_box_brtrue () cil managed {

		.locals init (valuetype [mscorlib]System.Nullable`1<int32> V_0)

		ldloc.0
		call int32 class Tests::Foo<valuetype [mscorlib]System.Nullable`1<int32>> (!!0)
		ret
	}

	//Bug 372410
	.method static public int32 test_0_ldelema_type_check () cil managed {
		.maxstack 16
		.locals init (object[] V_0,
					  object[,] V_1)

		ldc.i4.1
		newarr object
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			ldelema object
			leave L1
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR1
		}

	L1:
		ldc.i4.1
		newarr string
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			ldelema object
			leave ERROR2
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave L2
		}

	L2:
			ldc.i4.1
		newarr string
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			readonly. ldelema object
			leave L3
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR3
		}

	L3:
		ldc.i4.0
		ret


	ERROR1:
		ldc.i4.1
		ret

	ERROR2:
		ldc.i4.2
		ret

	ERROR3:
		ldc.i4.3
		ret
	}


	//Bug 372410
	.method static public int32 test_0_array_address_type_check () cil managed {
		.maxstack 16
		.locals init (object[] V_0,
					  object[,] V_1)

		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void object[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			call instance object&  object[,]::Address(int32, int32)
			leave L4
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR4
		}

	L4:
		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void string[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			call instance object&  object[,]::Address(int32, int32)
			leave ERROR5
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave L5
		}

	L5:
		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void string[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			readonly. call instance object&  object[,]::Address(int32, int32)
			leave L6
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR6
		}

	L6:
		ldc.i4.0
		ret
	ERROR4:
		ldc.i4.4
		ret

	ERROR5:
		ldc.i4.5
		ret

	ERROR6:
		ldc.i4.6
		ret
	}

	.field public  static unsigned int64 'ull'

	.field public  static int32 'shift2'

	.method public static int32 test_0_long_shift_regalloc () cil managed
	{
		.locals (unsigned int32 'cilsimp.28', unsigned int64 'cilsimp.27', int32 'cilsimp.26')

		.maxstack 4

		ldc.i8	81985529234382576
		stsfld	unsigned int64 Tests::ull
	    ldc.i4	60
		stsfld	int32 Tests::shift2

		ldsfld	unsigned int64 Tests::ull
		stloc	'cilsimp.27'
		ldsfld	int32 Tests::shift2
		stloc	'cilsimp.28'
		ldloc	'cilsimp.27'
		ldloc	'cilsimp.28'
		shr.un
		ldloc	'cilsimp.27'
		ldc.i4	64
		ldloc	'cilsimp.28'
		sub
		shl
		or
		ldc.i8	1311768467750121216
		ceq
		ldc.i4.1
		xor
		conv.u4
		ret
	}

	// Test calling ldfld directly on a vtype instead of a vtype address
	.method public static int32 test_5_call_ldfld_vtype () cil managed
	{
		.maxstack 16
		.locals init (
			valuetype Tests/TailCallStruct arg
		)
		ldloca 0
		ldc.i4.2
		stfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldc.i4.4
		stfld int32 Tests/TailCallStruct::b
		ldloc.0
		call valuetype Tests/TailCallStruct Tests::tail2 (valuetype Tests/TailCallStruct)
		ldfld int32 Tests/TailCallStruct::a
		ret
	}

	.method public static int32 throw_ret () cil managed
	{
		ldstr "FOO"
		newobj instance void class [mscorlib]System.OverflowException::.ctor(string)
		throw
		ldc.i4.4
		ret
	}

	.method public static int32 throw2_ret () cil managed
	{
		// Disable inlining
		ldc.i4.5
		localloc
		pop

		call int32 Tests::throw_ret ()
		ret
	}

	// Test inlining a method which contains just a throw
	.method public static int32 test_0_inline_throw () cil managed
	{
		.maxstack 16
		.locals init (
				int32 v_0
		)

		.try {
			call int32 Tests::throw2_ret ()
			stloc.0
			leave L0
		} catch [mscorlib]System.OverflowException {
			pop
			leave L1
		}

		L0:
			ldc.i4.1
			ret
		L1:
			ldc.i4.0
			ret			
	}

    .method public static int32 test_0_stelem_any_null_opt () cil managed
    {
		.maxstack 16
		.locals init (
				object[]	V_0,
				int32	V_1)

		ldc.i4.s 10
		newarr [mscorlib]System.Object
		stloc.0

		ldc.i4.0
		stloc.1
		br L0

	L1:
		ldloc.0
		ldloc.1
		ldnull
		stelem.any [mscorlib]System.Object
		ldloc.1
		ldc.i4.1
		add
		stloc.1
	L0:
		ldloc.1
		ldc.i4.s 10
		blt L1

		ldc.i4.0
		ret
	}

    // method line 2
    .method public static  hidebysig 
           default int32 manyargs_callee (int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 g, int32 h, int32 i, int32 j, int32 k, int32 l, int32 m, int32 n, int32 o, int32 p)  cil managed 
    {
        // Method begins at RVA 0x20f4
	// Code size 44 (0x2c)
	.maxstack 8
	IL_0000:  ldarg.0 
	IL_0001:  ldarg.1 
	IL_0002:  add 
	IL_0003:  ldarg.2 
	IL_0004:  add 
	IL_0005:  ldarg.3 
	IL_0006:  add 
	IL_0007:  ldarg.s 4
	IL_0009:  add 
	IL_000a:  ldarg.s 5
	IL_000c:  add 
	IL_000d:  ldarg.s 6
	IL_000f:  add 
	IL_0010:  ldarg.s 7
	IL_0012:  add 
	IL_0013:  ldarg.s 8
	IL_0015:  add 
	IL_0016:  ldarg.s 9
	IL_0018:  add 
	IL_0019:  ldarg.s 10
	IL_001b:  add 
	IL_001c:  ldarg.s 11
	IL_001e:  add 
	IL_001f:  ldarg.s 12
	IL_0021:  add 
	IL_0022:  ldarg.s 13
	IL_0024:  add 
	IL_0025:  ldarg.s 14
	IL_0027:  add 
	IL_0028:  ldarg.s 15
	IL_002a:  add 
	IL_002b:  ret 
    } // end of method main::callee

    // method line 3
    .method public static  hidebysig 
           default int32 manyargs_tail_caller (int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 g, int32 h, int32 i, int32 j, int32 k, int32 l, int32 m, int32 n, int32 o, int32 p)  cil managed 
    {
        // Method begins at RVA 0x2124
	// Code size 34 (0x22)
	.maxstack 17
	IL_0000:  ldarg.0 
	IL_0001:  ldarg.1 
	IL_0002:  ldarg.2 
	IL_0003:  ldarg.3 
	IL_0004:  ldarg.s 4
	IL_0006:  ldarg.s 5
	IL_0008:  ldarg.s 6
	IL_000a:  ldarg.s 7
	IL_000c:  ldarg.s 8
	IL_000e:  ldarg.s 9
	IL_0010:  ldarg.s 10
	IL_0012:  ldarg.s 11
	IL_0014:  ldarg.s 12
	IL_0016:  ldarg.s 13
	IL_0018:  ldarg.s 14
	IL_001a:  ldarg.s 15
	          tail.
	IL_001c:  call int32 class Tests::manyargs_callee(int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)
	IL_0021:  ret 
    } // end of method main::caller

    // method line 4
    .method public static  hidebysig 
           default int32 test_0_many_args_tail_call ()  cil managed 
    {
		// Some platforms might not be able to AOT tail calls
		.custom instance void class [TestDriver]CategoryAttribute::'.ctor'(string) =  (01 00 08 21 46 55 4C 4C 41 4F 54 00 00 ) // ...!FULLAOT..

        // Method begins at RVA 0x2154
	// Code size 43 (0x2b)
	.maxstack 17
	IL_0000:  ldc.i4.1 
	IL_0001:  ldc.i4.2 
	IL_0002:  ldc.i4.3 
	IL_0003:  ldc.i4.4 
	IL_0004:  ldc.i4.5 
	IL_0005:  ldc.i4.6 
	IL_0006:  ldc.i4.7 
	IL_0007:  ldc.i4.8 
	IL_0008:  ldc.i4.s 0x09
	IL_000a:  ldc.i4.s 0x0a
	IL_000c:  ldc.i4.s 0x0b
	IL_000e:  ldc.i4.s 0x0c
	IL_0010:  ldc.i4.s 0x0d
	IL_0012:  ldc.i4.s 0x0e
	IL_0014:  ldc.i4.s 0x0f
	IL_0016:  ldc.i4.s 0x10
	IL_0018:  call int32 class Tests::manyargs_tail_caller(int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)
	IL_001d:  ldc.i4 136
	IL_0022:  beq IL_0029

	IL_0027:  ldc.i4.1 
	IL_0028:  ret 
	IL_0029:  ldc.i4.0 
	IL_002a:  ret 
    } // end of method main::Main

	.class nested private auto ansi beforefieldinit R1
    	   extends [mscorlib]System.MarshalByRefObject
	{
		.field  public  int32 test_field

    	.method public hidebysig  specialname  rtspecialname
           		instance default void '.ctor' ()  cil managed
    	{
			ret
		}
	}

	.method public static hidebysig
			default int32 return_0 () cil managed
	{
		ldc.i4.0
		ret
	}

	.method public static hidebysig
			default int32 test_1_volatile_marshalbyref_bug_432673 () cil managed
	{
		.locals init (
			class Tests/R1 v_0
		)

		newobj instance void class Tests/R1::.ctor ()
		stloc.0
		ldloc.0
		ldc.i4.0
		volatile.
		stfld int32 Tests/R1::test_field
		call int32 class Tests::return_0 ()
		ldc.i4.1
		add
		ret
	}

	.method public static default int32 return_2 () cil managed
	{
		// Prevent inlining
		ldc.i4.s 16
        localloc
		pop
		ldc.i4.s 2
		ret
	}

	.method public static hidebysig
			default int32 test_1_cmov_opt_regress_463357 () cil managed
	{
		call int32 class Tests::return_2 ()
		ldc.i4.0
		ceq
		brfalse L1
		ldc.i4.0
		ret
		br L2
	L1: nop
	L2: nop
		ldc.i4.1
		ret
	}

   .method public static hidebysig default int32 cmov_opt_regress_474718_inner (int32 A_1)  cil managed 
   {
      .maxstack 3
      .locals init (int32 V_0, bool V_1, bool V_2)
      
	  ldc.i4.0
      IL_000b:  stloc.1 
      IL_000d:  br IL_002f

	  ldc.i4.1    
	  stloc.2
      IL_001e:  ldloc.2 
      IL_001f:  brfalse IL_0036

      IL_0024:  
      IL_002a:  br IL_0041
    
      IL_002f:  ldloc.1
      IL_0030:  stloc.2 
      IL_0031:  br IL_001e
    
      IL_0036:  ldc.i4 0
      IL_003b:  stloc.0 
      IL_003c:  br IL_0041
    
      IL_0041:  ldloc.0 
      IL_0042:  ret 
  } 

    .method public static default int32 test_0_cmov_opt_regress_474718 ()  cil managed 
    {
        .maxstack 16
        ldc.i4.1
        call int32 Tests::cmov_opt_regress_474718_inner (int32)
        ret
   }

	.method public static default int32 test_5_createarr_newobj () cil managed
	{
		.maxstack 16

		ldc.i4 5
		newobj void char[]::.ctor(int32)
		ldlen
		ret
	}

	.method public static default int32 test_0_initblk_3_regress_481458 () cil managed
	{
		.maxstack 16
		.locals init (native int)

		ldc.i4.s 10
		localloc
		stloc.0

		// Set the first value to 3
		ldloc.0
		ldc.i4.0
		add		//addr
		ldc.i4.3	//value
		stind.i1

		// Zero out the first 3 values
		ldloc.0		//addr
		ldc.i4.0	//value
		ldc.i4.s 3	//size
		initblk

		// Load the first value
		ldloc.0
		ldc.i4.0
		add	
		ldind.u1
		conv.i4
		ret
	}

	.method public static float32 GetFloat32() cil managed noinlining
	{
		.maxstack  8
		ldc.r8     0.19975845134874831
		ret
	}

/*	   Disabled until they can be fixed to run on amd64
	.method public static default int32 test_0_implicit_float_to_double_conversion () cil managed
	{
		.maxstack 16

		call float32 Tests::GetFloat32()
		ldc.r8     0.19975845134874831
		beq OK

		ldc.i4.1
		ret
OK:
		ldc.i4.0
		ret
	}
*/

	.method public static default int32 test_0_long_to_r8_un_overflow () cil managed
	{
		.maxstack 16
		ldc.i8     0x00FFFFFFFFFFFFFF
		conv.r.un
		conv.i8
		ldc.i8 0x100000000000000
		beq OK_1

		ldc.i4.1
		ret
OK_1:
		ldc.i8     0x00FFFFFFFFFFFFFF
		conv.r.un
		conv.r8
		conv.i8
		ldc.i8 0x100000000000000
		beq OK_2

		ldc.i4.2
		ret
OK_2:
		ldc.i4.0
		ret
	}

	.field public static int32 shift1

	.method public static int32 regress_497271_helper (int32 i) cil managed
	{
		ldarg.0
		ret
	}

	.method public static int32 test_0_regalloc_regress_497271 () cil managed
	{
		.locals (int32 var)

		ldc.i4	4
		stsfld	int32 Tests::shift1
		ldsfld	int32 Tests::shift1
		stloc	var
		ldc.i4	4660
		ldloc	var
		shr.un
		ldc.i4	4660
		ldc.i4	32
		ldloc	var
		sub
		shl
		or
		ldc.i4	1073742115
		beq	?L10
?L9:
		ldc.i4	1
		call	int32 Tests::regress_497271_helper (int32)
		ret
?L10:
		ldc.i4	0
		call	int32 Tests::regress_497271_helper (int32)
		ret
	}

   .field  private static  int32 Value

  .method public static hidebysig  specialname 
          default int32 regress_513931_inner ()  cil managed 
    {                                                                 
        // Method begins at RVA 0x225c                                
        // Code size 52 (0x34)                                        
        .maxstack 2                                                   
        .locals init (                                                
                int32   V_0,                                          
                int32   V_1,                                          
                bool    V_2)
                       
				ldc.i4 999
				stsfld int32 Tests::Value

        IL_0000:  nop                                                 
        IL_0001:  ldsfld int32 Tests::Value      
        IL_0006:  stloc.0                                             
        IL_0007:  ldloc.0                                             
        IL_0008:  ldc.i4.0                                            
        IL_0009:  cgt                                                 
        IL_000b:  ldc.i4.0                                            
        IL_000c:  ceq                                                 
        IL_000e:  stloc.2                                             
        IL_000f:  ldloc.2                                             
        IL_0010:  brtrue.s IL_0027                                    

        IL_0012:  nop 
        IL_0013:  ldloc.0 
        IL_0014:  ldc.i4.s 0x7b
        IL_0016:  ceq          
        IL_0018:  ldc.i4.0     
        IL_0019:  ceq          
        IL_001b:  stloc.2      
        IL_001c:  ldloc.2      
        IL_001d:  brtrue.s IL_0023

        IL_001f:  ldc.i4.m1 
        IL_0020:  stloc.1   
        IL_0021:  br.s IL_0032

        IL_0023:  ldc.i4.1 
        IL_0024:  stloc.1  
        IL_0025:  br.s IL_0032

        IL_0027:  
        IL_002c:  newobj instance void class [mscorlib]System.Exception::'.ctor'()
        IL_0031:  throw                                                                            
        IL_0032:  ldloc.1                                                                          
        IL_0033:  ret                                                                              
    }

	.method public static hidebysig  specialname 
         default int32 test_0_regress_513931 ()  cil managed 
	{
		call int32 Tests::regress_513931_inner ()
		pop
		ldc.i4.0
		ret
	}

	.method public static default int32 test_0_newarr_i8 () cil managed
	{
		ldc.i4 1000
		conv.i8
		newarr [mscorlib]System.Boolean
		pop
		ldc.i4 0
		ret
	}

	.method public static specialname 
    	       default int32 return_1_noinline ()  cil managed noinlining 
	{
		.maxstack 0

		ldc.i4.1
		ret 
   	}

	// Only happens with -O=-deadce,cmov
	.method public static default int32 test_0_cmov_unused_582322 () cil managed
	{
        .maxstack 2                                                   
        .locals init (                                                
				int32 V_0
		)				
		call int32 Tests::return_1_noinline ()
		ldc.i4.1
		bne.un L0
		ldloc.s 0
		pop
	L0:
		ldc.i4.0
		ret
	}

    .method public static  hidebysig 
           default int32 test_0_regress_586664 ()  cil managed 
    {                                        
        // Method begins at RVA 0x20f4       
        // Code size 76 (0x4c)               
        .maxstack 6                          
        .locals init (                       
                float64 V_0,                 
                float64[]       V_1)         
        IL_0000:  ldc.r8 1.                  
        IL_0009:  ldc.r8 2.                  
        IL_0012:  ldc.r8 1.                  
        IL_001b:  call float64 class [mscorlib]System.Math::Pow(float64, float64)
        IL_0020:  div                                                            
        IL_0021:  stloc.0                                                        
        IL_0022:  ldc.i4.2                                                       
        IL_0023:  newarr [mscorlib]System.Double                                 
        IL_0028:  dup                                                            
        IL_0029:  ldc.i4.0                                                       
        IL_002a:  ldloc.0                                                        
        IL_002b:  neg                                                            
        IL_002c:  stelem.r8                                                      
        IL_002d:  dup                                                            
        IL_002e:  ldc.i4.1                                                       
        IL_002f:  ldloc.0
        IL_0030:  neg
        IL_0031:  stelem.r8
        IL_0032:  stloc.1
        IL_0033:  ldloc.1
        IL_0034:  ldc.i4.0
        IL_0035:  ldelem.r8
        IL_0036:  ldc.r8 -0.5
        IL_003f:  bne.un IL_004a

        IL_0044:  ldc.i4.0
        IL_0045:  br IL_004b

        IL_004a:  ldc.i4.1
        IL_004b:  ret
    }

	.method public static int32 test_2_leave_multiple_blocks_from_end ()
	{
		.locals init (int32 V_0)

		.try {
			.try {
				nop
				nop
				leave END
			} finally {
				ldloc.0
				ldc.i4.1
				add
				stloc.0
				endfinally
			}
			nop
			leave END
		} finally {
			ldloc.0
			ldc.i4.1
			add
			stloc.0
			endfinally
		}
END:
		ldloc.0
		ret
	}

	.method public static int32 test_3_leave_multiple_blocks_from_hole ()
	{
		.locals init (int32 V_0)

		.try {
			.try {
				ldloc.0
				brtrue REST
				leave BEFORE_END
REST:
				nop
				nop
				leave END
			} finally {
				ldloc.0
				ldc.i4.1
				add
				stloc.0
				endfinally
			}
			nop
			leave END
		} finally {
			ldloc.0
			ldc.i4.1
			add
			stloc.0
			endfinally
		}
BEFORE_END:
		ldloc.0
		ldc.i4.1
		add
		stloc.0
END:
		ldloc.0
		ret
	}

	.class nested private auto ansi sealed beforefieldinit Pair`2<TKey,TValue>
  		   extends [mscorlib]System.ValueType
	{
		.field  public  !0 key
    	.field  public  !1 'value'
  	}

    .method private static hidebysig 
           default bool ContentEquals<TKey,TValue> (valuetype Tests/Pair`2<!!TKey, !!TValue> v)  cil managed 
    {
	.maxstack 8
	IL_0000:  ldarga.s 0 
	IL_0006:  ldnull 
			  constrained. valuetype Tests/Pair`2<!!0,!!1>
	IL_0007:  callvirt instance bool class [mscorlib]System.Object::Equals(object)
			  ret
    }

    .method public static hidebysig default int32 test_0_constrained_gshared_595863 () cil managed
    {
		.locals init (
		valuetype Tests/Pair`2<string, string>	V_0,
		valuetype Tests/Pair`2<string, string>	V_1)
	IL_0000:  ldloca.s 0
	IL_0002:  initobj valuetype Tests/Pair`2<string,string>
	IL_0008:  ldloc.0 
	IL_0009:  stloc.1 
	IL_000a:  ldloca.s 1
	IL_000c:  ldstr "A"
	IL_0011:  stfld !0 valuetype Tests/Pair`2<string,string>::key
	IL_0016:  ldloca.s 1
	IL_0018:  ldstr "B"
	IL_001d:  stfld !1 valuetype Tests/Pair`2<string,string>::'value'
	IL_0022:  ldloc.1 
	IL_0023:  stloc.0 
	IL_0024:  ldloc.0 
	IL_0025:  call bool class Tests::ContentEquals<string, string> (valuetype Tests/Pair`2<!!0,!!1>)
			  brfalse SUCCESS
			  ldc.i4.1
			  ret
	SUCCESS:
			  ldc.i4.0
			  ret
    }

	.method public static default int32 test_0_wrap_non_exception_throws () cil managed
	{
	  .try {
	  	    newobj instance void class [mscorlib]System.Object::'.ctor'()
			throw
		  leave IL_0
	  } catch class [mscorlib]System.Runtime.CompilerServices.RuntimeWrappedException {
		  leave IL_0
		}
		IL_0:
		ldc.i4.0
		ret
    }

	.method public static default int32 test_0_typespec_modopt () cil managed {
		ldtoken class Tests modopt (Tests)
		pop
		ldc.i4.0
		ret
	}

	.method public hidebysig static int32 SizeOfT<T>() cil managed
  	{
		.maxstack  8
    
		sizeof !!0
    	ret
  	}

	.method public static default int32 test_1_sizeof_gshared () cil managed {
	    call   int32 Tests::SizeOfT<int8>()
		ldc.i4.1
		ceq
		ret
	}

  .field static public int32 volatile_int

  	.method public static default int32 test_5_volatile_load_store () cil managed {
 		ldsflda int32 class Tests::volatile_int
 		ldc.i4 5
 		volatile.
		stind.i4
 		ldsflda int32 class Tests::volatile_int
		volatile.
		ldind.i4
		ret
  	} 		

    .method public static 
           default int32 regress_693905_inner (int32 x, int32 acc)  cil managed 
    {
        // Method begins at RVA 0x2050
        // Code size 17 (0x11)
        .maxstack 5
        IL_0000:  ldarg.0 
        IL_0001:  brtrue.s IL_0005

        IL_0003:  ldarg.1 
        IL_0004:  ret 
        IL_0005:  ldarg.0 
        IL_0006:  ldc.i4.1 
        IL_0007:  sub 
        IL_0008:  ldarg.1 
        IL_0009:  ldc.i4.1 
        IL_000a:  add 
        IL_000b:  starg.s 1
        IL_000d:  starg.s 0
        IL_000f:  br.s IL_0000

    } // end of method Test::f

    .method public static 
           default int32 test_10_regress_693905 ()  cil managed 
	{
		ldc.i4.s 0x0a
        ldc.i4.0 
        call int32 class Tests::regress_693905_inner(int32, int32)
		ret
	}

	.method public static
			default int32 test_0_llvm_regress_171 () cil managed
	{
		.locals init (
			int32 i
		)

		call int32 Tests::return_1_noinline ()
		ldc.i4.1
		beq L1
		ldc.i4.1
		stloc.s 0
		call int32 Tests::return_1_noinline ()
		ldc.i4.0
		beq L1
		L1:
		ldloc.s 0
		ret
	}

     .field  public static int32 static_a

	.method public static
			default int32 test_4_ldfld_stfld_static () cil managed
	{
		ldnull
		ldc.i4 2
		stfld int32 Tests::static_a
		ldnull
		ldfld int32 Tests::static_a
		ldnull
		ldflda int32 Tests::static_a
		ldind.i4
		add
		ret
	}
}
