%%

#
# inssel-arm.brg: burg file for special ARM instructions
#
# Author:
#   Dietmar Maurer (dietmar@ximian.com)
#   Paolo Molaro (lupus@ximian.com)
#
# (C) 2002 Ximian, Inc.
#

stmt: OP_START_HANDLER {
	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
	/*MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, spvar->inst_basereg, spvar->inst_offset, ppc_sp);
	*/
	tree->inst_left = spvar;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ENDFINALLY {
	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
	tree->inst_left = spvar;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ENDFILTER (reg) {
	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
	tree->inst_left = spvar;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

lreg: OP_LADD_OVF (lreg, lreg) "0" {
	/* ADC sets the condition code */
	MONO_EMIT_NEW_BIALU (s, OP_ADDCC, state->reg1, state->left->reg1, state->right->reg1);
	MONO_EMIT_NEW_BIALU (s, OP_ADD_OVF_CARRY, state->reg2, state->left->reg2, state->right->reg2);
}

lreg: OP_LADD_OVF_UN (lreg, lreg) "0" {
	/* ADC sets the condition code */
	MONO_EMIT_NEW_BIALU (s, OP_ADDCC, state->reg1, state->left->reg1, state->right->reg1);
	MONO_EMIT_NEW_BIALU (s, OP_ADD_OVF_UN_CARRY, state->reg2, state->left->reg2, state->right->reg2);
}

lreg: OP_LSUB_OVF (lreg, lreg) "0" {
	/* SBB sets the condition code */
	MONO_EMIT_NEW_BIALU (s, OP_SUBCC, state->reg1, state->left->reg1, state->right->reg1);
	MONO_EMIT_NEW_BIALU (s, OP_SUB_OVF_CARRY, state->reg2, state->left->reg2, state->right->reg2);
}

lreg: OP_LSUB_OVF_UN (lreg, lreg) "0" {
	/* SBB sets the condition code */
	MONO_EMIT_NEW_BIALU (s, OP_SUBCC, state->reg1, state->left->reg1, state->right->reg1);
	MONO_EMIT_NEW_BIALU (s, OP_SUB_OVF_UN_CARRY, state->reg2, state->left->reg2, state->right->reg2);
}

stmt: CEE_STIND_I8 (OP_REGVAR, lreg) {
	/* this should only happen for methods returning a long */
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, ARMREG_R0, state->right->reg1);
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, ARMREG_R1, state->right->reg2);
}

lreg: OP_LNEG (lreg) "2" {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ARM_RSBS_IMM, state->reg1, state->left->reg1, 0);
	MONO_EMIT_BIALU_IMM (s, tree, OP_ARM_RSC_IMM, state->reg2, state->left->reg2, 0);
}

freg: OP_LCONV_TO_R8 (lreg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
	tree->sreg2 = state->left->reg2;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_LCONV_TO_R4 (lreg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
	tree->sreg2 = state->left->reg2;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: CEE_CONV_R_UN (reg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LOCALLOC (OP_ICONST) {
	/* microcoded in mini-arm.c */
	tree->sreg1 = mono_regstate_next_int (s->rs);
	tree->dreg = state->reg1;
	MONO_EMIT_NEW_ICONST (s, tree->sreg1, state->left->tree->inst_c0);
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LOCALLOC (reg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (reg) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = ARMREG_R0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (lreg) {
	tree->opcode = OP_SETLRET;
	tree->sreg1 = state->left->reg1;
	tree->sreg2 = state->left->reg2;
	tree->dreg = ARMREG_R0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (freg) {
	if (SOFT_FLOAT_IMPL) {
		tree->opcode = OP_SETLRET;
		tree->sreg1 = state->left->reg1;
		tree->sreg2 = state->left->reg2;
		tree->dreg = ARMREG_R0;
		mono_bblock_add_inst (s->cbb, tree);
	} else {
		tree->opcode = OP_FMOVE;
		tree->sreg1 = state->left->reg1;
		tree->dreg = 0;
		mono_bblock_add_inst (s->cbb, tree);
	}
}

stmt: OP_SETRET (OP_ICONST) {
	tree->opcode = OP_ICONST;
	tree->inst_c0 = state->left->tree->inst_c0;
	tree->dreg = ARMREG_R0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_I (OP_REGVAR, CEE_SUB (CEE_LDIND_I (OP_REGVAR), OP_ICONST)),
stmt: CEE_STIND_I4 (OP_REGVAR, CEE_SUB (CEE_LDIND_I4 (OP_REGVAR), OP_ICONST)),
stmt: CEE_STIND_I (OP_REGVAR, CEE_ADD (CEE_LDIND_I (OP_REGVAR), OP_ICONST)),
stmt: CEE_STIND_I4 (OP_REGVAR, CEE_ADD (CEE_LDIND_I4 (OP_REGVAR), OP_ICONST)) {
	int con = state->right->right->tree->inst_c0;
	int dreg = state->left->tree->dreg;
	int sreg = state->right->left->left->tree->dreg;

	if (state->right->op == CEE_ADD)
		tree->opcode = OP_ADD_IMM;
	else if (state->right->op == CEE_SUB)
		tree->opcode = OP_SUB_IMM;
	else
		g_assert_not_reached ();
	tree->inst_imm = con;
	tree->sreg1 = sreg;
	tree->dreg = dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (reg) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;

	tree->opcode = OP_MOVE;
	tree->dreg = mono_regstate_next_int (s->rs);
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG (OP_REGVAR) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;
	tree->opcode = OP_MOVE;
	tree->dreg = mono_regstate_next_int (s->rs);
	tree->sreg1 = state->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG (lreg) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;
	int tdreg;
	tdreg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, tdreg, state->left->reg2);
	
	/* An #if would be better here, but monoburg
	   strips them out as comments */
	if (G_BYTE_ORDER == G_BIG_ENDIAN)
		mono_call_inst_add_outarg_reg (s, call, tdreg, tree->backend.reg3, FALSE);
	else
		mono_call_inst_add_outarg_reg (s, call, tdreg, tree->backend.reg3 + 1, FALSE);

	tree->opcode = OP_MOVE;
	tree->dreg = mono_regstate_next_int (s->rs);
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
	
	if (G_BYTE_ORDER == G_BIG_ENDIAN)
		mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3 + 1, FALSE);
	else
		mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG (OP_ICONST) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;
	tree->opcode = OP_ICONST;
	tree->dreg = mono_regstate_next_int (s->rs);
	tree->inst_c0 = state->left->tree->inst_c0;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGVAR)) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->left->tree->dreg;
	tree->dreg = mono_regstate_next_int (s->rs);
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG_R8 (freg),
stmt: OP_OUTARG (freg) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;
	int creg;
	if (SOFT_FLOAT_IMPL) {
		/* same as the OUTARG (lreg) case */
		int tdreg;
		tdreg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_UNALU (s, OP_MOVE, tdreg, state->left->reg2);
	
		/* An #if would be better here, but monoburg
		   strips them out as comments */
		if (G_BYTE_ORDER == G_BIG_ENDIAN)
			mono_call_inst_add_outarg_reg (s, call, tdreg, tree->backend.reg3, FALSE);
		else
			mono_call_inst_add_outarg_reg (s, call, tdreg, tree->backend.reg3 + 1, FALSE);

		tree->opcode = OP_MOVE;
		tree->dreg = mono_regstate_next_int (s->rs);
		tree->sreg1 = state->left->reg1;
		mono_bblock_add_inst (s->cbb, tree);
	
		if (G_BYTE_ORDER == G_BIG_ENDIAN)
			mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3 + 1, FALSE);
		else
			mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
	} else {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER8_MEMBASE_REG, ARMREG_SP, (s->param_area - 8), state->left->reg1);
		creg = mono_regstate_next_int (s->rs);
		mono_call_inst_add_outarg_reg (s, call, creg, tree->backend.reg3, FALSE);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, creg, ARMREG_SP, (s->param_area - 8));
		creg = mono_regstate_next_int (s->rs);
		mono_call_inst_add_outarg_reg (s, call, creg, tree->backend.reg3 + 1, FALSE);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, creg, ARMREG_SP, (s->param_area - 8 + 4));
	}
}

stmt: OP_OUTARG_R4 (freg) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;
	int creg;
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER4_MEMBASE_REG, ARMREG_SP, (s->param_area - 8), state->left->reg1);
	creg = mono_regstate_next_int (s->rs);
	mono_call_inst_add_outarg_reg (s, call, creg, tree->backend.reg3, FALSE);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, creg, ARMREG_SP, (s->param_area - 8));
}

stmt: OP_OUTARG_MEMBASE (reg) {
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, tree->backend.arg_info >> 8, state->left->reg1);
}

stmt: OP_OUTARG_MEMBASE (lreg) {
	int offset = tree->backend.arg_info >> 8;
	int partial = (tree->backend.arg_info & 0xff) == 0xff;
	if (partial) {
		MonoCallInst *call = (MonoCallInst*)tree->inst_right;
		if (G_BYTE_ORDER == G_BIG_ENDIAN) {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset, state->left->reg1);
		} else {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset, state->left->reg2);
		}
		tree->opcode = OP_MOVE;
		tree->dreg = mono_regstate_next_int (s->rs);
		tree->sreg1 = G_BYTE_ORDER == G_BIG_ENDIAN? state->left->reg2: state->left->reg1;
		mono_bblock_add_inst (s->cbb, tree);
		mono_call_inst_add_outarg_reg (s, call, tree->dreg, ARMREG_R3, FALSE);
		return;
	}
	if (G_BYTE_ORDER == G_BIG_ENDIAN) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset, state->left->reg2);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset + 4, state->left->reg1);
	} else {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset, state->left->reg1);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset + 4, state->left->reg2);
	}
}

stmt: OP_OUTARG_MEMBASE (freg) {
	int offset = tree->backend.arg_info >> 8;
	if (SOFT_FLOAT_IMPL) {
		int partial = (tree->backend.arg_info & 0xff) == 0xff;
		/* same as OP_OUTARG_MEMBASE (lreg) */
		if (G_BYTE_ORDER == G_BIG_ENDIAN) {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset, state->left->reg2);
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset + 4, state->left->reg1);
		} else {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset, state->left->reg1);
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset + 4, state->left->reg2);
		}
	} else {
		if ((tree->backend.arg_info & 0xff) == 8)
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER8_MEMBASE_REG, ARMREG_SP, offset, state->left->reg1);
		else if ((tree->backend.arg_info & 0xff) == 4)
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER4_MEMBASE_REG, ARMREG_SP, offset, state->left->reg1);
		else if ((tree->backend.arg_info & 0xff) == 0xff) {
			MonoCallInst *call = (MonoCallInst*)tree->inst_right;
			int creg;
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER8_MEMBASE_REG, ARMREG_SP, (s->param_area - 8), state->left->reg1);
			creg = mono_regstate_next_int (s->rs);
			mono_call_inst_add_outarg_reg (s, call, creg, ARMREG_R3, FALSE);
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, creg, ARMREG_SP, (s->param_area - 8));
			creg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, creg, ARMREG_SP, (s->param_area - 4));
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, ARMREG_SP, offset, creg);
		} else
			g_assert_not_reached ();
	}
}

stmt: OP_OUTARG_VT (CEE_LDOBJ (base)) {
	MonoCallInst *call = (MonoCallInst*)tree->inst_right;
	MonoInst *vt = state->left->left->tree;
	int start_reg = tree->backend.arg_info & 0xf;
	int nregs = (tree->backend.arg_info >> 4) & 0xf;
	int ovf_size = (tree->backend.arg_info >> 8) & 0xfff;
	int doffset = ((tree->backend.arg_info >> 20) & 0xfff) * 4;
	int i, tmpr, soffset, dreg;
	int size = 0;
	soffset = vt->inst_offset;

	for (i = 0; i < nregs; ++i) {
		tmpr = mono_regstate_next_int (s->rs);
		dreg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, vt->inst_basereg, soffset);
		MONO_EMIT_NEW_UNALU (s, OP_MOVE, dreg, tmpr);
		mono_call_inst_add_outarg_reg (s, call, dreg, start_reg + i, FALSE);
		soffset += sizeof (gpointer);
	}
	//g_print ("vt size: %d at R%d + %d\n", doffset, vt->inst_basereg, vt->inst_offset);
	if (ovf_size != 0) {
		mini_emit_memcpy (s, ARMREG_SP, doffset, vt->inst_basereg, soffset, ovf_size * sizeof (gpointer), 0);
	}
}

stmt: OP_OUTARG_VT (OP_ICONST) {
	int nregs = (tree->backend.arg_info >> 4) & 0xf;
	if (nregs) {
		MonoCallInst *call = (MonoCallInst*)tree->inst_right;
		tree->opcode = OP_ICONST;
		tree->dreg = mono_regstate_next_int (s->rs);
		tree->inst_c0 = state->left->tree->inst_c0;
		mono_bblock_add_inst (s->cbb, tree);

		mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.arg_info & 0xf, FALSE);
	} else {
		g_assert_not_reached ();
	}
}

stmt: OP_OUTARG_VT (reg) {
	int start_reg = tree->backend.arg_info & 0xff;
	int nregs = (tree->backend.arg_info >> 8) & 0xff;
	if (nregs) {
		tree->opcode = OP_MOVE;
		tree->dreg = start_reg;
		tree->sreg1 = state->left->reg1;
		mono_bblock_add_inst (s->cbb, tree);
	} else {
		g_assert_not_reached ();
	}
}

stmt: CEE_STIND_R8 (OP_REGVAR, freg) {
	/* nothing to do: the value is already on the FP stack */
}
 
stmt: CEE_BNE_UN (fpcflags) {
	tree->opcode = OP_FBNE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BEQ (fpcflags) {
	tree->opcode = OP_FBEQ;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT (fpcflags) {
	tree->opcode = OP_FBLT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT_UN (fpcflags) {
	tree->opcode = OP_FBLT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT (fpcflags) {
	tree->opcode = OP_FBGT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT_UN (fpcflags) {
	tree->opcode = OP_FBGT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE  (fpcflags) {
	tree->opcode = OP_FBGE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE_UN (fpcflags) {
	tree->opcode = OP_FBGE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE  (fpcflags) {
	tree->opcode = OP_FBLE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE_UN (fpcflags) {
	tree->opcode = OP_FBLE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_POP (freg) "0" {
	/* nothing to do */
}     

freg: OP_LCONV_TO_R8 (lreg) {
	/* nothing to do - emulated */
}

freg: OP_LCONV_TO_R4 (lreg) {
	/* nothing to do - emulated */
}

freg: OP_LCONV_TO_R_UN (lreg) {
	/* nothing to do - emulated */
}

freg: OP_FREM (freg, freg) {
	/* nothing to do - emulated */
}

reg: OP_CEQ (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCEQ, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: CEE_ADD_OVF (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1, state->right->reg1);
}

reg: CEE_ADD_OVF_UN (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1, state->right->reg1);
}

reg: CEE_SUB_OVF (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1, state->right->reg1);
}

reg: CEE_SUB_OVF_UN (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1, state->right->reg1);
}

stmt: OP_SWITCH (reg) {
	MonoInst *label;
	int n = GPOINTER_TO_INT (tree->klass);
	
	MONO_NEW_LABEL (s, label);

	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, state->left->reg1, n);
	MONO_EMIT_NEW_BRANCH_BLOCK (s, CEE_BGE_UN, tree->inst_many_bb [n]);

	if (s->compile_aot) {
		/* FIXME: Optimize this */
		int offset_reg = mono_regstate_next_int (s->rs);
		int target_reg = mono_regstate_next_int (s->rs);
		int table_reg = mono_regstate_next_int (s->rs);
		int sum_reg = mono_regstate_next_int (s->rs);
		MonoJumpInfoBBTable *table;

		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, offset_reg, state->left->reg1, 2);

		table = mono_mempool_alloc (s->mempool, sizeof (MonoJumpInfoBBTable));
		table->table = tree->inst_many_bb;
		table->table_size = n;

		MONO_EMIT_NEW_AOTCONST (s, table_reg, table, MONO_PATCH_INFO_SWITCH);

		MONO_EMIT_NEW_BIALU (s, CEE_ADD, sum_reg, table_reg, offset_reg);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, target_reg, sum_reg, 0);
		MONO_EMIT_UNALU (s, tree, OP_BR_REG, -1, target_reg);
	} else {
		mono_bblock_add_inst (s->cbb, label);
		mono_create_jump_table (s, label, tree->inst_many_bb, n);
		/* the backend code will deal with aot vs normal case */
		tree->sreg1 = state->left->reg1;
		mono_bblock_add_inst (s->cbb, tree);
	}
}

%%
