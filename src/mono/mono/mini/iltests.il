.assembly iltests {
  .custom instance void class [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::'.ctor'() =  (
		01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
		63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01       ) // ceptionThrows.
}
.assembly extern TestDriver {}
.assembly extern mscorlib {}

  .class private sequential ansi sealed beforefieldinit FLSharedKeys
  extends [mscorlib]System.ValueType
  {
	 .pack 0
	 .size 1
  }

.class public auto ansi sealed beforefieldinit Tests {

	.method static public int32 Main(string[] args) il managed {
		.entrypoint

		ldtoken Tests
		call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
		ldarg.0
		call       int32 [TestDriver]TestDriver::RunTests(class [mscorlib]System.Type, string[])
		ret
	}

	.method hidebysig static int32 comp_ptr_i8(void* arg, int64 v) cil managed
	{
		.maxstack 2

		ldarg.0
		ldarg.1
		ceq
		ret
	}

	.method hidebysig static int64 add_ptr_i4(void* arg) cil managed
	{
		.maxstack 2

		ldarg.0
		ldc.i4.2
		add
		ret
	}

	.method hidebysig static int64 add_ptr_i8(void* arg, int64 v) cil managed
	{
		.maxstack 2

		ldarg.0
		ldarg.1
		add
		ret
	}

	.method hidebysig static int64 and_ptr_i8(void* arg, int64 v) cil managed
	{
		.maxstack 2

		ldarg.0
		ldarg.1
		and
		ret
	}

	.method hidebysig static int32 i8_ptr_arithm_x64() cil managed
	{
		.maxstack 3

		ldc.i4.1
		ldc.i8 0x1111222233334444
		call int64 class Tests::add_ptr_i4(void*)
		ldc.i8 0x1111222233334446
		bne.un FAIL1
		pop

		ldc.i4.2
		ldc.i8 0x1111222233334444
		ldc.i8 0x2
		call int64 class Tests::add_ptr_i8(void*,int64)
		ldc.i8 0x1111222233334446
		bne.un FAIL1
		pop

		ldc.i4.3
		ldc.i8 0x1111222233334444
		ldc.i4 0x2
		call int64 class Tests::add_ptr_i8(void*,int64)
		ldc.i8 0x1111222233334446
		bne.un FAIL1
		pop

		ldc.i4.4
		ldc.i8 0x1111222233334444
		ldc.i8 0x0000FFFF00000000
		call int64 class Tests::and_ptr_i8(void*,int64)
		ldc.i8 0x0000222200000000
		bne.un FAIL1
		pop

		ldc.i4.5
		ldc.i8 0x1111222233334444
		ldc.i4 0xFFFF0000
		call int64 class Tests::and_ptr_i8(void*,int64)
		ldc.i8 0x1111222233330000
		bne.un FAIL1
		pop

		ldc.i4.6
		ldc.i8 0x1111222233334444
		ldc.i4 0xFFFF0000
		and
		ldc.i8 0x1111222233330000
		bne.un FAIL1
		pop

		ldc.i4.7
		ldc.i8 0x1111222233334444
		ldc.i8 0x1111222233334444
		call int32 class Tests::comp_ptr_i8(void*,int64)
		ldc.i4.1
		bne.un FAIL1
		pop

		ldc.i4.8
		ldc.i8 0x1111222233334444
		ldc.i4 0x1111
		add
		ldc.i8 0x1111222233335555
		bne.un FAIL1
		pop

		ldc.i4.0
FAIL1:
		ret
	}

	.method static public int32 test_0_i8_ptr_arithm() cil managed {
		.custom instance void [TestDriver]CategoryAttribute::.ctor(string) = ( 01 00 0C 21 49 4E 54 45 52 50 52 45 54 45 52 00 00)  // ...!INTERPRETER.
		.maxstack 2

		sizeof [mscorlib]System.IntPtr
		ldc.i4.8
		bne.un OK1
		call int32 class Tests::i8_ptr_arithm_x64()
		ret

OK1:
		ldc.i4.0
		ret
	}

	// make sure the register allocator works when the return value of
	// 'div' is discarded
	.method static public int32 test_0_div_regalloc () il managed {
		.locals init (
			int32 i
		)

		ldloc 0
		ldc.i4.s 0xa
		div
		pop
		ldc.i4.0
		ret
	}
	
	
	.method static public int32 test_1_ceq_to_i4 () il managed {
		.locals init (
			int32   foo
		)
		ldc.i4 500
		stloc foo
		ldloc foo
		ldc.i4 500
		ceq
		stloc foo
		ldloc foo
		ret
	}
	
	.method static public int32 test_3_shl_regvars () il managed {
		.locals init (
			int32	a,
			int32	b,
			int32	r1,
			int32	r2,
			int32	r3
		)
			
		ldc.i4.2
		stloc      a
		ldc.i4.1
		stloc      b
	
		ldloc      a
		ldloc      b
		shl 
		stloc      r1
		
		ldloc      a
		ldloc      b
		shl 
		stloc      r2
		
		ldloc      a
		ldloc      b
		shl 
		stloc      r3
		
		ldloc      r1
		ldc.i4.4
		ceq
		
		ldloc      r2
		ldc.i4.4
		ceq
		
		ldloc      r3
		ldc.i4.4
		ceq
		
		add
		add
		
		ret
	}
	
	.method static public int32 test_1_fceq_to_i4 () il managed {
	
		.locals init (
			float64	foo,
			int32   val
		)

		ldc.r8      2
		stloc       foo
		
		ldloc       foo
		ldc.r8      2
		ceq
		stloc       val
		
		ldloc       val
		ret
	}

	//
	// This should be manually checked. Basically under -O=linears,
	// you should not see tons of register spilling.
	//
	.method static public int32 test_1_bytedreg_free () il managed {
		.locals init (
			int32   foo
		)
		ldc.i4 500
		stloc foo
		ldloc foo
		ldc.i4 500
		ceq
		stloc foo
		
		ldloc foo
		ldc.i4 1
		ceq
		stloc foo

		ldloc foo
		ldc.i4 1
		ceq
		stloc foo

		ldloc foo
		ldc.i4 1
		ceq
		stloc foo
		
		ldloc foo
		ldc.i4 1
		ceq
		stloc foo
		
		ldloc foo
		ret
	}
	
	//
	// This should be manually checked. Basically under -O=linears,
	// you should not see tons of register spilling.
	//
	.method static public int32 test_0_bytesreg1_free () il managed {
		.locals init (
			unsigned int8	   dest,
			int32	           src,
			unsigned int8&	   pdest
		)

		ldloca     dest
		stloc      pdest
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldloc      src
		stind.i1
		
		ldloc      pdest
		ldind.i1
		ret
	}
	
	.method static public int32 test_1_shift_regvar () il managed {
	
		.locals init (
			int32   v7FFFFFFF,
			int32   v1
		)
		
		ldc.i4	0x7FFFFFFF
		stloc   v7FFFFFFF
	
		ldc.i4.1
		stloc v1
		
		ldloc   v7FFFFFFF
		ldloc   v1
		shl
		ldc.i4	0xFFFFFFFE
		ceq
		ret
	}
	
	// this only happens with the managed pointer, not an unmanaged one.
	.method static public int32 test_0_foo () il managed {
	
		.locals init (
			int32&	buf
		)
		
		ldc.i4.5
		localloc
		
		stloc buf
		ldloc buf
		
		ldind.i4
		
		ret
	}

	.method static public int32 test_0_localloc () cil managed {
		.locals init (native int, native int, native int, native int, int32)

		ldc.i4 6
		localloc
		conv.i
		stloc.0

		ldc.i4 6
		localloc
		conv.i
		stloc.1

		ldc.i4 6
		localloc
		conv.i
		stloc.2

		// Variable length
		ldc.i4 128
		stloc.s 4
		ldloc.s 4
		localloc
		conv.i
		stloc.3

		// Check zero initialized
		ldloc.0
		ldind.i4
		ldc.i4.0
		beq OK1
		ldc.i4.1
		br FAIL

OK1:
		ldloc.3
		ldind.i4
		ldc.i4.0
		beq OK2
		ldc.i4.2
		br FAIL

OK2:
		ldloc.3
		ldc.i4.s 124
		add
		ldind.i4
		ldc.i4.0
		beq OK3
		ldc.i4.3
		br FAIL

OK3:
		ldloc.1
		ldc.i4 999999
		stind.i4
		ldloc.1
		ldind.i4
		ldc.i4 999999
		beq OK4
		ldc.i4.4
		br FAIL

OK4:
		ldloc.0
		ldc.i4 999999
		stind.i4
		ldloc.0
		ldind.i4
		ldc.i4 999999
		beq OK5
		ldc.i4.5
		br FAIL

OK5:
		// Try allocations bigger than one page
		ldc.i4 8196
		localloc
		conv.i
		stloc.3
		ldloc.3
		ldc.i4 8192
		add
		ldc.i4 99
		stind.i4
		ldloc.3
		ldc.i4 8192
		add
		ldind.i4
		ldc.i4 99
		beq PASS
		ldc.i4.6
		br FAIL

FAIL:
		ret

PASS:	ldc.i4.0
		ret
	}

    .method private static void do_localloc () cil managed {
        .maxstack 3
        .locals init (
                unsigned int8*  V_0)
        IL_0000:  ldc.i4.1
        IL_0001:  ldc.i4 131072
        IL_0006:  mul
        IL_0007:  localloc
        IL_0009:  stloc.0
        IL_000a:  ret
    }

	// Check that localloc cannot be inlined
	.method static public int32 test_0_localloc_inline () cil managed {
		.maxstack 16
		.locals init (
			int32 i
		)

		ldc.i4.0
        stloc.0
        br COND

START:  call void class Tests::do_localloc()
        ldloc.0
        ldc.i4.1
        add
        stloc.0
COND:   ldloc.0
        ldc.i4 1000
        blt START

		ldc.i4.0
		ret
	}	
	
	.method static public int32 test_3_copy_used_bug () il managed {

		.locals init (
			int32 size,
			int32 res
		)

		ldc.i4 0
		stloc res

		ldc.i4 1
		stloc size

		ldloc size
		ldloc size
		ldloc size
		add
		stloc size
		ldloc size
		add
		stloc res

		ldloc res
		ret
	}

	// demonstrate that the copy_used_var is not a fix for the above bug
	.method static public int32 test_3_copy_used_indir_bug () il managed {

		.locals init (
			int32 size,
			int32 res
		)

		ldc.i4 0
		stloc res

		ldc.i4 1
		stloc size

		ldloc size
		ldloca size
		ldloc size
		ldloc size
		add
		stind.i4
		ldloc size
		add
		stloc res

		ldloc res
		ret
	}

	.method static public void do_nothing (int32 a) il managed {
		ret
	}
	
	// demonstrate the block_split failure: needs -O=inline
	// mini -O=inline --compile Tests:test_0_split_block_bug iltests.exe
	.method static public int32 test_0_split_block_bug () il managed {

		.locals init (
			int32 i1
		)

		ldc.i4 1
		stloc i1
 test_label:
		ldloc i1
		call void class Tests::do_nothing (int32)
		ldc.i4 0
		brtrue test_label
		
		ldc.i4 0
		ret
	}

	.method public void inline_do_nothing () il managed {
		ret
	}
	.method static public int32 test_1_checkthis_inlining () il managed {
		ldnull
		call instance void class Tests::inline_do_nothing ()
		ldc.i4 1
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TailCallStruct 
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
	}

	.method static valuetype Tests/TailCallStruct tail1 (valuetype Tests/TailCallStruct arg) {
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStruct::a
		ldc.i4.1
		add
		stfld int32 Tests/TailCallStruct::a
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStruct::a
		ldc.i4.2
		add
		stfld int32 Tests/TailCallStruct::a
		ldarg.0
		ret
	}

	.method static valuetype Tests/TailCallStruct tail2 (valuetype Tests/TailCallStruct arg) {
		ldarg.0
		tail.
		call valuetype Tests/TailCallStruct Tests::tail1 (valuetype Tests/TailCallStruct)
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TailCallStructBig
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
		.field public int32 c
		.field public int32 d
		.field public int32 e
	}

	.method static valuetype Tests/TailCallStructBig tail_vret_by_addr_inner (valuetype Tests/TailCallStructBig arg) {
		ldarga 0
		ldarga 0
		ldfld int32 Tests/TailCallStructBig::a
		ldc.i4.1
		add
		stfld int32 Tests/TailCallStructBig::a
		ldarg.0
		ret
	}

	.method static valuetype Tests/TailCallStructBig tail_vret_by_addr (valuetype Tests/TailCallStructBig arg) {
		ldarg.0
		tail.
		call valuetype Tests/TailCallStructBig Tests::tail_vret_by_addr_inner (valuetype Tests/TailCallStructBig)
		ret
	}

	.method static public int32 test_3_tail_call_vret_by_addr () il managed {
		.maxstack 16
		.locals init (
			valuetype Tests/TailCallStructBig arg2
		)

		ldloca 0
		ldc.i4.2
		stfld int32 Tests/TailCallStructBig::a
		ldloc.0
		call valuetype Tests/TailCallStructBig Tests::tail_vret_by_addr (valuetype Tests/TailCallStructBig)
		stloc.0

		ldloca 0
		ldfld int32 Tests/TailCallStructBig::a
		ret
	}

	.method static public int32 test_9_tail_call_vret_by_val () il managed {
		.maxstack 16
		.locals init (
			valuetype Tests/TailCallStruct arg
		)
		ldloca 0
		ldc.i4.2
		stfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldc.i4.4
		stfld int32 Tests/TailCallStruct::b
		ldloc.0
		call valuetype Tests/TailCallStruct Tests::tail2 (valuetype Tests/TailCallStruct)
		stloc.0

		ldloca 0
		ldfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldfld int32 Tests/TailCallStruct::b
		add
		ret
	}

	.method static public int32 tail3 (int32 i, int32 j) il managed {
		ldarg.0
		ldarg.1
		add
		ret
	}

	.method static public int32 tail4 (int32 i, int32 j) il managed {
		.maxstack 16
		.locals init (
			int32 k)

		// Test arg0 allocated to a register
		ldarg.0
		ldarg.0
		ldarg.0
		ldarg.0
		add
		add
		add
		starg 0

		// Test switched up argument variables as the actual arguments
		ldarg.1
		ldarg.0
		tail.
		call int32 Tests::tail3 (int32, int32)
		ret
	}

	.method static public int32 test_24_tail_calls2 () il managed {
		// Some platforms might not be able to AOT tail calls
		.custom instance void class [TestDriver]CategoryAttribute::'.ctor'(string) =  (01 00 08 21 46 55 4C 4C 41 4F 54 00 00 ) // ...!FULLAOT..

		.maxstack 16
		.locals init (
			int32 i,
			int32 j)

		ldc.i4.4
		stloc.0
		ldc.i4.8
		stloc.1

		ldloc.0	
		ldloc.1
		call int32 Tests::tail4 (int32, int32)
		ret
	}

	.method public static int32 test_5_jmp () cil managed {
		// Some platforms might not be able to AOT tail calls
		.custom instance void class [TestDriver]CategoryAttribute::'.ctor'(string) =  (01 00 08 21 46 55 4C 4C 41 4F 54 00 00 ) // ...!FULLAOT..

		ldc.i4.1
		ldc.i4.2
		call int32 Tests::jmp2 (int32, int32)
		ret
	}

	.method public static int32 jmp2 (int32, int32) cil managed {
		ldarg.0
		ldc.i4.1
		add
		starg.s 0
		ldarg.1
		ldc.i4.1
		add
		starg.s 1
		jmp int32 Tests::jmp3 (int32, int32)
		ldc.i4.0
		ret
	}		

	.method public static int32 jmp3 (int32 i, int32 j) cil managed {
		ldarg.0
		ldarg.1
		add
		ret
	}

	.method static public int32 test_11_switch_with_nonempty_stack () il managed {
		.maxstack 16

		ldc.i4.5
		ldc.i4.6
		ldc.i4.1
		switch (L0, L1)
	L0: 
		add
		ret
	L1:
		add
		ret
	}
 
    .method public static int32 test_5_endfinally_with_nonempty_stack () il managed {
		.maxstack 16

        .try {
          leave IL_0
        }
        finally  {
          ldc.i4.0
          endfinally
        }
        IL_0:  ldc.i4.5
		ret
    }

    .method public static int32 test_5_endfinally_llvm_linking () il managed {
		.maxstack 16

        .try {
          leave IL_0
        }
        finally  {
          ldc.i4.0
		  dup
		  brtrue L1
		  pop
		  br L2
		L1:
		  pop
		L2:
          endfinally
        }
        IL_0:  ldc.i4.5
		ret
    }

	.method public static int32 test_0_conv_ovf_i8_neg () il managed {
		.maxstack 16

		ldc.i4.m1
		conv.ovf.i8
		conv.i4
		ldc.i4.m1
		beq L_OK
		ldc.i4.1
		ret
	L_OK:
		ldc.i4.0
		ret
	}		

	.method public static int32 test_1234_conv_u4 () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.u4
		conv.i4
		ret
	}

	.method public static int32 test_0_conv_ovf_i_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4 0x7fffffff
		conv.ovf.i.un
		conv.i4
		ldc.i4 0x7fffffff
		beq L2
		ldc.i4.2
		ret
	L2:
		sizeof [mscorlib]System.IntPtr
		ldc.i4 8
		beq L5
		.try {
			ldc.i4 0x80000000
			conv.ovf.i.un
			leave L4
		} catch [mscorlib]System.OverflowException {
			pop
			leave L5
		}
	L4: 
		ldc.i4.3
		ret
	L5:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_u_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.u.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_i () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_conv_ovf_u () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.u
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_1234_conv_ovf_i8_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.ovf.i8.un
		conv.i4
		ret
	}

	.method public static int32 test_0_lconv_ovf_i () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_u () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_i_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_ovf_u_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_to_ovf_i8 () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.i8
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_0_lconv_to_ovf_u8_un () cil managed {
		.maxstack 16

		ldc.i4 1234
		conv.i8
		conv.ovf.u8.un
		conv.i4
		ldc.i4 1234
		beq L1
		ldc.i4.1
		ret
	L1:
		ldc.i4.0
		ret
	}

	.method public static int32 test_2_lconv_to_ovf_i4_un () cil managed {
		.maxstack 16
		.locals init (int32 res)

		ldc.i4 0x7fffffff
		conv.u8
		conv.ovf.i4.un
		pop

		ldc.i4.2
		stloc res

        .try {
			ldc.i8 0x80000000
			conv.ovf.i4.un
			pop
			ldc.i4.0
			stloc res
			leave RET
		} catch [mscorlib]System.OverflowException {
			pop
			leave IL_0
		}

	IL_0:

        .try {
			ldc.i8 0xffffffff80000000
			conv.ovf.i4.un
			pop
			ldc.i4.1
			stloc res
			leave RET
		} catch [mscorlib]System.OverflowException {
			pop
			leave RET
		}

	RET:
		ldloc res
		ret
	}

    .method public static int32 test_1_lconv_to_ovf_i_un () cil managed {
		.maxstack 16
		.locals init (int32 res)

		ldc.i4 0x7fffffff
		conv.u8
		conv.ovf.i.un
		conv.i4
		pop

		ldc.i4.1
		ret
	}

	.method public static int32 test_32_lconv_to_u8 () cil managed
	{
		.maxstack 16

		ldc.i4 32
		conv.i8
		conv.u8
		conv.i4
		ret
	}				

	.method public static int32 test_32_lconv_to_i8 () cil managed
	{
		.maxstack 16

		ldc.i4 32
		conv.i8
		conv.i8
		conv.i4
		ret
	}				

	.method public static int32 test_15_lconv_to_u () cil managed
	{
     	ldc.i8 0x10000000f
		conv.u
		conv.i4
		ret
	}

	.method public static int32 test_1234_fconv_u () cil managed {
		.maxstack 16

		ldc.r8 1234.0
		conv.u
		conv.i4
		ret
	}

	.method public static int32 test_0_get_type_from_handle_on_bblock_boundary () cil managed 
	{
		.maxstack 16
	
		ldc.i4.1
		brfalse OBJECT
	
		ldtoken [mscorlib]System.String
		br AFTER
	OBJECT:
		ldtoken [mscorlib]System.Object
	AFTER:
		call class [mscorlib]'System.Type' class [mscorlib]'System.Type'::'GetTypeFromHandle'(valuetype [mscorlib]'System.RuntimeTypeHandle')
		callvirt instance string class [mscorlib]System.Type::get_FullName ()
		ldstr "System.String"
		callvirt instance bool class [mscorlib]System.Object::Equals(object)
		ldc.i4.0
		ceq
		ret 
	}
		
	.method public static int32 test_0_bug59580  ()
	{
	        ldc.r4          float32(0x7FC00000)
	        ldc.r4          float32(0x7FC00000)
        	bge.un          pass
	        br              fail
	pass:
        	ldc.i4.0
	        ret
	fail:
        	ldc.i4.1
	        ret
	}
	
	.method public static int32 test_1_bug60056  () {
		.locals init (int32 m5)
			
		ldc.i4.m1
		stloc.0
		
		ldc.i4.1
		conv.u8
		
		ldloc.0
		conv.i8
		mul
		
		ldc.i4.m1
		conv.i8
		ceq
		ret
	}
	
	.method public static int32 test_1_conv_u8_cfold  () {
		ldc.i4.m1
		conv.u8
		
		ldc.i8 0x00000000ffffffff
		
		ceq
		ret
	}
	
	.method public static int32 test_1_array_type_mismatch_ldelema  () {
		.locals init (int32 r)
		
			ldc.i4.1
			newarr string
			ldc.i4.0 
			ldelema string
			pop
		
		.try {
			ldc.i4.1
			newarr string
			ldc.i4.0 
			ldelema object
			pop
			
			leave end
		} catch [mscorlib]System.ArrayTypeMismatchException {
			pop
			ldc.i4.1
			stloc.0
			leave end
		}
	end:
		ldloc.0
		ret
	}

	.method public static int32 test_1_conv_ovf_i8_with_i4 () {
			ldc.i4.m1 
			conv.ovf.i8
			conv.ovf.i4
			neg
			ret
	}

	// bug #72148
    .method public static int32 test_0_initlocals_float_ptr () {
	.maxstack 3
	.locals init (
		float32[]	V_0,
		float32& pinned	V_1,
		unsigned int32	V_2)
	  		ldc.i4.s 0x0f
	  		newarr [mscorlib]System.Single
	  		stloc.0 
	  		ldloc.0 
	  		ldc.i4.0 
	  		ldc.r4 1.13
	  		stelem.r4 
	  		ldloc.0 
	  		ldc.i4.0 
	  		ldelema [mscorlib]System.Single
	  		stloc.1 
	  		ldloc.1 
	  		conv.i 
	  		ldind.u4 
	  		stloc.2 
			ldc.i4.0
			ret
	}

	.method public static int32 test_7_conv_ovf_u8_un () {
    	.maxstack  2
        .locals    init (unsigned int64)

        ldc.i4.7
        conv.ovf.u8.un
        stloc.0
		ldloc.0
		conv.i4
        ret
	}

	.method public static int32 test_7_conv_ovf_u4_un () {
    	.maxstack  2
        .locals    init (unsigned int32)

        ldc.i4.7
        conv.ovf.u4.un
        stloc.0
		ldloc.0
		conv.i4
        ret
	}

	.method public static int32 test_1_bug_74591 () {
		.maxstack 16
		.locals init (int32)

		ldc.i4.m1
		stloc.0
		ldloc.0
		conv.ovf.i8
		ldc.i4.m1
		conv.ovf.i8
		mul.ovf
		conv.i4
		ret
	}

	.class nested public auto ansi Integer
  		extends [mscorlib]System.Object {

		.field public bool n

	    .method public hidebysig  specialname  rtspecialname 
           instance default void .ctor (unsigned int64 i, bool n)  cil managed 
	    {
			.maxstack 8
			ldarg.0
			call instance void class [mscorlib]System.Object::.ctor()
			ldarg.0
			ldarg.2
			stfld bool Tests/Integer::n
			ret
		}
	}

	.method public static int32 test_1_bug_74726 () {
		.maxstack 16

		ldc.i4.2
		conv.ovf.u8
		ldc.i4.1
		conv.ovf.u8
		mul.ovf.un
		ldc.i4.1
		newobj instance void class Tests/Integer::.ctor(unsigned int64, bool)
		ldfld bool Tests/Integer::n
		ldc.i4.1
		ceq
		ret
	}

	.class nested private auto ansi sealed xxx
  	extends [mscorlib]System.ValueType
   {
     .field  public   object a

     .method public hidebysig  specialname  rtspecialname 
            instance default void .ctor ()  cil managed 
     {
		 .maxstack 8
		 ret 
     }
   } // end of class xxx

	.method public static int32 test_0_newobj_vtype () {
		.maxstack 6
		.locals init (
			valuetype Tests/xxx V_0
		)

		newobj instance void valuetype Tests/xxx::.ctor ()
		stloc.0
		ldloca.s 0
		ldfld object Tests/xxx::a
		brfalse OK
		ldc.i4.s 1
		ret
	OK:
		ldc.i4.s 0
		ret
	}

	.method public static int32 test_0_newobj_vtype_primitive () {
		.maxstack 6
		.locals init (
			native int V_0
		)

		ldc.i4.s 10
		newobj instance void native int::'.ctor'(int32)
		stloc.0
		ldloc.0
		ldc.i4.s 10
		beq OK
		ldc.i4.s 1
		ret
	OK:
		ldc.i4.s 0
		ret
	}

	.method public static int32 test_1_filters () {
		.custom instance void [TestDriver]CategoryAttribute::.ctor(string) = ( 01 00 08 21 42 49 54 43 4F 44 45 00 00 )          // ...!BITCODE..
		.maxstack 16
		.locals init (
			int32 res
		)

		.try { // 0
			.try {
			  	ldstr "OnErrorSub test Exception"
			  	newobj instance void class [mscorlib]System.Exception::.ctor(string)
		  		throw 
		  		leave.s IL_0033
			}
			filter {
				pop
				ldc.i4.0
				endfilter
			} {
				pop
				// Should not be called
				ldc.i4.2
				stloc res
				leave.s IL_0033
			}
		}
		filter {
			pop
		  	ldc.i4.1
			endfilter 
		} {
		  pop
		  ldc.i4.1
		  stloc res	  
		  leave.s IL_0033

		}
		IL_0033:
		ldloc res
		ret
	}

	.class nested private auto ansi sealed beforefieldinit TheStruct
		extends [mscorlib]System.ValueType {
		.field public int32 a
		.field public int32 b
	}

	.method public static int32 test_5_cpobj () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloca v_1
		ldloca v_0
		cpobj Tests/TheStruct

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add

		ret
	}

	.method public static int32 test_5_ldobj_stloc_optimization () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloca v_0
		ldobj valuetype Tests/TheStruct
		stloc.s v_1

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add

		ret
	}

	.method public static int32 test_1_cpobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0, 
				object v_1
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloca v_1
		ldloca v_0
		cpobj object

		ldloc v_0
		ldloc v_1
		ceq
		ret
	}

	.method public static int32 test_1_initobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloca v_0
		initobj object

		ldloc v_0
		ldnull
		ceq
		ret
	}

	.method public static int32 test_1_ldobj_reference () {
		.maxstack 8
		.locals init (  
				object v_0
					 )

		newobj instance void object::.ctor()
		stloc v_0

		ldloc v_0
		ldloca v_0
		ldobj object
		ceq
		ret
	}

	.method public static int32 test_5_vtype_on_bb_boundary () {
		.maxstack 8
		.locals init (  
				valuetype Tests/TheStruct v_0, 
				valuetype Tests/TheStruct v_1
					 )

		ldloca v_0
		ldc.i4.2
		stfld int32 Tests/TheStruct::a

		ldloca v_0
		ldc.i4.3
		stfld int32 Tests/TheStruct::b

		ldloc v_0
		br L_0
	L_0: stloc v_1

		ldloca v_1
		ldfld int32 Tests/TheStruct::a
		ldloca v_1
		ldfld int32 Tests/TheStruct::b
		add
		ret
	}

	.method public static int32 test_5_different_in_stacks () cil managed {
		.maxstack 16

			ldc.i4.1
		 	ldc.i4.1
		 	beq L_0

		 	ldc.i4.3
		 	ldc.i4.3
		 	br L_1
		 	ldc.i4.3
		 	ldc.i4.3
		 	br L_2
	 L_0: 	ldc.i4.2
			ldc.i4.3
			ldc.i4.1
			ldc.i4.1
			beq L_2
	 L_1:	add
			ret
	 L_2:	add
			ret
	}

	.method public static int32 test_3_larray_get_set () {
		.locals init (
			int32[2]	V_0)
			  
			ldc.i4.2 
			newobj instance void int32[0...]::.ctor(int32)
			stloc.0 
			ldloc.0 
			ldc.i4.0 
			ldc.i4 1
			call instance void int32[0...]::Set(int32, int32)
		    ldloc.0 
		    ldc.i4.1 
			ldc.i4 2
			call instance void int32[0...]::Set(int32, int32)

			ldloc.0
			ldc.i4.0
			call instance int32 int32[0...]::Get(int32)
			ldloc.0
			ldc.i4.1
			call instance int32 int32[0...]::Get(int32)
			add
			ret
	}

	.method public static int32 test_0_pop_side_effects () {
		.try {
			ldc.r8 1
			ldc.r8 0
			div
			ckfinite
			pop
			leave FAIL
		}
		catch [mscorlib]System.ArithmeticException {
			pop
			leave L_0
		}
		L_0:
		ldc.i4.0
		ret
		FAIL:
		ldc.i4.1
		ret
	}

	.method public static void regalloc_regress_78314_helper (object o) cil managed
	{
		ret
	}

	.method public static int32 test_1_regalloc_regress_78314 () cil managed
	{
    // Code size       68 (0x44)
    .maxstack  6
    .locals init (int32 V_0, bool V_1)
    IL_0000:  ldc.i4.0
    IL_0001:  stloc.0
    IL_0002:  br.s       IL_003b

    IL_0004:
    IL_001e:  ldc.i4.s   10
    IL_0020:  ldloc.0
    IL_0021:  shl
    IL_0022:  ldc.i4.s   10
    IL_0024:  ldloc.0
    IL_0025:  shl
    IL_0026:  ceq
    IL_0028:  box        [mscorlib]System.Boolean
    IL_0032:  call       void Tests::regalloc_regress_78314_helper(object)
    IL_0037:  ldloc.0
    IL_0038:  ldc.i4.1
    IL_0039:  add
    IL_003a:  stloc.0
    IL_003b:  ldloc.0
    IL_003c:  ldc.i4.8
    IL_003f:  blt.s      IL_0004

	ldloc.0
	ldc.i4.8
	ceq
	conv.i4
	ret	
  }

	.method public static void try_block_end_remove_if_useless () cil managed {
	    .maxstack  8

	    T_START:
	        ldstr   "Start"
			pop
	        leave.s COMPLETE
	    T1_END:

	    COMPLETE:
	        ret

	    F1_START:
	        ldstr   "Finally1"
			pop
	        endfinally
	    F1_END:

	    .try T_START to T1_END finally handler F1_START to F1_END
	}

	.method public static int32 test_0_try_block_end_remove_if_useless () cil managed {
		call void class Tests::try_block_end_remove_if_useless ()
		ldc.i4.0
		ret
	}

   .method private static int32 test_0_regress_78629_switch_next_ins_target ()  cil managed
    {
        ldc.i4.0
        switch (target)
        target: ldstr "bar"
		pop
		ldc.i4.0
        ret
    }

	// This belongs to basic-float.cs, but its hard to tell mcs/csc to
	// generate the non .un version of the opcodes
    .method private static  hidebysig 
           default int32 test_4_float_branch_nan ()  cil managed 
    {
        // Method begins at RVA 0x27a4
	// Code size 74 (0x4a)
	.maxstack 2
	.locals init (
		float64	V_0,
		float64	V_1,
		int32	V_2)
	IL_0000:  ldc.r8 (00 00 00 00 00 00 f8 ff)
	IL_0009:  stloc.0 
	IL_000a:  ldc.r8 1.
	IL_0013:  stloc.1 
	IL_0014:  ldc.i4.0 
	IL_0015:  stloc.2 
	IL_0016:  ldloc.0 
	IL_0017:  ldloc.1 
	IL_0018:  bge.s IL_001a

				br L1
	IL_001a:  ldloc.2 
	IL_001b:  ret 
	L1:
	IL_001c:  ldloc.2 
	IL_001d:  ldc.i4.1 
	IL_001e:  add 
	IL_001f:  stloc.2 
	IL_0020:  ldloc.0 
	IL_0021:  ldloc.1 
	IL_0022:  ble.s IL_002e
				br L2
	IL_002e:  ldloc.2 
	IL_002f:  ret 
	L2:
	IL_0030:  ldloc.2 
	IL_0031:  ldc.i4.1 
	IL_0032:  add 
	IL_0033:  stloc.2 
	IL_0034:  ldloc.0 
	IL_0035:  ldloc.1 
	IL_0036:  blt.s IL_0038
				br L3		
	IL_0038:  ldloc.2 
	IL_0039:  ret 
	L3:
	IL_003a:  ldloc.2 
	IL_003b:  ldc.i4.1 
	IL_003c:  add 
	IL_003d:  stloc.2 
	IL_003e:  ldloc.0 
	IL_003f:  ldloc.1 
	IL_0040:  bgt.s IL_0042
				br L4
	IL_0042:  ldloc.2 
	IL_0043:  ret 
	L4:
	IL_0044:  ldloc.2 
	IL_0045:  ldc.i4.1 
	IL_0046:  add 
	IL_0047:  stloc.2 
	IL_0048:  ldloc.2 
	IL_0049:  ret 
    } // end of method Tests::test_5_float_branch_nan

    .method private static  hidebysig
           default void regress_80622_inner (object x)  cil managed
    {
		.locals init (unsigned int8 i)
        // Method begins at RVA 0x2050
        // Code size 14 (0xe)
        .maxstack 8
        IL_1000:  ldarg.0
        IL_1001:  unbox unsigned int8
        IL_1006:  ldobj unsigned int8
        IL_000b:  conv.ovf.i4.un
        IL_000c:  pop
        IL_000d:  ret
    }

    // method line 2
    .method private static  hidebysig
           default int32 test_0_regress_80622 ()  cil managed
    {
        .maxstack 8
        IL_0000:  ldc.i4 255
        IL_0005:  box unsigned int8
        IL_000a:  call void class Tests::regress_80622_inner (object)
		ldc.i4.0
        IL_000f:  ret
    }

	.method private static default int32 test_0_regresss_80190 () cil managed
	{
	    .maxstack  2
	    .locals init (int32 V_0,
	             int32* V_1)
	    IL_0000:  nop
	    IL_0001:  nop
	    IL_0002:  ldloca.s   V_0
	    IL_0004:  conv.u
	    IL_0005:  stloc.1
	    IL_0006:  ldloc.1
	    IL_0007:  ldc.i4.3
	    IL_0008:  stind.i4
	    IL_0009:  nop
				  ldc.i4.0
				  ret
	}

	.class interface nested public auto ansi abstract IFaceWithStaticMethod
	{
	    .method public static  specialname 
    	       default void foo ()  cil managed noinlining 
	    {
		.maxstack 0
		IL_0000:  ret 
    	}
	}
	
	.class nested public auto ansi AClass extends [mscorlib]System.Object implements Tests/IFaceWithStaticMethod
	{
	    .method public hidebysig  specialname  rtspecialname 
           instance default void .ctor ()  cil managed 
	    {
			.maxstack 8
			ret
		}

	}

	// Test that static methods in interfaces are ignored during vtable construction
	.method private static default int32 test_0_ifaces_with_static_methods () cil managed
	{
		.maxstack 16

		newobj instance void class Tests/AClass::.ctor()
		pop
		ldc.i4.0
		ret
	}

	.method private static hidebysig default int32 Foo<T> (!!T n)  cil managed {
		ldarg.0
		box !!0
		brtrue HAS_VALUE
		ldc.i4.0
		ret
HAS_VALUE:	ldc.i4.1
		ret
	}

	// bug 78019
	.method static public int32 test_0_nullable_box_brtrue () cil managed {

		.locals init (valuetype [mscorlib]System.Nullable`1<int32> V_0)

		ldloc.0
		call int32 class Tests::Foo<valuetype [mscorlib]System.Nullable`1<int32>> (!!0)
		ret
	}

	//Bug 372410
	.method static public int32 test_0_ldelema_type_check () cil managed {
		.maxstack 16
		.locals init (object[] V_0,
					  object[,] V_1)

		ldc.i4.1
		newarr object
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			ldelema object
			leave L1
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR1
		}

	L1:
		ldc.i4.1
		newarr string
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			ldelema object
			leave ERROR2
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave L2
		}

	L2:
			ldc.i4.1
		newarr string
		stloc.0

		.try {
			ldloc.0
			ldc.i4.0
			readonly. ldelema object
			leave L3
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR3
		}

	L3:
		ldc.i4.0
		ret


	ERROR1:
		ldc.i4.1
		ret

	ERROR2:
		ldc.i4.2
		ret

	ERROR3:
		ldc.i4.3
		ret
	}


	//Bug 372410
	.method static public int32 test_0_array_address_type_check () cil managed {
		.maxstack 16
		.locals init (object[] V_0,
					  object[,] V_1)

		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void object[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			call instance object&  object[,]::Address(int32, int32)
			leave L4
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR4
		}

	L4:
		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void string[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			call instance object&  object[,]::Address(int32, int32)
			leave ERROR5
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave L5
		}

	L5:
		ldc.i4.1 
	    ldc.i4.1 
	    newobj instance void string[,]::.ctor(int32, int32)
		stloc.1

		.try {
			ldloc.1
			ldc.i4.0
			ldc.i4.0
			readonly. call instance object&  object[,]::Address(int32, int32)
			leave L6
		} catch [mscorlib]System.ArrayTypeMismatchException {
			leave ERROR6
		}

	L6:
		ldc.i4.0
		ret
	ERROR4:
		ldc.i4.4
		ret

	ERROR5:
		ldc.i4.5
		ret

	ERROR6:
		ldc.i4.6
		ret
	}

	.field public  static unsigned int64 'ull'

	.field public  static int32 'shift2'

	.method public static int32 test_0_long_shift_regalloc () cil managed
	{
		.locals init (unsigned int32 'cilsimp.28', unsigned int64 'cilsimp.27', int32 'cilsimp.26')

		.maxstack 4

		ldc.i8	81985529234382576
		stsfld	unsigned int64 Tests::ull
	    ldc.i4	60
		stsfld	int32 Tests::shift2

		ldsfld	unsigned int64 Tests::ull
		stloc	'cilsimp.27'
		ldsfld	int32 Tests::shift2
		stloc	'cilsimp.28'
		ldloc	'cilsimp.27'
		ldloc	'cilsimp.28'
		shr.un
		ldloc	'cilsimp.27'
		ldc.i4	64
		ldloc	'cilsimp.28'
		sub
		shl
		or
		ldc.i8	1311768467750121216
		ceq
		ldc.i4.1
		xor
		conv.u4
		ret
	}

	// Test calling ldfld directly on a vtype instead of a vtype address
	.method public static int32 test_5_call_ldfld_vtype () cil managed
	{
		.maxstack 16
		.locals init (
			valuetype Tests/TailCallStruct arg
		)
		ldloca 0
		ldc.i4.2
		stfld int32 Tests/TailCallStruct::a
		ldloca 0
		ldc.i4.4
		stfld int32 Tests/TailCallStruct::b
		ldloc.0
		call valuetype Tests/TailCallStruct Tests::tail2 (valuetype Tests/TailCallStruct)
		ldfld int32 Tests/TailCallStruct::a
		ret
	}

	.method public static int32 throw_ret () cil managed
	{
		ldstr "FOO"
		newobj instance void class [mscorlib]System.OverflowException::.ctor(string)
		throw
		ldc.i4.4
		ret
	}

	.method public static int32 throw2_ret () cil managed
	{
		// Disable inlining
		ldc.i4.5
		localloc
		pop

		call int32 Tests::throw_ret ()
		ret
	}

	// Test inlining a method which contains just a throw
	.method public static int32 test_0_inline_throw () cil managed
	{
		.maxstack 16
		.locals init (
				int32 v_0
		)

		.try {
			call int32 Tests::throw2_ret ()
			stloc.0
			leave L0
		} catch [mscorlib]System.OverflowException {
			pop
			leave L1
		}

		L0:
			ldc.i4.1
			ret
		L1:
			ldc.i4.0
			ret			
	}

    .method public static int32 test_0_stelem_any_null_opt () cil managed
    {
		.maxstack 16
		.locals init (
				object[]	V_0,
				int32	V_1)

		ldc.i4.s 10
		newarr [mscorlib]System.Object
		stloc.0

		ldc.i4.0
		stloc.1
		br L0

	L1:
		ldloc.0
		ldloc.1
		ldnull
		stelem.any [mscorlib]System.Object
		ldloc.1
		ldc.i4.1
		add
		stloc.1
	L0:
		ldloc.1
		ldc.i4.s 10
		blt L1

		ldc.i4.0
		ret
	}

    // method line 2
    .method public static  hidebysig 
           default int32 manyargs_callee (int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 g, int32 h, int32 i, int32 j, int32 k, int32 l, int32 m, int32 n, int32 o, int32 p)  cil managed 
    {
        // Method begins at RVA 0x20f4
	// Code size 44 (0x2c)
	.maxstack 8
	IL_0000:  ldarg.0 
	IL_0001:  ldarg.1 
	IL_0002:  add 
	IL_0003:  ldarg.2 
	IL_0004:  add 
	IL_0005:  ldarg.3 
	IL_0006:  add 
	IL_0007:  ldarg.s 4
	IL_0009:  add 
	IL_000a:  ldarg.s 5
	IL_000c:  add 
	IL_000d:  ldarg.s 6
	IL_000f:  add 
	IL_0010:  ldarg.s 7
	IL_0012:  add 
	IL_0013:  ldarg.s 8
	IL_0015:  add 
	IL_0016:  ldarg.s 9
	IL_0018:  add 
	IL_0019:  ldarg.s 10
	IL_001b:  add 
	IL_001c:  ldarg.s 11
	IL_001e:  add 
	IL_001f:  ldarg.s 12
	IL_0021:  add 
	IL_0022:  ldarg.s 13
	IL_0024:  add 
	IL_0025:  ldarg.s 14
	IL_0027:  add 
	IL_0028:  ldarg.s 15
	IL_002a:  add 
	IL_002b:  ret 
    } // end of method main::callee

    // method line 3
    .method public static  hidebysig 
           default int32 manyargs_tail_caller (int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 g, int32 h, int32 i, int32 j, int32 k, int32 l, int32 m, int32 n, int32 o, int32 p)  cil managed 
    {
        // Method begins at RVA 0x2124
	// Code size 34 (0x22)
	.maxstack 17
	IL_0000:  ldarg.0 
			  ldc.i4.1
			  add
	IL_0001:  ldarg.1 
	IL_0002:  ldarg.2 
	IL_0003:  ldarg.3 
	IL_0004:  ldarg.s 4
	IL_0006:  ldarg.s 5
	IL_0008:  ldarg.s 6
	IL_000a:  ldarg.s 7
	IL_000c:  ldarg.s 8
	IL_000e:  ldarg.s 9
	IL_0010:  ldarg.s 10
	IL_0012:  ldarg.s 11
	IL_0014:  ldarg.s 12
	IL_0016:  ldarg.s 13
	IL_0018:  ldarg.s 14
			  ldc.i4.1
			  add
	IL_001a:  ldarg.s 15
			  ldc.i4.1
			  add
	          tail.
	IL_001c:  call int32 class Tests::manyargs_callee(int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)
	IL_0021:  ret 
    } // end of method main::caller

    // method line 4
    .method public static  hidebysig 
           default int32 test_139_many_args_tail_call ()  cil managed
    {
		// Some platforms might not be able to AOT tail calls
		.custom instance void class [TestDriver]CategoryAttribute::'.ctor'(string) =  (01 00 08 21 46 55 4C 4C 41 4F 54 00 00 ) // ...!FULLAOT..

        // Method begins at RVA 0x2154
	// Code size 43 (0x2b)
	.maxstack 17
	IL_0000:  ldc.i4.1 
	IL_0001:  ldc.i4.2 
	IL_0002:  ldc.i4.3 
	IL_0003:  ldc.i4.4 
	IL_0004:  ldc.i4.5 
	IL_0005:  ldc.i4.6 
	IL_0006:  ldc.i4.7 
	IL_0007:  ldc.i4.8 
	IL_0008:  ldc.i4.s 0x09
	IL_000a:  ldc.i4.s 0x0a
	IL_000c:  ldc.i4.s 0x0b
	IL_000e:  ldc.i4.s 0x0c
	IL_0010:  ldc.i4.s 0x0d
	IL_0012:  ldc.i4.s 0x0e
	IL_0014:  ldc.i4.s 0x0f
	IL_0016:  ldc.i4.s 0x10
	IL_0018:  call int32 class Tests::manyargs_tail_caller(int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32, int32)
	IL_0028:  ret 
    } // end of method main::Main

	.class nested private auto ansi beforefieldinit R1
    	   extends [mscorlib]System.MarshalByRefObject
	{
		.field  public  int32 test_field

    	.method public hidebysig  specialname  rtspecialname
           		instance default void '.ctor' ()  cil managed
    	{
			ret
		}
	}

	.method public static hidebysig
			default int32 return_0 () cil managed
	{
		ldc.i4.0
		ret
	}

	.method public static hidebysig
			default int32 test_1_volatile_marshalbyref_bug_432673 () cil managed
	{
		.locals init (
			class Tests/R1 v_0
		)

		newobj instance void class Tests/R1::.ctor ()
		stloc.0
		ldloc.0
		ldc.i4.0
		volatile.
		stfld int32 Tests/R1::test_field
		call int32 class Tests::return_0 ()
		ldc.i4.1
		add
		ret
	}

	.method public static default int32 return_2 () cil managed
	{
		// Prevent inlining
		ldc.i4.s 16
        localloc
		pop
		ldc.i4.s 2
		ret
	}

	.method public static hidebysig
			default int32 test_1_cmov_opt_regress_463357 () cil managed
	{
		call int32 class Tests::return_2 ()
		ldc.i4.0
		ceq
		brfalse L1
		ldc.i4.0
		ret
		br L2
	L1: nop
	L2: nop
		ldc.i4.1
		ret
	}

   .method public static hidebysig default int32 cmov_opt_regress_474718_inner (int32 A_1)  cil managed 
   {
      .maxstack 3
      .locals init (int32 V_0, bool V_1, bool V_2)
      
	  ldc.i4.0
      IL_000b:  stloc.1 
      IL_000d:  br IL_002f

	  ldc.i4.1    
	  stloc.2
      IL_001e:  ldloc.2 
      IL_001f:  brfalse IL_0036

      IL_0024:  
      IL_002a:  br IL_0041
    
      IL_002f:  ldloc.1
      IL_0030:  stloc.2 
      IL_0031:  br IL_001e
    
      IL_0036:  ldc.i4 0
      IL_003b:  stloc.0 
      IL_003c:  br IL_0041
    
      IL_0041:  ldloc.0 
      IL_0042:  ret 
  } 

    .method public static default int32 test_0_cmov_opt_regress_474718 ()  cil managed 
    {
        .maxstack 16
        ldc.i4.1
        call int32 Tests::cmov_opt_regress_474718_inner (int32)
        ret
   }

	.method public static default int32 test_5_createarr_newobj () cil managed
	{
		.maxstack 16

		ldc.i4 5
		newobj void char[]::.ctor(int32)
		ldlen
		ret
	}

	.method public static default int32 test_0_initblk_3_regress_481458 () cil managed
	{
		.maxstack 16
		.locals init (native int)

		ldc.i4.s 10
		localloc
		stloc.0

		// Set the first value to 3
		ldloc.0
		ldc.i4.0
		add		//addr
		ldc.i4.3	//value
		stind.i1

		// Zero out the first 3 values
		ldloc.0		//addr
		ldc.i4.0	//value
		ldc.i4.s 3	//size
		initblk

		// Load the first value
		ldloc.0
		ldc.i4.0
		add	
		ldind.u1
		conv.i4
		ret
	}

/*	   Disabled until they can be fixed to run on amd64
	.method public static float32 GetFloat32() cil managed noinlining
	{
		.maxstack  8
		ldc.r8     0.19975845134874831
		ret
	}

	.method public static default int32 test_0_implicit_float_to_double_conversion () cil managed
	{
		.maxstack 16

		call float32 Tests::GetFloat32()
		ldc.r8     0.19975845134874831
		beq OK

		ldc.i4.1
		ret
OK:
		ldc.i4.0
		ret
	}
*/

	.method public static default int32 test_0_long_to_r8_un_overflow () cil managed
	{
		.maxstack 16
		ldc.i8     0x00FFFFFFFFFFFFFF
		conv.r.un
		conv.i8
		ldc.i8 0x100000000000000
		beq OK_1

		ldc.i4.1
		ret
OK_1:
		ldc.i8     0x00FFFFFFFFFFFFFF
		conv.r.un
		conv.r8
		conv.i8
		ldc.i8 0x100000000000000
		beq OK_2

		ldc.i4.2
		ret
OK_2:
		ldc.i4.0
		ret
	}

	.field public static int32 shift1

	.method public static int32 regress_497271_helper (int32 i) cil managed
	{
		ldarg.0
		ret
	}

	.method public static int32 test_0_regalloc_regress_497271 () cil managed
	{
		.locals init (int32 var)

		ldc.i4	4
		stsfld	int32 Tests::shift1
		ldsfld	int32 Tests::shift1
		stloc	var
		ldc.i4	4660
		ldloc	var
		shr.un
		ldc.i4	4660
		ldc.i4	32
		ldloc	var
		sub
		shl
		or
		ldc.i4	1073742115
		beq	?L10
?L9:
		ldc.i4	1
		call	int32 Tests::regress_497271_helper (int32)
		ret
?L10:
		ldc.i4	0
		call	int32 Tests::regress_497271_helper (int32)
		ret
	}

   .field  private static  int32 Value

  .method public static hidebysig  specialname 
          default int32 regress_513931_inner ()  cil managed 
    {                                                                 
        // Method begins at RVA 0x225c                                
        // Code size 52 (0x34)                                        
        .maxstack 2                                                   
        .locals init (                                                
                int32   V_0,                                          
                int32   V_1,                                          
                bool    V_2)
                       
				ldc.i4 999
				stsfld int32 Tests::Value

        IL_0000:  nop                                                 
        IL_0001:  ldsfld int32 Tests::Value      
        IL_0006:  stloc.0                                             
        IL_0007:  ldloc.0                                             
        IL_0008:  ldc.i4.0                                            
        IL_0009:  cgt                                                 
        IL_000b:  ldc.i4.0                                            
        IL_000c:  ceq                                                 
        IL_000e:  stloc.2                                             
        IL_000f:  ldloc.2                                             
        IL_0010:  brtrue.s IL_0027                                    

        IL_0012:  nop 
        IL_0013:  ldloc.0 
        IL_0014:  ldc.i4.s 0x7b
        IL_0016:  ceq          
        IL_0018:  ldc.i4.0     
        IL_0019:  ceq          
        IL_001b:  stloc.2      
        IL_001c:  ldloc.2      
        IL_001d:  brtrue.s IL_0023

        IL_001f:  ldc.i4.m1 
        IL_0020:  stloc.1   
        IL_0021:  br.s IL_0032

        IL_0023:  ldc.i4.1 
        IL_0024:  stloc.1  
        IL_0025:  br.s IL_0032

        IL_0027:  
        IL_002c:  newobj instance void class [mscorlib]System.Exception::'.ctor'()
        IL_0031:  throw                                                                            
        IL_0032:  ldloc.1                                                                          
        IL_0033:  ret                                                                              
    }

	.method public static hidebysig  specialname 
         default int32 test_0_regress_513931 ()  cil managed 
	{
		call int32 Tests::regress_513931_inner ()
		pop
		ldc.i4.0
		ret
	}

	.method public static default int32 test_0_newarr_i8 () cil managed
	{
		ldc.i4 1000
		conv.i8
		newarr [mscorlib]System.Boolean
		pop
		ldc.i4 0
		ret
	}

	.method public static specialname 
    	       default int32 return_1_noinline ()  cil managed noinlining 
	{
		.maxstack 0

		ldc.i4.1
		ret 
   	}

	// Only happens with -O=-deadce,cmov
	.method public static default int32 test_0_cmov_unused_582322 () cil managed
	{
        .maxstack 2                                                   
        .locals init (                                                
				int32 V_0
		)				
		call int32 Tests::return_1_noinline ()
		ldc.i4.1
		bne.un L0
		ldloc.s 0
		pop
	L0:
		ldc.i4.0
		ret
	}

    .method public static  hidebysig 
           default int32 test_0_regress_586664 ()  cil managed 
    {                                        
        // Method begins at RVA 0x20f4       
        // Code size 76 (0x4c)               
        .maxstack 6                          
        .locals init (                       
                float64 V_0,                 
                float64[]       V_1)         
        IL_0000:  ldc.r8 1.                  
        IL_0009:  ldc.r8 2.                  
        IL_0012:  ldc.r8 1.                  
        IL_001b:  call float64 class [mscorlib]System.Math::Pow(float64, float64)
        IL_0020:  div                                                            
        IL_0021:  stloc.0                                                        
        IL_0022:  ldc.i4.2                                                       
        IL_0023:  newarr [mscorlib]System.Double                                 
        IL_0028:  dup                                                            
        IL_0029:  ldc.i4.0                                                       
        IL_002a:  ldloc.0                                                        
        IL_002b:  neg                                                            
        IL_002c:  stelem.r8                                                      
        IL_002d:  dup                                                            
        IL_002e:  ldc.i4.1                                                       
        IL_002f:  ldloc.0
        IL_0030:  neg
        IL_0031:  stelem.r8
        IL_0032:  stloc.1
        IL_0033:  ldloc.1
        IL_0034:  ldc.i4.0
        IL_0035:  ldelem.r8
        IL_0036:  ldc.r8 -0.5
        IL_003f:  bne.un IL_004a

        IL_0044:  ldc.i4.0
        IL_0045:  br IL_004b

        IL_004a:  ldc.i4.1
        IL_004b:  ret
    }

	.method public static int32 test_2_leave_multiple_blocks_from_end ()
	{
		.locals init (int32 V_0)

		.try {
			.try {
				nop
				nop
				leave END
			} finally {
				ldloc.0
				ldc.i4.1
				add
				stloc.0
				endfinally
			}
			nop
			leave END
		} finally {
			ldloc.0
			ldc.i4.1
			add
			stloc.0
			endfinally
		}
END:
		ldloc.0
		ret
	}

	.method public static int32 test_3_leave_multiple_blocks_from_hole ()
	{
		.locals init (int32 V_0)

		.try {
			.try {
				ldloc.0
				brtrue REST
				leave BEFORE_END
REST:
				nop
				nop
				leave END
			} finally {
				ldloc.0
				ldc.i4.1
				add
				stloc.0
				endfinally
			}
			nop
			leave END
		} finally {
			ldloc.0
			ldc.i4.1
			add
			stloc.0
			endfinally
		}
BEFORE_END:
		ldloc.0
		ldc.i4.1
		add
		stloc.0
END:
		ldloc.0
		ret
	}

	.class nested private auto ansi sealed beforefieldinit Pair`2<TKey,TValue>
  		   extends [mscorlib]System.ValueType
	{
		.field  public  !0 key
    	.field  public  !1 'value'
  	}

    .method private static hidebysig 
           default bool ContentEquals<TKey,TValue> (valuetype Tests/Pair`2<!!TKey, !!TValue> v)  cil managed 
    {
	.maxstack 8
	IL_0000:  ldarga.s 0 
	IL_0006:  ldnull 
			  constrained. valuetype Tests/Pair`2<!!0,!!1>
	IL_0007:  callvirt instance bool class [mscorlib]System.Object::Equals(object)
			  ret
    }

    .method public static hidebysig default int32 test_0_constrained_gshared_595863 () cil managed
    {
		.locals init (
		valuetype Tests/Pair`2<string, string>	V_0,
		valuetype Tests/Pair`2<string, string>	V_1)
	IL_0000:  ldloca.s 0
	IL_0002:  initobj valuetype Tests/Pair`2<string,string>
	IL_0008:  ldloc.0 
	IL_0009:  stloc.1 
	IL_000a:  ldloca.s 1
	IL_000c:  ldstr "A"
	IL_0011:  stfld !0 valuetype Tests/Pair`2<string,string>::key
	IL_0016:  ldloca.s 1
	IL_0018:  ldstr "B"
	IL_001d:  stfld !1 valuetype Tests/Pair`2<string,string>::'value'
	IL_0022:  ldloc.1 
	IL_0023:  stloc.0 
	IL_0024:  ldloc.0 
	IL_0025:  call bool class Tests::ContentEquals<string, string> (valuetype Tests/Pair`2<!!0,!!1>)
			  brfalse SUCCESS
			  ldc.i4.1
			  ret
	SUCCESS:
			  ldc.i4.0
			  ret
    }

	.method public static default int32 test_0_wrap_non_exception_throws () cil managed
	{
	  .try {
	  	    newobj instance void class [mscorlib]System.Object::'.ctor'()
			throw
		  leave IL_0
	  } catch class [mscorlib]System.Runtime.CompilerServices.RuntimeWrappedException {
		  leave IL_0
		}
		IL_0:
		ldc.i4.0
		ret
    }

	.method public static default int32 test_0_typespec_modopt () cil managed {
		ldtoken class Tests modopt (Tests)
		pop
		ldc.i4.0
		ret
	}

	.method public hidebysig static int32 SizeOfT<T>() cil managed
  	{
		.maxstack  8
    
		sizeof !!0
    	ret
  	}

	.method public static default int32 test_1_sizeof_gshared () cil managed {
	    call   int32 Tests::SizeOfT<int8>()
		ldc.i4.1
		ceq
		ret
	}

	.method public static default int32 test_1_sizeof_ref () cil managed {
	    call   int32 Tests::SizeOfT<object>()
		sizeof [mscorlib]System.IntPtr
		ceq
		ret
	}

  .field static public int32 volatile_int

  	.method public static default int32 test_5_volatile_load_store () cil managed {
 		ldsflda int32 class Tests::volatile_int
 		ldc.i4 5
 		volatile.
		stind.i4
 		ldsflda int32 class Tests::volatile_int
		volatile.
		ldind.i4
		ret
  	} 		

    .method public static 
           default int32 regress_693905_inner (int32 x, int32 acc)  cil managed 
    {
        // Method begins at RVA 0x2050
        // Code size 17 (0x11)
        .maxstack 5
        IL_0000:  ldarg.0 
        IL_0001:  brtrue.s IL_0005

        IL_0003:  ldarg.1 
        IL_0004:  ret 
        IL_0005:  ldarg.0 
        IL_0006:  ldc.i4.1 
        IL_0007:  sub 
        IL_0008:  ldarg.1 
        IL_0009:  ldc.i4.1 
        IL_000a:  add 
        IL_000b:  starg.s 1
        IL_000d:  starg.s 0
        IL_000f:  br.s IL_0000

    } // end of method Test::f

    .method public static 
           default int32 test_10_regress_693905 ()  cil managed 
	{
		ldc.i4.s 0x0a
        ldc.i4.0 
        call int32 class Tests::regress_693905_inner(int32, int32)
		ret
	}

	.method public static
			default int32 test_0_llvm_regress_171 () cil managed
	{
		.locals init (
			int32 i
		)

		call int32 Tests::return_1_noinline ()
		ldc.i4.1
		beq L1
		ldc.i4.1
		stloc.s 0
		call int32 Tests::return_1_noinline ()
		ldc.i4.0
		beq L1
		L1:
		ldloc.s 0
		ret
	}

     .field  public static int32 static_a

	.method public static
			default int32 test_4_ldfld_stfld_static () cil managed
	{
		ldnull
		ldc.i4 2
		stfld int32 Tests::static_a
		ldnull
		ldfld int32 Tests::static_a
		ldnull
		ldflda int32 Tests::static_a
		ldind.i4
		add
		ret
	}

  .method public static default int32 no_initlocals_inner () cil managed
  {
    .locals (
	int32 V_0,
	float32 V_1,
	float64 V_2,
	valuetype Tests/TailCallStruct V_3)
       ldloc V_0
       ret
  }

  .method public static default int32 test_0_no_initlocals () cil managed
  {
       call int32 Tests::no_initlocals_inner()
       pop
	   ldc.i4.0
       ret
  }

  .method public hidebysig static int32  test_5_r4_fadd_mixed() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  2
    .locals init (float32 V_0,
             float64 V_1)
    IL_0000:  ldc.r4     3
    IL_0005:  stloc.0
    IL_0006:  ldc.r8     2
    IL_000b:  stloc.1
    IL_000c:  ldloc.0
    IL_000d:  ldloc.1
    IL_000e:  add
    IL_000f:  conv.i4
    IL_0010:  ret
  }

 .method public hidebysig static int32  test_0_fcmp_eq_r4_mixed() cil managed
  {
    // Code size       32 (0x20)
    .maxstack  2
    .locals init (float32 V_0,
             float64 V_1)
    IL_0000:  ldc.r4     1
    IL_0005:  stloc.0
    IL_0006:  ldc.r8     1
    IL_000f:  stloc.1
    IL_0010:  ldloc.0
    IL_0012:  ldloc.1
    IL_0013:  bne.un     IL_001e

    IL_0018:  ldc.i4.0
    IL_0019:  br         IL_001f

    IL_001e:  ldc.i4.1
    IL_001f:  ret
  } // end of method Tests::test_0_fcmp_eq_r4_mixed

  .method public hidebysig static int32  test_0_fceq_r4_mixed() cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  2
    .locals init (float32 V_0,
             float64 V_1,
             bool V_2)
    IL_0000:  ldc.r4     1
    IL_0005:  stloc.0
    IL_0006:  ldc.r8     1
    IL_000b:  stloc.1
    IL_000c:  ldloc.0
    IL_000d:  ldloc.1
    IL_000e:  ceq
    IL_0010:  stloc.2
    IL_0011:  ldloc.2
    IL_0012:  brfalse    IL_001d

    IL_0017:  ldc.i4.0
    IL_0018:  br         IL_001e

    IL_001d:  ldc.i4.1
    IL_001e:  ret
  } // end of method Tests::test_0_fceq_r4

  .method public static int32 test_0_switch_loop () cil managed
  {
	.maxstack 16
	.locals init (valuetype Tests/TailCallStruct V_0, int32 V_1)
	ldc.i4.0
	ldloc.0
	ldloc.1
	brtrue L_1
	L_0:
	ldc.i4.4
	switch (L_0)
	L_1:
	pop
	ret
  }

  .method public static int32 test_2_fault () cil managed
  {
	.maxstack 16
	.locals init (int32 V_0)
    IL_0000:  ldc.i4.0
    IL_0001:  stloc.0
    .try
    {
      .try
      {
        IL_0002:  newobj     instance void [mscorlib]System.Exception::.ctor()
        IL_0007:  throw
		leave.s    IL_0018
      }  // end .try
	  fault
      {
        IL_0009:  ldloc.0
        IL_000a:  ldc.i4.1
        IL_000b:  add
        IL_000c:  stloc.0
				  endfinally
      }  // end handler
      IL_000f:  leave.s    IL_0018

    }  // end .try
    catch [mscorlib]System.Object
    {
      IL_0011:  pop
      IL_0012:  ldloc.0
      IL_0013:  ldc.i4.1
      IL_0014:  add
      IL_0015:  stloc.0
      IL_0016:  leave.s    IL_0018

    }  // end handler
    IL_0018:  ldloc.0
	ret
	}

  .method public static int32 test_0_fault_no_exception () cil managed
  {
	.maxstack 16
	.locals init (int32 V_0)
    IL_0000:  ldc.i4.0
    IL_0001:  stloc.0
    .try
    {
      .try
      {
		leave.s    IL_0018
      }  // end .try
	  fault
      {
        IL_0009:  ldloc.0
        IL_000a:  ldc.i4.1
        IL_000b:  add
        IL_000c:  stloc.0
				  endfinally
      }  // end handler
      IL_000f:  leave.s    IL_0018

    }  // end .try
    catch [mscorlib]System.Object
    {
      IL_0011:  pop
      IL_0012:  ldloc.0
      IL_0013:  ldc.i4.1
      IL_0014:  add
      IL_0015:  stloc.0
      IL_0016:  leave.s    IL_0018

    }  // end handler
    IL_0018:  ldloc.0
	ret
	}

    .field  private static  int32 byte_val
    .field  private static  int32 short_val

    .method static int32 widen_arguments (unsigned int8 a, int8 b, int16 c, unsigned int16 d) cil managed noinlining
    {
		.maxstack 4
		ldsfld int32 Tests::byte_val
		starg.s 0
		ldarg.0
		ldc.i4 128 //0x80
		beq L_0

		ldc.i4.1
		ret
L_0:
		ldsfld int32 Tests::byte_val
		starg.s 1
		ldarg.1
		ldc.i4 -128 //-0x80
		beq L_1

		ldc.i4.2
		ret

L_1:
		ldsfld int32 Tests::short_val
		starg.s 2
		ldarg.2
		ldc.i4 -32768 //-0x8000
		beq L_2

		ldc.i4.3
		ret

L_2:
		ldsfld int32 Tests::short_val
		starg.s 3
		ldarg.3
		ldc.i4 32768 //0x8000
		beq L_3

		ldc.i4.4
		ret

L_3:
		ldc.i4.0
		ret
    }

	.method public static int32 test_0_implicit_widen_of_argument_stores () cil managed
	{
		.maxstack 5
		/*
		This test verifies that storing an I4 value from the evail stack into a local variable triggers proper widening.
		The values are picked so storing them have different values depending on the sign'ness of the local variable.
		*/
		ldc.i4 0x180
		stsfld int32 Tests::byte_val
		ldc.i4 0x18000
		stsfld int32 Tests::short_val

		ldc.i4.0
		ldc.i4.0
		ldc.i4.0
		ldc.i4.0
		call int32 Tests::widen_arguments (unsigned int8 a, int8 b, int16 c, unsigned int16 d)
		ret
	}

    .method public static int32 test_0_implicit_widen_of_local_stores () cil managed
    {
		.maxstack 4
		.locals init (
			unsigned int8	V_0,
			int8	V_1,
			int16	V_2,
			unsigned int16	V_3)

		/*
		This test verifies that storing an I4 value from the evail stack into a local variable triggers proper widening.
		The values are picked so storing them have different values depending on the sign'ness of the local variable.
		*/
		ldc.i4 0x180
		stsfld int32 Tests::byte_val
		ldc.i4 0x18000
		stsfld int32 Tests::short_val

		ldsfld int32 Tests::byte_val
		stloc.0
		ldloc.0
		ldc.i4 128 //0x80
		beq L_0

		ldc.i4.1
		ret
L_0:
		ldsfld int32 Tests::byte_val
		stloc.1
		ldloc.1
		ldc.i4 -128 //-0x80
		beq L_1

		ldc.i4.2
		ret
L_1:
		ldsfld int32 Tests::short_val
		stloc.2
		ldloc.2
		ldc.i4 -32768 //-0x8000
		beq L_2

		ldc.i4.3
		ret
L_2:
		ldsfld int32 Tests::short_val
		stloc.3
		ldloc.3
		ldc.i4 32768 //0x8000
		beq L_3

		ldc.i4.4
		ret
L_3:
		ldc.i4.0
		ret
    }

	.method public static bool llvm_regress_59436 () {
		// Code size	   41 (0x29)
		.maxstack  3
		.locals init (float64 V_0,
					  float64 V_1,
					  valuetype [mscorlib]System.Decimal V_2)
		IL_0000:  ldc.r8	 1
		IL_0009:  stloc.0
		IL_000a:  ldc.r8	 2
		IL_0013:  stloc.1
		IL_0014:  ldloc.0
		IL_0015:  newobj	 instance void [mscorlib]System.Decimal::.ctor(float64)
		IL_001a:  ldloca.s   V_2
		IL_001c:  ldloc.1
		IL_001d:  call	   instance void [mscorlib]System.Decimal::.ctor(float64)
		IL_0022:  ldloc.2
		IL_0023:  call	   bool [mscorlib]System.Decimal::op_LessThanOrEqual(valuetype [mscorlib]System.Decimal,
																			   valuetype [mscorlib]System.Decimal)
		IL_0028:  ret
	}

  .method private hidebysig static void  fail_inline() cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldc.i4.s   16
    IL_0002:  conv.u
    IL_0003:  ldc.i4.1
    IL_0004:  mul.ovf.un
    IL_0005:  localloc
    IL_0007:  pop
    IL_0008:  ret
  }

  .method private hidebysig static int32
          always_inline(int32 op) cil managed aggressiveinlining
  {
    // Code size       24 (0x18)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  brfalse.s  IL_0009

    IL_0003:  ldarg.0
    IL_0004:  ldc.i4.2
    IL_0005:  beq.s      IL_000b

    IL_0007:  br.s       IL_000d

    IL_0009:  ldc.i4.0
    IL_000a:  ret

    IL_000b:  ldc.i4.3
    IL_000c:  ret

    IL_000d:  call       void Tests::fail_inline()
    IL_0012:  newobj     instance void [mscorlib]System.Exception::.ctor()
    IL_0017:  throw
  }

  .method public hidebysig static int32 test_3_regress_59608() cil managed
  {
    .maxstack  8
    IL_0000:  ldc.i4.2
    IL_0001:  call       int32 Tests::always_inline(int32)
    IL_000c:  ret
  }

  .method public hidebysig static int32 test_104_conv_u_and_string() cil managed
  {
    .maxstack  8
	ldstr "hello"
	conv.u
	call int32 [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::get_OffsetToStringData()
	add
	ldind.u2
	ret
  }

  .field public static class FLSharedKeys* keys

  .method public hidebysig static int32 test_0_regress_60634 () cil managed
  {
	.maxstack 8
	ldsflda     class FLSharedKeys* Tests::keys
	initobj    class FLSharedKeys*
	ldc.i4.0
	ret
  }

  .method public hidebysig static int32 test_0_github_issue_6721 () cil managed
  {
       .maxstack 8
       ldc.i4.0
       conv.i8
       ldc.i4.m1
       conv.ovf.i8.un
       sub.ovf
       ldc.i8 0xffffffff00000001
       beq.s IL_success
       ldc.i4.1
       ret
       IL_success:
       ldc.i4.0
       ret
  }

  .method public hidebysig static int32 test_3_github_issue_15794 () cil managed
  {
      .maxstack 8
      ldc.r8 3.4
      conv.r.un
      conv.i4
      ret
  }

  .method public hidebysig static int32 test_1_box_r8_r4_autoconv () cil managed
  {
		ldc.r8 1.234
		box float64
		unbox float64
		ldind.r8
		box float32
		unbox float32
		ldind.r4
		conv.r8
		conv.i4
		ret
	}

	.method public hidebysig static int32 test_1_dont_verify_ptr_byrefs () cil managed
	 {
		.locals init (int32 v_0, int32 *& v_1, int32 *v_2)

		//v_0 = 1
		ldc.i4.1
		stloc.0

		//v_1 = &v_0 < bad store of `int32&` to ìnt32*&` but must work
		ldloca v_0
		stloc.1

		//v_2 = (intptr)v_1
		ldloc.1
		conv.u
		stloc.2

		//return *v_2
		ldloc.2
		ldind.i4
		ret
	 }

	.method private hidebysig static valuetype [mscorlib]System.Nullable`1<int32> ret_some_vt(int32 val) cil managed
	 {
		.maxstack 8
		ldarg.0
		newobj instance void valuetype [mscorlib]System.Nullable`1<int32>::.ctor(!0)
		ldarg.0
		ldc.i4.0
		ble.s second_vt

		ldarg.0
		ldc.i4.s 40
		add
		newobj instance void valuetype [mscorlib]System.Nullable`1<int32>::.ctor(!0)
		pop
		ret

second_vt_2:
		ldarg.0
		ldc.i4.s 30
		add
		newobj instance void valuetype [mscorlib]System.Nullable`1<int32>::.ctor(!0)
		ret

second_vt:
		pop
		br second_vt_2
	 }

	// https://github.com/mono/mono/issues/17924
	.method static public int32 test_0_vt_sp_tracking () cil managed
	 {
		.maxstack  2
		.locals init (valuetype [mscorlib]System.Nullable`1<int32> V_0)

		ldc.i4.s 10
		call valuetype [mscorlib]System.Nullable`1<int32> Tests::ret_some_vt(int32)
		stloc.0
		ldloca.s V_0
		call instance !0 valuetype [mscorlib]System.Nullable`1<int32>::get_Value()
		ldc.i4.s 10
		bne.un.s wrong

		ldc.i4.0
		ret

wrong:
		ldc.i4.1
		ret
	}

	.class nested private auto ansi beforefieldinit R1_class
	{
		.field  public  int32 test_field

		.method public hidebysig  specialname  rtspecialname instance default void '.ctor' ()  cil managed
		{
			ret
		}
	}

	.method public hidebysig static int32  test_3_ldstloc_opt () cil managed
	{
		.locals init (
			class Tests/R1_class v_0,
			int32 v_1,
			class Tests/R1_class v_2
		)

		/* allocate first object */
		newobj instance void class Tests/R1_class::.ctor ()
		stloc.0
		ldloc.0
		stloc.2

		br L3
		/* dead code for interp opt barrier */
		ldc.i4.1
		ldc.i4.1
		add
		pop
L3:
		/* load first object on the stack */
		ldloc.0

		ldc.i4.3
		stloc.1
		ldloc.1

		/* allocate second object */
		newobj instance void class Tests/R1_class::.ctor ()
		/* overwrite first object at loc0 with second object */
		stloc.0

		/* should store '3' into first object.
		 * in the buggy case it stores '3' into the second object because it delays the load from loc.0 */
		stfld int32 Tests/R1_class::test_field

		/* load first object on the stack */
		ldloc.2
		/* should read '3' */
		ldfld int32 Tests/R1_class::test_field
		ret
	}

	.method public hidebysig static void ldstarg_opt_helper (Tests/R1_class a) cil managed
	{
		ldarg.0

		/* allocate second object */
		newobj instance void class Tests/R1_class::.ctor ()
		dup
		ldc.i4.1
		/* stores '1' in the field */
		stfld int32 Tests/R1_class::test_field
		/* overwrite first argument */
		starg 0

		ldc.i4.3
		/* stores '3' in the field */
		stfld int32 Tests/R1_class::test_field  /* might get fused with ldarg.0 at start of method */
		ret
	}

	.method public hidebysig static int32  test_3_ldstarg_opt () cil managed
	{
		/* allocate first object */
		newobj instance void class Tests/R1_class::.ctor ()
		dup
		ldc.i4.s 0x1337
		/* stores '0x1337' in the field */
		stfld int32 Tests/R1_class::test_field

		dup
		/* passing first object */
		call void class Tests::ldstarg_opt_helper (Tests/R1_class)
		/* should read '3' from first object */
		ldfld int32 Tests/R1_class::test_field
		ret
	}


  .method public hidebysig static int32  test_10_rconv_to_u8_ovf_un() cil managed
  {
    // Code size       20 (0x14)
    .maxstack  1
    .locals init (uint64 V_0,
             float32 V_1,
             int32 V_2)
    IL_0000:  nop
    IL_0001:  ldc.i4.s   10
    IL_0003:  conv.i8
    IL_0004:  stloc.0
    IL_0005:  ldloc.0
    IL_0006:  conv.r.un
    IL_0007:  conv.r4
    IL_0008:  stloc.1
    IL_0009:  nop
    IL_000a:  ldloc.1
    IL_000b:  conv.ovf.u8.un
    IL_000c:  stloc.0
    IL_000d:  ldloc.0
    IL_000e:  conv.ovf.i4.un
    IL_000f:  stloc.2
    IL_0010:  br.s       IL_0012

    IL_0012:  ldloc.2
    IL_0013:  ret
  } // end of method Tests::test_10_rconv_to_u8_ovf_un

  .field private static int64 TestLong

/* Disabled until its fixed on i386
  .method public static int32 test_1_stsfld_conv () cil managed
  {
	ldc.i4.2
	stsfld int64 Tests::TestLong
	ldsfld int64 Tests::TestLong
	ldc.i8 2
	ceq
	ret
   }
*/

	.method public hidebysig static string cmov_try_block_helper (string s) cil managed noinlining
  	{
		// Code size       43 (0x2b)
		.maxstack  2
		.locals init (bool V_0, string V_1)
		IL_0000:  nop
		IL_0001:  ldarg.0
		IL_0002:  callvirt   instance int32 [mscorlib]System.String::get_Length()
		IL_0007:  ldc.i4.0
		IL_0008:  ceq
		IL_000a:  stloc.0
		IL_000b:  ldloc.0
		IL_000c:  brfalse.s  IL_0016

		IL_000e:  ldstr	  "Empty"
		IL_0013:  stloc.1
		IL_0014:  br.s	  IL_0029

		IL_0016:  nop
		.try
		{
		  IL_0017:  nop
		  IL_0018:  ldarg.0
		  IL_0019:  stloc.1
		  IL_001a:  leave.s   IL_0029
		}  // end .try
		catch [mscorlib]System.Exception
		{
		  IL_001c:  pop
		  IL_001d:  nop
		  IL_001e:  nop
		  IL_001f:  leave.s   IL_0021
		}  // end handler
		IL_0021:  ldstr  "Should not happen"
		IL_0026:  stloc.1
		IL_0027:  br.s   IL_0029

		IL_0029:  ldloc.1
		IL_002a:  ret
	}

	.method public hidebysig static int32 test_1_cmov_try_block() cil managed
	{
		// Code size       37 (0x25)
		.maxstack  2
		.locals init (string V_0, bool V_1, int32 V_2)
		IL_0000:  nop
		IL_0001:  ldstr  "abc"
		IL_0006:  call   string Tests::cmov_try_block_helper(string)
		IL_000d:  ldstr  "abc"
		IL_0012:  call   bool [mscorlib]System.String::op_Equality(string,string)
		IL_0019:  brfalse.s  IL_001f

		IL_001b:  ldc.i4.1
		IL_001c:  stloc.2
		IL_001d:  br.s   IL_0023

		IL_001f:  ldc.i4.0
		IL_0020:  stloc.2
		IL_0021:  br.s   IL_0023

		IL_0023:  ldloc.2
		IL_0024:  ret
	 }

	.method private hidebysig static int32 validate_alloc_array_length_lbound(class [mscorlib]System.Array test_array) cil managed
	{
		// Code size       88 (0x58)
		.maxstack  2
		.locals init ([0] bool V_0, [1] int32 V_1, [2] bool V_2, [3] bool V_3, [4] bool V_4)
		IL_0000:  nop
		IL_0001:  ldarg.0
		IL_0002:  callvirt   instance int32 [mscorlib]System.Array::get_Length()
		IL_0007:  ldc.i4.6
		IL_0008:  ceq
		IL_000a:  ldc.i4.0
		IL_000b:  ceq
		IL_000d:  stloc.0
		IL_000e:  ldloc.0
		IL_000f:  brfalse.s  IL_0015
		IL_0011:  ldc.i4.1
		IL_0012:  stloc.1
		IL_0013:  br.s       IL_0056
		IL_0015:  ldarg.0
		IL_0016:  callvirt   instance int32 [mscorlib]System.Array::get_Rank()
		IL_001b:  ldc.i4.1
		IL_001c:  ceq
		IL_001e:  ldc.i4.0
		IL_001f:  ceq
		IL_0021:  stloc.2
		IL_0022:  ldloc.2
		IL_0023:  brfalse.s  IL_0029
		IL_0025:  ldc.i4.2
		IL_0026:  stloc.1
		IL_0027:  br.s       IL_0056
		IL_0029:  ldarg.0
		IL_002a:  ldc.i4.0
		IL_002b:  callvirt   instance int32 [mscorlib]System.Array::GetLowerBound(int32)
		IL_0030:  ldc.i4 0x2710
		IL_0031:  cgt.un
		IL_0033:  stloc.3
		IL_0034:  ldloc.3
		IL_0035:  brfalse.s  IL_003b
		IL_0037:  ldc.i4.3
		IL_0038:  stloc.1
		IL_0039:  br.s       IL_0056
		IL_003b:  ldarg.0
		IL_003c:  ldc.i4.0
		IL_003d:  callvirt   instance int32 [mscorlib]System.Array::GetUpperBound(int32)
		IL_0042:  ldc.i4 0x2715
		IL_0043:  ceq
		IL_0045:  ldc.i4.0
		IL_0046:  ceq
		IL_0048:  stloc.s    V_4
		IL_004a:  ldloc.s    V_4
		IL_004c:  brfalse.s  IL_0052
		IL_004e:  ldc.i4.4
		IL_004f:  stloc.1
		IL_0050:  br.s       IL_0056
		IL_0052:  ldc.i4.0
		IL_0053:  stloc.1
		IL_0054:  br.s       IL_0056
		IL_0056:  ldloc.1
		IL_0057:  ret
	}

	.method public hidebysig static int32  test_0_alloc_array_int16_length_lbound() cil managed
	{
		.maxstack  2
		.locals init ([0] int16[] test_array, [1] int32 V_1)
		ldc.i4 10000
		ldc.i4 6
		newobj instance void int16[10000...10005]::.ctor(int32, int32)
		call int32 class Tests::validate_alloc_array_length_lbound(class [mscorlib]System.Array)
		ret
	}

	.method public hidebysig static int32  test_0_alloc_array_int32_length_lbound() cil managed
	{
		.maxstack  2
		.locals init ([0] int32[] test_array, [1] int32 V_1)
		ldc.i4 10000
		ldc.i4 6
		newobj instance void int32[10000...10005]::.ctor(int32, int32)
		call int32 class Tests::validate_alloc_array_length_lbound(class [mscorlib]System.Array)
		ret
	}

	.method public hidebysig static int32  test_0_alloc_array_int64_length_lbound() cil managed
	{
		.maxstack  2
		.locals init ([0] int64[] test_array, [1] int32 V_1)
		ldc.i4 10000
		ldc.i4 6
		newobj instance void int64[10000...10005]::.ctor(int32, int32)
		call int32 class Tests::validate_alloc_array_length_lbound(class [mscorlib]System.Array)
		ret
	}

	.method public hidebysig static int32  test_0_alloc_array_float32_length_lbound() cil managed
	{
		.maxstack  2
		.locals init ([0] float32[] test_array, [1] int32 V_1)
		ldc.i4 10000
		ldc.i4 6
		newobj instance void float32[10000...10005]::.ctor(int32, int32)
		call int32 class Tests::validate_alloc_array_length_lbound(class [mscorlib]System.Array)
		ret
	}

	.method public hidebysig static int32  test_0_alloc_array_float64_length_lbound() cil managed
	{
		.maxstack  2
		.locals init ([0] float64[] test_array, [1] int32 V_1)
		ldc.i4 10000
		ldc.i4 6
		newobj instance void float64[10000...10005]::.ctor(int32, int32)
		call int32 class Tests::validate_alloc_array_length_lbound(class [mscorlib]System.Array)
		ret
	}

	.method private hidebysig static int32 test_0_two_dimensional_array_bounds() cil managed
	{
		.maxstack 5
		.locals init (int32[,] arr)
		ldc.i4 100
		ldc.i4 27
		ldc.i4 200
		ldc.i4 31
		newobj instance void int32[,]::.ctor(int32, int32, int32, int32)
		stloc arr

		ldc.i4 1
		ldloc arr
		ldc.i4 0
		callvirt instance int32 [mscorlib]System.Array::GetLowerBound(int32)
		ldc.i4 100
		bne.un exit
		pop

		ldc.i4 2
		ldloc arr
		ldc.i4 0
		callvirt instance int32 [mscorlib]System.Array::GetUpperBound(int32)
		ldc.i4 126
		bne.un exit
		pop

		ldc.i4 3
		ldloc arr
		ldc.i4 1
		callvirt instance int32 [mscorlib]System.Array::GetLowerBound(int32)
		ldc.i4 200
		bne.un exit
		pop

		ldc.i4 4
		ldloc arr
		ldc.i4 1
		callvirt instance int32 [mscorlib]System.Array::GetUpperBound(int32)
		ldc.i4 230
		bne.un exit
		pop

		ldc.i4 5
		ldloc arr
		ldc.i4 100
		ldc.i4 200
		ldc.i4 1234
		call instance void int32[,]::Set(int32, int32, int32)
		ldloc arr
		ldc.i4 100
		ldc.i4 200
		call instance int32 int32[,]::Get(int32, int32)
		ldc.i4 1234
		bne.un exit
		pop

		ldc.i4 6
		ldloc arr
		ldc.i4 126
		ldc.i4 230
		ldc.i4 5678
		call instance void int32[,]::Set(int32, int32, int32)
		ldloc arr
		ldc.i4 126
		ldc.i4 230
		call instance int32 int32[,]::Get(int32, int32)
		ldc.i4 5678
		bne.un exit
		pop

		ldc.i4 0
	exit:
		ret
	}

	.method private hidebysig static int32 test_0_five_dimensional_array() cil managed
	{
		.maxstack 12
		.locals init (int32[,,,,] arr)
		ldc.i4 100
		ldc.i4 2
		ldc.i4 200
		ldc.i4 3
		ldc.i4 300
		ldc.i4 4
		ldc.i4 400
		ldc.i4 5
		ldc.i4 500
		ldc.i4 6
		newobj instance void int32[,,,,]::.ctor(
			int32, int32, int32, int32, int32, int32,
			int32, int32, int32, int32)
		stloc arr

		ldc.i4 1
		ldloc arr
		ldc.i4 0
		callvirt instance int32 [mscorlib]System.Array::GetLowerBound(int32)
		ldc.i4 100
		bne.un exit
		pop

		ldc.i4 2
		ldloc arr
		ldc.i4 0
		callvirt instance int32 [mscorlib]System.Array::GetUpperBound(int32)
		ldc.i4 101
		bne.un exit
		pop

		ldc.i4 3
		ldloc arr
		ldc.i4 4
		callvirt instance int32 [mscorlib]System.Array::GetLowerBound(int32)
		ldc.i4 500
		bne.un exit
		pop

		ldc.i4 4
		ldloc arr
		ldc.i4 4
		callvirt instance int32 [mscorlib]System.Array::GetUpperBound(int32)
		ldc.i4 505
		bne.un exit
		pop

		ldc.i4 5
		ldloc arr
		ldc.i4 100
		ldc.i4 200
		ldc.i4 300
		ldc.i4 400
		ldc.i4 500
		ldc.i4 1234
		call instance void int32[,,,,]::Set(int32, int32, int32, int32, int32, int32)
		ldloc arr
		ldc.i4 100
		ldc.i4 200
		ldc.i4 300
		ldc.i4 400
		ldc.i4 500
		call instance int32 int32[,,,,]::Get(int32, int32, int32, int32, int32)
		ldc.i4 1234
		bne.un exit
		pop

		ldc.i4 6
		ldloc arr
		ldc.i4 101
		ldc.i4 202
		ldc.i4 303
		ldc.i4 404
		ldc.i4 505
		ldc.i4 5678
		call instance void int32[,,,,]::Set(int32, int32, int32, int32, int32, int32)
		ldloc arr
		ldc.i4 101
		ldc.i4 202
		ldc.i4 303
		ldc.i4 404
		ldc.i4 505
		call instance int32 int32[,,,,]::Get(int32, int32, int32, int32, int32)
		ldc.i4 5678
		bne.un exit
		pop

		ldc.i4 0
	exit:
		ret
	}

	.method public hidebysig static !!T	createinstance_intrins_primitive<.ctor T>() cil managed noinlining
	{
		.maxstack	8
		call			 !!0 [mscorlib]System.Activator::CreateInstance<!!0>()
		ret
	}

	.method public static int32 test_0_createinstance_intrins_primitive () cil managed
	{
		.maxstack	8
		call			 !!0 Tests::createinstance_intrins_primitive<bool>()
		ldc.i4.0
		beq L1
		ldc.i4.1
		ret
	L1:
		call			 !!0 Tests::createinstance_intrins_primitive<int64>()
		ldc.i8 0
		beq L2
		ldc.i4.2
		ret
	L2:
		ldc.i4.0
		ret
	}
}
