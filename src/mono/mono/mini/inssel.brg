/*
 * inssel.brg: instruction selection
 *
 * Author:
 *   Dietmar Maurer (dietmar@ximian.com)
 *   Paolo Molaro (lupus@ximian.com)
 *
 * (C) 2002 Ximian, Inc.
 *
 */
#include <config.h>
#include <string.h>

#include "mini.h"
#include <mono/metadata/marshal.h>
#include <mono/metadata/debug-helpers.h>

#define MBTREE_TYPE  MonoInst
#define MBCGEN_TYPE  MonoCompile
#define MBCOST_DATA  MonoCompile
#define MBALLOC_STATE mono_mempool_alloc (data->state_pool, sizeof (MBState))
#define MBMAX_OPCODES OP_LAST
#define MBGET_OP_NAME(op) mono_inst_name (op)

#define MBTREE_OP(t) ((t)->opcode)
#define MBTREE_LEFT(t) ((t)->inst_left)
#define MBTREE_RIGHT(t) ((t)->inst_right)

#define MONO_EMIT_UNALU(cfg,inst,op,dr,sr1) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->sreg1 = sr1; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_UNALU(cfg,op,dr,sr1) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = op; \
                inst->dreg = dr; \
                inst->sreg1 = sr1; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_BIALU(cfg,inst,op,dr,sr1,sr2) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->sreg1 = sr1; \
                (inst)->sreg2 = sr2; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_BIALU(cfg,op,dr,sr1,sr2) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = op; \
                inst->dreg = dr; \
                inst->sreg1 = sr1; \
                inst->sreg2 = sr2; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_BIALU_IMM(cfg,inst,op,dr,sr,imm) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->sreg1 = sr; \
                (inst)->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_BIALU_IMM(cfg,op,dr,sr,imm) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = op; \
                inst->dreg = dr; \
                inst->sreg1 = sr; \
                inst->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_LOAD_MEMBASE(cfg,inst,dr,base,offset) do { \
                (inst)->opcode = OP_LOAD_MEMBASE; \
                (inst)->dreg = dr; \
                (inst)->inst_basereg = base; \
                (inst)->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_LOAD_MEMBASE_OP(cfg,inst,op,dr,base,offset) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->inst_basereg = base; \
                (inst)->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_LOAD_MEM(cfg,dr,addr) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = OP_LOADU4_MEM; \
                inst->dreg = dr; \
                inst->inst_p0 = addr; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_LOAD_MEMBASE(cfg,dr,base,offset) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = OP_LOAD_MEMBASE; \
                inst->dreg = dr; \
                inst->inst_basereg = base; \
                inst->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_LOAD_MEMBASE_OP(cfg,op,dr,base,offset) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = op; \
                inst->dreg = dr; \
                inst->inst_basereg = base; \
                inst->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_STORE_MEMBASE(cfg,inst,op,base,offset,sr) do { \
                (inst)->opcode = op; \
                (inst)->sreg1 = sr; \
                (inst)->inst_destbasereg = base; \
                (inst)->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_STORE_MEMBASE(cfg,op,base,offset,sr) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = op; \
                inst->sreg1 = sr; \
                inst->inst_destbasereg = base; \
                inst->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_STORE_MEMBASE_IMM(cfg,inst,op,base,offset,imm) do { \
                (inst)->opcode = op; \
                (inst)->inst_destbasereg = base; \
                (inst)->inst_offset = offset; \
                (inst)->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_STORE_MEMBASE_IMM(cfg,op,base,offset,imm) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
                inst->opcode = op; \
                inst->inst_destbasereg = base; \
                inst->inst_offset = offset; \
                inst->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_COMPARE_IMM(cfg,sr1,imm) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = OP_COMPARE_IMM;	\
                inst->sreg1 = sr1; \
                inst->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_ICOMPARE_IMM(cfg,sr1,imm) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = sizeof (void*) == 8 ? OP_ICOMPARE_IMM : OP_COMPARE_IMM;	\
                inst->sreg1 = sr1; \
                inst->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_COND_EXC(cfg,cond,name) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = OP_COND_EXC_##cond;  \
                inst->inst_p1 = (char*)name; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_ICONST(cfg,dr,imm) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = OP_ICONST;	\
                inst->dreg = dr; \
                inst->inst_c0 = imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_I8CONST(cfg,dr,imm) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = OP_I8CONST;	\
                inst->dreg = dr; \
                inst->inst_l = imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_PCONST(cfg,dr,imm) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = OP_ICONST;	\
                inst->dreg = dr; \
                inst->inst_p0 = (gpointer) imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_AOTCONST(cfg,dr,imm,type) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = OP_AOTCONST;	\
                inst->dreg = dr; \
                inst->inst_p0 = imm; \
                inst->inst_c1 = type; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_CLASSCONST(cfg,dr,imm) MONO_EMIT_NEW_AOTCONST(cfg,dr,imm,MONO_PATCH_INFO_CLASS)

#define	MONO_EMIT_NEW_BRANCH_BLOCK(cfg,op,targetbb) do { \
                MonoInst *inst; \
        	MonoInst *target_label; \
		target_label = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		target_label->opcode = OP_LABEL;	\
	        target_label->next = (targetbb)->code; \
		target_label->inst_c0 = (targetbb)->native_offset; \
	        (targetbb)->code = target_label; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = op;	\
		inst->inst_i0 = target_label;	\
		inst->flags = MONO_INST_BRLABEL;	\
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_BRANCH_LABEL(cfg,op,label) do { \
                MonoInst *inst; \
		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		inst->opcode = op;	\
		inst->inst_i0 = label;	\
		inst->flags = MONO_INST_BRLABEL;	\
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define MONO_NEW_LABEL(cfg,inst) do { \
		(inst) = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		(inst)->opcode = OP_LABEL;	\
	} while (0)

#define MONO_EMIT_BOUNDS_CHECK(cfg, array_reg, array_type, array_length_field, index_reg) do { \
		if (! (state->tree->flags & MONO_INST_NORANGECHECK)) { \
			int _length_reg = mono_regstate_next_int (cfg->rs); \
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, _length_reg, array_reg, G_STRUCT_OFFSET (array_type, array_length_field)); \
			MONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, _length_reg, index_reg); \
			MONO_EMIT_NEW_COND_EXC (cfg, LE_UN, "IndexOutOfRangeException"); \
		} \
	} while (0)

#define MONO_EMIT_BOUNDS_CHECK_IMM(cfg, array_reg, array_type, array_length_field, index_imm) do { \
		if (! (state->tree->flags & MONO_INST_NORANGECHECK)) { \
			int _length_reg = mono_regstate_next_int (cfg->rs); \
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, _length_reg, array_reg, G_STRUCT_OFFSET (array_type, array_length_field)); \
			MONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, _length_reg, index_imm); \
			MONO_EMIT_NEW_COND_EXC (cfg, LE_UN, "IndexOutOfRangeException"); \
		} \
	} while (0)

/* we need to kludge state because monoburg puts this stuff before the definition of MBState */
void mini_emit_virtual_call (MonoCompile *s, void *state, MonoInst *tree, int novirt_op, int virtop);
void mini_emit_isninst_cast (MonoCompile *s, int klass_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target);
void mini_emit_isninst_iface_cast (MonoCompile *s, int vtable_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target);
void mini_emit_isninst_iface_class_cast (MonoCompile *s, int klass_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target);
void mini_emit_castclass (MonoCompile *s, int klass_reg, MonoClass *klass);
void mini_emit_castclass_iface (MonoCompile *s, int vtable_reg, MonoClass *klass);
void mini_emit_castclass_iface_class (MonoCompile *s, int klass_reg, MonoClass *klass);

void mini_emit_memcpy (MonoCompile *s, int destreg, int doffset, int srcreg, int soffset, int size, int align);
void mini_emit_memset (MonoCompile *s, int destreg, int offset, int size, int val, int align);

int ldind_to_load_membase (int opcode);

%%

%termprefix OP_ CEE_

%start stmt

#
# base addressing mode 
#

base: reg "0" {
	/* we create a new MonoInst in chain rules and set state->tree to it
	 * since a MBState (and hence state->tree) is reused in chain rules and
	 * normal rules.
	 */
	MonoInst *inst;
	inst = mono_mempool_alloc0 (s->mempool, sizeof (MonoInst));
	inst->opcode = OP_ICONST; /* doesn't matter */
	inst->inst_basereg = state->reg1;
	inst->inst_offset = 0;
	state->tree = inst;
	//g_print ("mybase: (assigned R%d from R%d - R%d)\n", state->reg1, tree->dreg, state->reg2);
	//tree->inst_offset = 0;
	//tree->inst_basereg = state->reg1;
}

base: CEE_LDIND_I (OP_REGVAR) "0" {
	tree->inst_offset = 0;
	tree->inst_basereg = state->left->tree->dreg;
}

base: OP_REGOFFSET "0" {
	/* nothing to do */
}

base: OP_LDADDR (OP_REGOFFSET) "0" {
	tree->inst_offset = state->left->tree->inst_offset;
	tree->inst_basereg = state->left->tree->inst_basereg;
}

base: CEE_LDOBJ (OP_REGOFFSET) "0" {
	tree->inst_offset = state->left->tree->inst_offset;
	tree->inst_basereg = state->left->tree->inst_basereg;
}

base: CEE_ADD (base, OP_ICONST) "0" {
	tree->inst_offset = state->left->tree->inst_offset + state->right->tree->inst_c0;
	tree->inst_basereg = state->left->tree->inst_basereg;
}

base: CEE_ADD (CEE_LDIND_REF (OP_REGVAR), OP_ICONST) "0" {
	tree->inst_offset = state->right->tree->inst_c0;
	tree->inst_basereg = state->left->left->tree->dreg;
}

base: CEE_ADD (CEE_LDIND_I (OP_REGVAR), OP_ICONST) "0" {
	tree->inst_offset = state->right->tree->inst_c0;
	tree->inst_basereg = state->left->left->tree->dreg;
}

#
# helpers
#

reg: OP_ICONST {
     	MONO_EMIT_NEW_ICONST (s, state->reg1, tree->inst_c0);
}

reg: OP_AOTCONST {
     	MONO_EMIT_NEW_AOTCONST (s, state->reg1, tree->inst_p0, tree->inst_c1);
}

#
# load/store operations
#

reg: CEE_LDIND_I (base),
reg: CEE_LDIND_REF (base),
reg: CEE_LDIND_I1 (base),
reg: CEE_LDIND_U1 (base),
reg: CEE_LDIND_I2 (base),
reg: CEE_LDIND_U2 (base) {
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, ldind_to_load_membase (tree->opcode),
				   state->reg1, state->left->tree->inst_basereg, state->left->tree->inst_offset);
}

reg: OP_LDADDR (OP_REGOFFSET) "2" {
	/* use LEA */
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->tree->inst_basereg;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
	if (state->left->tree->inst_offset) {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tree->dreg, tree->dreg, state->left->tree->inst_offset);
	}
}

reg: CEE_LDOBJ (OP_REGOFFSET) "2" {
	/* use LEA */
	/* FIXME: this is just an hack */
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->tree->inst_basereg;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
	if (state->left->tree->inst_offset) {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tree->dreg, tree->dreg, state->left->tree->inst_offset);
	}
}

reg: CEE_LDOBJ (reg) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_OBJADDR (reg) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_VTADDR (reg) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: CEE_LDIND_U1 (OP_REGVAR) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->tree->dreg, 0xff);
}

reg: CEE_LDIND_U2 (OP_REGVAR) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->tree->dreg, 0xffff);
}

stmt: CEE_STIND_REF (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_REF (base, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_REF (base, CEE_LDIND_I (OP_REGVAR)),
stmt: CEE_STIND_I (base, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_I (base, CEE_LDIND_I (OP_REGVAR)) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->left->tree->dreg);
}

stmt: CEE_STIND_REF (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STORE_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

stmt: CEE_STIND_REF (OP_REGVAR, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_REF (OP_REGVAR, CEE_LDIND_I (OP_REGVAR)),
stmt: CEE_STIND_I (OP_REGVAR, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_I (OP_REGVAR, CEE_LDIND_I (OP_REGVAR)) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->left->tree->dreg);
}


stmt: CEE_STIND_I (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STORE_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

reg: CEE_LDIND_I4 (base) {
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
				   state->left->tree->inst_basereg, state->left->tree->inst_offset);
}

reg: CEE_LDIND_U4 (base) {
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU4_MEMBASE, state->reg1, 
				   state->left->tree->inst_basereg, state->left->tree->inst_offset);
}

reg: CEE_LDIND_REF (OP_REGVAR),
reg: CEE_LDIND_I (OP_REGVAR),
reg: CEE_LDIND_I4 (OP_REGVAR),
reg: CEE_LDIND_U4 (OP_REGVAR) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->tree->dreg;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_I4 (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI4_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I4 (base, CEE_LDIND_I4 (OP_REGVAR)) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI4_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->left->tree->dreg);
}

stmt: CEE_STIND_I4 (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STOREI4_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

stmt: CEE_STIND_I4 (OP_REGVAR, OP_ICONST) {
	tree->inst_c0 = state->right->tree->inst_c0;
	tree->opcode = OP_ICONST;
	tree->dreg = state->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_I4 (OP_REGVAR, reg) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->reg1);
}

stmt: CEE_STIND_I4 (OP_REGVAR, CEE_LDIND_I4 (OP_REGVAR)) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->left->tree->dreg);
}

stmt: CEE_STIND_I4 (OP_REGVAR, CEE_LDIND_I4 (base)) {
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->left->tree->dreg, 
				   state->right->left->tree->inst_basereg, 
				   state->right->left->tree->inst_offset);
}

stmt: CEE_STIND_I1 (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI1_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I1 (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STOREI1_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

stmt: CEE_STIND_I2 (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI2_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I2 (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STOREI2_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

stmt: CEE_STIND_I2 (OP_REGVAR, reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->reg1, 0xffff);
}

stmt: CEE_STIND_I1 (OP_REGVAR, reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->reg1, 0xff);
}

stmt: CEE_STIND_I1 (OP_REGVAR, CEE_LDIND_U1 (OP_REGVAR)) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->left->tree->dreg, 0xff);
}

stmt: CEE_STIND_I1 (OP_REGVAR, CEE_LDIND_I1 (OP_REGVAR)) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->left->tree->dreg, 0xff);
}

stmt: CEE_STIND_I2 (OP_REGVAR, CEE_LDIND_U2 (OP_REGVAR)) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->left->tree->dreg, 0xffff);
}

stmt: CEE_STIND_I2 (OP_REGVAR, CEE_LDIND_I2 (OP_REGVAR)) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->left->tree->dreg, 0xffff);
}

stmt: CEE_STIND_I2 (OP_REGVAR, OP_ICONST),
stmt: CEE_STIND_I1 (OP_REGVAR, OP_ICONST),
stmt: CEE_STIND_REF (OP_REGVAR, OP_ICONST),
stmt: CEE_STIND_I (OP_REGVAR, OP_ICONST) {
	tree->inst_c0 = state->right->tree->inst_c0;
	if (tree->opcode == CEE_STIND_I2)
		tree->inst_c0 &= 0xffff;
	if (tree->opcode == CEE_STIND_I1)
		tree->inst_c0 &= 0xff;
	
	tree->opcode = OP_ICONST;
	tree->dreg = state->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_REF (OP_REGVAR, reg) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->reg1);
}

stmt: CEE_STIND_I (OP_REGVAR, reg) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->reg1);
}

stmt: CEE_STELEM_REF (OP_GROUP (reg, reg), reg) {

	g_assert_not_reached ();
}

reg: OP_GROUP (reg, reg) {
	g_assert_not_reached ();
}

stmt: OP_MEMCPY (base, base) {
	int size = tree->unused;
	if (size > 0)
		mini_emit_memcpy (s, state->left->tree->inst_basereg, state->left->tree->inst_offset,
				  state->right->tree->inst_basereg, state->right->tree->inst_offset, size, 0);
}

stmt: OP_MEMSET (base) {
	int size = tree->unused;
	if (size > 0)
		mini_emit_memset (s, state->left->tree->inst_basereg, state->left->tree->inst_offset, size, tree->inst_imm, 0);
}

reg: OP_LDELEMA2D (reg, OP_GROUP (reg, reg)) "20" {
	int bounds_reg = mono_regstate_next_int (s->rs);
	int add_reg = mono_regstate_next_int (s->rs);
	int mult_reg = mono_regstate_next_int (s->rs);
	int mult2_reg = mono_regstate_next_int (s->rs);
	int low1_reg = mono_regstate_next_int (s->rs);
	int low2_reg = mono_regstate_next_int (s->rs);
	int high1_reg = mono_regstate_next_int (s->rs);
	int high2_reg = mono_regstate_next_int (s->rs);
	int realidx1_reg = mono_regstate_next_int (s->rs);
	int realidx2_reg = mono_regstate_next_int (s->rs);
	int sum_reg = mono_regstate_next_int (s->rs);
	int index1, index2;
	guint32 size = mono_array_element_size (tree->klass);
	
	index1 = state->right->left->reg1;
	index2 = state->right->right->reg1;

	/* range checking */
	MONO_EMIT_NEW_LOAD_MEMBASE (s, bounds_reg, 
				       state->left->reg1, G_STRUCT_OFFSET (MonoArray, bounds));

	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, low1_reg, 
				       bounds_reg, G_STRUCT_OFFSET (MonoArrayBounds, lower_bound));
	MONO_EMIT_NEW_BIALU (s, CEE_SUB, realidx1_reg, index1, low1_reg);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, high1_reg, 
				       bounds_reg, G_STRUCT_OFFSET (MonoArrayBounds, length));
	MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, high1_reg, realidx1_reg);
	MONO_EMIT_NEW_COND_EXC (s, LE_UN, "IndexOutOfRangeException");

	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, low2_reg, 
				       bounds_reg, sizeof (MonoArrayBounds) + G_STRUCT_OFFSET (MonoArrayBounds, lower_bound));
	MONO_EMIT_NEW_BIALU (s, CEE_SUB, realidx2_reg, index2, low2_reg);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, high2_reg, 
				       bounds_reg, sizeof (MonoArrayBounds) + G_STRUCT_OFFSET (MonoArrayBounds, length));
	MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, high2_reg, realidx2_reg);
	MONO_EMIT_NEW_COND_EXC (s, LE_UN, "IndexOutOfRangeException");

	MONO_EMIT_NEW_BIALU (s, CEE_MUL, mult_reg, high2_reg, realidx1_reg);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, sum_reg, mult_reg, realidx2_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_MUL_IMM, mult2_reg, sum_reg, size);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult2_reg, state->left->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, add_reg, G_STRUCT_OFFSET (MonoArray, vector));
}

#
# conversions: conv_u can be implemented with AND, also all _ovf conversions?
#

reg: CEE_CONV_I1 (reg) {
	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
}

reg: CEE_CONV_I2 (reg) {
	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
}

reg: CEE_CONV_I4 (reg) {
	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
}

reg: CEE_CONV_U1 (reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xff);
}

reg: CEE_CONV_U2 (reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xffff);
}

reg: CEE_CONV_U4 (reg) {
	if (sizeof (void *) == 8) {
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	} else {
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
	}
}

reg: CEE_CONV_U (reg) {
	if (sizeof (void *) == 8) {
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	} else {
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
	}
}

reg: CEE_CONV_I (reg) {
	if (sizeof (void *) == 8) {
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	} else {
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
	}
}

reg: CEE_CONV_OVF_I4 (reg) {
	if (sizeof (void *) == 8) {
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	} else {
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
	}
}

reg: CEE_CONV_OVF_U4 (reg) {
	if (sizeof (void *) == 8) {
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	} else {
		/* Keep in sync with CONV_OVF_I4_UN below, they are the same on 32-bit machines */		
		MONO_EMIT_NEW_COMPARE_IMM (s, state->left->reg1, 0);
		MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
	}
}

reg: CEE_CONV_OVF_I4_UN (reg) {
	if (sizeof (void *) == 8) {
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	} else {
		/* Keep in sync with CONV_OVF_U4 above, they are the same on 32-bit machines */
		MONO_EMIT_NEW_COMPARE_IMM (s, state->left->reg1, 0);
		MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
	}
}

reg: CEE_CONV_OVF_I1 (reg) {     
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, 127);
	MONO_EMIT_NEW_COND_EXC (s, GT, "OverflowException");
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, -128);
	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_I1_UN (reg) {
	/* probe values between 0 to 127 */
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, 127);
	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_U1 (reg) {
	/* probe value to be within 0 to 255 */
	MONO_EMIT_NEW_COMPARE_IMM (s, state->left->reg1, 255);
	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xff);
}

reg: CEE_CONV_OVF_U1_UN (reg) {
	/* probe value to be within 0 to 255 */
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, 255);
	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xff);
}

reg: CEE_CONV_OVF_I2 (reg) {	
	/* Probe value to be within -32768 and 32767 */
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, 32767);
	MONO_EMIT_NEW_COND_EXC (s, GT, "OverflowException");
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, -32768);
	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_I2_UN (reg) {
	/* Convert uint value into short, value within 0 and 32767 */
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, 32767);
	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_U2 (reg) {
	/* Probe value to be within 0 and 65535 */
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, 0xffff);
	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xffff);
}

reg: CEE_CONV_OVF_U2_UN (reg) {
	/* Probe value to be within 0 and 65535 */
	MONO_EMIT_NEW_ICOMPARE_IMM (s, state->left->reg1, 0xffff);
	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xffff);
}

#
# other alu operations
#

reg: OP_CEQ (cflags) {	
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_CLT (cflags) {	
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_CLT_UN (cflags) {	
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_CGT (cflags) {	
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_CGT_UN (cflags) {	
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

#
# control flow commands 
#

stmt: OP_LABEL {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_NOP "0" {
}

stmt: CEE_BREAK "0" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_SWITCH (reg) {
	MonoInst *label;
	int offset_reg = mono_regstate_next_int (s->rs);
	int target_reg = mono_regstate_next_int (s->rs);
	int n = GPOINTER_TO_INT (tree->klass);
	
	MONO_NEW_LABEL (s, label);
	mono_create_jump_table (s, label, tree->inst_many_bb, n);

	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, state->left->reg1, n);
	MONO_EMIT_NEW_BRANCH_BLOCK (s, CEE_BGE_UN, tree->inst_many_bb [n]);
	if (sizeof (gpointer) == 8)
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, offset_reg, state->left->reg1, 3);
	else
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, offset_reg, state->left->reg1, 2);
	mono_bblock_add_inst (s->cbb, label);
	 /* the backend must patch the address. we use 0xf0f0f0f0 to avoid the usage 
	  * of special (short) opcodes on x86 */
	if (sizeof (gpointer) == 8) {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, target_reg, offset_reg, (long)0xf0f0f0f0f0f0f0f1LL);
	}
	else {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, target_reg, offset_reg, 0xf0f0f0f0);
	}
	MONO_EMIT_UNALU (s, tree, OP_BR_REG, -1, target_reg);
}

stmt: CEE_BR "0" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ARGLIST (reg) {
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: CEE_CALL {
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: CEE_CALLVIRT (reg) {
	mini_emit_virtual_call (s, state, tree, CEE_CALL, OP_CALL_MEMBASE);
}

stmt: OP_VOIDCALLVIRT (reg) {
	mini_emit_virtual_call (s, state, tree, OP_VOIDCALL, OP_VOIDCALL_MEMBASE);
}

freg: OP_FCALLVIRT (reg) {
	mini_emit_virtual_call (s, state, tree, OP_FCALL, OP_FCALL_MEMBASE);
}

stmt: OP_VCALLVIRT (reg, reg) {
	mini_emit_virtual_call (s, state, tree, OP_VCALL, OP_VCALL_MEMBASE);
}

reg: OP_CALL_REG (reg) {
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL_REG (reg) {
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL {
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL_REG (reg) {
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VCALL (reg) {
	mono_arch_emit_this_vret_args (s, (MonoCallInst*)tree, -1, -1, state->left->reg1);
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VCALL_REG (reg, reg) {
	mono_arch_emit_this_vret_args (s, (MonoCallInst*)tree, -1, -1, state->right->reg1);
	
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SAVE_LMF,
stmt: OP_RESTORE_LMF {
	mono_bblock_add_inst (s->cbb, tree);
}

#
# Optimized call instructions
#

reg: OP_CALL_REG (OP_ICONST) {
	tree->opcode = CEE_CALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL_REG (OP_ICONST) {
	tree->opcode = OP_VOIDCALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL_REG (OP_ICONST) {
	tree->opcode = OP_FCALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

# 64 bit versions
reg: OP_CALL_REG (OP_I8CONST) {
	tree->opcode = CEE_CALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL_REG (OP_I8CONST) {
	tree->opcode = OP_VOIDCALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL_REG (OP_I8CONST) {
	tree->opcode = OP_FCALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_RET "0" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_POP (reg)

# remove some common pops without side effects
stmt: CEE_POP (OP_ICONST)
stmt: CEE_POP (CEE_LDIND_I1 (base))
stmt: CEE_POP (CEE_LDIND_U1 (base))
stmt: CEE_POP (CEE_LDIND_I2 (base))
stmt: CEE_POP (CEE_LDIND_U2 (base))
stmt: CEE_POP (CEE_LDIND_I4 (base))
stmt: CEE_POP (CEE_LDIND_U4 (base))
stmt: CEE_POP (CEE_LDIND_I (base))
stmt: CEE_POP (CEE_LDIND_REF (base))
stmt: CEE_POP (CEE_LDIND_I1 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_U1 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_I2 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_U2 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_I4 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_U4 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_I (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_REF (OP_REGVAR))

stmt: CEE_JMP "0" {
	mono_bblock_add_inst (s->cbb, tree);
}

# exception handling

stmt: CEE_THROW (reg) {
	MONO_EMIT_UNALU (s, tree, CEE_THROW, -1, state->left->reg1);
}

stmt: OP_THROW_OR_NULL (reg) {
	MonoInst *object_is_null;

	MONO_NEW_LABEL (s, object_is_null);

	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, 0, state->left->reg1, 0);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);
	MONO_EMIT_UNALU (s, tree, CEE_THROW, -1, state->left->reg1);
	mono_bblock_add_inst (s->cbb, object_is_null);
}

stmt: CEE_THROW (CEE_LDIND_REF (OP_REGVAR)) {
	MONO_EMIT_UNALU (s, tree, CEE_THROW, -1, state->left->left->tree->dreg);
}

stmt: OP_CALL_HANDLER {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_START_HANDLER "2" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_ENDFINALLY "2" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ENDFILTER (reg) "2" {
	MONO_EMIT_UNALU (s, tree, OP_ENDFILTER, -1, state->left->reg1);
}

stmt: OP_CHECK_THIS (reg) {
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

# object related opcodes 

reg: CEE_ISINST (reg) {
     	MonoClass *klass = tree->inst_newa_class;
	MonoInst *object_is_null, *end_label, *false_label;
	int obj_reg = state->left->reg1;
	int vtable_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, object_is_null);
	MONO_NEW_LABEL (s, end_label);
	MONO_NEW_LABEL (s, false_label);

	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, obj_reg, 0);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		/* the object_is_null target simply copies the input register to the output */
		mini_emit_isninst_iface_cast (s, vtable_reg, klass, false_label, object_is_null);
	} else {
		int klass_reg = mono_regstate_next_int (s->rs);

		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));

		if (klass->rank) {
			int rank_reg = mono_regstate_next_int (s->rs);
			int eclass_reg = mono_regstate_next_int (s->rs);

			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, rank_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, rank));
			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, rank_reg, klass->rank);
			MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, false_label);
			MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, cast_class));
			if (klass->cast_class == mono_defaults.object_class) {
				int parent_reg = mono_regstate_next_int (s->rs);
				int const_reg;
				MONO_EMIT_NEW_LOAD_MEMBASE (s, parent_reg, eclass_reg, G_STRUCT_OFFSET (MonoClass, parent));
				if (mono_compile_aot) {
					const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, parent_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, parent_reg, mono_defaults.enum_class->parent);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, object_is_null);
				if (mono_compile_aot) {
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, false_label);
			} else if (klass->cast_class == mono_defaults.enum_class->parent) {
				int const_reg;
				
				if (mono_compile_aot) {
					const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class->parent);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);
				if (mono_compile_aot) {
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, false_label);
			} else if (klass->cast_class == mono_defaults.enum_class) {
				if (mono_compile_aot) {
					int const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, false_label);
			} else if (klass->cast_class->flags & TYPE_ATTRIBUTE_INTERFACE) {
				mini_emit_isninst_iface_class_cast (s, eclass_reg, klass->cast_class, false_label, object_is_null);
			} else {
				if ((klass->rank == 1) && (klass->byval_arg.type == MONO_TYPE_SZARRAY)) {
					/* Check that the object is a vector too */
					int bounds_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_LOAD_MEMBASE (s, bounds_reg, obj_reg, G_STRUCT_OFFSET (MonoArray, bounds));
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, bounds_reg, 0);
					MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, false_label);
				}

				/* the object_is_null target simply copies the input register to the output */
				mini_emit_isninst_cast (s, eclass_reg, klass->cast_class, false_label, object_is_null);
			}
		} else {
			/* the object_is_null target simply copies the input register to the output */
			mini_emit_isninst_cast (s, klass_reg, klass, false_label, object_is_null);
		}
	}

	mono_bblock_add_inst (s->cbb, false_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 0);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, end_label);
	mono_bblock_add_inst (s->cbb, object_is_null);
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
	mono_bblock_add_inst (s->cbb, end_label);
}

reg: OP_CISINST (reg) {
	/* This opcode takes as input an object reference and a class, and returns:
	0) if the object is an instance of the class,
	1) if the object is not instance of the class,
	2) if the object is a proxy whose type cannot be determined */
	
    MonoClass *klass = tree->inst_newa_class;
	MonoInst *end_label, *true_label, *false_label, *false2_label;
	MonoInst *no_proxy_label, *interface_fail_label;
	int obj_reg = state->left->reg1;
	int tmp_reg = mono_regstate_next_int (s->rs);
	int klass_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, end_label);
	MONO_NEW_LABEL (s, true_label);
	MONO_NEW_LABEL (s, false_label);
	MONO_NEW_LABEL (s, false2_label);

	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, obj_reg, 0);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, false_label);

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
		MONO_NEW_LABEL (s, interface_fail_label);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		mini_emit_isninst_iface_cast (s, tmp_reg, klass, interface_fail_label, true_label);
		
		mono_bblock_add_inst (s->cbb, interface_fail_label);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));
		
		if (mono_compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, klass_reg, tproxy_reg);
		} else {
			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, mono_defaults.transparent_proxy_class);
		}
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, false_label);
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, tmp_reg, 0);
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, false2_label);
		
	} else {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));
		
		MONO_NEW_LABEL (s, no_proxy_label);
		
		if (mono_compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, klass_reg, tproxy_reg);
		} else {
			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, mono_defaults.transparent_proxy_class);
		}
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, no_proxy_label);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, remote_class));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoRemoteClass, proxy_class));
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, tmp_reg, 0);
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, no_proxy_label);
		
		mini_emit_isninst_cast (s, klass_reg, klass, false2_label, true_label);
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, false2_label);
		
		mono_bblock_add_inst (s->cbb, no_proxy_label);
		mini_emit_isninst_cast (s, klass_reg, klass, false_label, true_label);
	}

	mono_bblock_add_inst (s->cbb, false_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 1);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, end_label);
	mono_bblock_add_inst (s->cbb, false2_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 2);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, end_label);
	mono_bblock_add_inst (s->cbb, true_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 0);
	mono_bblock_add_inst (s->cbb, end_label);
}

reg: OP_UNBOXCAST (reg) {
     	MonoClass *klass = tree->inst_newa_class;
	int obj_reg = state->left->reg1;
	int vtable_reg = mono_regstate_next_int (s->rs);
	int klass_reg = mono_regstate_next_int (s->rs);
	int eclass_reg = mono_regstate_next_int (s->rs);
	int rank_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, rank_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, rank));
	MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, element_class));

	/* FIXME: generics */
	g_assert (klass->rank == 0);

	// Check rank == 0
	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, rank_reg, 0);
	MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");

	if (mono_compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass->element_class);
		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
	}
	else {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, klass->element_class);
	}
	
	MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
}

reg: CEE_CASTCLASS (reg) {
     	MonoClass *klass = tree->inst_newa_class;
	MonoInst *object_is_null;
	int obj_reg = state->left->reg1;
	int vtable_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, object_is_null);

	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, obj_reg, 0);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		mini_emit_castclass_iface (s, vtable_reg, klass);
	} else {
		int klass_reg = mono_regstate_next_int (s->rs);

		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));

		if (klass->rank) {
			int rank_reg = mono_regstate_next_int (s->rs);
			int eclass_reg = mono_regstate_next_int (s->rs);

			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, rank_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, rank));
			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, rank_reg, klass->rank);
			MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
			MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, cast_class));
			if (klass->cast_class == mono_defaults.object_class) {
				int parent_reg = mono_regstate_next_int (s->rs);
				int const_reg;
				MONO_EMIT_NEW_LOAD_MEMBASE (s, parent_reg, eclass_reg, G_STRUCT_OFFSET (MonoClass, parent));
				if (mono_compile_aot) {
					const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, parent_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, parent_reg, mono_defaults.enum_class->parent);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, object_is_null);
				if (mono_compile_aot) {
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
				}
				MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
			} else if (klass->cast_class == mono_defaults.enum_class->parent) {
				int const_reg = mono_regstate_next_int (s->rs);
				if (mono_compile_aot) {
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class->parent);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, object_is_null);
				if (mono_compile_aot) {
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
				}
				MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
			} else if (klass->cast_class == mono_defaults.enum_class) {
				if (mono_compile_aot) {
					int const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
				} else {
					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
				}
				MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
			} else if (klass->cast_class->flags & TYPE_ATTRIBUTE_INTERFACE) {
				mini_emit_castclass_iface_class (s, eclass_reg, klass->cast_class);
			} else {
				mini_emit_castclass (s, eclass_reg, klass->cast_class);
			}

			if ((klass->rank == 1) && (klass->byval_arg.type == MONO_TYPE_SZARRAY)) {
				/* Check that the object is a vector too */
				int bounds_reg = mono_regstate_next_int (s->rs);
				MONO_EMIT_NEW_LOAD_MEMBASE (s, bounds_reg, obj_reg, G_STRUCT_OFFSET (MonoArray, bounds));
				MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, bounds_reg, 0);
				MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
			}
		} else {
			mini_emit_castclass (s, klass_reg, klass);
		}
	}

	mono_bblock_add_inst (s->cbb, object_is_null);
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
}

reg: OP_CCASTCLASS (reg) {
	/* This opcode takes as input an object reference and a class, and returns:
	0) if the object is an instance of the class,
	1) if the object is a proxy whose type cannot be determined
	an InvalidCastException exception is thrown otherwhise*/
	
	MonoClass *klass = tree->inst_newa_class;
	MonoInst *end_label, *fail_label, *no_proxy_label, *ok_result_label;
	int obj_reg = state->left->reg1;
	int tmp_reg = mono_regstate_next_int (s->rs);
	int klass_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, end_label);
	MONO_NEW_LABEL (s, ok_result_label);

	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, obj_reg, 0);
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, ok_result_label);

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
	
		MONO_NEW_LABEL (s, fail_label);
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		mini_emit_isninst_iface_cast (s, tmp_reg, klass, fail_label, ok_result_label);
		
		mono_bblock_add_inst (s->cbb, fail_label);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));

		if (mono_compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, klass_reg, tproxy_reg);
		} else {
			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, mono_defaults.transparent_proxy_class);
		}
		
		MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, remote_class));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoRemoteClass, proxy_class));
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, tmp_reg, 0);
		MONO_EMIT_NEW_COND_EXC (s, EQ, "InvalidCastException");
		
		MONO_EMIT_NEW_ICONST (s, state->reg1, 1);
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, end_label);
		
	} else {

		MONO_NEW_LABEL (s, no_proxy_label);
		MONO_NEW_LABEL (s, fail_label);
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));

		if (mono_compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, klass_reg, tproxy_reg);
		} else {
			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, mono_defaults.transparent_proxy_class);
		}
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, no_proxy_label);
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, remote_class));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoRemoteClass, proxy_class));
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, tmp_reg, 0);
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, no_proxy_label);
		
		mini_emit_isninst_cast (s, klass_reg, klass, fail_label, ok_result_label);
		mono_bblock_add_inst (s->cbb, fail_label);
		MONO_EMIT_NEW_ICONST (s, state->reg1, 1);
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, end_label);
		
		mono_bblock_add_inst (s->cbb, no_proxy_label);
		mini_emit_castclass (s, klass_reg, klass);
	}

	mono_bblock_add_inst (s->cbb, ok_result_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 0);
	mono_bblock_add_inst (s->cbb, end_label);
}

reg: CEE_NEWARR (reg),

lreg: OP_LMUL (lreg, lreg),
lreg: OP_LMUL_OVF (lreg, lreg),
lreg: OP_LMUL_OVF_UN (lreg, lreg),
lreg: OP_LDIV (lreg, lreg),
lreg: OP_LDIV_UN (lreg, lreg),
lreg: OP_LREM (lreg, lreg),
lreg: OP_LREM_UN (lreg, lreg),
lreg: OP_LSHL (lreg, reg),
lreg: OP_LSHR (lreg, reg),
lreg: OP_LSHR_UN (lreg, reg) {
	g_assert_not_reached ();
}

#
# string support
#
reg: OP_GETCHR (reg, reg) {
	int mult_reg = mono_regstate_next_int (s->rs);
	int add_reg = mono_regstate_next_int (s->rs);
	
	MONO_EMIT_BOUNDS_CHECK (s, state->left->reg1, MonoString, length, state->right->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, mult_reg, state->right->reg1, 1);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult_reg, state->left->reg1);
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU2_MEMBASE, state->reg1, 
				   add_reg, G_STRUCT_OFFSET (MonoString, chars));
}

reg: OP_GETCHR (reg, OP_ICONST) {
	int ind = 2 * state->right->tree->inst_c0 + G_STRUCT_OFFSET (MonoString, chars);

	MONO_EMIT_BOUNDS_CHECK_IMM (s, state->left->reg1, MonoString, length, state->right->tree->inst_c0);
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU2_MEMBASE, state->reg1, state->left->reg1, ind);
}

reg: OP_STRLEN (reg) {	
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
				   state->left->reg1, G_STRUCT_OFFSET (MonoString, length));
}

reg: OP_GETTYPE (reg) {	
	int vt_reg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, vt_reg, state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOAD_MEMBASE, state->reg1, vt_reg, G_STRUCT_OFFSET (MonoVTable, type));
}

#
# array support
#
reg: CEE_LDLEN (reg) {	
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
				   state->left->reg1, G_STRUCT_OFFSET (MonoArray, max_length));
}

reg: OP_ARRAY_RANK (reg) {	
	int vtable_reg = mono_regstate_next_int (s->rs);
	int class_reg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, vtable_reg, 
				       state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, class_reg, 
				       vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, state->reg1, 
				       class_reg, G_STRUCT_OFFSET (MonoClass, rank));
}

reg: OP_CHECK_ARRAY_TYPE (reg) {
	int vtable_reg = mono_regstate_next_int (s->rs);
	int class_reg = mono_regstate_next_int (s->rs);
	int elclass_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, vtable_reg, 
				       state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, class_reg, 
				       vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, elclass_reg, 
				       class_reg, G_STRUCT_OFFSET (MonoClass, element_class));
	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, elclass_reg, tree->klass);
	MONO_EMIT_NEW_COND_EXC (s, NE_UN, "ArrayTypeMismatchException");
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
}

reg: CEE_LDELEMA (reg, OP_ICONST) "15" {
	guint32 size = mono_class_array_element_size (tree->klass);

	int ind = size * state->right->tree->inst_c0 + G_STRUCT_OFFSET (MonoArray, vector);

	MONO_EMIT_BOUNDS_CHECK_IMM (s, state->left->reg1, MonoArray, max_length, state->right->tree->inst_c0);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, state->left->reg1, ind);
}

reg: CEE_LDELEMA (reg, reg) "20" {
	int mult_reg = mono_regstate_next_int (s->rs);
	int add_reg = mono_regstate_next_int (s->rs);
	guint32 size = mono_class_array_element_size (tree->klass);

	MONO_EMIT_BOUNDS_CHECK (s, state->left->reg1, MonoArray, max_length, state->right->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_MUL_IMM, mult_reg, state->right->reg1, size);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult_reg, state->left->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, add_reg, G_STRUCT_OFFSET (MonoArray, vector));
}

reg: CEE_REFANYVAL (reg) {
	int klass_reg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass));
	if (mono_compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, tree->inst_newa_class);
		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, klass_reg, const_reg);
	} else {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, tree->inst_newa_class);
	}
	MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, value));
}	

reg: OP_REFANYTYPE (reg) {
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, type));
}	

stmt: CEE_MKREFANY (OP_GROUP (reg, OP_ICONST), reg),
stmt: CEE_MKREFANY (OP_GROUP (reg, OP_I8CONST), reg) {
	MonoClass *klass = (MonoClass*)(tree->inst_left->inst_right->inst_p0);
	if (mono_compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		int type_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass), const_reg);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, type_reg, const_reg, G_STRUCT_OFFSET (MonoClass, byval_arg));
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, type), type_reg);
	}
	else {
		MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STOREP_MEMBASE_IMM, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, type), &klass->byval_arg);
		MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STOREP_MEMBASE_IMM, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass), klass);
	}
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, value), state->left->left->reg1);
}

%%

/* 
 * Emit code which checks whenever the interface id of @klass is smaller than
 * than the value given by max_iid_reg.
*/
static void
mini_emit_max_iid_check (MonoCompile *s, int max_iid_reg, MonoClass *klass,
						 MonoInst *false_target)
{
	if (mono_compile_aot) {
		int iid_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_AOTCONST (s, iid_reg, klass, MONO_PATCH_INFO_IID);
		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, max_iid_reg, iid_reg);
	}
	else
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, max_iid_reg, klass->interface_id);
	if (false_target)
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BLT_UN, false_target);
	else
		MONO_EMIT_NEW_COND_EXC (s, LT_UN, "InvalidCastException");
}

/* Same as above, but obtains max_iid from a vtable */
static void
mini_emit_max_iid_check_vtable (MonoCompile *s, int vtable_reg, MonoClass *klass,
								 MonoInst *false_target)
{
	int max_iid_reg = mono_regstate_next_int (s->rs);
		
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, max_iid_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, max_interface_id));
	mini_emit_max_iid_check (s, max_iid_reg, klass, false_target);
}

/* Same as above, but obtains max_iid from a klass */
static void
mini_emit_max_iid_check_class (MonoCompile *s, int klass_reg, MonoClass *klass,
								 MonoInst *false_target)
{
	int max_iid_reg = mono_regstate_next_int (s->rs);

 	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, max_iid_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, max_interface_id));		
	mini_emit_max_iid_check (s, max_iid_reg, klass, false_target);
}

static void
mini_emit_load_intf_reg (MonoCompile *s, int intf_reg, int ioffset_reg, MonoClass *klass)
{
	if (mono_compile_aot) {
		int iid_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_AOTCONST (s, iid_reg, klass, MONO_PATCH_INFO_IID);
		/* FIXME: Do a shift instead */
#if SIZEOF_VOID_P == 8
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, iid_reg, iid_reg, 3);
#else
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, iid_reg, iid_reg, 2);
#endif
		MONO_EMIT_NEW_BIALU (s, CEE_ADD, ioffset_reg, ioffset_reg, iid_reg);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, intf_reg, ioffset_reg, 0);
	}
	else
		MONO_EMIT_NEW_LOAD_MEMBASE (s, intf_reg, ioffset_reg, klass->interface_id * SIZEOF_VOID_P);
}

/* Emit code which loads <vtable_reg>->interface_offsets [klass->interface_id] */
static void
mini_emit_load_intf_reg_vtable (MonoCompile *s, int intf_reg, int vtable_reg, MonoClass *klass)
{
	int ioffset_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE (s, ioffset_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, interface_offsets));
	mini_emit_load_intf_reg (s, intf_reg, ioffset_reg, klass);
}

/* Emit code which loads <klass_reg>->interface_offsets [klass->interface_id] */
static void
mini_emit_load_intf_reg_class (MonoCompile *s, int intf_reg, int klass_reg, MonoClass *klass)
{
	int ioffset_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE (s, ioffset_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, interface_offsets));
	mini_emit_load_intf_reg (s, intf_reg, ioffset_reg, klass);
}

void 
mini_emit_virtual_call (MonoCompile *cfg, void *st, MonoInst *tree, int novirtop, int virtop)
{
	MonoMethod *method = ((MonoCallInst*)tree)->method;
	int vtable_reg, slot_reg, this_reg;
	MBState *state = st;

	this_reg = state->left->reg1;
	mono_arch_emit_this_vret_args (cfg, (MonoCallInst*)tree, this_reg, state->left->tree->type, novirtop == OP_VCALL? state->right->reg1: -1);

	if (!(method->flags & METHOD_ATTRIBUTE_VIRTUAL) || 
	    ((method->flags & METHOD_ATTRIBUTE_FINAL) && 
	     method->wrapper_type != MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK)) {
		/* 
		 * the method is not virtual, we just need to ensure this is not null
		 * and then we can call the method directly.
		 */
		if (method->klass->marshalbyref || method->klass == mono_defaults.object_class) {
			method = ((MonoCallInst*)tree)->method = mono_marshal_get_remoting_invoke_with_check (method);
		}

		if (!method->string_ctor)
			MONO_EMIT_NEW_UNALU (cfg, OP_CHECK_THIS, -1, this_reg);

		tree->dreg = state->reg1;
		tree->opcode = novirtop;
		mono_bblock_add_inst (cfg->cbb, tree);
		return;
	}

	vtable_reg = mono_regstate_next_int (cfg->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE (cfg, vtable_reg, this_reg, G_STRUCT_OFFSET (MonoObject, vtable));
	if (method->klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
		slot_reg = mono_regstate_next_int (cfg->rs);
		mini_emit_load_intf_reg_vtable (cfg, slot_reg, vtable_reg, method->klass);
		tree->inst_offset = method->slot * SIZEOF_VOID_P;
	} else {
		slot_reg = vtable_reg;
		tree->inst_offset = G_STRUCT_OFFSET (MonoVTable, vtable) + (method->slot * SIZEOF_VOID_P);
	}
	
	tree->dreg = state->reg1;
	tree->opcode = virtop;
	tree->sreg1 = slot_reg;
	((MonoCallInst*)tree)->virtual = TRUE;
	mono_bblock_add_inst (cfg->cbb, tree);
}

void 
mini_emit_isninst_cast (MonoCompile *s, int klass_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target)
{
	int idepth_reg = mono_regstate_next_int (s->rs);
	int stypes_reg = mono_regstate_next_int (s->rs);
	int stype = mono_regstate_next_int (s->rs);

	if (klass->idepth > MONO_DEFAULT_SUPERTABLE_SIZE) {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, idepth_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, idepth));
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, idepth_reg, klass->idepth);
		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BLT_UN, false_target);
	}
	MONO_EMIT_NEW_LOAD_MEMBASE (s, stypes_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, supertypes));
	MONO_EMIT_NEW_LOAD_MEMBASE (s, stype, stypes_reg, ((klass->idepth - 1) * SIZEOF_VOID_P));
	if (mono_compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass);
		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, stype, const_reg);
	} else {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, stype, klass);
	}
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BEQ, true_target);
}

void 
mini_emit_isninst_iface_cast (MonoCompile *s, int vtable_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target)
{
	int intf_reg = mono_regstate_next_int (s->rs);

	mini_emit_max_iid_check_vtable (s, vtable_reg, klass, false_target);
	mini_emit_load_intf_reg_vtable (s, intf_reg, vtable_reg, klass);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, intf_reg, 0);
	/* the object_is_null target simply copies the input register to the output */
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BNE_UN, true_target);
}

/*
 * Variant of the above that takes a register to the class, not the vtable.
 * Note that inside interfaces_offsets the empty value is -1, not NULL, in this case.
 */
void 
mini_emit_isninst_iface_class_cast (MonoCompile *s, int klass_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target)
{
	int intf_reg = mono_regstate_next_int (s->rs);

	mini_emit_max_iid_check_class (s, klass_reg, klass, false_target);
	mini_emit_load_intf_reg_class (s, intf_reg, klass_reg, klass);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, intf_reg, -1);
	/* the object_is_null target simply copies the input register to the output */
	MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BGE, true_target);
}

void 
mini_emit_castclass (MonoCompile *s, int klass_reg, MonoClass *klass)
{
	int idepth_reg = mono_regstate_next_int (s->rs);
	int stypes_reg = mono_regstate_next_int (s->rs);
	int stype = mono_regstate_next_int (s->rs);

	if (klass->idepth > MONO_DEFAULT_SUPERTABLE_SIZE) {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, idepth_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, idepth));
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, idepth_reg, klass->idepth);
		MONO_EMIT_NEW_COND_EXC (s, LT_UN, "InvalidCastException");
	}
	MONO_EMIT_NEW_LOAD_MEMBASE (s, stypes_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, supertypes));
	MONO_EMIT_NEW_LOAD_MEMBASE (s, stype, stypes_reg, ((klass->idepth - 1) * SIZEOF_VOID_P));
	if (mono_compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass);
		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, stype, const_reg);
	} else {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, stype, klass);
	}
	MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
}

void 
mini_emit_castclass_iface (MonoCompile *s, int vtable_reg, MonoClass *klass)
{
	int intf_reg = mono_regstate_next_int (s->rs);

	mini_emit_max_iid_check_vtable (s, vtable_reg, klass, NULL);
	mini_emit_load_intf_reg_vtable (s, intf_reg, vtable_reg, klass);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, intf_reg, 0);
	MONO_EMIT_NEW_COND_EXC (s, EQ, "InvalidCastException");
}

/*
 * Variant of the aboce that takes a register to the class, not the vtable.
 * Note that inside interfaces_offsets the empty value is -1, not NULL, in this case.
 */
void 
mini_emit_castclass_iface_class (MonoCompile *s, int klass_reg, MonoClass *klass)
{
	int intf_reg = mono_regstate_next_int (s->rs);

	mini_emit_max_iid_check_class (s, klass_reg, klass, NULL);
	mini_emit_load_intf_reg_class (s, intf_reg, klass_reg, klass);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, intf_reg, -1);
	MONO_EMIT_NEW_COND_EXC (s, EQ, "InvalidCastException");
}

void 
mini_emit_memcpy (MonoCompile *s, int destreg, int doffset, int srcreg, int soffset, int size, int align)
{
	int cur_reg;

	/* FIXME: consider alignment for archs that need it. */
	while (size >= 4) {
		cur_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, cur_reg, srcreg, soffset);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI4_MEMBASE_REG, destreg, doffset, cur_reg);
		doffset += 4;
		soffset += 4;
		size -= 4;
	}
	while (size >= 2) {
		cur_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI2_MEMBASE, cur_reg, srcreg, soffset);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI2_MEMBASE_REG, destreg, doffset, cur_reg);
		doffset += 2;
		soffset += 2;
		size -= 2;
	}
	while (size >= 1) {
		cur_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI1_MEMBASE, cur_reg, srcreg, soffset);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI1_MEMBASE_REG, destreg, doffset, cur_reg);
		doffset += 1;
		soffset += 1;
		size -= 1;
	}
}

void 
mini_emit_memset (MonoCompile *s, int destreg, int offset, int size, int val, int alignl)
{
	int val_reg = mono_regstate_next_int (s->rs);

	if (sizeof (gpointer) == 8)
		MONO_EMIT_NEW_I8CONST (s, val_reg, val);
	else
		MONO_EMIT_NEW_ICONST (s, val_reg, val);

	if (sizeof (gpointer) == 8) {
		while (size >= 8) {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI8_MEMBASE_REG, destreg, offset, val_reg);
			offset += 8;
			size -= 8;
		}
	}	

	while (size >= 4) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI4_MEMBASE_REG, destreg, offset, val_reg);
		offset += 4;
		size -= 4;
	}
	while (size >= 2) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI2_MEMBASE_REG, destreg, offset, val_reg);
		offset += 2;
		size -= 2;
	}
	while (size >= 1) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI1_MEMBASE_REG, destreg, offset, val_reg);
		offset += 1;
		size -= 1;
	}
}

int
ldind_to_load_membase (int opcode)
{
	switch (opcode) {
	case CEE_LDIND_I1:
		return OP_LOADI1_MEMBASE;
	case CEE_LDIND_U1:
		return OP_LOADU1_MEMBASE;
	case CEE_LDIND_I2:
		return OP_LOADI2_MEMBASE;
	case CEE_LDIND_U2:
		return OP_LOADU2_MEMBASE;
	case CEE_LDIND_I4:
		return OP_LOADI4_MEMBASE;
	case CEE_LDIND_U4:
		return OP_LOADU4_MEMBASE;
	case CEE_LDIND_I:
		return OP_LOAD_MEMBASE;
	case CEE_LDIND_REF:
		return OP_LOAD_MEMBASE;
	default:
		g_assert_not_reached ();
	}

	return -1;
}

