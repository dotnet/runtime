/*
 * inssel.brg: instruction selection
 *
 * Author:
 *   Dietmar Maurer (dietmar@ximian.com)
 *   Paolo Molaro (lupus@ximian.com)
 *
 * (C) 2002 Ximian, Inc.
 *
 */
#include <config.h>
#include <string.h>

#include "mini.h"
#include <mono/metadata/marshal.h>
#include <mono/metadata/debug-helpers.h>

#define MBTREE_TYPE  MonoInst
#define MBCGEN_TYPE  MonoCompile
#define MBCOST_DATA  MonoCompile
#define MBALLOC_STATE mono_mempool_alloc (data->state_pool, sizeof (MBState))
#define MBMAX_OPCODES OP_LAST
#define MBGET_OP_NAME(op) mono_inst_name (op)

#define MBTREE_OP(t) ((t)->opcode)
#define MBTREE_LEFT(t) ((t)->inst_left)
#define MBTREE_RIGHT(t) ((t)->inst_right)

#define MONO_EMIT_UNALU(cfg,inst,op,dr,sr1) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->sreg1 = sr1; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_UNALU(cfg,op,dr,sr1) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, op);	\
                inst->dreg = dr; \
                inst->sreg1 = sr1; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_BIALU(cfg,inst,op,dr,sr1,sr2) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->sreg1 = sr1; \
                (inst)->sreg2 = sr2; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_BIALU(cfg,op,dr,sr1,sr2) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, op);	\
                inst->dreg = dr; \
                inst->sreg1 = sr1; \
                inst->sreg2 = sr2; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_BIALU_IMM(cfg,inst,op,dr,sr,imm) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->sreg1 = sr; \
                (inst)->inst_p1 = (gpointer)(gssize)(imm); \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_BIALU_IMM(cfg,op,dr,sr,imm) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, op);	\
                inst->dreg = dr; \
                inst->sreg1 = sr; \
                inst->inst_p1 = (gpointer)(gssize)(imm); \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_BIALU_MEMBASE(cfg,tree,op,dr,sr,basereg,offset) do { \
				tree->opcode = op; \
				tree->dreg = dr; \
				tree->sreg1 = sr; \
				tree->sreg2 = basereg; \
				tree->inst_offset = offset; \
				mono_bblock_add_inst (s->cbb, tree); \
	} while (0)

#define MONO_EMIT_LOAD_MEMBASE(cfg,inst,dr,base,offset) do { \
                (inst)->opcode = OP_LOAD_MEMBASE; \
                (inst)->dreg = dr; \
                (inst)->inst_basereg = base; \
                (inst)->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_LOAD_MEMBASE_OP(cfg,inst,op,dr,base,offset) do { \
                (inst)->opcode = op; \
                (inst)->dreg = dr; \
                (inst)->inst_basereg = base; \
                (inst)->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_LOAD_MEM(cfg,dr,addr) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_LOADU4_MEM);	\
                inst->dreg = dr; \
                inst->inst_p0 = addr; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_LOAD_MEMBASE(cfg,dr,base,offset) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_LOAD_MEMBASE);	\
                inst->dreg = dr; \
                inst->inst_basereg = base; \
                inst->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_LOAD_MEMBASE_OP(cfg,op,dr,base,offset) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, op);	\
                inst->dreg = dr; \
                inst->inst_basereg = base; \
                inst->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_STORE_MEMBASE(cfg,inst,op,base,offset,sr) do { \
                (inst)->opcode = op; \
                (inst)->sreg1 = sr; \
                (inst)->inst_destbasereg = base; \
                (inst)->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_STORE_MEMBASE(cfg,op,base,offset,sr) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, op);	\
                inst->sreg1 = sr; \
                inst->inst_destbasereg = base; \
                inst->inst_offset = offset; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_STORE_MEMBASE_IMM(cfg,inst,op,base,offset,imm) do { \
                (inst)->opcode = op; \
                (inst)->inst_destbasereg = base; \
                (inst)->inst_offset = offset; \
                (inst)->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define MONO_EMIT_NEW_STORE_MEMBASE_IMM(cfg,op,base,offset,imm) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, op);	\
                inst->inst_destbasereg = base; \
                inst->inst_offset = offset; \
                inst->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst (cfg->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_COMPARE_IMM(cfg,sr1,imm) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_COMPARE_IMM);	\
                inst->sreg1 = sr1; \
                inst->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_ICOMPARE_IMM(cfg,sr1,imm) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, sizeof (void*) == 8 ? OP_ICOMPARE_IMM : OP_COMPARE_IMM);	\
                inst->sreg1 = sr1; \
                inst->inst_p1 = (gpointer)imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_COND_EXC(cfg,cond,name) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_NOP);	\
		inst->opcode = OP_COND_EXC_##cond;  \
                inst->inst_p1 = (char*)name; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_ICONST(cfg,dr,imm) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_ICONST);	\
                inst->dreg = dr; \
                inst->inst_c0 = imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_I8CONST(cfg,dr,imm) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_I8CONST);	\
                inst->dreg = dr; \
                inst->inst_l = imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_PCONST(cfg,dr,imm) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_ICONST);	\
                inst->dreg = dr; \
                inst->inst_p0 = (gpointer) imm; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)


#ifdef MONO_ARCH_NEED_GOT_VAR

#define MONO_EMIT_NEW_AOTCONST(cfg,dr,cons,patch_type) do { \
		mini_emit_aotconst ((cfg), (dr), (patch_type), (cons)); \
    } while (0)

#else

#define	MONO_EMIT_NEW_AOTCONST(cfg,dr,imm,type) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, OP_AOTCONST);	\
                inst->dreg = dr; \
                inst->inst_p0 = imm; \
                inst->inst_c1 = type; \
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#endif

#define	MONO_EMIT_NEW_CLASSCONST(cfg,dr,imm) MONO_EMIT_NEW_AOTCONST(cfg,dr,imm,MONO_PATCH_INFO_CLASS)
#define MONO_EMIT_NEW_VTABLECONST(cfg,dest,vtable) MONO_EMIT_NEW_AOTCONST ((cfg), (dest), (cfg)->compile_aot ? (gpointer)((vtable)->klass) : (vtable), MONO_PATCH_INFO_VTABLE)

#define	MONO_EMIT_NEW_BRANCH_BLOCK(cfg,op,targetbb) do { \
                MonoInst *inst; \
        	MonoInst *target_label; \
		target_label = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		target_label->opcode = OP_LABEL;	\
		MONO_INST_LIST_ADD (&target_label->node, \
				   &(targetbb)->ins_list); \
		target_label->inst_c0 = (targetbb)->native_offset; \
		MONO_INST_NEW ((cfg), inst, op);	\
		inst->inst_i0 = target_label;	\
		inst->flags = MONO_INST_BRLABEL;	\
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define	MONO_EMIT_NEW_BRANCH_LABEL(cfg,op,label) do { \
                MonoInst *inst; \
		MONO_INST_NEW ((cfg), inst, op);	\
		inst->inst_i0 = label;	\
		inst->flags = MONO_INST_BRLABEL;	\
	        mono_bblock_add_inst ((cfg)->cbb, inst); \
	} while (0)

#define MONO_NEW_LABEL(cfg,inst) do { \
		(inst) = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
		(inst)->opcode = OP_LABEL;	\
	} while (0)

#define MONO_EMIT_BOUNDS_CHECK(cfg, array_reg, array_type, array_length_field, index_reg) do { \
		if (! (state->tree->flags & MONO_INST_NORANGECHECK)) { \
			int _length_reg = mono_regstate_next_int (cfg->rs); \
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, _length_reg, array_reg, G_STRUCT_OFFSET (array_type, array_length_field)); \
			MONO_EMIT_NEW_COMPARE_EXC (cfg, LE_UN, _length_reg, index_reg, "IndexOutOfRangeException"); \
		} \
	} while (0)

#define MONO_EMIT_BOUNDS_CHECK_IMM(cfg, array_reg, array_type, array_length_field, index_imm) do { \
		if (! (state->tree->flags & MONO_INST_NORANGECHECK)) { \
			int _length_reg = mono_regstate_next_int (cfg->rs); \
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, _length_reg, array_reg, G_STRUCT_OFFSET (array_type, array_length_field)); \
			MONO_EMIT_NEW_COMPARE_IMM_EXC (cfg, LE_UN, _length_reg, index_imm, "IndexOutOfRangeException"); \
		} \
	} while (0)

#ifndef MONO_EMIT_NEW_COMPARE_EXC
#define MONO_EMIT_NEW_COMPARE_EXC(cfg, cmp_op, sreg1, sreg2, exc) do { \
		MONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, sreg1, sreg2); \
		MONO_EMIT_NEW_COND_EXC (cfg, cmp_op, exc); \
	} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_IMM_EXC
#define MONO_EMIT_NEW_COMPARE_IMM_EXC(cfg, cmp_op, sreg1, imm, exc) do { \
		MONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, sreg1, imm); \
		MONO_EMIT_NEW_COND_EXC (cfg, cmp_op, exc); \
	} while (0)
#endif

#ifndef MONO_EMIT_NEW_ICOMPARE_IMM_EXC
#define MONO_EMIT_NEW_ICOMPARE_IMM_EXC(cfg, cmp_op, sreg1, imm, exc) do { \
		MONO_EMIT_NEW_ICOMPARE_IMM(cfg, sreg1, imm); \
		MONO_EMIT_NEW_COND_EXC (cfg, cmp_op, exc); \
	} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_BRANCH_LABEL
#define MONO_EMIT_NEW_COMPARE_BRANCH_LABEL(cfg, cmp_op, sreg1, sreg2, label) \
	do { \
		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, (sreg1), (sreg2)); \
		MONO_EMIT_NEW_BRANCH_LABEL (s, (cmp_op), (label)); \
	} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_BRANCH_LABEL_CHAINED
#define MONO_EMIT_NEW_COMPARE_BRANCH_LABEL_CHAINED(cfg, cmp_op, sreg1, sreg2, label) \
        do { \
                MONO_EMIT_NEW_BRANCH_LABEL (s, (cmp_op), (label)); \
} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL
#define MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL(cfg, cmp_op, sreg1, imm, label) \
	do { \
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, (sreg1), (imm)); \
		MONO_EMIT_NEW_BRANCH_LABEL (s, (cmp_op), (label)); \
	} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL_CHAINED
#define MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL_CHAINED(cfg, cmp_op, sreg1, imm, label) \
        do { \
                MONO_EMIT_NEW_BRANCH_LABEL (s, (cmp_op), (label)); \
} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK
#define MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK(cfg, cmp_op, sreg1, sreg2, block) \
	do { \
		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, (sreg1), (sreg2)); \
		MONO_EMIT_NEW_BRANCH_BLOCK (s, (cmp_op), (block)); \
	} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK_CHAINED
#define MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK_CHAINED(cfg, cmp_op, sreg1, sreg2, block) \
        do { \
                MONO_EMIT_NEW_BRANCH_BLOCK (s, (cmp_op), (block)); \
} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_IMM_BRANCH_BLOCK
#define MONO_EMIT_NEW_COMPARE_IMM_BRANCH_BLOCK(cfg, cmp_op, sreg1, imm, block) \
	do { \
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, (sreg1), (imm)); \
		MONO_EMIT_NEW_BRANCH_BLOCK (s, (cmp_op), (block)); \
	} while (0)
#endif

#ifndef MONO_EMIT_NEW_COMPARE_IMM_BRANCH_BLOCK_CHAINED
#define MONO_EMIT_NEW_COMPARE_IMM_BRANCH_BLOCK_CHAINED(cfg, cmp_op, sreg1, imm, block) \
        do { \
                MONO_EMIT_NEW_BRANCH_BLOCK (s, (cmp_op), (block)); \
} while (0)
#endif

%%

%termprefix OP_ CEE_

%start stmt

#
# base addressing mode 
#

base: reg "0" {
	/* we create a new MonoInst in chain rules and set state->tree to it
	 * since a MBState (and hence state->tree) is reused in chain rules and
	 * normal rules.
	 */
	MonoInst *inst;
    MONO_INST_NEW (s, inst, OP_NOP); /* The opcode doesn't matter */
	inst->inst_basereg = state->reg1;
	inst->inst_offset = 0;
	state->tree = inst;
	//g_print ("mybase: (assigned R%d from R%d - R%d)\n", state->reg1, tree->dreg, state->reg2);
	//tree->inst_offset = 0;
	//tree->inst_basereg = state->reg1;
}

base: CEE_LDIND_I (OP_REGVAR) "0" {
	tree->inst_offset = 0;
	tree->inst_basereg = state->left->tree->dreg;
}

base: OP_REGOFFSET "0" {
	/* nothing to do */
}

base: OP_LDADDR (OP_REGOFFSET),
base: CEE_LDOBJ (OP_REGOFFSET) "0" {
	tree->inst_offset = state->left->tree->inst_offset;
	tree->inst_basereg = state->left->tree->inst_basereg;
}

base: CEE_ADD (base, OP_ICONST) "0" {
	tree->inst_offset = state->left->tree->inst_offset + state->right->tree->inst_c0;
	tree->inst_basereg = state->left->tree->inst_basereg;
}

base: CEE_ADD (CEE_LDIND_REF (OP_REGVAR), OP_ICONST),
base: CEE_ADD (CEE_LDIND_I (OP_REGVAR), OP_ICONST) "0" {
	tree->inst_offset = state->right->tree->inst_c0;
	tree->inst_basereg = state->left->left->tree->dreg;
}

#
# helpers
#

reg: OP_ICONST {
	tree->dreg = state->reg1;
     	MONO_EMIT_NEW_ICONST (s, state->reg1, tree->inst_c0);
}

reg: OP_AOTCONST {
     	MONO_EMIT_NEW_AOTCONST (s, state->reg1, tree->inst_p0, tree->inst_c1);
}

reg: OP_LOAD_GOTADDR {
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_I (OP_REGVAR, OP_LOAD_GOTADDR) {
	tree->opcode = OP_LOAD_GOTADDR;
	tree->dreg = state->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_GOT_ENTRY (reg, OP_PATCH_INFO) {
	tree->inst_basereg = state->left->tree->dreg;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_GOT_ENTRY (CEE_LDIND_I (OP_REGVAR), OP_PATCH_INFO) {
	tree->inst_basereg = state->left->left->tree->dreg;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_DUMMY_USE (CEE_LDIND_I (OP_REGVAR)) {
}

stmt: OP_DUMMY_USE (CEE_LDIND_I (OP_REGOFFSET)) {
}

stmt: OP_DUMMY_USE (CEE_LDIND_REF (OP_REGOFFSET)) {
}

stmt: OP_DUMMY_STORE {
}

stmt: OP_NOT_REACHED {
}

stmt: OP_MEMORY_BARRIER {
	mono_bblock_add_inst (s->cbb, tree);
}

#
# load/store operations
#

reg: CEE_LDIND_I (base),
reg: CEE_LDIND_REF (base),
reg: CEE_LDIND_I1 (base),
reg: CEE_LDIND_U1 (base),
reg: CEE_LDIND_I2 (base),
reg: CEE_LDIND_U2 (base),
reg: CEE_LDIND_I4 (base),
reg: CEE_LDIND_U4 (base) {
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, ldind_to_load_membase (tree->opcode),
				   state->reg1, state->left->tree->inst_basereg, state->left->tree->inst_offset);
}

reg: OP_LDADDR (OP_REGOFFSET),
reg: CEE_LDOBJ (OP_REGOFFSET) "2" {
	/* use LEA */
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->tree->inst_basereg;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
	if (state->left->tree->inst_offset)
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tree->dreg, tree->dreg, state->left->tree->inst_offset);
}

reg: CEE_LDOBJ (reg),
reg: OP_OBJADDR (reg),
reg: OP_VTADDR (reg) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
}

reg: CEE_LDIND_U1 (OP_REGVAR) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->tree->dreg, 0xff);
}

reg: CEE_LDIND_U2 (OP_REGVAR) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->tree->dreg, 0xffff);
}

stmt: CEE_STIND_REF (base, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_REF (base, CEE_LDIND_I (OP_REGVAR)),
stmt: CEE_STIND_I (base, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_I (base, CEE_LDIND_I (OP_REGVAR)) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->left->tree->dreg);
}

stmt: CEE_STIND_REF (OP_REGVAR, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_REF (OP_REGVAR, CEE_LDIND_I (OP_REGVAR)),
stmt: CEE_STIND_I (OP_REGVAR, CEE_LDIND_REF (OP_REGVAR)),
stmt: CEE_STIND_I (OP_REGVAR, CEE_LDIND_I (OP_REGVAR)),
stmt: CEE_STIND_I4 (OP_REGVAR, CEE_LDIND_I4 (OP_REGVAR)) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->left->tree->dreg);
}


stmt: CEE_STIND_I (base, reg),
stmt: CEE_STIND_REF (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I (base, OP_ICONST),
stmt: CEE_STIND_REF (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STORE_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

reg: CEE_LDIND_REF (OP_REGVAR),
reg: CEE_LDIND_I (OP_REGVAR),
reg: CEE_LDIND_I4 (OP_REGVAR),
reg: CEE_LDIND_U4 (OP_REGVAR) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->tree->dreg);
}

stmt: CEE_STIND_I4 (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI4_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I4 (base, CEE_LDIND_I4 (OP_REGVAR)) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI4_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->left->tree->dreg);
}

stmt: CEE_STIND_I4 (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STOREI4_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

stmt: CEE_STIND_I4 (OP_REGVAR, CEE_LDIND_I4 (base)) {
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->left->tree->dreg, 
				   state->right->left->tree->inst_basereg, 
				   state->right->left->tree->inst_offset);
}

stmt: CEE_STIND_I1 (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI1_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I1 (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STOREI1_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

stmt: CEE_STIND_I2 (base, reg) {
	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI2_MEMBASE_REG, state->left->tree->inst_basereg,
				 state->left->tree->inst_offset, state->right->reg1);
}

stmt: CEE_STIND_I2 (base, OP_ICONST) {
	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STOREI2_MEMBASE_IMM, state->left->tree->inst_basereg,
				     state->left->tree->inst_offset, state->right->tree->inst_c0);
}

stmt: CEE_STIND_I2 (OP_REGVAR, reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->reg1, 0xffff);
}

stmt: CEE_STIND_I1 (OP_REGVAR, reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->reg1, 0xff);
}

stmt: CEE_STIND_I1 (OP_REGVAR, CEE_LDIND_U1 (OP_REGVAR)),
stmt: CEE_STIND_I1 (OP_REGVAR, CEE_LDIND_I1 (OP_REGVAR)) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->left->tree->dreg, 0xff);
}

stmt: CEE_STIND_I2 (OP_REGVAR, CEE_LDIND_U2 (OP_REGVAR)),
stmt: CEE_STIND_I2 (OP_REGVAR, CEE_LDIND_I2 (OP_REGVAR)) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->left->tree->dreg, state->right->left->tree->dreg, 0xffff);
}

stmt: CEE_STIND_I4 (OP_REGVAR, OP_ICONST),
stmt: CEE_STIND_I2 (OP_REGVAR, OP_ICONST),
stmt: CEE_STIND_I1 (OP_REGVAR, OP_ICONST),
stmt: CEE_STIND_REF (OP_REGVAR, OP_ICONST),
stmt: CEE_STIND_I (OP_REGVAR, OP_ICONST) {
	tree->inst_c0 = state->right->tree->inst_c0;
	if (tree->opcode == CEE_STIND_I2)
		tree->inst_c0 &= 0xffff;
	if (tree->opcode == CEE_STIND_I1)
		tree->inst_c0 &= 0xff;
	
	tree->opcode = OP_ICONST;
	tree->dreg = state->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_I4 (OP_REGVAR, reg),
stmt: CEE_STIND_REF (OP_REGVAR, reg),
stmt: CEE_STIND_I (OP_REGVAR, reg) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->reg1);
}

stmt: OP_MEMCPY (base, base) {
	int size = tree->backend.memcpy_args->size;
	int align = tree->backend.memcpy_args->align;
	if (size > 0)
		mini_emit_memcpy (s, state->left->tree->inst_basereg, state->left->tree->inst_offset,
				  state->right->tree->inst_basereg, state->right->tree->inst_offset, size, align);
}

stmt: OP_MEMSET (base) {
	int size = tree->backend.memcpy_args->size;
	int align = tree->backend.memcpy_args->align;
	if (size > 0)
		mini_emit_memset (s, state->left->tree->inst_basereg, state->left->tree->inst_offset, size, tree->inst_imm, align);
}

reg: OP_LDELEMA2D (reg, OP_GROUP (reg, reg)) "20" {
	int bounds_reg = mono_regstate_next_int (s->rs);
	int add_reg = mono_regstate_next_int (s->rs);
	int mult_reg = mono_regstate_next_int (s->rs);
	int mult2_reg = mono_regstate_next_int (s->rs);
	int low1_reg = mono_regstate_next_int (s->rs);
	int low2_reg = mono_regstate_next_int (s->rs);
	int high1_reg = mono_regstate_next_int (s->rs);
	int high2_reg = mono_regstate_next_int (s->rs);
	int realidx1_reg = mono_regstate_next_int (s->rs);
	int realidx2_reg = mono_regstate_next_int (s->rs);
	int sum_reg = mono_regstate_next_int (s->rs);
	int index1, index2;
	guint32 size = mono_class_array_element_size (tree->klass);
	
	index1 = state->right->left->reg1;
	index2 = state->right->right->reg1;

	/* range checking */
	MONO_EMIT_NEW_LOAD_MEMBASE (s, bounds_reg, 
				       state->left->reg1, G_STRUCT_OFFSET (MonoArray, bounds));

	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, low1_reg, 
				       bounds_reg, G_STRUCT_OFFSET (MonoArrayBounds, lower_bound));
	MONO_EMIT_NEW_BIALU (s, CEE_SUB, realidx1_reg, index1, low1_reg);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, high1_reg, 
				       bounds_reg, G_STRUCT_OFFSET (MonoArrayBounds, length));
	MONO_EMIT_NEW_COMPARE_EXC (s, LE_UN, high1_reg, realidx1_reg, "IndexOutOfRangeException");

	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, low2_reg, 
				       bounds_reg, sizeof (MonoArrayBounds) + G_STRUCT_OFFSET (MonoArrayBounds, lower_bound));
	MONO_EMIT_NEW_BIALU (s, CEE_SUB, realidx2_reg, index2, low2_reg);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, high2_reg, 
				       bounds_reg, sizeof (MonoArrayBounds) + G_STRUCT_OFFSET (MonoArrayBounds, length));
	MONO_EMIT_NEW_COMPARE_EXC (s, LE_UN, high2_reg, realidx2_reg, "IndexOutOfRangeException");

	MONO_EMIT_NEW_BIALU (s, CEE_MUL, mult_reg, high2_reg, realidx1_reg);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, sum_reg, mult_reg, realidx2_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_MUL_IMM, mult2_reg, sum_reg, size);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult2_reg, state->left->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, add_reg, G_STRUCT_OFFSET (MonoArray, vector));
}

#
# conversions: conv_u can be implemented with AND, also all _ovf conversions?
#

reg: CEE_CONV_I1 (reg),
reg: CEE_CONV_I2 (reg),
reg: CEE_CONV_I4 (reg) {
	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
}

reg: CEE_CONV_U1 (reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xff);
}

reg: CEE_CONV_U2 (reg) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xffff);
}

reg: CEE_CONV_U4 (reg),
reg: CEE_CONV_U (reg),
reg: CEE_CONV_I (reg) {
	if (sizeof (void *) == 8)
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	else
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_I4 (reg) {
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_U4 (reg),
reg: CEE_CONV_OVF_I4_UN (reg) {
	if (sizeof (void *) == 8) {
		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
	} else {	
		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state->left->reg1, 0, "OverflowException");
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
	}
}

reg: CEE_CONV_OVF_I1 (reg) {     
	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT, state->left->reg1, 127, "OverflowException");
	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, LT, state->left->reg1, -128, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_I1_UN (reg) {
	/* probe values between 0 to 127 */
	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT_UN, state->left->reg1, 127, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_U1 (reg),
reg: CEE_CONV_OVF_U1_UN (reg) {
	/* probe value to be within 0 to 255 */
	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state->left->reg1, 255, "OverflowException");
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xff);
}

reg: CEE_CONV_OVF_I2 (reg) {	
	/* Probe value to be within -32768 and 32767 */
	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT, state->left->reg1, 32767, "OverflowException");
	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, LT, state->left->reg1, -32768, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_I2_UN (reg) {
	/* Convert uint value into short, value within 0 and 32767 */
	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT_UN, state->left->reg1, 32767, "OverflowException");
	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state->reg1, state->left->reg1);
}

reg: CEE_CONV_OVF_U2 (reg),
reg: CEE_CONV_OVF_U2_UN (reg) {
	/* Probe value to be within 0 and 65535 */
	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT_UN, state->left->reg1, 0xffff, "OverflowException");
	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->reg1, 0xffff);
}

#
# other alu operations
#

reg: OP_CEQ (cflags),
reg: OP_CLT (cflags),
reg: OP_CLT_UN (cflags),
reg: OP_CGT (cflags),
reg: OP_CGT_UN (cflags) "2" {	
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

#
# control flow commands 
#

stmt: OP_LABEL {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_NOP "0" {
}

stmt: OP_BREAK "0" {
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_TLS_GET {
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SWITCH (reg) "2" {
	MonoInst *label;
	int offset_reg = mono_regstate_next_int (s->rs);
	int target_reg = mono_regstate_next_int (s->rs);
	int n = GPOINTER_TO_INT (tree->klass);
	
	MONO_NEW_LABEL (s, label);

	if (sizeof (gpointer) == 8) {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ICOMPARE_IMM, -1, state->left->reg1, n);
		MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_IBGE_UN, tree->inst_many_bb [n]);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, offset_reg, state->left->reg1, 3);
		/* The upper word might not be zero, and we add it to a 64 bit address later */
		MONO_EMIT_NEW_UNALU (s, CEE_CONV_U8, offset_reg, offset_reg);
	} else {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, state->left->reg1, n);
		MONO_EMIT_NEW_BRANCH_BLOCK (s, CEE_BGE_UN, tree->inst_many_bb [n]);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, offset_reg, state->left->reg1, 2);
	}
	mono_bblock_add_inst (s->cbb, label);
	if (s->compile_aot) {
		int table_reg = mono_regstate_next_int (s->rs);
		int sum_reg = mono_regstate_next_int (s->rs);
		MonoJumpInfoBBTable *table;

		table = mono_mempool_alloc (s->mempool, sizeof (MonoJumpInfoBBTable));
		table->table = tree->inst_many_bb;
		table->table_size = n;

		MONO_EMIT_NEW_AOTCONST (s, table_reg, table, MONO_PATCH_INFO_SWITCH);

		MONO_EMIT_NEW_BIALU (s, CEE_ADD, sum_reg, table_reg, offset_reg);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, target_reg, sum_reg, 0);
	} else {
		mono_create_jump_table (s, label, tree->inst_many_bb, n);

		 /* the backend must patch the address. we use 0xf0f0f0f0 to avoid the usage 
		  * of special (short) opcodes on x86 */
		if (sizeof (gpointer) == 8)
			MONO_EMIT_NEW_LOAD_MEMBASE (s, target_reg, offset_reg, (gint64)0xf0f0f0f0f0f0f0f1LL);
		else
			MONO_EMIT_NEW_LOAD_MEMBASE (s, target_reg, offset_reg, 0xf0f0f0f0);
	}
	MONO_EMIT_UNALU (s, tree, OP_BR_REG, -1, target_reg);
}

stmt: OP_BR "0" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ARGLIST (reg) {
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_CALL {
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_CALLVIRT (reg) {
	mini_emit_virtual_call (s, state, tree, OP_CALL, OP_CALL_MEMBASE);
}

stmt: OP_VOIDCALLVIRT (reg) {
	mini_emit_virtual_call (s, state, tree, OP_VOIDCALL, OP_VOIDCALL_MEMBASE);
}

freg: OP_FCALLVIRT (reg) {
	mini_emit_virtual_call (s, state, tree, OP_FCALL, OP_FCALL_MEMBASE);
}

stmt: OP_VCALLVIRT (reg, reg) {
	mini_emit_virtual_call (s, state, tree, OP_VCALL, OP_VCALL_MEMBASE);
}

reg: OP_CALL_REG (reg) {
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL_REG (reg) {
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL {
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL_REG (reg) {
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VCALL (reg) {
	mono_arch_emit_this_vret_args (s, (MonoCallInst*)tree, -1, -1, state->left->reg1);
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VCALL_REG (reg, reg) {
	mono_arch_emit_this_vret_args (s, (MonoCallInst*)tree, -1, -1, state->right->reg1);
	
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_TRAMPCALL_VTABLE (reg) {
	#ifdef MONO_ARCH_VTABLE_REG
		MonoCallInst *call = (MonoCallInst*)tree;
		int vtable_reg = mono_regstate_next_int (s->rs);

		MONO_EMIT_NEW_UNALU (s, OP_MOVE, vtable_reg, state->left->reg1);

		call->inst.opcode = OP_VOIDCALL;

		mono_call_inst_add_outarg_reg (s, call, vtable_reg, MONO_ARCH_VTABLE_REG, FALSE);

		mono_bblock_add_inst (s->cbb, &call->inst);
	#else
		g_assert_not_reached ();
	#endif
}

reg: OP_CALL_RGCTX (reg) {
	emit_rgctx_argument (s, tree, state->left->reg1, OP_CALL);

	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL_RGCTX (reg) {
	emit_rgctx_argument (s, tree, state->left->reg1, OP_FCALL);

	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL_RGCTX (reg) {
	emit_rgctx_argument (s, tree, state->left->reg1, OP_VOIDCALL);

	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VCALL_RGCTX (reg, reg) {
	emit_rgctx_argument (s, tree, state->right->reg1, OP_VCALL);

	mono_arch_emit_this_vret_args (s, (MonoCallInst*)tree, -1, -1, state->left->reg1);
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_CALL_REG_RGCTX (reg, reg) {
	emit_rgctx_argument (s, tree, state->right->reg1, OP_CALL_REG);

	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL_REG_RGCTX (reg, reg) {
	emit_rgctx_argument (s, tree, state->right->reg1, OP_FCALL_REG);

	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL_REG_RGCTX (reg, reg) {
	emit_rgctx_argument (s, tree, state->right->reg1, OP_VOIDCALL_REG);

	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VCALL_REG_RGCTX (OP_GROUP (reg, reg), reg) {
	emit_rgctx_argument (s, tree, state->left->right->reg1, OP_VCALL_REG);

	tree->inst_left = tree->inst_left->inst_left;
	state->left = state->left->left;

	mono_arch_emit_this_vret_args (s, (MonoCallInst*)tree, -1, -1, state->right->reg1);

	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SAVE_LMF,
stmt: OP_RESTORE_LMF {
	mono_bblock_add_inst (s->cbb, tree);
}

#
# Optimized call instructions
#

reg: OP_CALL_REG (OP_ICONST),
reg: OP_CALL_REG (OP_I8CONST) {
	tree->opcode = OP_CALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_VOIDCALL_REG (OP_ICONST),
stmt: OP_VOIDCALL_REG (OP_I8CONST) {
	tree->opcode = OP_VOIDCALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_FCALL_REG (OP_ICONST),
freg: OP_FCALL_REG (OP_I8CONST) {
	tree->opcode = OP_FCALL;
	((MonoCallInst*)tree)->fptr = state->left->tree->inst_p0;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_POP (reg)

# remove some common pops without side effects
stmt: CEE_POP (OP_ICONST)
stmt: CEE_POP (CEE_LDIND_I1 (base))
stmt: CEE_POP (CEE_LDIND_U1 (base))
stmt: CEE_POP (CEE_LDIND_I2 (base))
stmt: CEE_POP (CEE_LDIND_U2 (base))
stmt: CEE_POP (CEE_LDIND_I4 (base))
stmt: CEE_POP (CEE_LDIND_U4 (base))
stmt: CEE_POP (CEE_LDIND_I (base))
stmt: CEE_POP (CEE_LDIND_REF (base))
stmt: CEE_POP (CEE_LDIND_I1 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_U1 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_I2 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_U2 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_I4 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_U4 (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_I (OP_REGVAR))
stmt: CEE_POP (CEE_LDIND_REF (OP_REGVAR))

stmt: OP_JMP "0" {
	mono_bblock_add_inst (s->cbb, tree);
}

# exception handling

stmt: OP_THROW (reg) {
	MONO_EMIT_UNALU (s, tree, OP_THROW, -1, state->left->reg1);
}

stmt: OP_RETHROW (reg) {
	MONO_EMIT_UNALU (s, tree, OP_RETHROW, -1, state->left->reg1);
}

stmt: OP_THROW_OR_NULL (reg, reg) {
	MonoInst *dont_throw;

	MONO_NEW_LABEL (s, dont_throw);

	/*
	 * Currently, we allways rethrow the abort exception, despite the fact
	 * that this is not correct. See thread6.cs for an example. But propagating
	 * the abort exception is more important than getting the sematics right.
	 */
	MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, state->left->reg1, 0, dont_throw);
	MONO_EMIT_UNALU (s, tree, OP_THROW, -1, state->left->reg1);
	mono_bblock_add_inst (s->cbb, dont_throw);
}

stmt: OP_THROW (CEE_LDIND_REF (OP_REGVAR)) {
	MONO_EMIT_UNALU (s, tree, OP_THROW, -1, state->left->left->tree->dreg);
}

stmt: OP_CALL_HANDLER {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_START_HANDLER "2" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ENDFINALLY "2" {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ENDFILTER (reg) "2" {
	MONO_EMIT_UNALU (s, tree, OP_ENDFILTER, -1, state->left->reg1);
}

stmt: OP_CHECK_THIS (reg) {
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

# object related opcodes 

reg: CEE_ISINST (reg) {
     	MonoClass *klass = tree->inst_newa_class;
	MonoInst *object_is_null, *end_label, *false_label;
	int obj_reg = state->left->reg1;
	int vtable_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, object_is_null);
	MONO_NEW_LABEL (s, end_label);
	MONO_NEW_LABEL (s, false_label);

	MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, obj_reg, 0, object_is_null);

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		/* the object_is_null target simply copies the input register to the output */
		mini_emit_isinst_iface (s, vtable_reg, klass, false_label, object_is_null);
	} else {
		int klass_reg = mono_regstate_next_int (s->rs);

		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));

		if (klass->rank) {
			int rank_reg = mono_regstate_next_int (s->rs);
			int eclass_reg = mono_regstate_next_int (s->rs);

			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, rank_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, rank));
			MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, rank_reg, klass->rank, false_label);
			MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
			MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, cast_class));
			if (klass->cast_class == mono_defaults.object_class) {
				int parent_reg = mono_regstate_next_int (s->rs);
				int const_reg = -1;
				MONO_EMIT_NEW_LOAD_MEMBASE (s, parent_reg, eclass_reg, G_STRUCT_OFFSET (MonoClass, parent));
				if (s->compile_aot) {
					const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
					MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BNE_UN, parent_reg,
							const_reg, object_is_null);
				} else {
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, parent_reg,
							mono_defaults.enum_class->parent, object_is_null);
				}
				if (s->compile_aot) {
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BEQ, eclass_reg, const_reg, object_is_null);
				} else {
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, eclass_reg,
						mono_defaults.enum_class, object_is_null);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, false_label);
			} else if (klass->cast_class == mono_defaults.enum_class->parent) {
				int const_reg = -1;
				
				if (s->compile_aot) {
					const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
					MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BEQ, eclass_reg, const_reg, object_is_null);
				} else {
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, eclass_reg,
						mono_defaults.enum_class->parent, object_is_null);
				}
				if (s->compile_aot) {
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BEQ, eclass_reg, const_reg, object_is_null);
				} else {
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, eclass_reg,
						mono_defaults.enum_class, object_is_null);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, false_label);
			} else if (klass->cast_class == mono_defaults.enum_class) {
				if (s->compile_aot) {
					int const_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
					MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BEQ, eclass_reg, const_reg, object_is_null);
				} else {
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, eclass_reg,
						mono_defaults.enum_class, object_is_null);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, false_label);
			} else if (klass->cast_class->flags & TYPE_ATTRIBUTE_INTERFACE) {
				mini_emit_isinst_iface_class (s, eclass_reg, klass->cast_class, false_label, object_is_null);
			} else {
				if ((klass->rank == 1) && (klass->byval_arg.type == MONO_TYPE_SZARRAY)) {
					/* Check that the object is a vector too */
					int bounds_reg = mono_regstate_next_int (s->rs);
					MONO_EMIT_NEW_LOAD_MEMBASE (s, bounds_reg, obj_reg, G_STRUCT_OFFSET (MonoArray, bounds));
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, bounds_reg, 0, false_label);
				}

				/* the object_is_null target simply copies the input register to the output */
				mini_emit_isinst (s, eclass_reg, klass->cast_class, false_label, object_is_null);
			}
		} else if (mono_class_is_nullable (klass)) {
			MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
			/* the object_is_null target simply copies the input register to the output */
			mini_emit_isinst (s, klass_reg, klass->cast_class, false_label, object_is_null);
		} else {
			if (!s->compile_aot && !(s->opt & MONO_OPT_SHARED) && (klass->flags & TYPE_ATTRIBUTE_SEALED)) {
				/* the remoting code is broken, access the class for now */
				if (0) {
					MonoVTable *vt = mono_class_vtable (s->domain, klass);
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, vtable_reg, vt, false_label);
				} else {
					MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
					MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, klass_reg, klass, false_label);
				}
				MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, object_is_null);
			} else {
				MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
				/* the object_is_null target simply copies the input register to the output */
				mini_emit_isinst (s, klass_reg, klass, false_label, object_is_null);
			}
		}
	}

	mono_bblock_add_inst (s->cbb, false_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 0);
	MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, end_label);
	mono_bblock_add_inst (s->cbb, object_is_null);
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
	mono_bblock_add_inst (s->cbb, end_label);
}

reg: OP_CISINST (reg) {
	/* This opcode takes as input an object reference and a class, and returns:
	0) if the object is an instance of the class,
	1) if the object is not instance of the class,
	2) if the object is a proxy whose type cannot be determined */
	
	MonoClass *klass = tree->inst_newa_class;
	MonoInst *end_label, *true_label, *false_label, *false2_label;
	MonoInst *no_proxy_label, *interface_fail_label;
	int obj_reg = state->left->reg1;
	int tmp_reg = mono_regstate_next_int (s->rs);
	int klass_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, end_label);
	MONO_NEW_LABEL (s, true_label);
	MONO_NEW_LABEL (s, false_label);
	MONO_NEW_LABEL (s, false2_label);

	MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, obj_reg, 0, false_label);

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
		MONO_NEW_LABEL (s, interface_fail_label);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		mini_emit_isinst_iface (s, tmp_reg, klass, interface_fail_label, true_label);
		
		mono_bblock_add_inst (s->cbb, interface_fail_label);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));
		
		if (s->compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BNE_UN, klass_reg, tproxy_reg, false_label);
		} else {
			MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, klass_reg,
				mono_defaults.transparent_proxy_class, false_label);
		}
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, tmp_reg, 0, false2_label);
		
	} else {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));
		
		MONO_NEW_LABEL (s, no_proxy_label);
		
		if (s->compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BNE_UN, klass_reg, tproxy_reg, no_proxy_label);
		} else {
			MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, klass_reg,
				mono_defaults.transparent_proxy_class, no_proxy_label);
		}
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, remote_class));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoRemoteClass, proxy_class));
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, tmp_reg, 0, no_proxy_label);
		
		mini_emit_isinst (s, klass_reg, klass, false2_label, true_label);
		MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, false2_label);
		
		mono_bblock_add_inst (s->cbb, no_proxy_label);
		mini_emit_isinst (s, klass_reg, klass, false_label, true_label);
	}

	mono_bblock_add_inst (s->cbb, false_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 1);
	MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, end_label);
	mono_bblock_add_inst (s->cbb, false2_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 2);
	MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, end_label);
	mono_bblock_add_inst (s->cbb, true_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 0);
	mono_bblock_add_inst (s->cbb, end_label);
}

reg: OP_UNBOXCAST (reg) {
     	MonoClass *klass = tree->inst_newa_class;
	int obj_reg = state->left->reg1;
	int vtable_reg = mono_regstate_next_int (s->rs);
	int klass_reg = mono_regstate_next_int (s->rs);
	int eclass_reg = mono_regstate_next_int (s->rs);
	int rank_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, rank_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, rank));

	/* FIXME: generics */
	g_assert (klass->rank == 0);

	// Check rank == 0
	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, rank_reg, 0, "InvalidCastException");

	MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
	MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, element_class));

	if (s->compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass->element_class);
		MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, "InvalidCastException");
	} else {
		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, klass->element_class, "InvalidCastException");
	}
	
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
}

reg: OP_UNBOXCAST_REG (reg, reg) {
	int obj_reg = state->left->reg1;
     	int element_klass_reg = state->right->reg1;
	int vtable_reg = mono_regstate_next_int (s->rs);
	int klass_reg = mono_regstate_next_int (s->rs);
	int eclass_reg = mono_regstate_next_int (s->rs);
	int rank_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, rank_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, rank));

	// Check rank == 0
	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, rank_reg, 0, "InvalidCastException");

	MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
	MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, element_class));

	MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, element_klass_reg, "InvalidCastException");

	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
}

reg: CEE_CASTCLASS (reg) {
     	MonoClass *klass = tree->inst_newa_class;
	MonoInst *object_is_null;
	int obj_reg = state->left->reg1;
	int vtable_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, object_is_null);

	MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, obj_reg, 0, object_is_null);

	if (tree->backend.record_cast_details) {
		int to_klass_reg = mono_regstate_next_int (s->rs);
		int klass_reg = mono_regstate_next_int (s->rs);
		MonoInst *tls_get = mono_get_jit_tls_intrinsic (s);

		if (!tls_get) {
			fprintf (stderr, "error: --debug=casts not supported on this platform.\n.");
			exit (1);
		}

		MONO_ADD_INS (s->cbb, tls_get);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));

		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, tls_get->dreg, G_STRUCT_OFFSET (MonoJitTlsData, class_cast_from), klass_reg);
		MONO_EMIT_NEW_PCONST (s, to_klass_reg, klass);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, tls_get->dreg, G_STRUCT_OFFSET (MonoJitTlsData, class_cast_to), to_klass_reg);
	}

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		mini_emit_castclass_iface (s, vtable_reg, klass);
	} else {
		int klass_reg = mono_regstate_next_int (s->rs);

		MONO_EMIT_NEW_LOAD_MEMBASE (s, vtable_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));

		if (!klass->rank && !s->compile_aot && !(s->opt & MONO_OPT_SHARED) && (klass->flags & TYPE_ATTRIBUTE_SEALED)) {
			/* the remoting code is broken, access the class for now */
			if (0) {
				MonoVTable *vt = mono_class_vtable (s->domain, klass);
				MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, vtable_reg, vt, "InvalidCastException");
			} else {
				MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
				MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, klass_reg, klass, "InvalidCastException");
			}
		} else {
			MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
			mini_emit_castclass (s, obj_reg, klass_reg, klass, object_is_null);
		}
	}

	mono_bblock_add_inst (s->cbb, object_is_null);

	/* Reset the variables holding the cast details */
	if (tree->backend.record_cast_details) {
		MonoInst *tls_get = mono_get_jit_tls_intrinsic (s);

		MONO_ADD_INS (s->cbb, tls_get);
		/* It is enough to reset the from field */
		MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STORE_MEMBASE_IMM, tls_get->dreg, G_STRUCT_OFFSET (MonoJitTlsData, class_cast_from), 0);
	}

	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
}

reg: OP_CCASTCLASS (reg) {
	/* This opcode takes as input an object reference and a class, and returns:
	0) if the object is an instance of the class,
	1) if the object is a proxy whose type cannot be determined
	an InvalidCastException exception is thrown otherwhise*/
	
	MonoClass *klass = tree->inst_newa_class;
	MonoInst *end_label, *fail_label, *no_proxy_label, *ok_result_label;
	int obj_reg = state->left->reg1;
	int tmp_reg = mono_regstate_next_int (s->rs);
	int klass_reg = mono_regstate_next_int (s->rs);

	MONO_NEW_LABEL (s, end_label);
	MONO_NEW_LABEL (s, ok_result_label);

	/* Return 0 if the object is null */
	MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, obj_reg, 0, ok_result_label);

	if (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
	
		MONO_NEW_LABEL (s, fail_label);
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		mini_emit_isinst_iface (s, tmp_reg, klass, fail_label, ok_result_label);
		
		mono_bblock_add_inst (s->cbb, fail_label);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));

		if (s->compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, klass_reg, tproxy_reg, "InvalidCastException");
		} else {
			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, klass_reg, mono_defaults.transparent_proxy_class, "InvalidCastException");
		}
		
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, remote_class));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoRemoteClass, proxy_class));
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, EQ, tmp_reg, 0, "InvalidCastException");
		
		MONO_EMIT_NEW_ICONST (s, state->reg1, 1);
		MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, end_label);
		
	} else {

		MONO_NEW_LABEL (s, no_proxy_label);
		MONO_NEW_LABEL (s, fail_label);
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoObject, vtable));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoVTable, klass));

		if (s->compile_aot) {
			int tproxy_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
			MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BNE_UN, klass_reg, tproxy_reg, no_proxy_label);
		} else {
			MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, klass_reg,
				mono_defaults.transparent_proxy_class, no_proxy_label);
		}
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, remote_class));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoRemoteClass, proxy_class));
		
		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
		MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, tmp_reg, 0, no_proxy_label);
		
		mini_emit_isinst (s, klass_reg, klass, fail_label, ok_result_label);
		mono_bblock_add_inst (s->cbb, fail_label);
		MONO_EMIT_NEW_ICONST (s, state->reg1, 1);
		MONO_EMIT_NEW_BRANCH_LABEL (s, OP_BR, end_label);
		
		mono_bblock_add_inst (s->cbb, no_proxy_label);
		/* Again, use ok_result_label as "object_is_null" */
		mini_emit_castclass (s, obj_reg, klass_reg, klass, ok_result_label);
	}

	mono_bblock_add_inst (s->cbb, ok_result_label);
	MONO_EMIT_NEW_ICONST (s, state->reg1, 0);
	mono_bblock_add_inst (s->cbb, end_label);
}

stmt: CEE_STELEM_REF (OP_GROUP (reg, reg), reg),
reg: OP_GROUP (reg, reg),
reg: CEE_NEWARR (reg),
lreg: OP_LMUL (lreg, lreg),
lreg: OP_LMUL_OVF (lreg, lreg),
lreg: OP_LMUL_OVF_UN (lreg, lreg),
lreg: OP_LDIV (lreg, lreg),
lreg: OP_LDIV_UN (lreg, lreg),
lreg: OP_LREM (lreg, lreg),
lreg: OP_LREM_UN (lreg, lreg),
lreg: OP_LSHL (lreg, reg),
lreg: OP_LSHR (lreg, reg),
lreg: OP_LSHR_UN (lreg, reg) {
	g_assert_not_reached ();
}

#
# string support
#
reg: OP_GETCHR (reg, reg) "4" {
	int index_reg;
	int mult_reg = mono_regstate_next_int (s->rs);
	int add_reg = mono_regstate_next_int (s->rs);
	
	if (sizeof (gpointer) == 8) {
		/* The array reg is 64 bits but the index reg is only 32 */
		index_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_UNALU (s, OP_SEXT_I4, index_reg, state->right->reg1);
	} else {
		index_reg = state->right->reg1;
	}

	MONO_EMIT_BOUNDS_CHECK (s, state->left->reg1, MonoString, length, index_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, mult_reg, index_reg, 1);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult_reg, state->left->reg1);
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU2_MEMBASE, state->reg1, 
				   add_reg, G_STRUCT_OFFSET (MonoString, chars));
}

reg: OP_GETCHR (reg, OP_ICONST) {
	int ind = 2 * state->right->tree->inst_c0 + G_STRUCT_OFFSET (MonoString, chars);

	MONO_EMIT_BOUNDS_CHECK_IMM (s, state->left->reg1, MonoString, length, state->right->tree->inst_c0);
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU2_MEMBASE, state->reg1, state->left->reg1, ind);
}

reg: OP_STR_CHAR_ADDR (reg, reg) "4" {
	int mult_reg = mono_regstate_next_int (s->rs);
	int add_reg = mono_regstate_next_int (s->rs);

	/*
	 * The corlib functions check for oob already.
	 * MONO_EMIT_BOUNDS_CHECK (s, state->left->reg1, MonoString, length, state->right->reg1);
	 */
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, mult_reg, state->right->reg1, 1);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult_reg, state->left->reg1);
	MONO_EMIT_BIALU_IMM (s, tree, OP_ADD_IMM, state->reg1, add_reg, G_STRUCT_OFFSET (MonoString, chars));
}

reg: OP_STRLEN (reg) {	
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
				   state->left->reg1, G_STRUCT_OFFSET (MonoString, length));
}

reg: OP_GETTYPE (reg) {	
	int vt_reg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, vt_reg, state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOAD_MEMBASE, state->reg1, vt_reg, G_STRUCT_OFFSET (MonoVTable, type));
}

reg: OP_GETHASHCODE (reg) {
	int t1 = mono_regstate_next_int (s->rs);
	
	#define MONO_OBJECT_ALIGNMENT_SHIFT	3

	/* return (GPOINTER_TO_UINT (this) >> MONO_OBJECT_ALIGNMENT_SHIFT) * 2654435761u; */
	
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SHL_IMM, t1, state->left->reg1, MONO_OBJECT_ALIGNMENT_SHIFT);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_MUL_IMM, state->reg1, t1, 2654435761u);
}

#
# array support
#
reg: CEE_LDLEN (reg) {	
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
				   state->left->reg1, G_STRUCT_OFFSET (MonoArray, max_length));
}

reg: OP_ARRAY_RANK (reg) {	
	int vtable_reg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, vtable_reg, 
				       state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, state->reg1, 
				       vtable_reg, G_STRUCT_OFFSET (MonoVTable, rank));
}

reg: OP_CHECK_ARRAY_TYPE (reg) {

	MonoClass* array_class = tree->klass;
	
	int vtable_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, vtable_reg, 
				       state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
				       
	if (s->opt & MONO_OPT_SHARED) {
		int class_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, class_reg, 
					       vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
		if (s->compile_aot) {
			int klass_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, klass_reg, array_class);
			MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, class_reg, klass_reg, "ArrayTypeMismatchException");
		} else {
			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, class_reg, array_class, "ArrayTypeMismatchException");
		}
	} else {
		if (s->compile_aot) {
			int vt_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_VTABLECONST (s, vt_reg, mono_class_vtable (s->domain, array_class));
			MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, vtable_reg, vt_reg, "ArrayTypeMismatchException");
		} else {
			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, vtable_reg, mono_class_vtable (s->domain, array_class), "ArrayTypeMismatchException");
		}
	}
	
	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
}

reg: CEE_LDELEMA (reg, OP_ICONST) "15" {
	guint32 size = mono_class_array_element_size (tree->klass);

	int ind = size * state->right->tree->inst_c0 + G_STRUCT_OFFSET (MonoArray, vector);

	MONO_EMIT_BOUNDS_CHECK_IMM (s, state->left->reg1, MonoArray, max_length, state->right->tree->inst_c0);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, state->left->reg1, ind);
}

reg: CEE_LDELEMA (reg, reg) "20" {
	int index_reg;
	int mult_reg = mono_regstate_next_int (s->rs);
	int add_reg = mono_regstate_next_int (s->rs);
	guint32 size = mono_class_array_element_size (tree->klass);

	if (sizeof (gpointer) == 8) {
		/* The array reg is 64 bits but the index reg is only 32 */
		index_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_UNALU (s, OP_SEXT_I4, index_reg, state->right->reg1);
	} else {
		index_reg = state->right->reg1;
	}

	MONO_EMIT_BOUNDS_CHECK (s, state->left->reg1, MonoArray, max_length, index_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_MUL_IMM, mult_reg, index_reg, size);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult_reg, state->left->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, add_reg, G_STRUCT_OFFSET (MonoArray, vector));
}

reg: CEE_REFANYVAL (reg) {
	int klass_reg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass));
	if (s->compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, tree->inst_newa_class);
		MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, klass_reg, const_reg, "InvalidCastException");
	} else {
		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, klass_reg, tree->inst_newa_class, "InvalidCastException");
	}
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, value));
}	

reg: OP_REFANYVAL_REG (reg, reg) {
	int klass_reg = mono_regstate_next_int (s->rs);
	g_assert (!s->compile_aot);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass));
	MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, klass_reg, state->right->reg1, "InvalidCastException");
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, value));
}	

reg: OP_REFANYTYPE (reg) {
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, type));
}	

stmt: CEE_MKREFANY (OP_GROUP (reg, OP_ICONST), reg),
stmt: CEE_MKREFANY (OP_GROUP (reg, OP_I8CONST), reg) {
	MonoClass *klass = (MonoClass*)(tree->inst_left->inst_right->inst_p0);
	if (s->compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		int type_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass), const_reg);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, type_reg, const_reg, G_STRUCT_OFFSET (MonoClass, byval_arg));
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, type), type_reg);
	}
	else {
		MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STOREP_MEMBASE_IMM, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, type), &klass->byval_arg);
		MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STOREP_MEMBASE_IMM, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass), klass);
	}
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG, state->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, value), state->left->left->reg1);
}

stmt: OP_MKREFANY_REGS (OP_GROUP (reg, reg), OP_GROUP (reg, reg)) {
	int class_reg = state->left->right->reg1;
	g_assert (!s->compile_aot);
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG,
			state->right->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, type), state->left->left->reg1);
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG,
			state->right->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, klass), state->left->right->reg1);
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREP_MEMBASE_REG,
			state->right->right->reg1, G_STRUCT_OFFSET (MonoTypedRef, value), state->right->left->reg1);
}

reg: OP_MIN (reg, reg) "2" {
	/* min (x,y) = y + (((x-y)>>31)&(x-y)); */
	int diff = mono_regstate_next_int (s->rs);
	int shifted = mono_regstate_next_int (s->rs);
	int anded = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU (s, CEE_SUB, diff, state->left->reg1, state->right->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SHR_IMM, shifted, diff, (sizeof(void*)*8-1));
	MONO_EMIT_NEW_BIALU (s, CEE_AND, anded, shifted, diff);
	MONO_EMIT_NEW_BIALU (s, CEE_ADD, state->reg1, anded, state->right->reg1);
}

reg: OP_MAX (reg, reg) "2" {
	/* max (x,y) = x - (((x-y)>>31)&(x-y)); */
	int diff = mono_regstate_next_int (s->rs);
	int shifted = mono_regstate_next_int (s->rs);
	int anded = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU (s, CEE_SUB, diff, state->left->reg1, state->right->reg1);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SHR_IMM, shifted, diff, (sizeof(void*)*8-1));
	MONO_EMIT_NEW_BIALU (s, CEE_AND, anded, shifted, diff);
	MONO_EMIT_NEW_BIALU (s, CEE_SUB, state->reg1, state->left->reg1, anded);
}

%%

#ifdef MONO_ARCH_NEED_GOT_VAR

static void mini_emit_aotconst (MonoCompile *cfg, int dreg, MonoJumpInfoType patch_type, gpointer cons);

#endif

/* 
 * Emit code which checks whenever the interface id of @klass is smaller than
 * than the value given by max_iid_reg.
*/
static void
mini_emit_max_iid_check (MonoCompile *s, int max_iid_reg, MonoClass *klass,
						 MonoInst *false_target)
{
	if (s->compile_aot) {
		int iid_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_AOTCONST (s, iid_reg, klass, MONO_PATCH_INFO_IID);
		if (false_target)
			MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BLT_UN, max_iid_reg, iid_reg, false_target);
		else
			MONO_EMIT_NEW_COMPARE_EXC (s, LT_UN, max_iid_reg, iid_reg, "InvalidCastException");
	} else {
		if (false_target)
			MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BLT_UN, max_iid_reg, klass->interface_id, false_target);
		else
			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT_UN, max_iid_reg, klass->interface_id, "InvalidCastException");
	}
}

/* Same as above, but obtains max_iid from a vtable */
static void
mini_emit_max_iid_check_vtable (MonoCompile *s, int vtable_reg, MonoClass *klass,
								 MonoInst *false_target)
{
	int max_iid_reg = mono_regstate_next_int (s->rs);
		
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU2_MEMBASE, max_iid_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, max_interface_id));
	mini_emit_max_iid_check (s, max_iid_reg, klass, false_target);
}

/* Same as above, but obtains max_iid from a klass */
static void
mini_emit_max_iid_check_class (MonoCompile *s, int klass_reg, MonoClass *klass,
								 MonoInst *false_target)
{
	int max_iid_reg = mono_regstate_next_int (s->rs);

 	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU2_MEMBASE, max_iid_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, max_interface_id));		
	mini_emit_max_iid_check (s, max_iid_reg, klass, false_target);
}

/* Emit code which loads interface_offsets [klass->interface_id]
 * The array is stored in memory before vtable.
 */
#ifndef MONO_ARCH_HAVE_IMT
static void
mini_emit_load_intf_reg_vtable (MonoCompile *s, int intf_reg, int vtable_reg, MonoClass *klass)
{
	if (s->compile_aot) {
		int ioffset_reg = mono_regstate_next_int (s->rs);
		int iid_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_AOTCONST (s, iid_reg, klass, MONO_PATCH_INFO_ADJUSTED_IID);
		MONO_EMIT_NEW_BIALU (s, OP_PADD, ioffset_reg, iid_reg, vtable_reg);
		MONO_EMIT_NEW_LOAD_MEMBASE (s, intf_reg, ioffset_reg, 0);
	} else {
		MONO_EMIT_NEW_LOAD_MEMBASE (s, intf_reg, vtable_reg, -((klass->interface_id + 1) * SIZEOF_VOID_P));
	}
}
#endif

/* 
 * Emit code which loads into "intf_bit_reg" a nonzero value if the MonoClass
 * stored in "klass_reg" implements the interface "klass".
 */
static void
mini_emit_load_intf_bit_reg_class (MonoCompile *s, int intf_bit_reg, int klass_reg, MonoClass *klass)
{
	int ibitmap_reg = mono_regstate_next_int (s->rs);
	int ibitmap_byte_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE (s, ibitmap_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, interface_bitmap));

	if (s->compile_aot) {
		int iid_reg = mono_regstate_next_int (s->rs);
		int shifted_iid_reg = mono_regstate_next_int (s->rs);
		int ibitmap_byte_address_reg = mono_regstate_next_int (s->rs);
		int masked_iid_reg = mono_regstate_next_int (s->rs);
		int iid_one_bit_reg = mono_regstate_next_int (s->rs);
		int iid_bit_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_AOTCONST (s, iid_reg, klass, MONO_PATCH_INFO_IID);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHR_IMM, shifted_iid_reg, iid_reg, 3);
		MONO_EMIT_NEW_BIALU (s, CEE_ADD, ibitmap_byte_address_reg, ibitmap_reg, shifted_iid_reg);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, ibitmap_byte_reg, ibitmap_byte_address_reg, 0);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_AND_IMM, masked_iid_reg, iid_reg, 7);
		MONO_EMIT_NEW_ICONST (s, iid_one_bit_reg, 1);
		MONO_EMIT_NEW_BIALU (s, CEE_SHL, iid_bit_reg, iid_one_bit_reg, masked_iid_reg);
		MONO_EMIT_NEW_BIALU (s, CEE_AND, intf_bit_reg, ibitmap_byte_reg, iid_bit_reg);
	} else {
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI1_MEMBASE, ibitmap_byte_reg, ibitmap_reg, klass->interface_id >> 3);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_AND_IMM, intf_bit_reg, ibitmap_byte_reg, 1 << (klass->interface_id & 7));
	}
}
/* 
 * Emit code which loads into "intf_bit_reg" a nonzero value if the MonoVTable
 * stored in "vtable_reg" implements the interface "klass".
 */
static void
mini_emit_load_intf_bit_reg_vtable (MonoCompile *s, int intf_bit_reg, int vtable_reg, MonoClass *klass)
{
	int ibitmap_reg = mono_regstate_next_int (s->rs);
	int ibitmap_byte_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_LOAD_MEMBASE (s, ibitmap_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, interface_bitmap));

	if (s->compile_aot) {
		int iid_reg = mono_regstate_next_int (s->rs);
		int shifted_iid_reg = mono_regstate_next_int (s->rs);
		int ibitmap_byte_address_reg = mono_regstate_next_int (s->rs);
		int masked_iid_reg = mono_regstate_next_int (s->rs);
		int iid_one_bit_reg = mono_regstate_next_int (s->rs);
		int iid_bit_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_AOTCONST (s, iid_reg, klass, MONO_PATCH_INFO_IID);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SHR_IMM, shifted_iid_reg, iid_reg, 3);
		MONO_EMIT_NEW_BIALU (s, CEE_ADD, ibitmap_byte_address_reg, ibitmap_reg, shifted_iid_reg);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, ibitmap_byte_reg, ibitmap_byte_address_reg, 0);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_AND_IMM, masked_iid_reg, iid_reg, 7);
		MONO_EMIT_NEW_ICONST (s, iid_one_bit_reg, 1);
		MONO_EMIT_NEW_BIALU (s, CEE_SHL, iid_bit_reg, iid_one_bit_reg, masked_iid_reg);
		MONO_EMIT_NEW_BIALU (s, CEE_AND, intf_bit_reg, ibitmap_byte_reg, iid_bit_reg);
	} else {
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI1_MEMBASE, ibitmap_byte_reg, ibitmap_reg, klass->interface_id >> 3);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_AND_IMM, intf_bit_reg, ibitmap_byte_reg, 1 << (klass->interface_id & 7));
	}
}

#ifdef MONO_ARCH_HAVE_IMT
static void
emit_imt_argument (MonoCompile *cfg, MonoCallInst *call) {
#ifdef MONO_ARCH_IMT_REG
	int method_reg = mono_regstate_next_int (cfg->rs);

	if (cfg->compile_aot) {
		MONO_EMIT_NEW_AOTCONST (cfg, method_reg, call->method, MONO_PATCH_INFO_METHODCONST);
	} else {
		MonoInst *inst;
		MONO_INST_NEW (cfg, inst, OP_PCONST);
		inst->inst_p0 = call->method;
		inst->dreg = method_reg;
		mono_bblock_add_inst (cfg->cbb, inst);
	}

	mono_call_inst_add_outarg_reg (cfg, call, method_reg, MONO_ARCH_IMT_REG, FALSE);
#else
	mono_arch_emit_imt_argument (cfg, call);
#endif
}
#endif

static void 
mini_emit_virtual_call (MonoCompile *cfg, void *st, MonoInst *tree, int novirtop, int virtop)
{
	MonoMethod *method = ((MonoCallInst*)tree)->method;
	int vtable_reg, slot_reg, this_reg;
	MBState *state = st;
	int slot;

	this_reg = state->left->reg1;
	mono_arch_emit_this_vret_args (cfg, (MonoCallInst*)tree, this_reg, state->left->tree->type, novirtop == OP_VCALL? state->right->reg1: -1);

	if (!(method->flags & METHOD_ATTRIBUTE_VIRTUAL) || 
	     ((method->flags & METHOD_ATTRIBUTE_FINAL) && 
	     method->wrapper_type != MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK)) {
		/* 
		 * the method is not virtual, we just need to ensure this is not null
		 * and then we can call the method directly.
		 */
		if (method->klass->marshalbyref || method->klass == mono_defaults.object_class) {
			method = ((MonoCallInst*)tree)->method = mono_marshal_get_remoting_invoke_with_check (method);
		}

		if (!method->string_ctor)
			MONO_EMIT_NEW_UNALU (cfg, OP_CHECK_THIS, -1, this_reg);

		tree->dreg = state->reg1;
		tree->opcode = novirtop;
		mono_bblock_add_inst (cfg->cbb, tree);
		return;
	}

#ifdef MONO_ARCH_HAVE_CREATE_DELEGATE_TRAMPOLINE
	if ((method->klass->parent == mono_defaults.multicastdelegate_class) && (!strcmp (method->name, "Invoke"))) {
		/* Make a call to delegate->invoke_impl */
		tree->dreg = state->reg1;
		tree->opcode = virtop;
		tree->inst_basereg = this_reg;
		tree->inst_offset = G_STRUCT_OFFSET (MonoDelegate, invoke_impl);
		mono_bblock_add_inst (cfg->cbb, tree);
		return;
	}
#endif
	
	if ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) &&
		((method->flags &  METHOD_ATTRIBUTE_FINAL) ||
			(method->klass && method->klass->flags & TYPE_ATTRIBUTE_SEALED))) {
		/*
		 * the method is virtual, but we can statically dispatch since either
		 * it's class or the method itself are sealed.
		 * But first we need to ensure it's not a null reference.
		 */
		MONO_EMIT_NEW_UNALU (cfg, OP_CHECK_THIS, -1, this_reg);

		tree->dreg = state->reg1;
		tree->opcode = novirtop;
		mono_bblock_add_inst (cfg->cbb, tree);
		return;
	}

	if (method->klass->generic_class && !method->klass->vtable) {
	   MonoMethod *gmethod = mono_method_get_declaring_generic_method (method);
	   mono_class_setup_vtable (gmethod->klass);

	   slot = gmethod->slot;
	   g_assert (slot != -1);
	} else {
		/* Initialize method->slot */
		mono_class_setup_vtable (method->klass);
		slot = method->slot;
	}

	vtable_reg = mono_regstate_next_int (cfg->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE (cfg, vtable_reg, this_reg, G_STRUCT_OFFSET (MonoObject, vtable));
	if (method->klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
#ifdef MONO_ARCH_HAVE_IMT
		guint32 imt_slot = mono_method_get_imt_slot (method);
		emit_imt_argument (cfg, (MonoCallInst*)tree);
		slot_reg = vtable_reg;
		tree->inst_offset = ((gint32)imt_slot - MONO_IMT_SIZE) * SIZEOF_VOID_P;
#else
		slot_reg = mono_regstate_next_int (cfg->rs);
		mini_emit_load_intf_reg_vtable (cfg, slot_reg, vtable_reg, method->klass);
		tree->inst_offset = slot * SIZEOF_VOID_P;
#endif
	} else {
		slot_reg = vtable_reg;
		tree->inst_offset = G_STRUCT_OFFSET (MonoVTable, vtable) + (slot * SIZEOF_VOID_P);
	}
	
	tree->dreg = state->reg1;
	tree->opcode = virtop;
	tree->sreg1 = slot_reg;
	((MonoCallInst*)tree)->virtual = TRUE;
	mono_bblock_add_inst (cfg->cbb, tree);
}

static void
emit_rgctx_argument (MonoCompile *s, MonoInst *tree, int reg, int new_opcode)
{
#ifdef MONO_ARCH_RGCTX_REG
	MonoCallInst *call = (MonoCallInst*)tree;
	int rgctx_reg = mono_regstate_next_int (s->rs);

	MONO_EMIT_NEW_UNALU (s, OP_MOVE, rgctx_reg, reg);

	call->inst.opcode = new_opcode;

	mono_call_inst_add_outarg_reg (s, call, rgctx_reg, MONO_ARCH_RGCTX_REG, FALSE);
#else
	g_assert_not_reached ();
#endif
}

/*
 * Emit code for ISINST/CASTCLASS
 */
static void
mini_emit_isinst (MonoCompile *s, int klass_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target)
{
	int idepth_reg = mono_regstate_next_int (s->rs);
	int stypes_reg = mono_regstate_next_int (s->rs);
	int stype = mono_regstate_next_int (s->rs);

	if (klass->idepth > MONO_DEFAULT_SUPERTABLE_SIZE) {
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU2_MEMBASE, idepth_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, idepth));
		MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BLT_UN, idepth_reg, klass->idepth, false_target);
	}
	MONO_EMIT_NEW_LOAD_MEMBASE (s, stypes_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, supertypes));
	MONO_EMIT_NEW_LOAD_MEMBASE (s, stype, stypes_reg, ((klass->idepth - 1) * SIZEOF_VOID_P));
	if (s->compile_aot) {
		int const_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass);
		MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BEQ, stype, const_reg, true_target);
	} else {
		MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, stype, klass, true_target);
	}
}

/*
 * Emit code for ISINST/CASTCLASS for interfaces
 */
static void
mini_emit_isinst_iface (MonoCompile *s, int vtable_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target)
{
	int intf_reg = mono_regstate_next_int (s->rs);

	mini_emit_max_iid_check_vtable (s, vtable_reg, klass, false_target);
	mini_emit_load_intf_bit_reg_vtable (s, intf_reg, vtable_reg, klass);
	if (true_target)
		MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, intf_reg, 0, true_target);
	else
		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, EQ, intf_reg, 0, "InvalidCastException");
}

/*
 * Variant of the above that takes a register to the class, not the vtable.
 */
static void
mini_emit_isinst_iface_class (MonoCompile *s, int klass_reg, MonoClass *klass, MonoInst *false_target, MonoInst *true_target)
{
	int intf_bit_reg = mono_regstate_next_int (s->rs);

	mini_emit_max_iid_check_class (s, klass_reg, klass, false_target);
	mini_emit_load_intf_bit_reg_class (s, intf_bit_reg, klass_reg, klass);
	if (true_target)
		MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, intf_bit_reg, 0, true_target);
	else
		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, EQ, intf_bit_reg, 0, "InvalidCastException");
}

static void
mini_emit_castclass_iface (MonoCompile *s, int vtable_reg, MonoClass *klass)
{
	mini_emit_isinst_iface (s, vtable_reg, klass, NULL, NULL);
}

/*
 * Variant of the aboce that takes a register to the class, not the vtable.
 */
static void
mini_emit_castclass_iface_class (MonoCompile *s, int klass_reg, MonoClass *klass)
{
	mini_emit_isinst_iface_class (s, klass_reg, klass, NULL, NULL);
}

static void
mini_emit_castclass (MonoCompile *s, int obj_reg, int klass_reg, MonoClass *klass, MonoInst *object_is_null)
{
	if (klass->rank) {
		int rank_reg = mono_regstate_next_int (s->rs);
		int eclass_reg = mono_regstate_next_int (s->rs);

		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, rank_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, rank));
		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, rank_reg, klass->rank, "InvalidCastException");
//		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, cast_class));
		if (klass->cast_class == mono_defaults.object_class) {
			int parent_reg = mono_regstate_next_int (s->rs);
			int const_reg = -1;
			MONO_EMIT_NEW_LOAD_MEMBASE (s, parent_reg, eclass_reg, G_STRUCT_OFFSET (MonoClass, parent));
			if (s->compile_aot) {
				const_reg = mono_regstate_next_int (s->rs);
				MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
				MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BNE_UN, parent_reg, const_reg, object_is_null);
			} else {
				MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BNE_UN, parent_reg,
					mono_defaults.enum_class->parent, object_is_null);
			}
			if (s->compile_aot) {
				MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
				MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, "InvalidCastException");
			} else {
				MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, mono_defaults.enum_class, "InvalidCastException");
			}
		} else if (klass->cast_class == mono_defaults.enum_class->parent) {
			int const_reg = mono_regstate_next_int (s->rs);
			if (s->compile_aot) {
				MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class->parent);
				MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BEQ, eclass_reg, const_reg, object_is_null);
			} else {
				MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BEQ, eclass_reg,
					mono_defaults.enum_class->parent, object_is_null);
			}
			if (s->compile_aot) {
				MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
				MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, "InvalidCastException");
			} else {
				MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, mono_defaults.enum_class, "InvalidCastException");
			}
		} else if (klass->cast_class == mono_defaults.enum_class) {
			if (s->compile_aot) {
				int const_reg = mono_regstate_next_int (s->rs);
				MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
				MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, "InvalidCastException");
			} else {
				MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, mono_defaults.enum_class, "InvalidCastException");
			}
		} else if (klass->cast_class->flags & TYPE_ATTRIBUTE_INTERFACE) {
			mini_emit_castclass_iface_class (s, eclass_reg, klass->cast_class);
		} else {
			mini_emit_castclass (s, obj_reg, eclass_reg, klass->cast_class, object_is_null);
		}

		if ((klass->rank == 1) && (klass->byval_arg.type == MONO_TYPE_SZARRAY)) {
			/* Check that the object is a vector too */
			int bounds_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_LOAD_MEMBASE (s, bounds_reg, obj_reg, G_STRUCT_OFFSET (MonoArray, bounds));
			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, bounds_reg, 0, "InvalidCastException");
		}
	} else {
		int idepth_reg = mono_regstate_next_int (s->rs);
		int stypes_reg = mono_regstate_next_int (s->rs);
		int stype = mono_regstate_next_int (s->rs);

		if (klass->idepth > MONO_DEFAULT_SUPERTABLE_SIZE) {
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU2_MEMBASE, idepth_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, idepth));
			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT_UN, idepth_reg, klass->idepth, "InvalidCastException");
		}
		MONO_EMIT_NEW_LOAD_MEMBASE (s, stypes_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, supertypes));
		MONO_EMIT_NEW_LOAD_MEMBASE (s, stype, stypes_reg, ((klass->idepth - 1) * SIZEOF_VOID_P));
		if (s->compile_aot) {
			int const_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass);
			MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, stype, const_reg, "InvalidCastException");
		} else {
			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, stype, klass, "InvalidCastException");
		}
	}
}

static void
mini_emit_memcpy (MonoCompile *s, int destreg, int doffset, int srcreg, int soffset, int size, int align)
{
	int cur_reg;

	if (align < 4) {
		/* This could be optimized further if neccesary */
		while (size >= 1) {
			cur_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI1_MEMBASE, cur_reg, srcreg, soffset);
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI1_MEMBASE_REG, destreg, doffset, cur_reg);
			doffset += 1;
			soffset += 1;
			size -= 1;
		}
	}

	/* FIXME: consider alignment for archs that need it. */
#if !NO_UNALIGNED_ACCESS
	if (sizeof (gpointer) == 8) {
		while (size >= 8) {
			cur_reg = mono_regstate_next_int (s->rs);
			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI8_MEMBASE, cur_reg, srcreg, soffset);
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI8_MEMBASE_REG, destreg, doffset, cur_reg);
			doffset += 8;
			soffset += 8;
			size -= 8;
		}
	}	
#endif

	while (size >= 4) {
		cur_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, cur_reg, srcreg, soffset);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI4_MEMBASE_REG, destreg, doffset, cur_reg);
		doffset += 4;
		soffset += 4;
		size -= 4;
	}
	while (size >= 2) {
		cur_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI2_MEMBASE, cur_reg, srcreg, soffset);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI2_MEMBASE_REG, destreg, doffset, cur_reg);
		doffset += 2;
		soffset += 2;
		size -= 2;
	}
	while (size >= 1) {
		cur_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI1_MEMBASE, cur_reg, srcreg, soffset);
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI1_MEMBASE_REG, destreg, doffset, cur_reg);
		doffset += 1;
		soffset += 1;
		size -= 1;
	}
}

static void
mini_emit_memset (MonoCompile *s, int destreg, int offset, int size, int val, int align)
{
	int val_reg = mono_regstate_next_int (s->rs);

	if (sizeof (gpointer) == 8)
		MONO_EMIT_NEW_I8CONST (s, val_reg, val);
	else
		MONO_EMIT_NEW_ICONST (s, val_reg, val);

	if (align < 4) {
		/* This could be optimized further if neccesary */
		while (size >= 1) {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI1_MEMBASE_REG, destreg, offset, val_reg);
			offset += 1;
			size -= 1;
		}
		return;
	}	

	/* FIXME: consider alignment for archs that need it. */
#if !NO_UNALIGNED_ACCESS
	if (sizeof (gpointer) == 8) {
		if (offset % 8) {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI4_MEMBASE_REG, destreg, offset, val_reg);
			offset += 4;
			size -= 4;
		}
		while (size >= 8) {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI8_MEMBASE_REG, destreg, offset, val_reg);
			offset += 8;
			size -= 8;
		}
	}	
#endif

	while (size >= 4) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI4_MEMBASE_REG, destreg, offset, val_reg);
		offset += 4;
		size -= 4;
	}
	while (size >= 2) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI2_MEMBASE_REG, destreg, offset, val_reg);
		offset += 2;
		size -= 2;
	}
	while (size >= 1) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI1_MEMBASE_REG, destreg, offset, val_reg);
		offset += 1;
		size -= 1;
	}
}

#ifdef MONO_ARCH_NEED_GOT_VAR

/* This is similar to NEW_AOTCONST in mini.c, but generates linear IL */
static void
mini_emit_aotconst (MonoCompile *cfg, int dreg, MonoJumpInfoType patch_type, gpointer cons)
{
	MonoInst *dest, *pinfo;
	int got_var_reg;

	g_assert (cfg->got_var);

	pinfo = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));
	pinfo->opcode = OP_PATCH_INFO;
	pinfo->inst_left = cons;
	pinfo->inst_right = (gpointer)(patch_type);

	if (cfg->got_var->opcode == OP_REGOFFSET) {
		got_var_reg = mono_regstate_next_int (cfg->rs);
		MONO_EMIT_NEW_LOAD_MEMBASE (cfg, got_var_reg, cfg->got_var->inst_basereg, cfg->got_var->inst_offset);
	} else {
		g_assert (cfg->got_var->opcode == OP_REGVAR);
		got_var_reg = cfg->got_var->dreg;
	}

	MONO_INST_NEW ((cfg), dest, OP_GOT_ENTRY);
	dest->inst_left = cfg->got_var; /* not used */
	dest->inst_right = pinfo;

	dest->inst_basereg = got_var_reg;
	dest->dreg = dreg;
	mono_bblock_add_inst (cfg->cbb, dest);
}

#endif

static int
ldind_to_load_membase (int opcode)
{
	switch (opcode) {
	case CEE_LDIND_I1:
		return OP_LOADI1_MEMBASE;
	case CEE_LDIND_U1:
		return OP_LOADU1_MEMBASE;
	case CEE_LDIND_I2:
		return OP_LOADI2_MEMBASE;
	case CEE_LDIND_U2:
		return OP_LOADU2_MEMBASE;
	case CEE_LDIND_I4:
		return OP_LOADI4_MEMBASE;
	case CEE_LDIND_U4:
		return OP_LOADU4_MEMBASE;
	case CEE_LDIND_I:
		return OP_LOAD_MEMBASE;
	case CEE_LDIND_REF:
		return OP_LOAD_MEMBASE;
	case CEE_LDIND_I8:
		return OP_LOADI8_MEMBASE;
	default:
		g_assert_not_reached ();
	}

	return -1;
}

