* MCS: The Ximian C# compiler

	MCS began as an experiment to learn the features of C# by
	writing a large C# program.  MCS is currently able to parse C#
	programs and create an internal tree representation of the
	program.  MCS can parse itself.  

	Work is progressing quickly on various fronts in the C#
	compiler.  Recently I started using the System.Reflection API
	to load system type definitions and avoid self-population of
	types in the compiler and dropped my internal Type
	representation in favor of using the CLI's System.Type.  

** Phases of the compiler

	The compiler has a number of phases:

	<ul>
		* Lexical analyzer: hand-coded lexical analyzer that
		  provides tokens to the parser.

		* The Parser: the parser is implemented using Jay (A
		  Berkeley Yacc port to Java, that I ported to C#).
		  The parser does minimal work and syntax checking,
		  and only constructs a parsed tree.

		  Each language element gets its own class.  The code
		  convention is to use an uppercase name for the
		  language element.  So a C# class and its associated
		  information is kept in a "Class" class, a "struct"
		  in a "Struct" class and so on.  Statements derive
		  from the "Statement" class, and Expressions from the
		  Expr class.

		* Parent class resolution: before the actual code
		  generation, we need to resolve the parents and
		  interfaces for interface, classe and struct
		  definitions.

		* Semantic analysis: since C# can not resolve in a
		  top-down pass what identifiers actually mean, we
		  have to postpone this decision until the above steps
		  are finished.

		* Code generation: nothing done so far, but I do not
		  expect this to be hard, as I will just use
		  System.Reflection.Emit to generate the code. 
	
	</ul>

<a name="tasks">
** Current pending tasks

	Simple tasks:

	<ul>
		* Array declarations are currently being ignored, 

		* PInvoke declarations are not supported.

		* Pre-processing is not supported.

		* Attribute declarations and passing currently ignored.

		* Compiler does not pass around line/col information from tokenizer for error reporting.

		* Jay does not work correctly with `error'
		  productions, making parser errors hard to point.  It
		  would be best to port the Bison-To-Java compiler to
		  become Bison-to-C# compiler (bjepson@oreilly.com
		  might have more information)
	</ul>

	Interesting and Fun hacks to the compiler:

	<ul>
		* Finishing the JB port from Java to C#.  If you are
		  interested in working on this, please contact Brian
		  Jepson (bjepson at oreilly d-o-t com).

		  More on JB at: <a href="http://www.cs.colorado.edu/~dennis/software/jb.html">
		  http://www.cs.colorado.edu/~dennis/software/jb.html</a>

		  JB will allow us to move from the Berkeley Yacc
		  based Jay to a Bison-based compiler (better error
		  reporting and recovery).

		* Semantic Analysis: Return path coverage and
		  initialization before use coverage are two great
		  features of C# that help reduce the number of bugs
		  in applications.  It is one interesting hack.

		* TypeRefManager.  This exists currently in its infancy only. 

		* Enum resolutions: it is another fun hack, as enums can be defined 
		  in terms of themselves (<tt>enum X { a = b + 1, b = 5 }</tt>). 

	</ul>

** Questions and Answers

Q: Why not write a C# front-end for GCC?

A: I wanted to learn about C#, and this was an exercise in this
   task.  The resulting compiler is highly object-oriented, which has
   lead to a very nice, easy to follow and simple implementation of
   the compiler.

   I found that the design of this compiler is very similar to
   Guavac's implementation.

   Targeting the CIL/MSIL byte codes would require to re-architecting
   GCC, as GCC is mostly designed to be used for register machines.
   
   The GCC Java engine that generates Java byte codes cheats: it does
   not use the GCC backend; it has a special backend just for Java, so
   you can not really generate Java bytecodes from the other languages
   supported by GCC. 

Q: If your C# compiler is written in C#, how do you plan on getting
   this working on a non-Microsoft environment.

   We will do this through an implementation of the CLI Virtual
   Execution System for Unix (our JIT engine). 

Q: Do you use Bison?

A: No, currently I am using Jay which is a port of Berkeley Yacc to
   Java that I later ported to C#.  This means that error recovery is
   not as nice as I would like to, and for some reason error
   productions are not being caught.  

   In the future I want to port one of the Bison/Java ports to C# for
   the parser.

Q: Should someone work on a GCC front-end to C#?

A: I would love if someone does, and we would love to help anyone that
   takes on that task, but we do not have the time or expertise to
   build a C# compiler with the GCC engine.  I find it a lot more fun
   personally to work on C# on a C# compiler, which has an intrinsic
   beauty.

   We can provide help and assistance to anyone who would like to work
   on this task.

Q: Should someone make a GCC backend that will generate CIL images?

A: I would love to see a backend to GCC that generates CIL images.  It
   would provide a ton of free compilers that would generate CIL
   code.  This is something that people would want to look into
   anyways for Windows interoperation in the future.

   Again, we would love to provide help and assistance to anyone
   interested in working in such a project.

Q: What about making a front-end to GCC that takes CIL images and
   generates native code?

A: I would love to see this, specially since GCC supports this same
   feature for Java Byte Codes.  You could use the metadata library
   from Mono to read the byte codes (ie, this would be your
   "front-end") and generate the trees that get passed to the
   optimizer.

   Ideally our implementation of the CLI will be available as a shared
   library that could be linked with your application as its runtime
   support. 

   Again, we would love to provide help and assistance to anyone
   interested in working in such a project.
   
Q: But would this work around the GPL in the GCC compiler and allow
   people to work on non-free front-ends?

A: People can already do this by targeting the JVM byte codes (there
   are about 130 compilers for various languages that target the JVM).

Q: Why are you writing a JIT engine instead of a front-end to GCC?

A: The JIT engine and runtime engine will be able to execute CIL
   executables generated on Windows.

You might also want to look at the <a href="faq.html#gcc">GCC</a>
section on the main FAQ
