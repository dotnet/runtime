//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once

//*****************************************************************************
//
// Notes on the ETW event code generated by MC:
//
// - Structures and arrays of structures are treated as an opaque binary blob.
//   The caller is responsible for packing the data for the structure into a
//   single region of memory, with no padding between values. The macro will
//   have an extra parameter for the length of the blob.
// - Arrays of nul-terminated strings must be packed by the caller into a
//   single binary blob containing the correct number of strings, with a nul
//   after each string. The size of the blob is specified in characters, and
//   includes the final nul.
// - Arrays of SID are treated as a single binary blob. The caller is
//   responsible for packing the SID values into a single region of memory with
//   no padding.
// - The length attribute on the data element in the manifest is significant
//   for values with intype win:UnicodeString, win:AnsiString, or win:Binary.
//   The length attribute must be specified for win:Binary, and is optional for
//   win:UnicodeString and win:AnsiString (if no length is given, the strings
//   are assumed to be nul-terminated). For win:UnicodeString, the length is
//   measured in characters, not bytes.
// - For an array of win:UnicodeString, win:AnsiString, or win:Binary, the
//   length attribute applies to every value in the array, so every value in
//   the array must have the same length. The values in the array are provided
//   to the macro via a single pointer -- the caller is responsible for packing
//   all of the values into a single region of memory with no padding between
//   values.
// - Values of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary can be generated and collected on Vista or later.
//   However, they may not decode properly without the Windows 10 2018 Fall
//   Update.
// - Arrays of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary must be packed by the caller into a single region of
//   memory. The format for each item is a UINT16 byte-count followed by that
//   many bytes of data. When providing the array to the generated macro, you
//   must provide the total size of the packed array data, including the UINT16
//   sizes for each item. In the case of win:CountedUnicodeString, the data
//   size is specified in WCHAR (16-bit) units. In the case of
//   win:CountedAnsiString and win:CountedBinary, the data size is specified in
//   bytes.
//
//*****************************************************************************

#include <stdint.h>
#include <stddef.h>


#include <windef.h>
#include <winnt.h>
#include <stdlib.h>
#include <wchar.h>
#include <objbase.h>
#include <float.h>
#include <math.h>
#include <time.h>
#include <limits.h>
#include <assert.h>

#include <olectl.h>

#include <wmistr.h>
#include <evntrace.h>
#include <evntprov.h>

#ifndef ETW_INLINE
  #ifdef _ETW_KM_
    // In kernel mode, save stack space by never inlining templates.
    #define ETW_INLINE DECLSPEC_NOINLINE __inline
  #else
    // In user mode, save code size by inlining templates as appropriate.
    #define ETW_INLINE __inline
  #endif
#endif // ETW_INLINE

#if defined(__cplusplus)
extern "C" {
#endif

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_USE_KERNEL_MODE_APIS macro:
// Controls whether the generated code uses kernel-mode or user-mode APIs.
// - Set to 0 to use Windows user-mode APIs such as EventRegister.
// - Set to 1 to use Windows kernel-mode APIs such as EtwRegister.
// Default is based on whether the _ETW_KM_ macro is defined (i.e. by wdm.h).
// Note that the APIs can also be overridden directly, e.g. by setting the
// MCGEN_EVENTWRITETRANSFER or MCGEN_EVENTREGISTER macros.
//
#ifndef MCGEN_USE_KERNEL_MODE_APIS
  #ifdef _ETW_KM_
    #define MCGEN_USE_KERNEL_MODE_APIS 1
  #else
    #define MCGEN_USE_KERNEL_MODE_APIS 0
  #endif
#endif // MCGEN_USE_KERNEL_MODE_APIS

//
// MCGEN_HAVE_EVENTSETINFORMATION macro:
// Controls how McGenEventSetInformation uses the EventSetInformation API.
// - Set to 0 to disable the use of EventSetInformation
//   (McGenEventSetInformation will always return an error).
// - Set to 1 to directly invoke MCGEN_EVENTSETINFORMATION.
// - Set to 2 to to locate EventSetInformation at runtime via GetProcAddress
//   (user-mode) or MmGetSystemRoutineAddress (kernel-mode).
// Default is determined as follows:
// - If MCGEN_EVENTSETINFORMATION has been customized, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else if the target OS version has EventSetInformation, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else set to 2 (i.e. try to dynamically locate EventSetInformation).
// Note that an McGenEventSetInformation function will only be generated if one
// or more provider in a manifest has provider traits.
//
#ifndef MCGEN_HAVE_EVENTSETINFORMATION
  #ifdef MCGEN_EVENTSETINFORMATION             // if MCGEN_EVENTSETINFORMATION has been customized,
    #define MCGEN_HAVE_EVENTSETINFORMATION   1 //   directly invoke MCGEN_EVENTSETINFORMATION(...).
  #elif MCGEN_USE_KERNEL_MODE_APIS             // else if using kernel-mode APIs,
    #if NTDDI_VERSION >= 0x06040000            //   if target OS is Windows 10 or later,
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EtwSetInformation" via MmGetSystemRoutineAddress.
    #endif                                     // else (using user-mode APIs)
  #else                                        //   if target OS and SDK is Windows 8 or later,
    #if WINVER >= 0x0602 && defined(EVENT_FILTER_TYPE_SCHEMATIZED)
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EventSetInformation" via GetModuleHandleExW/GetProcAddress.
    #endif
  #endif
#endif // MCGEN_HAVE_EVENTSETINFORMATION

//
// MCGEN Override Macros
//
// The following override macros may be defined before including this header
// to control the APIs used by this header:
//
// - MCGEN_EVENTREGISTER
// - MCGEN_EVENTUNREGISTER
// - MCGEN_EVENTSETINFORMATION
// - MCGEN_EVENTWRITETRANSFER
//
// If the the macro is undefined, the MC implementation will default to the
// corresponding ETW APIs. For example, if the MCGEN_EVENTREGISTER macro is
// undefined, the EventRegister[MyProviderName] macro will use EventRegister
// in user mode and will use EtwRegister in kernel mode.
//
// To prevent issues from conflicting definitions of these macros, the value
// of the override macro will be used as a suffix in certain internal function
// names. Because of this, the override macros must follow certain rules:
//
// - The macro must be defined before any MC-generated header is included and
//   must not be undefined or redefined after any MC-generated header is
//   included. Different translation units (i.e. different .c or .cpp files)
//   may set the macros to different values, but within a translation unit
//   (within a single .c or .cpp file), the macro must be set once and not
//   changed.
// - The override must be an object-like macro, not a function-like macro
//   (i.e. the override macro must not have a parameter list).
// - The override macro's value must be a simple identifier, i.e. must be
//   something that starts with a letter or '_' and contains only letters,
//   numbers, and '_' characters.
// - If the override macro's value is the name of a second object-like macro,
//   the second object-like macro must follow the same rules. (The override
//   macro's value can also be the name of a function-like macro, in which
//   case the function-like macro does not need to follow the same rules.)
//
// For example, the following will cause compile errors:
//
//   #define MCGEN_EVENTWRITETRANSFER MyNamespace::MyClass::MyFunction // Value has non-identifier characters (colon).
//   #define MCGEN_EVENTWRITETRANSFER GetEventWriteFunctionPointer(7)  // Value has non-identifier characters (parentheses).
//   #define MCGEN_EVENTWRITETRANSFER(h,e,a,r,c,d) EventWrite(h,e,c,d) // Override is defined as a function-like macro.
//   #define MY_OBJECT_LIKE_MACRO     MyNamespace::MyClass::MyEventWriteFunction
//   #define MCGEN_EVENTWRITETRANSFER MY_OBJECT_LIKE_MACRO // Evaluates to something with non-identifier characters (colon).
//
// The following would be ok:
//
//   #define MCGEN_EVENTWRITETRANSFER  MyEventWriteFunction1  // OK, suffix will be "MyEventWriteFunction1".
//   #define MY_OBJECT_LIKE_MACRO      MyEventWriteFunction2
//   #define MCGEN_EVENTWRITETRANSFER  MY_OBJECT_LIKE_MACRO   // OK, suffix will be "MyEventWriteFunction2".
//   #define MY_FUNCTION_LIKE_MACRO(h,e,a,r,c,d) MyNamespace::MyClass::MyEventWriteFunction3(h,e,c,d)
//   #define MCGEN_EVENTWRITETRANSFER  MY_FUNCTION_LIKE_MACRO // OK, suffix will be "MY_FUNCTION_LIKE_MACRO".
//
#ifndef MCGEN_EVENTREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTREGISTER        EtwRegister
  #else
    #define MCGEN_EVENTREGISTER        EventRegister
  #endif
#endif // MCGEN_EVENTREGISTER
#ifndef MCGEN_EVENTUNREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTUNREGISTER      EtwUnregister
  #else
    #define MCGEN_EVENTUNREGISTER      EventUnregister
  #endif
#endif // MCGEN_EVENTUNREGISTER
#ifndef MCGEN_EVENTSETINFORMATION
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTSETINFORMATION  EtwSetInformation
  #else
    #define MCGEN_EVENTSETINFORMATION  EventSetInformation
  #endif
#endif // MCGEN_EVENTSETINFORMATION
#ifndef MCGEN_EVENTWRITETRANSFER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTWRITETRANSFER   EtwWriteTransfer
  #else
    #define MCGEN_EVENTWRITETRANSFER   EventWriteTransfer
  #endif
#endif // MCGEN_EVENTWRITETRANSFER

//
// MCGEN_EVENT_ENABLED macro:
// Override to control how the EventWrite[EventName] macros determine whether
// an event is enabled. The default behavior is for EventWrite[EventName] to
// use the EventXplatEnabled[EventName] macros.
//
#ifndef MCGEN_EVENT_ENABLED
#define MCGEN_EVENT_ENABLED(EventName) EventXplatEnabled##EventName()
#endif

//
// MCGEN_EVENT_ENABLED_FORCONTEXT macro:
// Override to control how the EventWrite[EventName]_ForContext macros
// determine whether an event is enabled. The default behavior is for
// EventWrite[EventName]_ForContext to use the
// EventXplatEnabled[EventName]_ForContext macros.
//
#ifndef MCGEN_EVENT_ENABLED_FORCONTEXT
#define MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EventName) EventXplatEnabled##EventName##_ForContext(pContext)
#endif

//
// MCGEN_ENABLE_CHECK macro:
// Determines whether the specified event would be considered as enabled
// based on the state of the specified context. Slightly faster than calling
// McGenEventXplatEnabled directly.
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled && McGenEventXplatEnabled(&Context, &Descriptor))
#endif

#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
// This structure is for use by MC-generated code and should not be used directly.
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE            RegistrationHandle;
    TRACEHANDLE            Logger;      // Used as pointer to provider traits.
    ULONGLONG              MatchAnyKeyword;
    ULONGLONG              MatchAllKeyword;
    ULONG                  Flags;
    ULONG                  IsEnabled;
    UCHAR                  Level;
    UCHAR                  Reserve;
    USHORT                 EnableBitsCount;
    PULONG                 EnableBitMask;
    const ULONGLONG*       EnableKeyWords;
    const UCHAR*           EnableLevel;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif // MCGEN_TRACE_CONTEXT_DEF

#if !defined(MCGEN_LEVEL_KEYWORD_ENABLED_DEF)
#define MCGEN_LEVEL_KEYWORD_ENABLED_DEF
//
// Determines whether an event with a given Level and Keyword would be
// considered as enabled based on the state of the specified context.
// Note that you may want to use MCGEN_ENABLE_CHECK instead of calling this
// function directly.
//
FORCEINLINE
BOOLEAN
McGenLevelKeywordEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ UCHAR Level,
    _In_ ULONGLONG Keyword
    )
{
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((Keyword == (ULONGLONG)0) ||
            ((Keyword & EnableInfo->MatchAnyKeyword) &&
             ((Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;
}
#endif // MCGEN_LEVEL_KEYWORD_ENABLED_DEF

#if !defined(MCGEN_EVENT_ENABLED_DEF)
#define MCGEN_EVENT_ENABLED_DEF
//
// Determines whether the specified event would be considered as enabled based
// on the state of the specified context. Note that you may want to use
// MCGEN_ENABLE_CHECK instead of calling this function directly.
//
FORCEINLINE
BOOLEAN
McGenEventXplatEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return McGenLevelKeywordEnabled(EnableInfo, EventDescriptor->Level, EventDescriptor->Keyword);
}
#endif // MCGEN_EVENT_ENABLED_DEF

#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    _In_ LPCGUID SourceId,
    _In_ ULONG ControlCode,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ PEVENT_FILTER_DESCRIPTOR FilterData,
    _Inout_opt_ void* CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Windows Vista and later.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider.

    ControlCode - The parameter indicates whether the provider
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category
                      of events that the provider writes.

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
    ULONG Ix;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;

            for (Ix = 0; Ix < Ctx->EnableBitsCount; Ix += 1) {
                if (McGenLevelKeywordEnabled(Ctx, Ctx->EnableLevel[Ix], Ctx->EnableKeyWords[Ix]) != FALSE) {
                    Ctx->EnableBitMask[Ix >> 5] |= (1 << (Ix % 32));
                } else {
                    Ctx->EnableBitMask[Ix >> 5] &= ~(1 << (Ix % 32));
                }
            }
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            if (Ctx->EnableBitsCount > 0) {
#pragma warning(suppress: 26451) // Arithmetic overflow cannot occur, no matter the value of EnableBitCount
                RtlZeroMemory(Ctx->EnableBitMask, (((Ctx->EnableBitsCount - 1) / 32) + 1) * sizeof(ULONG));
            }
            break;

        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif // MCGEN_PRIVATE_ENABLE_CALLBACK_V2

    return;
}

#endif // MCGEN_CONTROL_CALLBACK

#ifndef _mcgen_PENABLECALLBACK
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define _mcgen_PENABLECALLBACK      PETWENABLECALLBACK
  #else
    #define _mcgen_PENABLECALLBACK      PENABLECALLBACK
  #endif
#endif // _mcgen_PENABLECALLBACK

#if !defined(_mcgen_PASTE2)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE2(a, b) _mcgen_PASTE2_imp(a, b)
#define _mcgen_PASTE2_imp(a, b) a##b
#endif // _mcgen_PASTE2

#if !defined(_mcgen_PASTE3)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE3(a, b, c) _mcgen_PASTE3_imp(a, b, c)
#define _mcgen_PASTE3_imp(a, b, c) a##b##_##c
#endif // _mcgen_PASTE3

//
// Macro validation
//

// Validate MCGEN_EVENTREGISTER:

// Trigger an error if MCGEN_EVENTREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER);

// Trigger an error if MCGEN_EVENTREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER)
    MCGEN_EVENTREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTREGISTER);

// Validate MCGEN_EVENTUNREGISTER:

// Trigger an error if MCGEN_EVENTUNREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER);

// Trigger an error if MCGEN_EVENTUNREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER)
    MCGEN_EVENTUNREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTUNREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTUNREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTUNREGISTER);

// Validate MCGEN_EVENTSETINFORMATION:

// Trigger an error if MCGEN_EVENTSETINFORMATION is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION);

// Trigger an error if MCGEN_EVENTSETINFORMATION is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION)
    MCGEN_EVENTSETINFORMATION_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTSETINFORMATION is defined as a function-like macro:
typedef void MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_MCGEN_EVENTSETINFORMATION;
typedef int _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_, MCGEN_EVENTSETINFORMATION);

// Validate MCGEN_EVENTWRITETRANSFER:

// Trigger an error if MCGEN_EVENTWRITETRANSFER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER);

// Trigger an error if MCGEN_EVENTWRITETRANSFER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER)
    MCGEN_EVENTWRITETRANSFER_must_not_be_redefined_between_headers;;

// Trigger an error if MCGEN_EVENTWRITETRANSFER is defined as a function-like macro:
typedef void MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_MCGEN_EVENTWRITETRANSFER;
typedef int _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_, MCGEN_EVENTWRITETRANSFER);

#ifndef McGenEventWrite_def
#define McGenEventWrite_def

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventWrite _mcgen_PASTE2(McGenEventWrite_, MCGEN_EVENTWRITETRANSFER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventWrite(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_range_(1, 128) ULONG EventDataCount,
    _Pre_cap_(EventDataCount) EVENT_DATA_DESCRIPTOR* EventData
    )
{
    const USHORT UNALIGNED* Traits;

    // Some customized MCGEN_EVENTWRITETRANSFER macros might ignore ActivityId.
    UNREFERENCED_PARAMETER(ActivityId);

    Traits = (const USHORT UNALIGNED*)(UINT_PTR)Context->Logger;

    if (Traits == NULL) {
        EventData[0].Ptr = 0;
        EventData[0].Size = 0;
        EventData[0].Reserved = 0;
    } else {
        EventData[0].Ptr = (ULONG_PTR)Traits;
        EventData[0].Size = *Traits;
        EventData[0].Reserved = 2; // EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA
    }

    return MCGEN_EVENTWRITETRANSFER(
        Context->RegistrationHandle,
        Descriptor,
        ActivityId,
        NULL,
        EventDataCount,
        EventData);
}
#endif // McGenEventWrite_def

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventRegister _mcgen_PASTE2(McGenEventRegister_, MCGEN_EVENTREGISTER)

#pragma warning(push)
#pragma warning(disable:6103)
// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ _mcgen_PENABLECALLBACK EnableCallback,
    _In_opt_ void* CallbackContext,
    _Inout_ PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function registers the provider with ETW.

Arguments:

    ProviderId - Provider ID to register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for the callback.

    RegHandle - Pointer to registration handle.

Remarks:

    Should not be called if the provider is already registered (i.e. should not
    be called if *RegHandle != 0). Repeatedly registering a provider is a bug
    and may indicate a race condition. However, for compatibility with previous
    behavior, this function will return SUCCESS in this case.

--*/
{
    ULONG Error;

    if (*RegHandle != 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTREGISTER(ProviderId, EnableCallback, CallbackContext, RegHandle);
    }

    return Error;
}
#pragma warning(pop)

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventUnregister _mcgen_PASTE2(McGenEventUnregister_, MCGEN_EVENTUNREGISTER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(_Inout_ PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW and set *RegHandle = 0.

Arguments:

    RegHandle - the pointer to the provider registration handle

Remarks:

    If provider has not been registered (i.e. if *RegHandle == 0),
    return SUCCESS. It is safe to call McGenEventUnregister even if the
    call to McGenEventRegister returned an error.

--*/
{
    ULONG Error;

    if(*RegHandle == 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTUNREGISTER(*RegHandle);
        *RegHandle = (REGHANDLE)0;
    }

    return Error;
}

#endif // McGenEventRegisterUnregister

#ifndef _mcgen_EVENT_BIT_SET
  #if defined(_M_IX86) || defined(_M_X64)
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((((const unsigned char*)EnableBits)[BitPosition >> 3] & (1u << (BitPosition & 7))) != 0)
  #else // CPU type
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((EnableBits[BitPosition >> 5] & (1u << (BitPosition & 31))) != 0)
  #endif // CPU type
#endif // _mcgen_EVENT_BIT_SET

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Microsoft-Windows-DotNETRuntime" event count 207
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = e13c0d23-ccbc-4e12-931b-d9cc2eee27e4
EXTERN_C __declspec(selectany) const GUID MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER = {0xe13c0d23, 0xccbc, 0x4e12, {0x93, 0x1b, 0xd9, 0xcc, 0x2e, 0xee, 0x27, 0xe4}};

#ifndef MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits NULL
#endif // MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits

//
// Opcodes
//
#define CLR_GC_RESTARTEEEND_OPCODE 0x84
#define CLR_GC_HEAPSTATS_OPCODE 0x85
#define CLR_GC_CREATESEGMENT_OPCODE 0x86
#define CLR_GC_FREESEGMENT_OPCODE 0x87
#define CLR_GC_RESTARTEEBEING_OPCODE 0x88
#define CLR_GC_SUSPENDEEND_OPCODE 0x89
#define CLR_GC_SUSPENDEEBEGIN_OPCODE 0xa
#define CLR_GC_ALLOCATIONTICK_OPCODE 0xb
#define CLR_GC_CREATECONCURRENTTHREAD_OPCODE 0xc
#define CLR_GC_TERMINATECONCURRENTTHREAD_OPCODE 0xd
#define CLR_GC_FINALIZERSEND_OPCODE 0xf
#define CLR_GC_FINALIZERSBEGIN_OPCODE 0x13
#define CLR_GC_BULKROOTEDGE_OPCODE 0x14
#define CLR_GC_BULKROOTCONDITIONALWEAKTABLEELEMENTEDGE_OPCODE 0x15
#define CLR_GC_BULKNODE_OPCODE 0x16
#define CLR_GC_BULKEDGE_OPCODE 0x17
#define CLR_GC_OBJECTALLOCATION_OPCODE 0x18
#define CLR_GC_BULKSURVIVINGOBJECTRANGES_OPCODE 0x19
#define CLR_GC_BULKMOVEDOBJECTRANGES_OPCODE 0x1a
#define CLR_GC_GENERATIONRANGE_OPCODE 0x1b
#define CLR_GC_MARKSTACKROOTS_OPCODE 0x1c
#define CLR_GC_MARKFINALIZEQUEUEROOTS_OPCODE 0x1d
#define CLR_GC_MARKHANDLES_OPCODE 0x1e
#define CLR_GC_MARKCARDS_OPCODE 0x1f
#define CLR_GC_FINALIZEOBJECT_OPCODE 0x20
#define CLR_GC_SETGCHANDLE_OPCODE 0x21
#define CLR_GC_DESTROYGCHANDLE_OPCODE 0x22
#define CLR_GC_TRIGGERED_OPCODE 0x23
#define CLR_GC_PINGCOBJECT_OPCODE 0x24
#define CLR_GC_BULKROOTCCW_OPCODE 0x26
#define CLR_GC_BULKRCW_OPCODE 0x27
#define CLR_GC_BULKROOTSTATICVAR_OPCODE 0x28
#define CLR_GC_DYNAMICEVENT_OPCODE 0x29
#define CLR_GC_INCREASEMEMORYPRESSURE_OPCODE 0xc8
#define CLR_GC_DECREASEMEMORYPRESSURE_OPCODE 0xc9
#define CLR_GC_MARK_OPCODE 0xca
#define CLR_GC_JOIN_OPCODE 0xcb
#define CLR_GC_GCPERHEAPHISTORY_OPCODE 0xcc
#define CLR_GC_GCGLOBALHEAPHISTORY_OPCODE 0xcd
#define CLR_GC_GENAWAREBEGIN_OPCODE 0xce
#define CLR_GC_GENAWAREEND_OPCODE 0xcf
#define CLR_GC_GCLOHCOMPACT_OPCODE 0xd0
#define CLR_GC_GCFITBUCKETINFO_OPCODE 0xd1
#define CLR_CONTENTION_LOCK_CREATED_OPCODE 0xb
#define CLR_METHOD_DCSTARTCOMPLETE_OPCODE 0xe
#define CLR_METHOD_DCENDCOMPLETE_OPCODE 0xf
#define CLR_METHOD_METHODLOAD_OPCODE 0x21
#define CLR_METHOD_METHODUNLOAD_OPCODE 0x22
#define CLR_METHOD_METHODDCSTART_OPCODE 0x23
#define CLR_METHOD_METHODDCEND_OPCODE 0x24
#define CLR_METHOD_METHODLOADVERBOSE_OPCODE 0x25
#define CLR_METHOD_METHODUNLOADVERBOSE_OPCODE 0x26
#define CLR_METHODDETAILS_OPCODE 0x2b
#define CLR_METHOD_METHODDCSTARTVERBOSE_OPCODE 0x27
#define CLR_METHOD_METHODDCENDVERBOSE_OPCODE 0x28
#define CLR_METHOD_METHODJITTINGSTARTED_OPCODE 0x2a
#define CLR_METHOD_MEMORY_ALLOCATED_FOR_JIT_CODE_OPCODE 0x67
#define CLR_JITINLININGSUCCEEDED_OPCODE 0x53
#define CLR_JITINLININGFAILED_OPCODE 0x54
#define CLR_JITTAILCALLSUCCEEDED_OPCODE 0x55
#define CLR_JITTAILCALLFAILED_OPCODE 0x56
#define CLR_METHODILTONATIVEMAP_OPCODE 0x57
#define CLR_DOMAINMODULELOAD_OPCODE 0x2d
#define CLR_MODULELOAD_OPCODE 0x21
#define CLR_MODULEUNLOAD_OPCODE 0x22
#define CLR_MODULEDCSTART_OPCODE 0x23
#define CLR_MODULEDCEND_OPCODE 0x24
#define CLR_ASSEMBLYLOAD_OPCODE 0x25
#define CLR_ASSEMBLYUNLOAD_OPCODE 0x26
#define CLR_APPDOMAINLOAD_OPCODE 0x29
#define CLR_APPDOMAINUNLOAD_OPCODE 0x2a
#define CLR_STACK_STACKWALK_OPCODE 0x52
#define CLR_APPDOMAINRESOURCEMANAGEMENT_APPDOMAINMEMALLOCATED_OPCODE 0x30
#define CLR_APPDOMAINRESOURCEMANAGEMENT_APPDOMAINMEMSURVIVED_OPCODE 0x31
#define CLR_APPDOMAINRESOURCEMANAGEMENT_THREADCREATED_OPCODE 0x32
#define CLR_APPDOMAINRESOURCEMANAGEMENT_THREADTERMINATED_OPCODE 0x33
#define CLR_APPDOMAINRESOURCEMANAGEMENT_THREADDOMAINENTER_OPCODE 0x34
#define CLR_ILSTUB_ILSTUBGENERATED_OPCODE 0x58
#define CLR_ILSTUB_ILSTUBCACHEHIT_OPCODE 0x59
#define CLR_WAIT_OPCODE 0x5a
#define CLR_THREADPOOL_WORKERTHREADADJUSTMENT_SAMPLE_OPCODE 0x64
#define CLR_THREADPOOL_WORKERTHREADADJUSTMENT_ADJUSTMENT_OPCODE 0x65
#define CLR_THREADPOOL_WORKERTHREADADJUSTMENT_STATS_OPCODE 0x66
#define CLR_PERFTRACK_MODULERANGELOAD_OPCODE 0xa
#define CLR_BULKTYPE_OPCODE 0xa
#define CLR_ENQUEUE_OPCODE 0xb
#define CLR_DEQUEUE_OPCODE 0xc
#define CLR_IOENQUEUE_OPCODE 0xd
#define CLR_IODEQUEUE_OPCODE 0xe
#define CLR_IOPACK_OPCODE 0xf
#define CLR_THREAD_CREATING_OPCODE 0xb
#define CLR_THREAD_RUNNING_OPCODE 0xc
#define CLR_TIERED_COMPILATION_SETTINGS_OPCODE 0xb
#define CLR_TIERED_COMPILATION_PAUSE_OPCODE 0xc
#define CLR_TIERED_COMPILATION_RESUME_OPCODE 0xd
#define CLR_RESOLUTION_ATTEMPTED_OPCODE 0xb
#define CLR_ALC_RESOLVING_HANDLER_INVOKED_OPCODE 0xc
#define CLR_APPDOMAIN_ASSEMBLY_RESOLVE_HANDLER_INVOKED_OPCODE 0xd
#define CLR_ASSEMBLY_LOAD_FROM_RESOLVE_HANDLER_INVOKED_OPCODE 0xe
#define CLR_BINDING_PATH_PROBED_OPCODE 0xf
#define CLR_INSTRUMENTATION_DATA_OPCODE 0xb
#define CLR_INSTRUMENTATION_DATA_VERBOSE_OPCODE 0xc
#define CLR_EXECUTIONCHECKPOINT_OPCODE 0xb
#define CLR_PROFILER_OPCODE 0xb

//
// Tasks
//
#define CLR_GC_TASK 0x1
EXTERN_C __declspec(selectany) const GUID GarbageCollectionId = {0x044973cd, 0x251f, 0x4dff, {0xa3, 0xe9, 0x9d, 0x63, 0x07, 0x28, 0x6b, 0x05}};
#define CLR_WORKERTHREADCREATE_TASK 0x2
EXTERN_C __declspec(selectany) const GUID WorkerThreadCreationId = {0xcfc4ba53, 0xfb42, 0x4757, {0x8b, 0x70, 0x5f, 0x5d, 0x51, 0xfe, 0xe2, 0xf4}};
#define CLR_IOTHREADCREATE_TASK 0x3
EXTERN_C __declspec(selectany) const GUID IOThreadCreationId = {0xc71408de, 0x42cc, 0x4f81, {0x9c, 0x93, 0xb8, 0x91, 0x2a, 0xbf, 0x2a, 0x0f}};
#define CLR_WORKERTHREADRETIRE_TASK 0x4
EXTERN_C __declspec(selectany) const GUID WorkerThreadRetirementId = {0xefdf1eac, 0x1d5d, 0x4e84, {0x89, 0x3a, 0x19, 0xb8, 0x0f, 0x69, 0x21, 0x76}};
#define CLR_IOTHREADRETIRE_TASK 0x5
EXTERN_C __declspec(selectany) const GUID IOThreadRetirementId = {0x840c8456, 0x6457, 0x4eb7, {0x9c, 0xd0, 0xd2, 0x8f, 0x01, 0xc6, 0x4f, 0x5e}};
#define CLR_THREADPOOLSUSPEND_TASK 0x6
EXTERN_C __declspec(selectany) const GUID ThreadpoolSuspensionId = {0xc424b3e3, 0x2ae0, 0x416e, {0xa0, 0x39, 0x41, 0x0c, 0x5d, 0x8e, 0x5f, 0x14}};
#define CLR_EXCEPTION_TASK 0x7
EXTERN_C __declspec(selectany) const GUID ExceptionId = {0x300ce105, 0x86d1, 0x41f8, {0xb9, 0xd2, 0x83, 0xfc, 0xbf, 0xf3, 0x2d, 0x99}};
#define CLR_EXCEPTION_CATCH_TASK 0x1b
EXTERN_C __declspec(selectany) const GUID ExceptionCatchId = {0x5bbf9499, 0x1715, 0x4658, {0x88, 0xdc, 0xaf, 0xd7, 0x69, 0x0a, 0x87, 0x11}};
#define CLR_EXCEPTION_FINALLY_TASK 0x1c
EXTERN_C __declspec(selectany) const GUID ExceptionFinallyId = {0x9565bc31, 0x300f, 0x4ea2, {0xa5, 0x32, 0x30, 0xbc, 0xe9, 0xa1, 0x41, 0x99}};
#define CLR_EXCEPTION_FILTER_TASK 0x1d
EXTERN_C __declspec(selectany) const GUID ExceptionFilterId = {0x72e72606, 0xbb71, 0x4290, {0xa2, 0x42, 0xd5, 0xf3, 0x6c, 0xe5, 0x31, 0x2e}};
#define CLR_CONTENTION_TASK 0x8
EXTERN_C __declspec(selectany) const GUID ContentionId = {0x561410f5, 0xa138, 0x4ab3, {0x94, 0x5e, 0x51, 0x64, 0x83, 0xcd, 0xdf, 0xbc}};
#define CLR_METHOD_TASK 0x9
EXTERN_C __declspec(selectany) const GUID CLRMethodId = {0x3044f61a, 0x99b0, 0x4c21, {0xb2, 0x03, 0xd3, 0x94, 0x23, 0xc7, 0x3b, 0x00}};
#define CLR_LOADER_TASK 0xa
EXTERN_C __declspec(selectany) const GUID CLRLoaderId = {0xd00792da, 0x07b7, 0x40f5, {0x97, 0xeb, 0x5d, 0x97, 0x4e, 0x05, 0x47, 0x40}};
#define CLR_STACK_TASK 0xb
EXTERN_C __declspec(selectany) const GUID CLRStackId = {0xd3363dc0, 0x243a, 0x4620, {0xa4, 0xd0, 0x8a, 0x07, 0xd7, 0x72, 0xf5, 0x33}};
#define CLR_STRONGNAMEVERIFICATION_TASK 0xc
EXTERN_C __declspec(selectany) const GUID CLRStrongNameVerificationId = {0x15447a14, 0xb523, 0x46ae, {0xb7, 0x5b, 0x02, 0x3f, 0x90, 0x0b, 0x43, 0x93}};
#define CLR_AUTHENTICODEVERIFICATION_TASK 0xd
EXTERN_C __declspec(selectany) const GUID CLRAuthenticodeVerificationId = {0xb17304d9, 0x5afa, 0x4da6, {0x9f, 0x7b, 0x5a, 0x4f, 0xa7, 0x31, 0x29, 0xb6}};
#define CLR_APPDOMAINRESOURCEMANAGEMENT_TASK 0xe
EXTERN_C __declspec(selectany) const GUID AppDomainResourceManagementId = {0x88e83959, 0x6185, 0x4e0b, {0x95, 0xb8, 0x0e, 0x4a, 0x35, 0xdf, 0x61, 0x22}};
#define CLR_IL_STUB 0xf
EXTERN_C __declspec(selectany) const GUID CLRILStubId = {0xd00792da, 0x07b7, 0x40f5, {0x00, 0x00, 0x5d, 0x97, 0x4e, 0x05, 0x47, 0x40}};
#define CLR_THREADPOOLWORKERTHREAD_TASK 0x10
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkerThreadId = {0x8a9a44ab, 0xf681, 0x4271, {0x88, 0x10, 0x83, 0x0d, 0xab, 0x9f, 0x56, 0x21}};
#define CLR_THREADPOOLWORKERTHREADRETIREMENT_TASK 0x11
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkerThreadRetirementId = {0x402ee399, 0xc137, 0x4dc0, {0xa5, 0xab, 0x3c, 0x2d, 0xea, 0x64, 0xac, 0x9c}};
#define CLR_THREADPOOLWORKERTHREADADJUSTMENT_TASK 0x12
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkerThreadAdjustmentId = {0x94179831, 0xe99a, 0x4625, {0x88, 0x24, 0x23, 0xca, 0x5e, 0x00, 0xca, 0x7d}};
#define CLR_EEStartup_TASK 0x13
EXTERN_C __declspec(selectany) const GUID CLRRuntimeInformationId = {0xcd7d3e32, 0x65fe, 0x40cd, {0x92, 0x25, 0xa2, 0x57, 0x7d, 0x20, 0x3f, 0xc3}};
#define CLR_PERFTRACK_TASK 0x14
EXTERN_C __declspec(selectany) const GUID CLRPerfTrackId = {0xeac685f6, 0x2104, 0x4dec, {0x88, 0xfd, 0x91, 0xe4, 0x25, 0x42, 0x21, 0xec}};
#define CLR_TYPE_TASK 0x15
EXTERN_C __declspec(selectany) const GUID TypeId = {0x003e5a9b, 0x4757, 0x4d3e, {0xb4, 0xa1, 0xe4, 0x7b, 0xfb, 0x48, 0x94, 0x08}};
#define CLR_THREADPOOLWORKINGTHREADCOUNT_TASK 0x16
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkingThreadCountId = {0x1b032b96, 0x767c, 0x42e4, {0x84, 0x81, 0xcb, 0x52, 0x8a, 0x66, 0xd7, 0xbd}};
#define CLR_THREADPOOL_TASK 0x17
EXTERN_C __declspec(selectany) const GUID ThreadPoolId = {0xead685f6, 0x2104, 0x4dec, {0x88, 0xfd, 0x91, 0xe4, 0x25, 0x42, 0x21, 0xe9}};
#define CLR_THREADING_TASK 0x18
EXTERN_C __declspec(selectany) const GUID ThreadId = {0x641994c5, 0x16f2, 0x4123, {0x91, 0xa7, 0xa2, 0x99, 0x9d, 0xd7, 0xbf, 0xc3}};
#define CLR_DEBUG_IPC_EVENT_TASK 0x19
EXTERN_C __declspec(selectany) const GUID DebugIPCEventId = {0xec2f3703, 0x8321, 0x4301, {0xbd, 0x51, 0x2c, 0xb9, 0xa0, 0x9f, 0x31, 0xb1}};
#define CLR_EXCEPTION_PROCESSING_TASK 0x1a
EXTERN_C __declspec(selectany) const GUID DebugExceptionProcessingId = {0xc4412198, 0xef03, 0x47f1, {0x9b, 0xd1, 0x11, 0xc6, 0x63, 0x7a, 0x20, 0x62}};
#define CLR_CODE_SYMBOLS_TASK 0x1e
EXTERN_C __declspec(selectany) const GUID CodeSymbolsId = {0x53aedf69, 0x2049, 0x4f7d, {0x93, 0x45, 0xd3, 0x01, 0x8b, 0x5c, 0x4d, 0x80}};
#define CLR_TIERED_COMPILATION_TASK 0x1f
EXTERN_C __declspec(selectany) const GUID TieredCompilationId = {0xa77f474d, 0x9d0d, 0x4311, {0xb9, 0x8e, 0xcf, 0xbc, 0xf8, 0x4b, 0x9e, 0x0f}};
#define CLR_ASSEMBLY_LOADER_TASK 0x20
EXTERN_C __declspec(selectany) const GUID AssemblyLoaderId = {0xbcf2339e, 0xb0a6, 0x452d, {0x96, 0x6c, 0x33, 0xac, 0x9d, 0xd8, 0x25, 0x73}};
#define CLR_TYPELOAD_TASK 0x21
EXTERN_C __declspec(selectany) const GUID TypeLoadId = {0x9db1562b, 0x512f, 0x475d, {0x8d, 0x4c, 0x0c, 0x6d, 0x97, 0xc1, 0xe7, 0x3c}};
#define CLR_JITINSTRUMENTATIONDATA_TASK 0x22
EXTERN_C __declspec(selectany) const GUID JitInstrumentationDataId = {0xf8666925, 0x22c8, 0x4b70, {0xa1, 0x31, 0x07, 0x38, 0x13, 0x7e, 0x7f, 0x25}};
#define CLR_EXECUTION_CHECKPOINT_TASK 0x23
EXTERN_C __declspec(selectany) const GUID ExecutionCheckpointId = {0x598832c8, 0xdf4d, 0x4e9e, {0xab, 0xe6, 0x2c, 0x7b, 0xf0, 0xba, 0x2d, 0xa2}};
#define CLR_PROFILER_TASK 0x24
EXTERN_C __declspec(selectany) const GUID ProfilerId = {0x68895e46, 0xfd03, 0x4528, {0x89, 0xd2, 0x5e, 0x1f, 0xbb, 0x1d, 0x3b, 0xcf}};
#define CLR_YIELD_PROCESSOR_MEASUREMENT_TASK 0x25
EXTERN_C __declspec(selectany) const GUID YieldProcessorMeasurementId = {0xb4afc324, 0xdece, 0x4b02, {0x86, 0xdc, 0xaa, 0xb8, 0xf2, 0x2b, 0xc1, 0xb1}};
#define CLR_THREADPOOLMINMAXTHREADS_TASK 0x26
EXTERN_C __declspec(selectany) const GUID ThreadPoolMinMaxThreadsId = {0x6d168d67, 0xfb06, 0x4a60, {0x83, 0xba, 0x25, 0x44, 0xe8, 0x17, 0xf6, 0xa3}};

//
// Keyword
//
#define CLR_GC_KEYWORD 0x1
#define CLR_GCHANDLE_KEYWORD 0x2
#define CLR_ASSEMBLY_LOADER_KEYWORD 0x4
#define CLR_LOADER_KEYWORD 0x8
#define CLR_JIT_KEYWORD 0x10
#define CLR_NGEN_KEYWORD 0x20
#define CLR_STARTENUMERATION_KEYWORD 0x40
#define CLR_ENDENUMERATION_KEYWORD 0x80
#define CLR_SECURITY_KEYWORD 0x400
#define CLR_APPDOMAINRESOURCEMANAGEMENT_KEYWORD 0x800
#define CLR_JITTRACING_KEYWORD 0x1000
#define CLR_INTEROP_KEYWORD 0x2000
#define CLR_CONTENTION_KEYWORD 0x4000
#define CLR_EXCEPTION_KEYWORD 0x8000
#define CLR_THREADING_KEYWORD 0x10000
#define CLR_JITTEDMETHODILTONATIVEMAP_KEYWORD 0x20000
#define CLR_OVERRIDEANDSUPPRESSNGENEVENTS_KEYWORD 0x40000
#define CLR_TYPE_KEYWORD 0x80000
#define CLR_GCHEAPDUMP_KEYWORD 0x100000
#define CLR_GCHEAPALLOCHIGH_KEYWORD 0x200000
#define CLR_GCHEAPSURVIVALANDMOVEMENT_KEYWORD 0x400000
#define CLR_MANAGEDHEAPCOLLECT_KEYWORD 0x800000
#define CLR_GCHEAPANDTYPENAMES_KEYWORD 0x1000000
#define CLR_GCHEAPALLOCLOW_KEYWORD 0x2000000
#define CLR_PERFTRACK_KEYWORD 0x20000000
#define CLR_STACK_KEYWORD 0x40000000
#define CLR_THREADTRANSFER_KEYWORD 0x80000000
#define CLR_DEBUGGER_KEYWORD 0x100000000
#define CLR_MONITORING_KEYWORD 0x200000000
#define CLR_CODESYMBOLS_KEYWORD 0x400000000
#define CLR_EVENTSOURCE_KEYWORD 0x800000000
#define CLR_COMPILATION_KEYWORD 0x1000000000
#define CLR_COMPILATIONDIAGNOSTIC_KEYWORD 0x2000000000
#define CLR_METHODDIAGNOSTIC_KEYWORD 0x4000000000
#define CLR_TYPEDIAGNOSTIC_KEYWORD 0x8000000000
#define CLR_JITINSTRUMENTEDDATA_KEYWORD 0x10000000000
#define CLR_PROFILER_KEYWORD 0x20000000000

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCStart = {0x1, 0x0, 0x0, 0x4, 0x1, 0x1, 0x1};
#define GCStart_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCStart_V1 = {0x1, 0x1, 0x0, 0x4, 0x1, 0x1, 0x1};
#define GCStart_V1_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCStart_V2 = {0x1, 0x2, 0x0, 0x4, 0x1, 0x1, 0x1};
#define GCStart_V2_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCEnd = {0x2, 0x0, 0x0, 0x4, 0x2, 0x1, 0x1};
#define GCEnd_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCEnd_V1 = {0x2, 0x1, 0x0, 0x4, 0x2, 0x1, 0x1};
#define GCEnd_V1_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEEnd = {0x3, 0x0, 0x0, 0x4, 0x84, 0x1, 0x1};
#define GCRestartEEEnd_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEEnd_V1 = {0x3, 0x1, 0x0, 0x4, 0x84, 0x1, 0x1};
#define GCRestartEEEnd_V1_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCHeapStats = {0x4, 0x0, 0x0, 0x4, 0x85, 0x1, 0x1};
#define GCHeapStats_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCHeapStats_V1 = {0x4, 0x1, 0x0, 0x4, 0x85, 0x1, 0x1};
#define GCHeapStats_V1_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCHeapStats_V2 = {0x4, 0x2, 0x0, 0x4, 0x85, 0x1, 0x1};
#define GCHeapStats_V2_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateSegment = {0x5, 0x0, 0x0, 0x4, 0x86, 0x1, 0x1};
#define GCCreateSegment_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateSegment_V1 = {0x5, 0x1, 0x0, 0x4, 0x86, 0x1, 0x1};
#define GCCreateSegment_V1_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFreeSegment = {0x6, 0x0, 0x0, 0x4, 0x87, 0x1, 0x1};
#define GCFreeSegment_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFreeSegment_V1 = {0x6, 0x1, 0x0, 0x4, 0x87, 0x1, 0x1};
#define GCFreeSegment_V1_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEBegin = {0x7, 0x0, 0x0, 0x4, 0x88, 0x1, 0x1};
#define GCRestartEEBegin_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEBegin_V1 = {0x7, 0x1, 0x0, 0x4, 0x88, 0x1, 0x1};
#define GCRestartEEBegin_V1_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEEnd = {0x8, 0x0, 0x0, 0x4, 0x89, 0x1, 0x1};
#define GCSuspendEEEnd_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEEnd_V1 = {0x8, 0x1, 0x0, 0x4, 0x89, 0x1, 0x1};
#define GCSuspendEEEnd_V1_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEBegin = {0x9, 0x0, 0x0, 0x4, 0xa, 0x1, 0x1};
#define GCSuspendEEBegin_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEBegin_V1 = {0x9, 0x1, 0x0, 0x4, 0xa, 0x1, 0x1};
#define GCSuspendEEBegin_V1_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick = {0xa, 0x0, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick_V1 = {0xa, 0x1, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_V1_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick_V2 = {0xa, 0x2, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_V2_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick_V3 = {0xa, 0x3, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_V3_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick_V4 = {0xa, 0x4, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_V4_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateConcurrentThread = {0xb, 0x0, 0x0, 0x4, 0xc, 0x1, 0x1};
#define GCCreateConcurrentThread_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateConcurrentThread_V1 = {0xb, 0x1, 0x0, 0x4, 0xc, 0x1, 0x10001};
#define GCCreateConcurrentThread_V1_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCTerminateConcurrentThread = {0xc, 0x0, 0x0, 0x4, 0xd, 0x1, 0x1};
#define GCTerminateConcurrentThread_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCTerminateConcurrentThread_V1 = {0xc, 0x1, 0x0, 0x4, 0xd, 0x1, 0x10001};
#define GCTerminateConcurrentThread_V1_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersEnd = {0xd, 0x0, 0x0, 0x4, 0xf, 0x1, 0x1};
#define GCFinalizersEnd_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersEnd_V1 = {0xd, 0x1, 0x0, 0x4, 0xf, 0x1, 0x1};
#define GCFinalizersEnd_V1_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersBegin = {0xe, 0x0, 0x0, 0x4, 0x13, 0x1, 0x1};
#define GCFinalizersBegin_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersBegin_V1 = {0xe, 0x1, 0x0, 0x4, 0x13, 0x1, 0x1};
#define GCFinalizersBegin_V1_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BulkType = {0xf, 0x0, 0x0, 0x4, 0xa, 0x15, 0x80000};
#define BulkType_value 0xf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootEdge = {0x10, 0x0, 0x0, 0x4, 0x14, 0x1, 0x100000};
#define GCBulkRootEdge_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootConditionalWeakTableElementEdge = {0x11, 0x0, 0x0, 0x4, 0x15, 0x1, 0x100000};
#define GCBulkRootConditionalWeakTableElementEdge_value 0x11
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkNode = {0x12, 0x0, 0x0, 0x4, 0x16, 0x1, 0x100000};
#define GCBulkNode_value 0x12
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkEdge = {0x13, 0x0, 0x0, 0x4, 0x17, 0x1, 0x100000};
#define GCBulkEdge_value 0x13
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSampledObjectAllocationHigh = {0x14, 0x0, 0x0, 0x4, 0x18, 0x1, 0x200000};
#define GCSampledObjectAllocationHigh_value 0x14
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkSurvivingObjectRanges = {0x15, 0x0, 0x0, 0x4, 0x19, 0x1, 0x400000};
#define GCBulkSurvivingObjectRanges_value 0x15
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkMovedObjectRanges = {0x16, 0x0, 0x0, 0x4, 0x1a, 0x1, 0x400000};
#define GCBulkMovedObjectRanges_value 0x16
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGenerationRange = {0x17, 0x0, 0x0, 0x4, 0x1b, 0x1, 0x400000};
#define GCGenerationRange_value 0x17
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkStackRoots = {0x19, 0x0, 0x0, 0x4, 0x1c, 0x1, 0x1};
#define GCMarkStackRoots_value 0x19
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkFinalizeQueueRoots = {0x1a, 0x0, 0x0, 0x4, 0x1d, 0x1, 0x1};
#define GCMarkFinalizeQueueRoots_value 0x1a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkHandles = {0x1b, 0x0, 0x0, 0x4, 0x1e, 0x1, 0x1};
#define GCMarkHandles_value 0x1b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkOlderGenerationRoots = {0x1c, 0x0, 0x0, 0x4, 0x1f, 0x1, 0x1};
#define GCMarkOlderGenerationRoots_value 0x1c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FinalizeObject = {0x1d, 0x0, 0x0, 0x5, 0x20, 0x1, 0x1};
#define FinalizeObject_value 0x1d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SetGCHandle = {0x1e, 0x0, 0x0, 0x4, 0x21, 0x1, 0x2};
#define SetGCHandle_value 0x1e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DestroyGCHandle = {0x1f, 0x0, 0x0, 0x4, 0x22, 0x1, 0x2};
#define DestroyGCHandle_value 0x1f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSampledObjectAllocationLow = {0x20, 0x0, 0x0, 0x4, 0x18, 0x1, 0x2000000};
#define GCSampledObjectAllocationLow_value 0x20
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PinObjectAtGCTime = {0x21, 0x0, 0x0, 0x5, 0x24, 0x1, 0x1};
#define PinObjectAtGCTime_value 0x21
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCTriggered = {0x23, 0x0, 0x0, 0x4, 0x23, 0x1, 0x1};
#define GCTriggered_value 0x23
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootCCW = {0x24, 0x0, 0x0, 0x4, 0x26, 0x1, 0x100000};
#define GCBulkRootCCW_value 0x24
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRCW = {0x25, 0x0, 0x0, 0x4, 0x27, 0x1, 0x100000};
#define GCBulkRCW_value 0x25
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootStaticVar = {0x26, 0x0, 0x0, 0x4, 0x28, 0x1, 0x100000};
#define GCBulkRootStaticVar_value 0x26
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCDynamicEvent = {0x27, 0x0, 0x0, 0x4, 0x29, 0x1, 0x3f00003};
#define GCDynamicEvent_value 0x27
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadCreate = {0x28, 0x0, 0x0, 0x4, 0x1, 0x2, 0x10000};
#define WorkerThreadCreate_value 0x28
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadTerminate = {0x29, 0x0, 0x0, 0x4, 0x2, 0x2, 0x10000};
#define WorkerThreadTerminate_value 0x29
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadRetire = {0x2a, 0x0, 0x0, 0x4, 0x1, 0x4, 0x10000};
#define WorkerThreadRetire_value 0x2a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadUnretire = {0x2b, 0x0, 0x0, 0x4, 0x2, 0x4, 0x10000};
#define WorkerThreadUnretire_value 0x2b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadCreate = {0x2c, 0x0, 0x0, 0x4, 0x1, 0x3, 0x10000};
#define IOThreadCreate_value 0x2c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadCreate_V1 = {0x2c, 0x1, 0x0, 0x4, 0x1, 0x3, 0x10000};
#define IOThreadCreate_V1_value 0x2c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadTerminate = {0x2d, 0x0, 0x0, 0x4, 0x2, 0x3, 0x10000};
#define IOThreadTerminate_value 0x2d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadTerminate_V1 = {0x2d, 0x1, 0x0, 0x4, 0x2, 0x3, 0x10000};
#define IOThreadTerminate_V1_value 0x2d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadRetire = {0x2e, 0x0, 0x0, 0x4, 0x1, 0x5, 0x10000};
#define IOThreadRetire_value 0x2e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadRetire_V1 = {0x2e, 0x1, 0x0, 0x4, 0x1, 0x5, 0x10000};
#define IOThreadRetire_V1_value 0x2e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadUnretire = {0x2f, 0x0, 0x0, 0x4, 0x2, 0x5, 0x10000};
#define IOThreadUnretire_value 0x2f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadUnretire_V1 = {0x2f, 0x1, 0x0, 0x4, 0x2, 0x5, 0x10000};
#define IOThreadUnretire_V1_value 0x2f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadpoolSuspensionSuspendThread = {0x30, 0x0, 0x0, 0x4, 0x1, 0x6, 0x10000};
#define ThreadpoolSuspensionSuspendThread_value 0x30
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadpoolSuspensionResumeThread = {0x31, 0x0, 0x0, 0x4, 0x2, 0x6, 0x10000};
#define ThreadpoolSuspensionResumeThread_value 0x31
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadStart = {0x32, 0x0, 0x0, 0x4, 0x1, 0x10, 0x10000};
#define ThreadPoolWorkerThreadStart_value 0x32
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadStop = {0x33, 0x0, 0x0, 0x4, 0x2, 0x10, 0x10000};
#define ThreadPoolWorkerThreadStop_value 0x33
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadRetirementStart = {0x34, 0x0, 0x0, 0x4, 0x1, 0x11, 0x10000};
#define ThreadPoolWorkerThreadRetirementStart_value 0x34
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadRetirementStop = {0x35, 0x0, 0x0, 0x4, 0x2, 0x11, 0x10000};
#define ThreadPoolWorkerThreadRetirementStop_value 0x35
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadAdjustmentSample = {0x36, 0x0, 0x0, 0x4, 0x64, 0x12, 0x10000};
#define ThreadPoolWorkerThreadAdjustmentSample_value 0x36
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadAdjustmentAdjustment = {0x37, 0x0, 0x0, 0x4, 0x65, 0x12, 0x10000};
#define ThreadPoolWorkerThreadAdjustmentAdjustment_value 0x37
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadAdjustmentStats = {0x38, 0x0, 0x0, 0x5, 0x66, 0x12, 0x10000};
#define ThreadPoolWorkerThreadAdjustmentStats_value 0x38
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadWait = {0x39, 0x0, 0x0, 0x4, 0x5a, 0x10, 0x10000};
#define ThreadPoolWorkerThreadWait_value 0x39
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR YieldProcessorMeasurement = {0x3a, 0x0, 0x0, 0x4, 0x0, 0x25, 0x10000};
#define YieldProcessorMeasurement_value 0x3a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolMinMaxThreads = {0x3b, 0x0, 0x0, 0x4, 0x0, 0x26, 0x10000};
#define ThreadPoolMinMaxThreads_value 0x3b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkingThreadCount = {0x3c, 0x0, 0x0, 0x5, 0x1, 0x16, 0x10000};
#define ThreadPoolWorkingThreadCount_value 0x3c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolEnqueue = {0x3d, 0x0, 0x0, 0x5, 0xb, 0x17, 0x80010000};
#define ThreadPoolEnqueue_value 0x3d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolDequeue = {0x3e, 0x0, 0x0, 0x5, 0xc, 0x17, 0x80010000};
#define ThreadPoolDequeue_value 0x3e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolIOEnqueue = {0x3f, 0x0, 0x0, 0x5, 0xd, 0x17, 0x80010000};
#define ThreadPoolIOEnqueue_value 0x3f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolIODequeue = {0x40, 0x0, 0x0, 0x5, 0xe, 0x17, 0x80010000};
#define ThreadPoolIODequeue_value 0x40
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolIOPack = {0x41, 0x0, 0x0, 0x5, 0xf, 0x17, 0x10000};
#define ThreadPoolIOPack_value 0x41
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadCreating = {0x46, 0x0, 0x0, 0x4, 0xb, 0x18, 0x80010000};
#define ThreadCreating_value 0x46
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadRunning = {0x47, 0x0, 0x0, 0x4, 0xc, 0x18, 0x80010000};
#define ThreadRunning_value 0x47
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDetails = {0x48, 0x0, 0x0, 0x4, 0x2b, 0x9, 0x4000000000};
#define MethodDetails_value 0x48
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TypeLoadStart = {0x49, 0x0, 0x0, 0x4, 0x1, 0x21, 0x8000000000};
#define TypeLoadStart_value 0x49
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TypeLoadStop = {0x4a, 0x0, 0x0, 0x4, 0x2, 0x21, 0x8000000000};
#define TypeLoadStop_value 0x4a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionThrown = {0x50, 0x0, 0x0, 0x4, 0x1, 0x7, 0x0};
#define ExceptionThrown_value 0x50
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionThrown_V1 = {0x50, 0x1, 0x0, 0x2, 0x1, 0x7, 0x200008000};
#define ExceptionThrown_V1_value 0x50
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionCatchStart = {0xfa, 0x0, 0x0, 0x4, 0x1, 0x1b, 0x8000};
#define ExceptionCatchStart_value 0xfa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionCatchStop = {0xfb, 0x0, 0x0, 0x4, 0x2, 0x1b, 0x8000};
#define ExceptionCatchStop_value 0xfb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFinallyStart = {0xfc, 0x0, 0x0, 0x4, 0x1, 0x1c, 0x8000};
#define ExceptionFinallyStart_value 0xfc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFinallyStop = {0xfd, 0x0, 0x0, 0x4, 0x2, 0x1c, 0x8000};
#define ExceptionFinallyStop_value 0xfd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFilterStart = {0xfe, 0x0, 0x0, 0x4, 0x1, 0x1d, 0x8000};
#define ExceptionFilterStart_value 0xfe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFilterStop = {0xff, 0x0, 0x0, 0x4, 0x2, 0x1d, 0x8000};
#define ExceptionFilterStop_value 0xff
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionThrownStop = {0x100, 0x0, 0x0, 0x4, 0x2, 0x7, 0x8000};
#define ExceptionThrownStop_value 0x100
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Contention = {0x51, 0x0, 0x0, 0x4, 0x1, 0x8, 0x0};
#define Contention_value 0x51
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ContentionStart_V1 = {0x51, 0x1, 0x0, 0x4, 0x1, 0x8, 0x4000};
#define ContentionStart_V1_value 0x51
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ContentionStart_V2 = {0x51, 0x2, 0x0, 0x4, 0x1, 0x8, 0x4000};
#define ContentionStart_V2_value 0x51
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ContentionStop = {0x5b, 0x0, 0x0, 0x4, 0x2, 0x8, 0x4000};
#define ContentionStop_value 0x5b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ContentionStop_V1 = {0x5b, 0x1, 0x0, 0x4, 0x2, 0x8, 0x4000};
#define ContentionStop_V1_value 0x5b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ContentionLockCreated = {0x5a, 0x0, 0x0, 0x4, 0xb, 0x8, 0x4000};
#define ContentionLockCreated_value 0x5a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CLRStackWalk = {0x52, 0x0, 0x0, 0x0, 0x52, 0xb, 0x40000000};
#define CLRStackWalk_value 0x52
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainMemAllocated = {0x53, 0x0, 0x0, 0x4, 0x30, 0xe, 0x800};
#define AppDomainMemAllocated_value 0x53
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainMemSurvived = {0x54, 0x0, 0x0, 0x4, 0x31, 0xe, 0x800};
#define AppDomainMemSurvived_value 0x54
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadCreated = {0x55, 0x0, 0x0, 0x4, 0x32, 0xe, 0x10800};
#define ThreadCreated_value 0x55
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadTerminated = {0x56, 0x0, 0x0, 0x4, 0x33, 0xe, 0x10800};
#define ThreadTerminated_value 0x56
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadDomainEnter = {0x57, 0x0, 0x0, 0x4, 0x34, 0xe, 0x10800};
#define ThreadDomainEnter_value 0x57
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ILStubGenerated = {0x58, 0x0, 0x0, 0x4, 0x58, 0xf, 0x2000};
#define ILStubGenerated_value 0x58
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ILStubCacheHit = {0x59, 0x0, 0x0, 0x4, 0x59, 0xf, 0x2000};
#define ILStubCacheHit_value 0x59
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartCompleteV2 = {0x87, 0x0, 0x0, 0x4, 0xe, 0x9, 0x30};
#define DCStartCompleteV2_value 0x87
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndCompleteV2 = {0x88, 0x0, 0x0, 0x4, 0xf, 0x9, 0x30};
#define DCEndCompleteV2_value 0x88
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartV2 = {0x89, 0x0, 0x0, 0x4, 0x23, 0x9, 0x30};
#define MethodDCStartV2_value 0x89
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndV2 = {0x8a, 0x0, 0x0, 0x4, 0x24, 0x9, 0x30};
#define MethodDCEndV2_value 0x8a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerboseV2 = {0x8b, 0x0, 0x0, 0x4, 0x27, 0x9, 0x30};
#define MethodDCStartVerboseV2_value 0x8b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerboseV2 = {0x8c, 0x0, 0x0, 0x4, 0x28, 0x9, 0x30};
#define MethodDCEndVerboseV2_value 0x8c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoad = {0x8d, 0x0, 0x0, 0x4, 0x21, 0x9, 0x30};
#define MethodLoad_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoad_V1 = {0x8d, 0x1, 0x0, 0x4, 0x21, 0x9, 0x30};
#define MethodLoad_V1_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoad_V2 = {0x8d, 0x2, 0x0, 0x4, 0x21, 0x9, 0x30};
#define MethodLoad_V2_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR R2RGetEntryPoint = {0x9f, 0x0, 0x0, 0x4, 0x21, 0x9, 0x2000000000};
#define R2RGetEntryPoint_value 0x9f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR R2RGetEntryPointStart = {0xa0, 0x0, 0x0, 0x4, 0x21, 0x9, 0x2000000000};
#define R2RGetEntryPointStart_value 0xa0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnload = {0x8e, 0x0, 0x0, 0x4, 0x22, 0x9, 0x30};
#define MethodUnload_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnload_V1 = {0x8e, 0x1, 0x0, 0x4, 0x22, 0x9, 0x30};
#define MethodUnload_V1_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnload_V2 = {0x8e, 0x2, 0x0, 0x4, 0x22, 0x9, 0x30};
#define MethodUnload_V2_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoadVerbose = {0x8f, 0x0, 0x0, 0x4, 0x25, 0x9, 0x30};
#define MethodLoadVerbose_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoadVerbose_V1 = {0x8f, 0x1, 0x0, 0x4, 0x25, 0x9, 0x30};
#define MethodLoadVerbose_V1_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoadVerbose_V2 = {0x8f, 0x2, 0x0, 0x4, 0x25, 0x9, 0x30};
#define MethodLoadVerbose_V2_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnloadVerbose = {0x90, 0x0, 0x0, 0x4, 0x26, 0x9, 0x30};
#define MethodUnloadVerbose_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnloadVerbose_V1 = {0x90, 0x1, 0x0, 0x4, 0x26, 0x9, 0x30};
#define MethodUnloadVerbose_V1_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnloadVerbose_V2 = {0x90, 0x2, 0x0, 0x4, 0x26, 0x9, 0x30};
#define MethodUnloadVerbose_V2_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJittingStarted = {0x91, 0x0, 0x0, 0x5, 0x2a, 0x9, 0x10};
#define MethodJittingStarted_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJittingStarted_V1 = {0x91, 0x1, 0x0, 0x5, 0x2a, 0x9, 0x10};
#define MethodJittingStarted_V1_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitMemoryAllocatedForCode = {0x92, 0x0, 0x0, 0x5, 0x67, 0x9, 0x10};
#define MethodJitMemoryAllocatedForCode_value 0x92
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitInliningSucceeded = {0xb9, 0x0, 0x0, 0x5, 0x53, 0x9, 0x1000};
#define MethodJitInliningSucceeded_value 0xb9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitInliningFailedAnsi = {0xba, 0x0, 0x0, 0x5, 0x54, 0x9, 0x1000};
#define MethodJitInliningFailedAnsi_value 0xba
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitTailCallSucceeded = {0xbc, 0x0, 0x0, 0x5, 0x55, 0x9, 0x1000};
#define MethodJitTailCallSucceeded_value 0xbc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitTailCallFailedAnsi = {0xbd, 0x0, 0x0, 0x5, 0x56, 0x9, 0x1000};
#define MethodJitTailCallFailedAnsi_value 0xbd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodILToNativeMap = {0xbe, 0x0, 0x0, 0x5, 0x57, 0x9, 0x20000};
#define MethodILToNativeMap_value 0xbe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodILToNativeMap_V1 = {0xbe, 0x1, 0x0, 0x5, 0x57, 0x9, 0x20000};
#define MethodILToNativeMap_V1_value 0xbe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitTailCallFailed = {0xbf, 0x0, 0x0, 0x5, 0x56, 0x9, 0x1000};
#define MethodJitTailCallFailed_value 0xbf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitInliningFailed = {0xc0, 0x0, 0x0, 0x5, 0x54, 0x9, 0x1000};
#define MethodJitInliningFailed_value 0xc0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStartV2 = {0x95, 0x0, 0x0, 0x4, 0x23, 0xa, 0x8};
#define ModuleDCStartV2_value 0x95
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEndV2 = {0x96, 0x0, 0x0, 0x4, 0x24, 0xa, 0x8};
#define ModuleDCEndV2_value 0x96
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleLoad = {0x97, 0x0, 0x0, 0x4, 0x2d, 0xa, 0x8};
#define DomainModuleLoad_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleLoad_V1 = {0x97, 0x1, 0x0, 0x4, 0x2d, 0xa, 0x8};
#define DomainModuleLoad_V1_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleLoad = {0x98, 0x0, 0x0, 0x4, 0x21, 0xa, 0x8};
#define ModuleLoad_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleLoad_V1 = {0x98, 0x1, 0x0, 0x4, 0x21, 0xa, 0x20000008};
#define ModuleLoad_V1_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleLoad_V2 = {0x98, 0x2, 0x0, 0x4, 0x21, 0xa, 0x20000008};
#define ModuleLoad_V2_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleUnload = {0x99, 0x0, 0x0, 0x4, 0x22, 0xa, 0x8};
#define ModuleUnload_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleUnload_V1 = {0x99, 0x1, 0x0, 0x4, 0x22, 0xa, 0x20000008};
#define ModuleUnload_V1_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleUnload_V2 = {0x99, 0x2, 0x0, 0x4, 0x22, 0xa, 0x20000008};
#define ModuleUnload_V2_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoad = {0x9a, 0x0, 0x0, 0x4, 0x25, 0xa, 0x8};
#define AssemblyLoad_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoad_V1 = {0x9a, 0x1, 0x0, 0x4, 0x25, 0xa, 0x8};
#define AssemblyLoad_V1_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyUnload = {0x9b, 0x0, 0x0, 0x4, 0x26, 0xa, 0x8};
#define AssemblyUnload_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyUnload_V1 = {0x9b, 0x1, 0x0, 0x4, 0x26, 0xa, 0x8};
#define AssemblyUnload_V1_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainLoad = {0x9c, 0x0, 0x0, 0x4, 0x29, 0xa, 0x8};
#define AppDomainLoad_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainLoad_V1 = {0x9c, 0x1, 0x0, 0x4, 0x29, 0xa, 0x8};
#define AppDomainLoad_V1_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainUnload = {0x9d, 0x0, 0x0, 0x4, 0x2a, 0xa, 0x8};
#define AppDomainUnload_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainUnload_V1 = {0x9d, 0x1, 0x0, 0x4, 0x2a, 0xa, 0x8};
#define AppDomainUnload_V1_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleRangeLoad = {0x9e, 0x0, 0x0, 0x4, 0xa, 0x14, 0x20000000};
#define ModuleRangeLoad_value 0x9e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStart = {0xb5, 0x0, 0x0, 0x5, 0x1, 0xc, 0x400};
#define StrongNameVerificationStart_value 0xb5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStart_V1 = {0xb5, 0x1, 0x0, 0x5, 0x1, 0xc, 0x400};
#define StrongNameVerificationStart_V1_value 0xb5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStop = {0xb6, 0x0, 0x0, 0x4, 0x2, 0xc, 0x400};
#define StrongNameVerificationStop_value 0xb6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStop_V1 = {0xb6, 0x1, 0x0, 0x4, 0x2, 0xc, 0x400};
#define StrongNameVerificationStop_V1_value 0xb6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStart = {0xb7, 0x0, 0x0, 0x5, 0x1, 0xd, 0x400};
#define AuthenticodeVerificationStart_value 0xb7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStart_V1 = {0xb7, 0x1, 0x0, 0x5, 0x1, 0xd, 0x400};
#define AuthenticodeVerificationStart_V1_value 0xb7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStop = {0xb8, 0x0, 0x0, 0x4, 0x2, 0xd, 0x400};
#define AuthenticodeVerificationStop_value 0xb8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStop_V1 = {0xb8, 0x1, 0x0, 0x4, 0x2, 0xd, 0x400};
#define AuthenticodeVerificationStop_V1_value 0xb8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RuntimeInformationStart = {0xbb, 0x0, 0x0, 0x4, 0x1, 0x13, 0x0};
#define RuntimeInformationStart_value 0xbb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IncreaseMemoryPressure = {0xc8, 0x0, 0x0, 0x5, 0xc8, 0x1, 0x1};
#define IncreaseMemoryPressure_value 0xc8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DecreaseMemoryPressure = {0xc9, 0x0, 0x0, 0x5, 0xc9, 0x1, 0x1};
#define DecreaseMemoryPressure_value 0xc9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkWithType = {0xca, 0x0, 0x0, 0x4, 0xca, 0x1, 0x1};
#define GCMarkWithType_value 0xca
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCJoin_V2 = {0xcb, 0x2, 0x0, 0x5, 0xcb, 0x1, 0x1};
#define GCJoin_V2_value 0xcb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCPerHeapHistory_V3 = {0xcc, 0x3, 0x0, 0x4, 0xcc, 0x1, 0x1};
#define GCPerHeapHistory_V3_value 0xcc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGlobalHeapHistory_V2 = {0xcd, 0x2, 0x0, 0x4, 0xcd, 0x1, 0x1};
#define GCGlobalHeapHistory_V2_value 0xcd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGlobalHeapHistory_V3 = {0xcd, 0x3, 0x0, 0x4, 0xcd, 0x1, 0x1};
#define GCGlobalHeapHistory_V3_value 0xcd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGlobalHeapHistory_V4 = {0xcd, 0x4, 0x0, 0x4, 0xcd, 0x1, 0x1};
#define GCGlobalHeapHistory_V4_value 0xcd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GenAwareBegin = {0xce, 0x0, 0x0, 0x4, 0xce, 0x1, 0x100000};
#define GenAwareBegin_value 0xce
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GenAwareEnd = {0xcf, 0x0, 0x0, 0x4, 0xcf, 0x1, 0x100000};
#define GenAwareEnd_value 0xcf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCLOHCompact = {0xd0, 0x0, 0x0, 0x4, 0xd0, 0x1, 0x1};
#define GCLOHCompact_value 0xd0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFitBucketInfo = {0xd1, 0x0, 0x0, 0x5, 0xd1, 0x1, 0x1};
#define GCFitBucketInfo_value 0xd1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugIPCEventStart = {0xf0, 0x0, 0x0, 0x4, 0x1, 0x19, 0x100000000};
#define DebugIPCEventStart_value 0xf0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugIPCEventEnd = {0xf1, 0x0, 0x0, 0x4, 0x2, 0x19, 0x100000000};
#define DebugIPCEventEnd_value 0xf1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugExceptionProcessingStart = {0xf2, 0x0, 0x0, 0x4, 0x1, 0x1a, 0x100000000};
#define DebugExceptionProcessingStart_value 0xf2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugExceptionProcessingEnd = {0xf3, 0x0, 0x0, 0x4, 0x2, 0x1a, 0x100000000};
#define DebugExceptionProcessingEnd_value 0xf3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CodeSymbols = {0x104, 0x0, 0x0, 0x5, 0x1, 0x1e, 0x400000000};
#define CodeSymbols_value 0x104
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EventSource = {0x10e, 0x0, 0x0, 0x4, 0x0, 0x0, 0x800000000};
#define EventSource_value 0x10e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TieredCompilationSettings = {0x118, 0x0, 0x0, 0x4, 0xb, 0x1f, 0x1000000000};
#define TieredCompilationSettings_value 0x118
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TieredCompilationPause = {0x119, 0x0, 0x0, 0x4, 0xc, 0x1f, 0x1000000000};
#define TieredCompilationPause_value 0x119
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TieredCompilationResume = {0x11a, 0x0, 0x0, 0x4, 0xd, 0x1f, 0x1000000000};
#define TieredCompilationResume_value 0x11a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TieredCompilationBackgroundJitStart = {0x11b, 0x0, 0x0, 0x4, 0x1, 0x1f, 0x1000000000};
#define TieredCompilationBackgroundJitStart_value 0x11b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TieredCompilationBackgroundJitStop = {0x11c, 0x0, 0x0, 0x4, 0x2, 0x1f, 0x1000000000};
#define TieredCompilationBackgroundJitStop_value 0x11c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoadStart = {0x122, 0x0, 0x0, 0x4, 0x1, 0x20, 0x4};
#define AssemblyLoadStart_value 0x122
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoadStop = {0x123, 0x0, 0x0, 0x4, 0x2, 0x20, 0x4};
#define AssemblyLoadStop_value 0x123
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ResolutionAttempted = {0x124, 0x0, 0x0, 0x4, 0xb, 0x20, 0x4};
#define ResolutionAttempted_value 0x124
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoadContextResolvingHandlerInvoked = {0x125, 0x0, 0x0, 0x4, 0xc, 0x20, 0x4};
#define AssemblyLoadContextResolvingHandlerInvoked_value 0x125
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainAssemblyResolveHandlerInvoked = {0x126, 0x0, 0x0, 0x4, 0xd, 0x20, 0x4};
#define AppDomainAssemblyResolveHandlerInvoked_value 0x126
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoadFromResolveHandlerInvoked = {0x127, 0x0, 0x0, 0x4, 0xe, 0x20, 0x4};
#define AssemblyLoadFromResolveHandlerInvoked_value 0x127
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR KnownPathProbed = {0x128, 0x0, 0x0, 0x4, 0xf, 0x20, 0x4};
#define KnownPathProbed_value 0x128
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR JitInstrumentationData = {0x129, 0x0, 0x0, 0x4, 0xb, 0x22, 0x10000000000};
#define JitInstrumentationData_value 0x129
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR JitInstrumentationDataVerbose = {0x12a, 0x0, 0x0, 0x4, 0xc, 0x22, 0x10000000000};
#define JitInstrumentationDataVerbose_value 0x12a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ProfilerMessage = {0x12b, 0x0, 0x0, 0x4, 0xb, 0x24, 0x20000000000};
#define ProfilerMessage_value 0x12b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExecutionCheckpoint = {0x12c, 0x0, 0x0, 0x4, 0xb, 0x23, 0x20000000};
#define ExecutionCheckpoint_value 0x12c

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Microsoft_Windows_DotNETRuntimeEnableBits[2];
EXTERN_C __declspec(selectany) const ULONGLONG Microsoft_Windows_DotNETRuntimeKeywords[41] = {0x1, 0x1, 0x10001, 0x80000, 0x100000, 0x200000, 0x400000, 0x2, 0x2000000, 0x3f00003, 0x10000, 0x10000, 0x80010000, 0x80010000, 0x4000000000, 0x8000000000, 0x0, 0x200008000, 0x8000, 0x4000, 0x40000000, 0x800, 0x10800, 0x2000, 0x30, 0x2000000000, 0x10, 0x1000, 0x20000, 0x8, 0x20000008, 0x20000000, 0x400, 0x400, 0x100000000, 0x400000000, 0x800000000, 0x1000000000, 0x4, 0x10000000000, 0x20000000000};
EXTERN_C __declspec(selectany) const unsigned char Microsoft_Windows_DotNETRuntimeLevels[41] = {4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4, 2, 4, 4, 0, 4, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4, 5, 4, 4, 5, 4, 4, 4, 4, 4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context = {0, (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 41, Microsoft_Windows_DotNETRuntimeEnableBits, Microsoft_Windows_DotNETRuntimeKeywords, Microsoft_Windows_DotNETRuntimeLevels};

//
// Provider REGHANDLE
//
#define Microsoft_Windows_DotNETRuntimeHandle (MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterMicrosoft_Windows_DotNETRuntime
#define EventRegisterMicrosoft_Windows_DotNETRuntime() McGenEventRegister(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER, McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidMicrosoft_Windows_DotNETRuntime
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntime(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterMicrosoft_Windows_DotNETRuntime
#define EventUnregisterMicrosoft_Windows_DotNETRuntime() McGenEventUnregister(&Microsoft_Windows_DotNETRuntimeHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Microsoft_Windows_DotNETRuntime));
// - Caller registers the provider, e.g. EventRegisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Microsoft_Windows_DotNETRuntime {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Microsoft_Windows_DotNETRuntimeHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[2];
} McGenContext_Microsoft_Windows_DotNETRuntime;

#define EventRegisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntime_, MCGEN_EVENTREGISTER)(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER, pContext)
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntime_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntime_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Microsoft_Windows_DotNETRuntimeHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntime_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Microsoft_Windows_DotNETRuntime* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits;
    pContext->Context.EnableBitsCount = 41;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Microsoft_Windows_DotNETRuntimeKeywords;
    pContext->Context.EnableLevel = Microsoft_Windows_DotNETRuntimeLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Microsoft_Windows_DotNETRuntime*
_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(_In_ McGenContext_Microsoft_Windows_DotNETRuntime* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "GCStart"
//
#define EventXplatEnabledGCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCStart"
//
#define FireEtXplatGCStart(Count, Reason) \
        MCGEN_EVENT_ENABLED(GCStart) \
        ? _mcgen_TEMPLATE_FOR_GCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart, Count, Reason) : 0
#define FireEtXplatGCStart_AssumeEnabled(Count, Reason) \
        _mcgen_TEMPLATE_FOR_GCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart, Count, Reason)
#define FireEtXplatGCStart_ForContext(pContext, Count, Reason) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCStart) \
        ? _mcgen_TEMPLATE_FOR_GCStart(&(pContext)->Context, &GCStart, Count, Reason) : 0
#define FireEtXplatGCStart_ForContextAssumeEnabled(pContext, Count, Reason) \
        _mcgen_TEMPLATE_FOR_GCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCStart, Count, Reason)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCStart _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCStart_V1"
//
#define EventXplatEnabledGCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCStart_V1"
//
#define FireEtXplatGCStart_V1(Count, Depth, Reason, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID) : 0
#define FireEtXplatGCStart_V1_AssumeEnabled(Count, Depth, Reason, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID)
#define FireEtXplatGCStart_V1_ForContext(pContext, Count, Depth, Reason, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V1(&(pContext)->Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID) : 0
#define FireEtXplatGCStart_V1_ForContextAssumeEnabled(pContext, Count, Depth, Reason, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCStart_V1 _mcgen_PASTE2(McTemplateCoU0qqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCStart_V2"
//
#define EventXplatEnabledGCStart_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCStart_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCStart_V2"
//
#define FireEtXplatGCStart_V2(Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        MCGEN_EVENT_ENABLED(GCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) : 0
#define FireEtXplatGCStart_V2_AssumeEnabled(Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        _mcgen_TEMPLATE_FOR_GCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber)
#define FireEtXplatGCStart_V2_ForContext(pContext, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V2(&(pContext)->Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) : 0
#define FireEtXplatGCStart_V2_ForContextAssumeEnabled(pContext, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        _mcgen_TEMPLATE_FOR_GCStart_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCStart_V2 _mcgen_PASTE2(McTemplateCoU0qqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCEnd"
//
#define EventXplatEnabledGCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCEnd"
//
#define FireEtXplatGCEnd(Count, Depth) \
        MCGEN_EVENT_ENABLED(GCEnd) \
        ? _mcgen_TEMPLATE_FOR_GCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd, Count, Depth) : 0
#define FireEtXplatGCEnd_AssumeEnabled(Count, Depth) \
        _mcgen_TEMPLATE_FOR_GCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd, Count, Depth)
#define FireEtXplatGCEnd_ForContext(pContext, Count, Depth) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCEnd) \
        ? _mcgen_TEMPLATE_FOR_GCEnd(&(pContext)->Context, &GCEnd, Count, Depth) : 0
#define FireEtXplatGCEnd_ForContextAssumeEnabled(pContext, Count, Depth) \
        _mcgen_TEMPLATE_FOR_GCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCEnd, Count, Depth)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCEnd _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCEnd_V1"
//
#define EventXplatEnabledGCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCEnd_V1"
//
#define FireEtXplatGCEnd_V1(Count, Depth, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd_V1, Count, Depth, ClrInstanceID) : 0
#define FireEtXplatGCEnd_V1_AssumeEnabled(Count, Depth, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd_V1, Count, Depth, ClrInstanceID)
#define FireEtXplatGCEnd_V1_ForContext(pContext, Count, Depth, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCEnd_V1(&(pContext)->Context, &GCEnd_V1, Count, Depth, ClrInstanceID) : 0
#define FireEtXplatGCEnd_V1_ForContextAssumeEnabled(pContext, Count, Depth, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCEnd_V1, Count, Depth, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCEnd_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEEnd"
//
#define EventXplatEnabledGCRestartEEEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCRestartEEEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEEnd"
//
#define FireEtXplatGCRestartEEEnd() \
        MCGEN_EVENT_ENABLED(GCRestartEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd) : 0
#define FireEtXplatGCRestartEEEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd)
#define FireEtXplatGCRestartEEEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&(pContext)->Context, &GCRestartEEEnd) : 0
#define FireEtXplatGCRestartEEEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEEnd_V1"
//
#define EventXplatEnabledGCRestartEEEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCRestartEEEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEEnd_V1"
//
#define FireEtXplatGCRestartEEEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCRestartEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd_V1, ClrInstanceID) : 0
#define FireEtXplatGCRestartEEEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd_V1, ClrInstanceID)
#define FireEtXplatGCRestartEEEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&(pContext)->Context, &GCRestartEEEnd_V1, ClrInstanceID) : 0
#define FireEtXplatGCRestartEEEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCHeapStats"
//
#define EventXplatEnabledGCHeapStats() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCHeapStats_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCHeapStats"
//
#define FireEtXplatGCHeapStats(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        MCGEN_EVENT_ENABLED(GCHeapStats) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) : 0
#define FireEtXplatGCHeapStats_AssumeEnabled(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        _mcgen_TEMPLATE_FOR_GCHeapStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount)
#define FireEtXplatGCHeapStats_ForContext(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCHeapStats) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats(&(pContext)->Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) : 0
#define FireEtXplatGCHeapStats_ForContextAssumeEnabled(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        _mcgen_TEMPLATE_FOR_GCHeapStats(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCHeapStats _mcgen_PASTE2(McTemplateCoU0xxxxxxxxxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCHeapStats_V1"
//
#define EventXplatEnabledGCHeapStats_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCHeapStats_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCHeapStats_V1"
//
#define FireEtXplatGCHeapStats_V1(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCHeapStats_V1) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) : 0
#define FireEtXplatGCHeapStats_V1_AssumeEnabled(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID)
#define FireEtXplatGCHeapStats_V1_ForContext(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCHeapStats_V1) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&(pContext)->Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) : 0
#define FireEtXplatGCHeapStats_V1_ForContextAssumeEnabled(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCHeapStats_V1 _mcgen_PASTE2(McTemplateCoU0xxxxxxxxxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCHeapStats_V2"
//
#define EventXplatEnabledGCHeapStats_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCHeapStats_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCHeapStats_V2"
//
#define FireEtXplatGCHeapStats_V2(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4) \
        MCGEN_EVENT_ENABLED(GCHeapStats_V2) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats_V2, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4) : 0
#define FireEtXplatGCHeapStats_V2_AssumeEnabled(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4) \
        _mcgen_TEMPLATE_FOR_GCHeapStats_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats_V2, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4)
#define FireEtXplatGCHeapStats_V2_ForContext(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCHeapStats_V2) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats_V2(&(pContext)->Context, &GCHeapStats_V2, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4) : 0
#define FireEtXplatGCHeapStats_V2_ForContextAssumeEnabled(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4) \
        _mcgen_TEMPLATE_FOR_GCHeapStats_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCHeapStats_V2, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID, GenerationSize4, TotalPromotedSize4)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCHeapStats_V2 _mcgen_PASTE2(McTemplateCoU0xxxxxxxxxxqqqhxx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateSegment"
//
#define EventXplatEnabledGCCreateSegment() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCCreateSegment_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCCreateSegment"
//
#define FireEtXplatGCCreateSegment(Address, Size, Type) \
        MCGEN_EVENT_ENABLED(GCCreateSegment) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment, Address, Size, Type) : 0
#define FireEtXplatGCCreateSegment_AssumeEnabled(Address, Size, Type) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment, Address, Size, Type)
#define FireEtXplatGCCreateSegment_ForContext(pContext, Address, Size, Type) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateSegment) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment(&(pContext)->Context, &GCCreateSegment, Address, Size, Type) : 0
#define FireEtXplatGCCreateSegment_ForContextAssumeEnabled(pContext, Address, Size, Type) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateSegment, Address, Size, Type)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateSegment _mcgen_PASTE2(McTemplateCoU0xxq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateSegment_V1"
//
#define EventXplatEnabledGCCreateSegment_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCCreateSegment_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCCreateSegment_V1"
//
#define FireEtXplatGCCreateSegment_V1(Address, Size, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCCreateSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID) : 0
#define FireEtXplatGCCreateSegment_V1_AssumeEnabled(Address, Size, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID)
#define FireEtXplatGCCreateSegment_V1_ForContext(pContext, Address, Size, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&(pContext)->Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID) : 0
#define FireEtXplatGCCreateSegment_V1_ForContextAssumeEnabled(pContext, Address, Size, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateSegment_V1 _mcgen_PASTE2(McTemplateCoU0xxqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFreeSegment"
//
#define EventXplatEnabledGCFreeSegment() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCFreeSegment_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFreeSegment"
//
#define FireEtXplatGCFreeSegment(Address) \
        MCGEN_EVENT_ENABLED(GCFreeSegment) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment, Address) : 0
#define FireEtXplatGCFreeSegment_AssumeEnabled(Address) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment, Address)
#define FireEtXplatGCFreeSegment_ForContext(pContext, Address) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFreeSegment) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment(&(pContext)->Context, &GCFreeSegment, Address) : 0
#define FireEtXplatGCFreeSegment_ForContextAssumeEnabled(pContext, Address) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFreeSegment, Address)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFreeSegment _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFreeSegment_V1"
//
#define EventXplatEnabledGCFreeSegment_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCFreeSegment_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFreeSegment_V1"
//
#define FireEtXplatGCFreeSegment_V1(Address, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCFreeSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment_V1, Address, ClrInstanceID) : 0
#define FireEtXplatGCFreeSegment_V1_AssumeEnabled(Address, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment_V1, Address, ClrInstanceID)
#define FireEtXplatGCFreeSegment_V1_ForContext(pContext, Address, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFreeSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&(pContext)->Context, &GCFreeSegment_V1, Address, ClrInstanceID) : 0
#define FireEtXplatGCFreeSegment_V1_ForContextAssumeEnabled(pContext, Address, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFreeSegment_V1, Address, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFreeSegment_V1 _mcgen_PASTE2(McTemplateCoU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEBegin"
//
#define EventXplatEnabledGCRestartEEBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCRestartEEBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEBegin"
//
#define FireEtXplatGCRestartEEBegin() \
        MCGEN_EVENT_ENABLED(GCRestartEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin) : 0
#define FireEtXplatGCRestartEEBegin_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin)
#define FireEtXplatGCRestartEEBegin_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&(pContext)->Context, &GCRestartEEBegin) : 0
#define FireEtXplatGCRestartEEBegin_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEBegin)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEBegin _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEBegin_V1"
//
#define EventXplatEnabledGCRestartEEBegin_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCRestartEEBegin_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEBegin_V1"
//
#define FireEtXplatGCRestartEEBegin_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCRestartEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin_V1, ClrInstanceID) : 0
#define FireEtXplatGCRestartEEBegin_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin_V1, ClrInstanceID)
#define FireEtXplatGCRestartEEBegin_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&(pContext)->Context, &GCRestartEEBegin_V1, ClrInstanceID) : 0
#define FireEtXplatGCRestartEEBegin_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEBegin_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEEnd"
//
#define EventXplatEnabledGCSuspendEEEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCSuspendEEEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEEnd"
//
#define FireEtXplatGCSuspendEEEnd() \
        MCGEN_EVENT_ENABLED(GCSuspendEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd) : 0
#define FireEtXplatGCSuspendEEEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd)
#define FireEtXplatGCSuspendEEEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&(pContext)->Context, &GCSuspendEEEnd) : 0
#define FireEtXplatGCSuspendEEEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEEnd_V1"
//
#define EventXplatEnabledGCSuspendEEEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCSuspendEEEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEEnd_V1"
//
#define FireEtXplatGCSuspendEEEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSuspendEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd_V1, ClrInstanceID) : 0
#define FireEtXplatGCSuspendEEEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd_V1, ClrInstanceID)
#define FireEtXplatGCSuspendEEEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&(pContext)->Context, &GCSuspendEEEnd_V1, ClrInstanceID) : 0
#define FireEtXplatGCSuspendEEEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEBegin"
//
#define EventXplatEnabledGCSuspendEEBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCSuspendEEBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEBegin"
//
#define FireEtXplatGCSuspendEEBegin(Reason) \
        MCGEN_EVENT_ENABLED(GCSuspendEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin, Reason) : 0
#define FireEtXplatGCSuspendEEBegin_AssumeEnabled(Reason) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin, Reason)
#define FireEtXplatGCSuspendEEBegin_ForContext(pContext, Reason) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&(pContext)->Context, &GCSuspendEEBegin, Reason) : 0
#define FireEtXplatGCSuspendEEBegin_ForContextAssumeEnabled(pContext, Reason) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEBegin, Reason)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEBegin _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEBegin_V1"
//
#define EventXplatEnabledGCSuspendEEBegin_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCSuspendEEBegin_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEBegin_V1"
//
#define FireEtXplatGCSuspendEEBegin_V1(Reason, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSuspendEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID) : 0
#define FireEtXplatGCSuspendEEBegin_V1_AssumeEnabled(Reason, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID)
#define FireEtXplatGCSuspendEEBegin_V1_ForContext(pContext, Reason, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&(pContext)->Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID) : 0
#define FireEtXplatGCSuspendEEBegin_V1_ForContextAssumeEnabled(pContext, Reason, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick"
//
#define EventXplatEnabledGCAllocationTick() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledGCAllocationTick_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick"
//
#define FireEtXplatGCAllocationTick(AllocationAmount, AllocationKind) \
        MCGEN_EVENT_ENABLED(GCAllocationTick) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick, AllocationAmount, AllocationKind) : 0
#define FireEtXplatGCAllocationTick_AssumeEnabled(AllocationAmount, AllocationKind) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick, AllocationAmount, AllocationKind)
#define FireEtXplatGCAllocationTick_ForContext(pContext, AllocationAmount, AllocationKind) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick(&(pContext)->Context, &GCAllocationTick, AllocationAmount, AllocationKind) : 0
#define FireEtXplatGCAllocationTick_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick, AllocationAmount, AllocationKind)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick_V1"
//
#define EventXplatEnabledGCAllocationTick_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledGCAllocationTick_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick_V1"
//
#define FireEtXplatGCAllocationTick_V1(AllocationAmount, AllocationKind, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCAllocationTick_V1) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID) : 0
#define FireEtXplatGCAllocationTick_V1_AssumeEnabled(AllocationAmount, AllocationKind, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID)
#define FireEtXplatGCAllocationTick_V1_ForContext(pContext, AllocationAmount, AllocationKind, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick_V1) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&(pContext)->Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID) : 0
#define FireEtXplatGCAllocationTick_V1_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick_V2"
//
#define EventXplatEnabledGCAllocationTick_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledGCAllocationTick_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick_V2"
//
#define FireEtXplatGCAllocationTick_V2(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        MCGEN_EVENT_ENABLED(GCAllocationTick_V2) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) : 0
#define FireEtXplatGCAllocationTick_V2_AssumeEnabled(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex)
#define FireEtXplatGCAllocationTick_V2_ForContext(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick_V2) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&(pContext)->Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) : 0
#define FireEtXplatGCAllocationTick_V2_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick_V2 _mcgen_PASTE2(McTemplateCoU0qqhxpzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick_V3"
//
#define EventXplatEnabledGCAllocationTick_V3() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledGCAllocationTick_V3_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick_V3"
//
#define FireEtXplatGCAllocationTick_V3(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        MCGEN_EVENT_ENABLED(GCAllocationTick_V3) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) : 0
#define FireEtXplatGCAllocationTick_V3_AssumeEnabled(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address)
#define FireEtXplatGCAllocationTick_V3_ForContext(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick_V3) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&(pContext)->Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) : 0
#define FireEtXplatGCAllocationTick_V3_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick_V3 _mcgen_PASTE2(McTemplateCoU0qqhxpzqp_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick_V4"
//
#define EventXplatEnabledGCAllocationTick_V4() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledGCAllocationTick_V4_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick_V4"
//
#define FireEtXplatGCAllocationTick_V4(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize) \
        MCGEN_EVENT_ENABLED(GCAllocationTick_V4) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V4(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V4, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize) : 0
#define FireEtXplatGCAllocationTick_V4_AssumeEnabled(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V4(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V4, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize)
#define FireEtXplatGCAllocationTick_V4_ForContext(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick_V4) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V4(&(pContext)->Context, &GCAllocationTick_V4, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize) : 0
#define FireEtXplatGCAllocationTick_V4_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V4(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick_V4, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address, ObjectSize)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick_V4 _mcgen_PASTE2(McTemplateCoU0qqhxpzqpx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateConcurrentThread"
//
#define EventXplatEnabledGCCreateConcurrentThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCCreateConcurrentThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCCreateConcurrentThread"
//
#define FireEtXplatGCCreateConcurrentThread() \
        MCGEN_EVENT_ENABLED(GCCreateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread) : 0
#define FireEtXplatGCCreateConcurrentThread_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread)
#define FireEtXplatGCCreateConcurrentThread_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&(pContext)->Context, &GCCreateConcurrentThread) : 0
#define FireEtXplatGCCreateConcurrentThread_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateConcurrentThread)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateConcurrentThread_V1"
//
#define EventXplatEnabledGCCreateConcurrentThread_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 2)
#define EventXplatEnabledGCCreateConcurrentThread_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 2)

//
// Event write macros for event "GCCreateConcurrentThread_V1"
//
#define FireEtXplatGCCreateConcurrentThread_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCCreateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread_V1, ClrInstanceID) : 0
#define FireEtXplatGCCreateConcurrentThread_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread_V1, ClrInstanceID)
#define FireEtXplatGCCreateConcurrentThread_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&(pContext)->Context, &GCCreateConcurrentThread_V1, ClrInstanceID) : 0
#define FireEtXplatGCCreateConcurrentThread_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateConcurrentThread_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCTerminateConcurrentThread"
//
#define EventXplatEnabledGCTerminateConcurrentThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCTerminateConcurrentThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCTerminateConcurrentThread"
//
#define FireEtXplatGCTerminateConcurrentThread() \
        MCGEN_EVENT_ENABLED(GCTerminateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread) : 0
#define FireEtXplatGCTerminateConcurrentThread_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread)
#define FireEtXplatGCTerminateConcurrentThread_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCTerminateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&(pContext)->Context, &GCTerminateConcurrentThread) : 0
#define FireEtXplatGCTerminateConcurrentThread_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCTerminateConcurrentThread)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCTerminateConcurrentThread_V1"
//
#define EventXplatEnabledGCTerminateConcurrentThread_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 2)
#define EventXplatEnabledGCTerminateConcurrentThread_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 2)

//
// Event write macros for event "GCTerminateConcurrentThread_V1"
//
#define FireEtXplatGCTerminateConcurrentThread_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCTerminateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread_V1, ClrInstanceID) : 0
#define FireEtXplatGCTerminateConcurrentThread_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread_V1, ClrInstanceID)
#define FireEtXplatGCTerminateConcurrentThread_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCTerminateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&(pContext)->Context, &GCTerminateConcurrentThread_V1, ClrInstanceID) : 0
#define FireEtXplatGCTerminateConcurrentThread_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCTerminateConcurrentThread_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersEnd"
//
#define EventXplatEnabledGCFinalizersEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCFinalizersEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersEnd"
//
#define FireEtXplatGCFinalizersEnd(Count) \
        MCGEN_EVENT_ENABLED(GCFinalizersEnd) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd, Count) : 0
#define FireEtXplatGCFinalizersEnd_AssumeEnabled(Count) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd, Count)
#define FireEtXplatGCFinalizersEnd_ForContext(pContext, Count) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersEnd) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&(pContext)->Context, &GCFinalizersEnd, Count) : 0
#define FireEtXplatGCFinalizersEnd_ForContextAssumeEnabled(pContext, Count) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersEnd, Count)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersEnd _mcgen_PASTE2(McTemplateCoU0q_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersEnd_V1"
//
#define EventXplatEnabledGCFinalizersEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCFinalizersEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersEnd_V1"
//
#define FireEtXplatGCFinalizersEnd_V1(Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCFinalizersEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd_V1, Count, ClrInstanceID) : 0
#define FireEtXplatGCFinalizersEnd_V1_AssumeEnabled(Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd_V1, Count, ClrInstanceID)
#define FireEtXplatGCFinalizersEnd_V1_ForContext(pContext, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&(pContext)->Context, &GCFinalizersEnd_V1, Count, ClrInstanceID) : 0
#define FireEtXplatGCFinalizersEnd_V1_ForContextAssumeEnabled(pContext, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersEnd_V1, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1 _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersBegin"
//
#define EventXplatEnabledGCFinalizersBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCFinalizersBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersBegin"
//
#define FireEtXplatGCFinalizersBegin() \
        MCGEN_EVENT_ENABLED(GCFinalizersBegin) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin) : 0
#define FireEtXplatGCFinalizersBegin_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin)
#define FireEtXplatGCFinalizersBegin_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersBegin) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&(pContext)->Context, &GCFinalizersBegin) : 0
#define FireEtXplatGCFinalizersBegin_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersBegin)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersBegin _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersBegin_V1"
//
#define EventXplatEnabledGCFinalizersBegin_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCFinalizersBegin_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersBegin_V1"
//
#define FireEtXplatGCFinalizersBegin_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCFinalizersBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin_V1, ClrInstanceID) : 0
#define FireEtXplatGCFinalizersBegin_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin_V1, ClrInstanceID)
#define FireEtXplatGCFinalizersBegin_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&(pContext)->Context, &GCFinalizersBegin_V1, ClrInstanceID) : 0
#define FireEtXplatGCFinalizersBegin_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersBegin_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BulkType"
//
#define EventXplatEnabledBulkType() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 3)
#define EventXplatEnabledBulkType_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 3)

//
// Event write macros for event "BulkType"
//
#define FireEtXplatBulkType(Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(BulkType) \
        ? _mcgen_TEMPLATE_FOR_BulkType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatBulkType_AssumeEnabled(Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_BulkType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatBulkType_ForContext(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BulkType) \
        ? _mcgen_TEMPLATE_FOR_BulkType(&(pContext)->Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatBulkType_ForContextAssumeEnabled(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_BulkType(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BulkType _mcgen_PASTE2(McTemplateCoU0qhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootEdge"
//
#define EventXplatEnabledGCBulkRootEdge() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGCBulkRootEdge_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootEdge"
//
#define FireEtXplatGCBulkRootEdge(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootEdge_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkRootEdge_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&(pContext)->Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootEdge_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootEdge _mcgen_PASTE2(McTemplateCoU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootConditionalWeakTableElementEdge"
//
#define EventXplatEnabledGCBulkRootConditionalWeakTableElementEdge() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGCBulkRootConditionalWeakTableElementEdge_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootConditionalWeakTableElementEdge"
//
#define FireEtXplatGCBulkRootConditionalWeakTableElementEdge(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootConditionalWeakTableElementEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootConditionalWeakTableElementEdge_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkRootConditionalWeakTableElementEdge_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootConditionalWeakTableElementEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&(pContext)->Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootConditionalWeakTableElementEdge_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge _mcgen_PASTE2(McTemplateCoU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkNode"
//
#define EventXplatEnabledGCBulkNode() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGCBulkNode_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkNode"
//
#define FireEtXplatGCBulkNode(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkNode) \
        ? _mcgen_TEMPLATE_FOR_GCBulkNode(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkNode_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkNode(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkNode_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkNode) \
        ? _mcgen_TEMPLATE_FOR_GCBulkNode(&(pContext)->Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkNode_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkNode(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkNode _mcgen_PASTE2(McTemplateCoU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkEdge"
//
#define EventXplatEnabledGCBulkEdge() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGCBulkEdge_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkEdge"
//
#define FireEtXplatGCBulkEdge(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkEdge_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkEdge_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkEdge(&(pContext)->Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkEdge_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkEdge(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkEdge _mcgen_PASTE2(McTemplateCoU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSampledObjectAllocationHigh"
//
#define EventXplatEnabledGCSampledObjectAllocationHigh() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 5)
#define EventXplatEnabledGCSampledObjectAllocationHigh_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 5)

//
// Event write macros for event "GCSampledObjectAllocationHigh"
//
#define FireEtXplatGCSampledObjectAllocationHigh(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSampledObjectAllocationHigh) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define FireEtXplatGCSampledObjectAllocationHigh_AssumeEnabled(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)
#define FireEtXplatGCSampledObjectAllocationHigh_ForContext(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSampledObjectAllocationHigh) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&(pContext)->Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define FireEtXplatGCSampledObjectAllocationHigh_ForContextAssumeEnabled(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh _mcgen_PASTE2(McTemplateCoU0ppqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkSurvivingObjectRanges"
//
#define EventXplatEnabledGCBulkSurvivingObjectRanges() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 6)
#define EventXplatEnabledGCBulkSurvivingObjectRanges_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 6)

//
// Event write macros for event "GCBulkSurvivingObjectRanges"
//
#define FireEtXplatGCBulkSurvivingObjectRanges(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkSurvivingObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkSurvivingObjectRanges_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkSurvivingObjectRanges_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkSurvivingObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&(pContext)->Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkSurvivingObjectRanges_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges _mcgen_PASTE2(McTemplateCoU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkMovedObjectRanges"
//
#define EventXplatEnabledGCBulkMovedObjectRanges() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 6)
#define EventXplatEnabledGCBulkMovedObjectRanges_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 6)

//
// Event write macros for event "GCBulkMovedObjectRanges"
//
#define FireEtXplatGCBulkMovedObjectRanges(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkMovedObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkMovedObjectRanges_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkMovedObjectRanges_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkMovedObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&(pContext)->Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkMovedObjectRanges_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges _mcgen_PASTE2(McTemplateCoU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGenerationRange"
//
#define EventXplatEnabledGCGenerationRange() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 6)
#define EventXplatEnabledGCGenerationRange_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 6)

//
// Event write macros for event "GCGenerationRange"
//
#define FireEtXplatGCGenerationRange(Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCGenerationRange) \
        ? _mcgen_TEMPLATE_FOR_GCGenerationRange(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) : 0
#define FireEtXplatGCGenerationRange_AssumeEnabled(Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCGenerationRange(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID)
#define FireEtXplatGCGenerationRange_ForContext(pContext, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGenerationRange) \
        ? _mcgen_TEMPLATE_FOR_GCGenerationRange(&(pContext)->Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) : 0
#define FireEtXplatGCGenerationRange_ForContextAssumeEnabled(pContext, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCGenerationRange(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGenerationRange _mcgen_PASTE2(McTemplateCoU0upxxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkStackRoots"
//
#define EventXplatEnabledGCMarkStackRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCMarkStackRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkStackRoots"
//
#define FireEtXplatGCMarkStackRoots(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkStackRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkStackRoots, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkStackRoots_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkStackRoots, HeapNum, ClrInstanceID)
#define FireEtXplatGCMarkStackRoots_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkStackRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&(pContext)->Context, &GCMarkStackRoots, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkStackRoots_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkStackRoots, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkStackRoots _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkFinalizeQueueRoots"
//
#define EventXplatEnabledGCMarkFinalizeQueueRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCMarkFinalizeQueueRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkFinalizeQueueRoots"
//
#define FireEtXplatGCMarkFinalizeQueueRoots(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkFinalizeQueueRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkFinalizeQueueRoots_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID)
#define FireEtXplatGCMarkFinalizeQueueRoots_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkFinalizeQueueRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&(pContext)->Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkFinalizeQueueRoots_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkHandles"
//
#define EventXplatEnabledGCMarkHandles() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCMarkHandles_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkHandles"
//
#define FireEtXplatGCMarkHandles(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkHandles) \
        ? _mcgen_TEMPLATE_FOR_GCMarkHandles(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkHandles, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkHandles_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkHandles(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkHandles, HeapNum, ClrInstanceID)
#define FireEtXplatGCMarkHandles_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkHandles) \
        ? _mcgen_TEMPLATE_FOR_GCMarkHandles(&(pContext)->Context, &GCMarkHandles, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkHandles_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkHandles(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkHandles, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkHandles _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkOlderGenerationRoots"
//
#define EventXplatEnabledGCMarkOlderGenerationRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCMarkOlderGenerationRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkOlderGenerationRoots"
//
#define FireEtXplatGCMarkOlderGenerationRoots(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkOlderGenerationRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkOlderGenerationRoots_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID)
#define FireEtXplatGCMarkOlderGenerationRoots_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkOlderGenerationRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&(pContext)->Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID) : 0
#define FireEtXplatGCMarkOlderGenerationRoots_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FinalizeObject"
//
#define EventXplatEnabledFinalizeObject() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledFinalizeObject_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "FinalizeObject"
//
#define FireEtXplatFinalizeObject(TypeID, ObjectID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FinalizeObject) \
        ? _mcgen_TEMPLATE_FOR_FinalizeObject(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID) : 0
#define FireEtXplatFinalizeObject_AssumeEnabled(TypeID, ObjectID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FinalizeObject(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID)
#define FireEtXplatFinalizeObject_ForContext(pContext, TypeID, ObjectID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FinalizeObject) \
        ? _mcgen_TEMPLATE_FOR_FinalizeObject(&(pContext)->Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID) : 0
#define FireEtXplatFinalizeObject_ForContextAssumeEnabled(pContext, TypeID, ObjectID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FinalizeObject(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FinalizeObject _mcgen_PASTE2(McTemplateCoU0pph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SetGCHandle"
//
#define EventXplatEnabledSetGCHandle() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 7)
#define EventXplatEnabledSetGCHandle_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 7)

//
// Event write macros for event "SetGCHandle"
//
#define FireEtXplatSetGCHandle(HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(SetGCHandle) \
        ? _mcgen_TEMPLATE_FOR_SetGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatSetGCHandle_AssumeEnabled(HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SetGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID)
#define FireEtXplatSetGCHandle_ForContext(pContext, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SetGCHandle) \
        ? _mcgen_TEMPLATE_FOR_SetGCHandle(&(pContext)->Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatSetGCHandle_ForContextAssumeEnabled(pContext, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SetGCHandle(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SetGCHandle _mcgen_PASTE2(McTemplateCoU0ppqqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DestroyGCHandle"
//
#define EventXplatEnabledDestroyGCHandle() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 7)
#define EventXplatEnabledDestroyGCHandle_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 7)

//
// Event write macros for event "DestroyGCHandle"
//
#define FireEtXplatDestroyGCHandle(HandleID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DestroyGCHandle) \
        ? _mcgen_TEMPLATE_FOR_DestroyGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DestroyGCHandle, HandleID, ClrInstanceID) : 0
#define FireEtXplatDestroyGCHandle_AssumeEnabled(HandleID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DestroyGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DestroyGCHandle, HandleID, ClrInstanceID)
#define FireEtXplatDestroyGCHandle_ForContext(pContext, HandleID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DestroyGCHandle) \
        ? _mcgen_TEMPLATE_FOR_DestroyGCHandle(&(pContext)->Context, &DestroyGCHandle, HandleID, ClrInstanceID) : 0
#define FireEtXplatDestroyGCHandle_ForContextAssumeEnabled(pContext, HandleID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DestroyGCHandle(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DestroyGCHandle, HandleID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DestroyGCHandle _mcgen_PASTE2(McTemplateCoU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSampledObjectAllocationLow"
//
#define EventXplatEnabledGCSampledObjectAllocationLow() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 8)
#define EventXplatEnabledGCSampledObjectAllocationLow_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 8)

//
// Event write macros for event "GCSampledObjectAllocationLow"
//
#define FireEtXplatGCSampledObjectAllocationLow(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSampledObjectAllocationLow) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define FireEtXplatGCSampledObjectAllocationLow_AssumeEnabled(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)
#define FireEtXplatGCSampledObjectAllocationLow_ForContext(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSampledObjectAllocationLow) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&(pContext)->Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define FireEtXplatGCSampledObjectAllocationLow_ForContextAssumeEnabled(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow _mcgen_PASTE2(McTemplateCoU0ppqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PinObjectAtGCTime"
//
#define EventXplatEnabledPinObjectAtGCTime() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledPinObjectAtGCTime_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "PinObjectAtGCTime"
//
#define FireEtXplatPinObjectAtGCTime(HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PinObjectAtGCTime) \
        ? _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) : 0
#define FireEtXplatPinObjectAtGCTime_AssumeEnabled(HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID)
#define FireEtXplatPinObjectAtGCTime_ForContext(pContext, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PinObjectAtGCTime) \
        ? _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&(pContext)->Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) : 0
#define FireEtXplatPinObjectAtGCTime_ForContextAssumeEnabled(pContext, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PinObjectAtGCTime _mcgen_PASTE2(McTemplateCoU0ppxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCTriggered"
//
#define EventXplatEnabledGCTriggered() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCTriggered_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCTriggered"
//
#define FireEtXplatGCTriggered(Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCTriggered) \
        ? _mcgen_TEMPLATE_FOR_GCTriggered(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTriggered, Reason, ClrInstanceID) : 0
#define FireEtXplatGCTriggered_AssumeEnabled(Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTriggered(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTriggered, Reason, ClrInstanceID)
#define FireEtXplatGCTriggered_ForContext(pContext, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCTriggered) \
        ? _mcgen_TEMPLATE_FOR_GCTriggered(&(pContext)->Context, &GCTriggered, Reason, ClrInstanceID) : 0
#define FireEtXplatGCTriggered_ForContextAssumeEnabled(pContext, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTriggered(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCTriggered, Reason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCTriggered _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootCCW"
//
#define EventXplatEnabledGCBulkRootCCW() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGCBulkRootCCW_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootCCW"
//
#define FireEtXplatGCBulkRootCCW(Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootCCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootCCW_AssumeEnabled(Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkRootCCW_ForContext(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootCCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&(pContext)->Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootCCW_ForContextAssumeEnabled(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootCCW _mcgen_PASTE2(McTemplateCoU0qhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRCW"
//
#define EventXplatEnabledGCBulkRCW() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGCBulkRCW_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRCW"
//
#define FireEtXplatGCBulkRCW(Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRCW_AssumeEnabled(Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkRCW_ForContext(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRCW(&(pContext)->Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRCW_ForContextAssumeEnabled(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRCW(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRCW _mcgen_PASTE2(McTemplateCoU0qhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootStaticVar"
//
#define EventXplatEnabledGCBulkRootStaticVar() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGCBulkRootStaticVar_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootStaticVar"
//
#define FireEtXplatGCBulkRootStaticVar(Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootStaticVar) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootStaticVar_AssumeEnabled(Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values)
#define FireEtXplatGCBulkRootStaticVar_ForContext(pContext, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootStaticVar) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&(pContext)->Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) : 0
#define FireEtXplatGCBulkRootStaticVar_ForContextAssumeEnabled(pContext, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar _mcgen_PASTE2(McTemplateCoU0qxhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCDynamicEvent"
//
#define EventXplatEnabledGCDynamicEvent() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 9)
#define EventXplatEnabledGCDynamicEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 9)

//
// Event write macros for event "GCDynamicEvent"
//
#define FireEtXplatGCDynamicEvent(Name, DataSize, Data, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCDynamicEvent) \
        ? _mcgen_TEMPLATE_FOR_GCDynamicEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID) : 0
#define FireEtXplatGCDynamicEvent_AssumeEnabled(Name, DataSize, Data, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCDynamicEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID)
#define FireEtXplatGCDynamicEvent_ForContext(pContext, Name, DataSize, Data, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCDynamicEvent) \
        ? _mcgen_TEMPLATE_FOR_GCDynamicEvent(&(pContext)->Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID) : 0
#define FireEtXplatGCDynamicEvent_ForContextAssumeEnabled(pContext, Name, DataSize, Data, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCDynamicEvent(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCDynamicEvent _mcgen_PASTE2(McTemplateCoU0zqbr1h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadCreate"
//
#define EventXplatEnabledWorkerThreadCreate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledWorkerThreadCreate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadCreate"
//
#define FireEtXplatWorkerThreadCreate(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadCreate_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads)
#define FireEtXplatWorkerThreadCreate_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&(pContext)->Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadCreate_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadCreate _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadTerminate"
//
#define EventXplatEnabledWorkerThreadTerminate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledWorkerThreadTerminate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadTerminate"
//
#define FireEtXplatWorkerThreadTerminate(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadTerminate_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads)
#define FireEtXplatWorkerThreadTerminate_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&(pContext)->Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadTerminate_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadTerminate _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadRetire"
//
#define EventXplatEnabledWorkerThreadRetire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledWorkerThreadRetire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadRetire"
//
#define FireEtXplatWorkerThreadRetire(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadRetire_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads)
#define FireEtXplatWorkerThreadRetire_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&(pContext)->Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadRetire_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadRetire _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadUnretire"
//
#define EventXplatEnabledWorkerThreadUnretire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledWorkerThreadUnretire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadUnretire"
//
#define FireEtXplatWorkerThreadUnretire(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadUnretire_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads)
#define FireEtXplatWorkerThreadUnretire_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&(pContext)->Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define FireEtXplatWorkerThreadUnretire_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadUnretire _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadCreate"
//
#define EventXplatEnabledIOThreadCreate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadCreate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadCreate"
//
#define FireEtXplatIOThreadCreate(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadCreate_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads)
#define FireEtXplatIOThreadCreate_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate(&(pContext)->Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadCreate_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadCreate _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadCreate_V1"
//
#define EventXplatEnabledIOThreadCreate_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadCreate_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadCreate_V1"
//
#define FireEtXplatIOThreadCreate_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadCreate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadCreate_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define FireEtXplatIOThreadCreate_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadCreate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&(pContext)->Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadCreate_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadCreate_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadTerminate"
//
#define EventXplatEnabledIOThreadTerminate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadTerminate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadTerminate"
//
#define FireEtXplatIOThreadTerminate(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadTerminate_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads)
#define FireEtXplatIOThreadTerminate_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate(&(pContext)->Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadTerminate_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadTerminate _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadTerminate_V1"
//
#define EventXplatEnabledIOThreadTerminate_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadTerminate_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadTerminate_V1"
//
#define FireEtXplatIOThreadTerminate_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadTerminate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadTerminate_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define FireEtXplatIOThreadTerminate_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadTerminate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&(pContext)->Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadTerminate_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadRetire"
//
#define EventXplatEnabledIOThreadRetire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadRetire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadRetire"
//
#define FireEtXplatIOThreadRetire(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadRetire_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads)
#define FireEtXplatIOThreadRetire_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire(&(pContext)->Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadRetire_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadRetire _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadRetire_V1"
//
#define EventXplatEnabledIOThreadRetire_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadRetire_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadRetire_V1"
//
#define FireEtXplatIOThreadRetire_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadRetire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadRetire_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define FireEtXplatIOThreadRetire_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadRetire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&(pContext)->Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadRetire_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadRetire_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadUnretire"
//
#define EventXplatEnabledIOThreadUnretire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadUnretire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadUnretire"
//
#define FireEtXplatIOThreadUnretire(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadUnretire_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads)
#define FireEtXplatIOThreadUnretire_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire(&(pContext)->Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads) : 0
#define FireEtXplatIOThreadUnretire_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadUnretire _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadUnretire_V1"
//
#define EventXplatEnabledIOThreadUnretire_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledIOThreadUnretire_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadUnretire_V1"
//
#define FireEtXplatIOThreadUnretire_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadUnretire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadUnretire_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define FireEtXplatIOThreadUnretire_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadUnretire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&(pContext)->Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define FireEtXplatIOThreadUnretire_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadpoolSuspensionSuspendThread"
//
#define EventXplatEnabledThreadpoolSuspensionSuspendThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadpoolSuspensionSuspendThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadpoolSuspensionSuspendThread"
//
#define FireEtXplatThreadpoolSuspensionSuspendThread(ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED(ThreadpoolSuspensionSuspendThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization) : 0
#define FireEtXplatThreadpoolSuspensionSuspendThread_AssumeEnabled(ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization)
#define FireEtXplatThreadpoolSuspensionSuspendThread_ForContext(pContext, ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadpoolSuspensionSuspendThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&(pContext)->Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization) : 0
#define FireEtXplatThreadpoolSuspensionSuspendThread_ForContextAssumeEnabled(pContext, ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadpoolSuspensionResumeThread"
//
#define EventXplatEnabledThreadpoolSuspensionResumeThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadpoolSuspensionResumeThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadpoolSuspensionResumeThread"
//
#define FireEtXplatThreadpoolSuspensionResumeThread(ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED(ThreadpoolSuspensionResumeThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization) : 0
#define FireEtXplatThreadpoolSuspensionResumeThread_AssumeEnabled(ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization)
#define FireEtXplatThreadpoolSuspensionResumeThread_ForContext(pContext, ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadpoolSuspensionResumeThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&(pContext)->Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization) : 0
#define FireEtXplatThreadpoolSuspensionResumeThread_ForContextAssumeEnabled(pContext, ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadStart"
//
#define EventXplatEnabledThreadPoolWorkerThreadStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolWorkerThreadStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadStart"
//
#define FireEtXplatThreadPoolWorkerThreadStart(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadStart_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadStart_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&(pContext)->Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadStart_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadStop"
//
#define EventXplatEnabledThreadPoolWorkerThreadStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolWorkerThreadStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadStop"
//
#define FireEtXplatThreadPoolWorkerThreadStop(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadStop_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadStop_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&(pContext)->Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadStop_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadRetirementStart"
//
#define EventXplatEnabledThreadPoolWorkerThreadRetirementStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolWorkerThreadRetirementStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadRetirementStart"
//
#define FireEtXplatThreadPoolWorkerThreadRetirementStart(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadRetirementStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadRetirementStart_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadRetirementStart_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadRetirementStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&(pContext)->Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadRetirementStart_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadRetirementStop"
//
#define EventXplatEnabledThreadPoolWorkerThreadRetirementStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolWorkerThreadRetirementStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadRetirementStop"
//
#define FireEtXplatThreadPoolWorkerThreadRetirementStop(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadRetirementStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadRetirementStop_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadRetirementStop_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadRetirementStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&(pContext)->Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadRetirementStop_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadAdjustmentSample"
//
#define EventXplatEnabledThreadPoolWorkerThreadAdjustmentSample() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolWorkerThreadAdjustmentSample_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadAdjustmentSample"
//
#define FireEtXplatThreadPoolWorkerThreadAdjustmentSample(Throughput, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadAdjustmentSample) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadAdjustmentSample_AssumeEnabled(Throughput, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadAdjustmentSample_ForContext(pContext, Throughput, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadAdjustmentSample) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadAdjustmentSample_ForContextAssumeEnabled(pContext, Throughput, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample _mcgen_PASTE2(McTemplateCoU0gh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadAdjustmentAdjustment"
//
#define EventXplatEnabledThreadPoolWorkerThreadAdjustmentAdjustment() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolWorkerThreadAdjustmentAdjustment_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadAdjustmentAdjustment"
//
#define FireEtXplatThreadPoolWorkerThreadAdjustmentAdjustment(AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadAdjustmentAdjustment) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadAdjustmentAdjustment_AssumeEnabled(AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadAdjustmentAdjustment_ForContext(pContext, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadAdjustmentAdjustment) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadAdjustmentAdjustment_ForContextAssumeEnabled(pContext, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment _mcgen_PASTE2(McTemplateCoU0gqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadAdjustmentStats"
//
#define EventXplatEnabledThreadPoolWorkerThreadAdjustmentStats() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 11)
#define EventXplatEnabledThreadPoolWorkerThreadAdjustmentStats_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 11)

//
// Event write macros for event "ThreadPoolWorkerThreadAdjustmentStats"
//
#define FireEtXplatThreadPoolWorkerThreadAdjustmentStats(Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadAdjustmentStats) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadAdjustmentStats_AssumeEnabled(Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadAdjustmentStats_ForContext(pContext, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadAdjustmentStats) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadAdjustmentStats_ForContextAssumeEnabled(pContext, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats _mcgen_PASTE2(McTemplateCoU0ggggggggghh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadWait"
//
#define EventXplatEnabledThreadPoolWorkerThreadWait() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolWorkerThreadWait_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadWait"
//
#define FireEtXplatThreadPoolWorkerThreadWait(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadWait) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadWait_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define FireEtXplatThreadPoolWorkerThreadWait_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadWait) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&(pContext)->Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkerThreadWait_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "YieldProcessorMeasurement"
//
#define EventXplatEnabledYieldProcessorMeasurement() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledYieldProcessorMeasurement_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "YieldProcessorMeasurement"
//
#define FireEtXplatYieldProcessorMeasurement(ClrInstanceID, NsPerYield, EstablishedNsPerYield) \
        MCGEN_EVENT_ENABLED(YieldProcessorMeasurement) \
        ? _mcgen_TEMPLATE_FOR_YieldProcessorMeasurement(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &YieldProcessorMeasurement, ClrInstanceID, NsPerYield, EstablishedNsPerYield) : 0
#define FireEtXplatYieldProcessorMeasurement_AssumeEnabled(ClrInstanceID, NsPerYield, EstablishedNsPerYield) \
        _mcgen_TEMPLATE_FOR_YieldProcessorMeasurement(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &YieldProcessorMeasurement, ClrInstanceID, NsPerYield, EstablishedNsPerYield)
#define FireEtXplatYieldProcessorMeasurement_ForContext(pContext, ClrInstanceID, NsPerYield, EstablishedNsPerYield) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, YieldProcessorMeasurement) \
        ? _mcgen_TEMPLATE_FOR_YieldProcessorMeasurement(&(pContext)->Context, &YieldProcessorMeasurement, ClrInstanceID, NsPerYield, EstablishedNsPerYield) : 0
#define FireEtXplatYieldProcessorMeasurement_ForContextAssumeEnabled(pContext, ClrInstanceID, NsPerYield, EstablishedNsPerYield) \
        _mcgen_TEMPLATE_FOR_YieldProcessorMeasurement(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &YieldProcessorMeasurement, ClrInstanceID, NsPerYield, EstablishedNsPerYield)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_YieldProcessorMeasurement _mcgen_PASTE2(McTemplateCoU0hgg_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolMinMaxThreads"
//
#define EventXplatEnabledThreadPoolMinMaxThreads() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventXplatEnabledThreadPoolMinMaxThreads_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolMinMaxThreads"
//
#define FireEtXplatThreadPoolMinMaxThreads(MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolMinMaxThreads) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolMinMaxThreads(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolMinMaxThreads, MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID) : 0
#define FireEtXplatThreadPoolMinMaxThreads_AssumeEnabled(MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolMinMaxThreads(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolMinMaxThreads, MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID)
#define FireEtXplatThreadPoolMinMaxThreads_ForContext(pContext, MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolMinMaxThreads) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolMinMaxThreads(&(pContext)->Context, &ThreadPoolMinMaxThreads, MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID) : 0
#define FireEtXplatThreadPoolMinMaxThreads_ForContextAssumeEnabled(pContext, MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolMinMaxThreads(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolMinMaxThreads, MinWorkerThreads, MaxWorkerThreads, MinIOCompletionThreads, MaxIOCompletionThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolMinMaxThreads _mcgen_PASTE2(McTemplateCoU0hhhhh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkingThreadCount"
//
#define EventXplatEnabledThreadPoolWorkingThreadCount() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 11)
#define EventXplatEnabledThreadPoolWorkingThreadCount_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 11)

//
// Event write macros for event "ThreadPoolWorkingThreadCount"
//
#define FireEtXplatThreadPoolWorkingThreadCount(Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkingThreadCount) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkingThreadCount_AssumeEnabled(Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID)
#define FireEtXplatThreadPoolWorkingThreadCount_ForContext(pContext, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkingThreadCount) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&(pContext)->Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID) : 0
#define FireEtXplatThreadPoolWorkingThreadCount_ForContextAssumeEnabled(pContext, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolEnqueue"
//
#define EventXplatEnabledThreadPoolEnqueue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventXplatEnabledThreadPoolEnqueue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolEnqueue"
//
#define FireEtXplatThreadPoolEnqueue(WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID) : 0
#define FireEtXplatThreadPoolEnqueue_AssumeEnabled(WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID)
#define FireEtXplatThreadPoolEnqueue_ForContext(pContext, WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&(pContext)->Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID) : 0
#define FireEtXplatThreadPoolEnqueue_ForContextAssumeEnabled(pContext, WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue _mcgen_PASTE2(McTemplateCoU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolDequeue"
//
#define EventXplatEnabledThreadPoolDequeue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventXplatEnabledThreadPoolDequeue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolDequeue"
//
#define FireEtXplatThreadPoolDequeue(WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolDequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolDequeue, WorkID, ClrInstanceID) : 0
#define FireEtXplatThreadPoolDequeue_AssumeEnabled(WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolDequeue, WorkID, ClrInstanceID)
#define FireEtXplatThreadPoolDequeue_ForContext(pContext, WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolDequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&(pContext)->Context, &ThreadPoolDequeue, WorkID, ClrInstanceID) : 0
#define FireEtXplatThreadPoolDequeue_ForContextAssumeEnabled(pContext, WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolDequeue, WorkID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolDequeue _mcgen_PASTE2(McTemplateCoU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolIOEnqueue"
//
#define EventXplatEnabledThreadPoolIOEnqueue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventXplatEnabledThreadPoolIOEnqueue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolIOEnqueue"
//
#define FireEtXplatThreadPoolIOEnqueue(NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolIOEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) : 0
#define FireEtXplatThreadPoolIOEnqueue_AssumeEnabled(NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID)
#define FireEtXplatThreadPoolIOEnqueue_ForContext(pContext, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolIOEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&(pContext)->Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) : 0
#define FireEtXplatThreadPoolIOEnqueue_ForContextAssumeEnabled(pContext, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue _mcgen_PASTE2(McTemplateCoU0ppth_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolIODequeue"
//
#define EventXplatEnabledThreadPoolIODequeue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventXplatEnabledThreadPoolIODequeue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolIODequeue"
//
#define FireEtXplatThreadPoolIODequeue(NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolIODequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define FireEtXplatThreadPoolIODequeue_AssumeEnabled(NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID)
#define FireEtXplatThreadPoolIODequeue_ForContext(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolIODequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&(pContext)->Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define FireEtXplatThreadPoolIODequeue_ForContextAssumeEnabled(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue _mcgen_PASTE2(McTemplateCoU0pph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolIOPack"
//
#define EventXplatEnabledThreadPoolIOPack() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 11)
#define EventXplatEnabledThreadPoolIOPack_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 11)

//
// Event write macros for event "ThreadPoolIOPack"
//
#define FireEtXplatThreadPoolIOPack(NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolIOPack) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define FireEtXplatThreadPoolIOPack_AssumeEnabled(NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID)
#define FireEtXplatThreadPoolIOPack_ForContext(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolIOPack) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&(pContext)->Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define FireEtXplatThreadPoolIOPack_ForContextAssumeEnabled(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolIOPack _mcgen_PASTE2(McTemplateCoU0pph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadCreating"
//
#define EventXplatEnabledThreadCreating() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 13)
#define EventXplatEnabledThreadCreating_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 13)

//
// Event write macros for event "ThreadCreating"
//
#define FireEtXplatThreadCreating(ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadCreating) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreating(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreating, ID, ClrInstanceID) : 0
#define FireEtXplatThreadCreating_AssumeEnabled(ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreating(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreating, ID, ClrInstanceID)
#define FireEtXplatThreadCreating_ForContext(pContext, ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadCreating) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreating(&(pContext)->Context, &ThreadCreating, ID, ClrInstanceID) : 0
#define FireEtXplatThreadCreating_ForContextAssumeEnabled(pContext, ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreating(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadCreating, ID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadCreating _mcgen_PASTE2(McTemplateCoU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadRunning"
//
#define EventXplatEnabledThreadRunning() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 13)
#define EventXplatEnabledThreadRunning_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 13)

//
// Event write macros for event "ThreadRunning"
//
#define FireEtXplatThreadRunning(ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadRunning) \
        ? _mcgen_TEMPLATE_FOR_ThreadRunning(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadRunning, ID, ClrInstanceID) : 0
#define FireEtXplatThreadRunning_AssumeEnabled(ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadRunning(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadRunning, ID, ClrInstanceID)
#define FireEtXplatThreadRunning_ForContext(pContext, ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadRunning) \
        ? _mcgen_TEMPLATE_FOR_ThreadRunning(&(pContext)->Context, &ThreadRunning, ID, ClrInstanceID) : 0
#define FireEtXplatThreadRunning_ForContextAssumeEnabled(pContext, ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadRunning(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadRunning, ID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadRunning _mcgen_PASTE2(McTemplateCoU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDetails"
//
#define EventXplatEnabledMethodDetails() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 14)
#define EventXplatEnabledMethodDetails_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 14)

//
// Event write macros for event "MethodDetails"
//
#define FireEtXplatMethodDetails(MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters) \
        MCGEN_EVENT_ENABLED(MethodDetails) \
        ? _mcgen_TEMPLATE_FOR_MethodDetails(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDetails, MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters) : 0
#define FireEtXplatMethodDetails_AssumeEnabled(MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters) \
        _mcgen_TEMPLATE_FOR_MethodDetails(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDetails, MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters)
#define FireEtXplatMethodDetails_ForContext(pContext, MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDetails) \
        ? _mcgen_TEMPLATE_FOR_MethodDetails(&(pContext)->Context, &MethodDetails, MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters) : 0
#define FireEtXplatMethodDetails_ForContextAssumeEnabled(pContext, MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters) \
        _mcgen_TEMPLATE_FOR_MethodDetails(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDetails, MethodID, TypeID, MethodToken, TypeParameterCount, LoaderModuleID, TypeParameters)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDetails _mcgen_PASTE2(McTemplateCoU0xxqqxXR3_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TypeLoadStart"
//
#define EventXplatEnabledTypeLoadStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 15)
#define EventXplatEnabledTypeLoadStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 15)

//
// Event write macros for event "TypeLoadStart"
//
#define FireEtXplatTypeLoadStart(TypeLoadStartID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(TypeLoadStart) \
        ? _mcgen_TEMPLATE_FOR_TypeLoadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TypeLoadStart, TypeLoadStartID, ClrInstanceID) : 0
#define FireEtXplatTypeLoadStart_AssumeEnabled(TypeLoadStartID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TypeLoadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TypeLoadStart, TypeLoadStartID, ClrInstanceID)
#define FireEtXplatTypeLoadStart_ForContext(pContext, TypeLoadStartID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TypeLoadStart) \
        ? _mcgen_TEMPLATE_FOR_TypeLoadStart(&(pContext)->Context, &TypeLoadStart, TypeLoadStartID, ClrInstanceID) : 0
#define FireEtXplatTypeLoadStart_ForContextAssumeEnabled(pContext, TypeLoadStartID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TypeLoadStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &TypeLoadStart, TypeLoadStartID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TypeLoadStart _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TypeLoadStop"
//
#define EventXplatEnabledTypeLoadStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 15)
#define EventXplatEnabledTypeLoadStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 15)

//
// Event write macros for event "TypeLoadStop"
//
#define FireEtXplatTypeLoadStop(TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName) \
        MCGEN_EVENT_ENABLED(TypeLoadStop) \
        ? _mcgen_TEMPLATE_FOR_TypeLoadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TypeLoadStop, TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName) : 0
#define FireEtXplatTypeLoadStop_AssumeEnabled(TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName) \
        _mcgen_TEMPLATE_FOR_TypeLoadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TypeLoadStop, TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName)
#define FireEtXplatTypeLoadStop_ForContext(pContext, TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TypeLoadStop) \
        ? _mcgen_TEMPLATE_FOR_TypeLoadStop(&(pContext)->Context, &TypeLoadStop, TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName) : 0
#define FireEtXplatTypeLoadStop_ForContextAssumeEnabled(pContext, TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName) \
        _mcgen_TEMPLATE_FOR_TypeLoadStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &TypeLoadStop, TypeLoadStartID, ClrInstanceID, LoadLevel, TypeID, TypeName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TypeLoadStop _mcgen_PASTE2(McTemplateCoU0qhhxz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionThrown"
//
#define EventXplatEnabledExceptionThrown() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventXplatEnabledExceptionThrown_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionThrown"
//
#define FireEtXplatExceptionThrown() \
        MCGEN_EVENT_ENABLED(ExceptionThrown) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown) : 0
#define FireEtXplatExceptionThrown_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionThrown(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown)
#define FireEtXplatExceptionThrown_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionThrown) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown(&(pContext)->Context, &ExceptionThrown) : 0
#define FireEtXplatExceptionThrown_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionThrown(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionThrown)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionThrown _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionThrown_V1"
//
#define EventXplatEnabledExceptionThrown_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 17)
#define EventXplatEnabledExceptionThrown_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 17)

//
// Event write macros for event "ExceptionThrown_V1"
//
#define FireEtXplatExceptionThrown_V1(ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionThrown_V1) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) : 0
#define FireEtXplatExceptionThrown_V1_AssumeEnabled(ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID)
#define FireEtXplatExceptionThrown_V1_ForContext(pContext, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionThrown_V1) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&(pContext)->Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) : 0
#define FireEtXplatExceptionThrown_V1_ForContextAssumeEnabled(pContext, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionThrown_V1 _mcgen_PASTE2(McTemplateCoU0zzpqhh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionCatchStart"
//
#define EventXplatEnabledExceptionCatchStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventXplatEnabledExceptionCatchStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "ExceptionCatchStart"
//
#define FireEtXplatExceptionCatchStart(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionCatchStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define FireEtXplatExceptionCatchStart_AssumeEnabled(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID)
#define FireEtXplatExceptionCatchStart_ForContext(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionCatchStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&(pContext)->Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define FireEtXplatExceptionCatchStart_ForContextAssumeEnabled(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionCatchStart _mcgen_PASTE2(McTemplateCoU0xxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionCatchStop"
//
#define EventXplatEnabledExceptionCatchStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventXplatEnabledExceptionCatchStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "ExceptionCatchStop"
//
#define FireEtXplatExceptionCatchStop() \
        MCGEN_EVENT_ENABLED(ExceptionCatchStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStop) : 0
#define FireEtXplatExceptionCatchStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStop)
#define FireEtXplatExceptionCatchStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionCatchStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&(pContext)->Context, &ExceptionCatchStop) : 0
#define FireEtXplatExceptionCatchStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionCatchStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionCatchStop _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFinallyStart"
//
#define EventXplatEnabledExceptionFinallyStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventXplatEnabledExceptionFinallyStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "ExceptionFinallyStart"
//
#define FireEtXplatExceptionFinallyStart(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionFinallyStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define FireEtXplatExceptionFinallyStart_AssumeEnabled(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID)
#define FireEtXplatExceptionFinallyStart_ForContext(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFinallyStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&(pContext)->Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define FireEtXplatExceptionFinallyStart_ForContextAssumeEnabled(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFinallyStart _mcgen_PASTE2(McTemplateCoU0xxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFinallyStop"
//
#define EventXplatEnabledExceptionFinallyStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventXplatEnabledExceptionFinallyStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "ExceptionFinallyStop"
//
#define FireEtXplatExceptionFinallyStop() \
        MCGEN_EVENT_ENABLED(ExceptionFinallyStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStop) : 0
#define FireEtXplatExceptionFinallyStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStop)
#define FireEtXplatExceptionFinallyStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFinallyStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&(pContext)->Context, &ExceptionFinallyStop) : 0
#define FireEtXplatExceptionFinallyStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFinallyStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFinallyStop _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFilterStart"
//
#define EventXplatEnabledExceptionFilterStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventXplatEnabledExceptionFilterStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "ExceptionFilterStart"
//
#define FireEtXplatExceptionFilterStart(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionFilterStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define FireEtXplatExceptionFilterStart_AssumeEnabled(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID)
#define FireEtXplatExceptionFilterStart_ForContext(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFilterStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&(pContext)->Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define FireEtXplatExceptionFilterStart_ForContextAssumeEnabled(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFilterStart _mcgen_PASTE2(McTemplateCoU0xxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFilterStop"
//
#define EventXplatEnabledExceptionFilterStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventXplatEnabledExceptionFilterStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "ExceptionFilterStop"
//
#define FireEtXplatExceptionFilterStop() \
        MCGEN_EVENT_ENABLED(ExceptionFilterStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStop) : 0
#define FireEtXplatExceptionFilterStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStop)
#define FireEtXplatExceptionFilterStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFilterStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&(pContext)->Context, &ExceptionFilterStop) : 0
#define FireEtXplatExceptionFilterStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFilterStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFilterStop _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionThrownStop"
//
#define EventXplatEnabledExceptionThrownStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventXplatEnabledExceptionThrownStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "ExceptionThrownStop"
//
#define FireEtXplatExceptionThrownStop() \
        MCGEN_EVENT_ENABLED(ExceptionThrownStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrownStop) : 0
#define FireEtXplatExceptionThrownStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrownStop)
#define FireEtXplatExceptionThrownStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionThrownStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&(pContext)->Context, &ExceptionThrownStop) : 0
#define FireEtXplatExceptionThrownStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionThrownStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionThrownStop _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Contention"
//
#define EventXplatEnabledContention() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventXplatEnabledContention_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "Contention"
//
#define FireEtXplatContention() \
        MCGEN_EVENT_ENABLED(Contention) \
        ? _mcgen_TEMPLATE_FOR_Contention(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Contention) : 0
#define FireEtXplatContention_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_Contention(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Contention)
#define FireEtXplatContention_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Contention) \
        ? _mcgen_TEMPLATE_FOR_Contention(&(pContext)->Context, &Contention) : 0
#define FireEtXplatContention_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_Contention(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &Contention)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Contention _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ContentionStart_V1"
//
#define EventXplatEnabledContentionStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 19)
#define EventXplatEnabledContentionStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 19)

//
// Event write macros for event "ContentionStart_V1"
//
#define FireEtXplatContentionStart_V1(ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ContentionStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ContentionStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID) : 0
#define FireEtXplatContentionStart_V1_AssumeEnabled(ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID)
#define FireEtXplatContentionStart_V1_ForContext(pContext, ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ContentionStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ContentionStart_V1(&(pContext)->Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID) : 0
#define FireEtXplatContentionStart_V1_ForContextAssumeEnabled(pContext, ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ContentionStart_V1 _mcgen_PASTE2(McTemplateCoU0uh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ContentionStart_V2"
//
#define EventXplatEnabledContentionStart_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 19)
#define EventXplatEnabledContentionStart_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 19)

//
// Event write macros for event "ContentionStart_V2"
//
#define FireEtXplatContentionStart_V2(ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID) \
        MCGEN_EVENT_ENABLED(ContentionStart_V2) \
        ? _mcgen_TEMPLATE_FOR_ContentionStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStart_V2, ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID) : 0
#define FireEtXplatContentionStart_V2_AssumeEnabled(ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID) \
        _mcgen_TEMPLATE_FOR_ContentionStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStart_V2, ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID)
#define FireEtXplatContentionStart_V2_ForContext(pContext, ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ContentionStart_V2) \
        ? _mcgen_TEMPLATE_FOR_ContentionStart_V2(&(pContext)->Context, &ContentionStart_V2, ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID) : 0
#define FireEtXplatContentionStart_V2_ForContextAssumeEnabled(pContext, ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID) \
        _mcgen_TEMPLATE_FOR_ContentionStart_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ContentionStart_V2, ContentionFlags, ClrInstanceID, LockID, AssociatedObjectID, LockOwnerThreadID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ContentionStart_V2 _mcgen_PASTE2(McTemplateCoU0uhppx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ContentionStop"
//
#define EventXplatEnabledContentionStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 19)
#define EventXplatEnabledContentionStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 19)

//
// Event write macros for event "ContentionStop"
//
#define FireEtXplatContentionStop(ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ContentionStop) \
        ? _mcgen_TEMPLATE_FOR_ContentionStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStop, ContentionFlags, ClrInstanceID) : 0
#define FireEtXplatContentionStop_AssumeEnabled(ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStop, ContentionFlags, ClrInstanceID)
#define FireEtXplatContentionStop_ForContext(pContext, ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ContentionStop) \
        ? _mcgen_TEMPLATE_FOR_ContentionStop(&(pContext)->Context, &ContentionStop, ContentionFlags, ClrInstanceID) : 0
#define FireEtXplatContentionStop_ForContextAssumeEnabled(pContext, ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ContentionStop, ContentionFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ContentionStop _mcgen_PASTE2(McTemplateCoU0uh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ContentionStop_V1"
//
#define EventXplatEnabledContentionStop_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 19)
#define EventXplatEnabledContentionStop_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 19)

//
// Event write macros for event "ContentionStop_V1"
//
#define FireEtXplatContentionStop_V1(ContentionFlags, ClrInstanceID, DurationNs) \
        MCGEN_EVENT_ENABLED(ContentionStop_V1) \
        ? _mcgen_TEMPLATE_FOR_ContentionStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStop_V1, ContentionFlags, ClrInstanceID, DurationNs) : 0
#define FireEtXplatContentionStop_V1_AssumeEnabled(ContentionFlags, ClrInstanceID, DurationNs) \
        _mcgen_TEMPLATE_FOR_ContentionStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStop_V1, ContentionFlags, ClrInstanceID, DurationNs)
#define FireEtXplatContentionStop_V1_ForContext(pContext, ContentionFlags, ClrInstanceID, DurationNs) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ContentionStop_V1) \
        ? _mcgen_TEMPLATE_FOR_ContentionStop_V1(&(pContext)->Context, &ContentionStop_V1, ContentionFlags, ClrInstanceID, DurationNs) : 0
#define FireEtXplatContentionStop_V1_ForContextAssumeEnabled(pContext, ContentionFlags, ClrInstanceID, DurationNs) \
        _mcgen_TEMPLATE_FOR_ContentionStop_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ContentionStop_V1, ContentionFlags, ClrInstanceID, DurationNs)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ContentionStop_V1 _mcgen_PASTE2(McTemplateCoU0uhg_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ContentionLockCreated"
//
#define EventXplatEnabledContentionLockCreated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 19)
#define EventXplatEnabledContentionLockCreated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 19)

//
// Event write macros for event "ContentionLockCreated"
//
#define FireEtXplatContentionLockCreated(LockID, AssociatedObjectID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ContentionLockCreated) \
        ? _mcgen_TEMPLATE_FOR_ContentionLockCreated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionLockCreated, LockID, AssociatedObjectID, ClrInstanceID) : 0
#define FireEtXplatContentionLockCreated_AssumeEnabled(LockID, AssociatedObjectID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionLockCreated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionLockCreated, LockID, AssociatedObjectID, ClrInstanceID)
#define FireEtXplatContentionLockCreated_ForContext(pContext, LockID, AssociatedObjectID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ContentionLockCreated) \
        ? _mcgen_TEMPLATE_FOR_ContentionLockCreated(&(pContext)->Context, &ContentionLockCreated, LockID, AssociatedObjectID, ClrInstanceID) : 0
#define FireEtXplatContentionLockCreated_ForContextAssumeEnabled(pContext, LockID, AssociatedObjectID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionLockCreated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ContentionLockCreated, LockID, AssociatedObjectID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ContentionLockCreated _mcgen_PASTE2(McTemplateCoU0pph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CLRStackWalk"
//
#define EventXplatEnabledCLRStackWalk() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 20)
#define EventXplatEnabledCLRStackWalk_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 20)

//
// Event write macros for event "CLRStackWalk"
//
#define FireEtXplatCLRStackWalk(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED(CLRStackWalk) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalk(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalk_AssumeEnabled(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalk(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)
#define FireEtXplatCLRStackWalk_ForContext(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CLRStackWalk) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalk(&(pContext)->Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalk_ForContextAssumeEnabled(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalk(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CLRStackWalk _mcgen_PASTE2(McTemplateCoU0huuqP2_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainMemAllocated"
//
#define EventXplatEnabledAppDomainMemAllocated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 21)
#define EventXplatEnabledAppDomainMemAllocated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 21)

//
// Event write macros for event "AppDomainMemAllocated"
//
#define FireEtXplatAppDomainMemAllocated(AppDomainID, Allocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainMemAllocated) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID) : 0
#define FireEtXplatAppDomainMemAllocated_AssumeEnabled(AppDomainID, Allocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID)
#define FireEtXplatAppDomainMemAllocated_ForContext(pContext, AppDomainID, Allocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainMemAllocated) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&(pContext)->Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID) : 0
#define FireEtXplatAppDomainMemAllocated_ForContextAssumeEnabled(pContext, AppDomainID, Allocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainMemAllocated _mcgen_PASTE2(McTemplateCoU0xxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainMemSurvived"
//
#define EventXplatEnabledAppDomainMemSurvived() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 21)
#define EventXplatEnabledAppDomainMemSurvived_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 21)

//
// Event write macros for event "AppDomainMemSurvived"
//
#define FireEtXplatAppDomainMemSurvived(AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainMemSurvived) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) : 0
#define FireEtXplatAppDomainMemSurvived_AssumeEnabled(AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID)
#define FireEtXplatAppDomainMemSurvived_ForContext(pContext, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainMemSurvived) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&(pContext)->Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) : 0
#define FireEtXplatAppDomainMemSurvived_ForContextAssumeEnabled(pContext, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainMemSurvived _mcgen_PASTE2(McTemplateCoU0xxxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadCreated"
//
#define EventXplatEnabledThreadCreated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventXplatEnabledThreadCreated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "ThreadCreated"
//
#define FireEtXplatThreadCreated(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadCreated) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define FireEtXplatThreadCreated_AssumeEnabled(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)
#define FireEtXplatThreadCreated_ForContext(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadCreated) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreated(&(pContext)->Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define FireEtXplatThreadCreated_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadCreated _mcgen_PASTE2(McTemplateCoU0xxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadTerminated"
//
#define EventXplatEnabledThreadTerminated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventXplatEnabledThreadTerminated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "ThreadTerminated"
//
#define FireEtXplatThreadTerminated(ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadTerminated) \
        ? _mcgen_TEMPLATE_FOR_ThreadTerminated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatThreadTerminated_AssumeEnabled(ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadTerminated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID)
#define FireEtXplatThreadTerminated_ForContext(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadTerminated) \
        ? _mcgen_TEMPLATE_FOR_ThreadTerminated(&(pContext)->Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatThreadTerminated_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadTerminated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadTerminated _mcgen_PASTE2(McTemplateCoU0xxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadDomainEnter"
//
#define EventXplatEnabledThreadDomainEnter() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventXplatEnabledThreadDomainEnter_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "ThreadDomainEnter"
//
#define FireEtXplatThreadDomainEnter(ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadDomainEnter) \
        ? _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatThreadDomainEnter_AssumeEnabled(ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID)
#define FireEtXplatThreadDomainEnter_ForContext(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadDomainEnter) \
        ? _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&(pContext)->Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatThreadDomainEnter_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadDomainEnter _mcgen_PASTE2(McTemplateCoU0xxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ILStubGenerated"
//
#define EventXplatEnabledILStubGenerated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 23)
#define EventXplatEnabledILStubGenerated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 23)

//
// Event write macros for event "ILStubGenerated"
//
#define FireEtXplatILStubGenerated(ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        MCGEN_EVENT_ENABLED(ILStubGenerated) \
        ? _mcgen_TEMPLATE_FOR_ILStubGenerated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) : 0
#define FireEtXplatILStubGenerated_AssumeEnabled(ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        _mcgen_TEMPLATE_FOR_ILStubGenerated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode)
#define FireEtXplatILStubGenerated_ForContext(pContext, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ILStubGenerated) \
        ? _mcgen_TEMPLATE_FOR_ILStubGenerated(&(pContext)->Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) : 0
#define FireEtXplatILStubGenerated_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        _mcgen_TEMPLATE_FOR_ILStubGenerated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ILStubGenerated _mcgen_PASTE2(McTemplateCoU0hxxqqzzzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ILStubCacheHit"
//
#define EventXplatEnabledILStubCacheHit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 23)
#define EventXplatEnabledILStubCacheHit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 23)

//
// Event write macros for event "ILStubCacheHit"
//
#define FireEtXplatILStubCacheHit(ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        MCGEN_EVENT_ENABLED(ILStubCacheHit) \
        ? _mcgen_TEMPLATE_FOR_ILStubCacheHit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) : 0
#define FireEtXplatILStubCacheHit_AssumeEnabled(ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        _mcgen_TEMPLATE_FOR_ILStubCacheHit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature)
#define FireEtXplatILStubCacheHit_ForContext(pContext, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ILStubCacheHit) \
        ? _mcgen_TEMPLATE_FOR_ILStubCacheHit(&(pContext)->Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) : 0
#define FireEtXplatILStubCacheHit_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        _mcgen_TEMPLATE_FOR_ILStubCacheHit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ILStubCacheHit _mcgen_PASTE2(McTemplateCoU0hxxqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartCompleteV2"
//
#define EventXplatEnabledDCStartCompleteV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledDCStartCompleteV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "DCStartCompleteV2"
//
#define FireEtXplatDCStartCompleteV2() \
        MCGEN_EVENT_ENABLED(DCStartCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCStartCompleteV2) : 0
#define FireEtXplatDCStartCompleteV2_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCStartCompleteV2)
#define FireEtXplatDCStartCompleteV2_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&(pContext)->Context, &DCStartCompleteV2) : 0
#define FireEtXplatDCStartCompleteV2_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DCStartCompleteV2)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartCompleteV2 _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndCompleteV2"
//
#define EventXplatEnabledDCEndCompleteV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledDCEndCompleteV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "DCEndCompleteV2"
//
#define FireEtXplatDCEndCompleteV2() \
        MCGEN_EVENT_ENABLED(DCEndCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCEndCompleteV2) : 0
#define FireEtXplatDCEndCompleteV2_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCEndCompleteV2)
#define FireEtXplatDCEndCompleteV2_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&(pContext)->Context, &DCEndCompleteV2) : 0
#define FireEtXplatDCEndCompleteV2_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DCEndCompleteV2)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndCompleteV2 _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartV2"
//
#define EventXplatEnabledMethodDCStartV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodDCStartV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodDCStartV2"
//
#define FireEtXplatMethodDCStartV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCStartV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define FireEtXplatMethodDCStartV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartV2(&(pContext)->Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCStartV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStartV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartV2 _mcgen_PASTE2(McTemplateCoU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndV2"
//
#define EventXplatEnabledMethodDCEndV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodDCEndV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodDCEndV2"
//
#define FireEtXplatMethodDCEndV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCEndV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define FireEtXplatMethodDCEndV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndV2(&(pContext)->Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCEndV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEndV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndV2 _mcgen_PASTE2(McTemplateCoU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerboseV2"
//
#define EventXplatEnabledMethodDCStartVerboseV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodDCStartVerboseV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodDCStartVerboseV2"
//
#define FireEtXplatMethodDCStartVerboseV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCStartVerboseV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMethodDCStartVerboseV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&(pContext)->Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCStartVerboseV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerboseV2"
//
#define EventXplatEnabledMethodDCEndVerboseV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodDCEndVerboseV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodDCEndVerboseV2"
//
#define FireEtXplatMethodDCEndVerboseV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCEndVerboseV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMethodDCEndVerboseV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&(pContext)->Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCEndVerboseV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoad"
//
#define EventXplatEnabledMethodLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodLoad"
//
#define FireEtXplatMethodLoad(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodLoad) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodLoad_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define FireEtXplatMethodLoad_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoad) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad(&(pContext)->Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodLoad_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoad _mcgen_PASTE2(McTemplateCoU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoad_V1"
//
#define EventXplatEnabledMethodLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodLoad_V1"
//
#define FireEtXplatMethodLoad_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodLoad_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define FireEtXplatMethodLoad_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V1(&(pContext)->Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodLoad_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoad_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoad_V2"
//
#define EventXplatEnabledMethodLoad_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodLoad_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodLoad_V2"
//
#define FireEtXplatMethodLoad_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodLoad_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define FireEtXplatMethodLoad_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V2(&(pContext)->Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodLoad_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoad_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "R2RGetEntryPoint"
//
#define EventXplatEnabledR2RGetEntryPoint() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 25)
#define EventXplatEnabledR2RGetEntryPoint_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 25)

//
// Event write macros for event "R2RGetEntryPoint"
//
#define FireEtXplatR2RGetEntryPoint(MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(R2RGetEntryPoint) \
        ? _mcgen_TEMPLATE_FOR_R2RGetEntryPoint(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &R2RGetEntryPoint, MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID) : 0
#define FireEtXplatR2RGetEntryPoint_AssumeEnabled(MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_R2RGetEntryPoint(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &R2RGetEntryPoint, MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID)
#define FireEtXplatR2RGetEntryPoint_ForContext(pContext, MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, R2RGetEntryPoint) \
        ? _mcgen_TEMPLATE_FOR_R2RGetEntryPoint(&(pContext)->Context, &R2RGetEntryPoint, MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID) : 0
#define FireEtXplatR2RGetEntryPoint_ForContextAssumeEnabled(pContext, MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_R2RGetEntryPoint(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &R2RGetEntryPoint, MethodID, MethodNamespace, MethodName, MethodSignature, EntryPoint, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_R2RGetEntryPoint _mcgen_PASTE2(McTemplateCoU0xzzzxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "R2RGetEntryPointStart"
//
#define EventXplatEnabledR2RGetEntryPointStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 25)
#define EventXplatEnabledR2RGetEntryPointStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 25)

//
// Event write macros for event "R2RGetEntryPointStart"
//
#define FireEtXplatR2RGetEntryPointStart(MethodID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(R2RGetEntryPointStart) \
        ? _mcgen_TEMPLATE_FOR_R2RGetEntryPointStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &R2RGetEntryPointStart, MethodID, ClrInstanceID) : 0
#define FireEtXplatR2RGetEntryPointStart_AssumeEnabled(MethodID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_R2RGetEntryPointStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &R2RGetEntryPointStart, MethodID, ClrInstanceID)
#define FireEtXplatR2RGetEntryPointStart_ForContext(pContext, MethodID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, R2RGetEntryPointStart) \
        ? _mcgen_TEMPLATE_FOR_R2RGetEntryPointStart(&(pContext)->Context, &R2RGetEntryPointStart, MethodID, ClrInstanceID) : 0
#define FireEtXplatR2RGetEntryPointStart_ForContextAssumeEnabled(pContext, MethodID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_R2RGetEntryPointStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &R2RGetEntryPointStart, MethodID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_R2RGetEntryPointStart _mcgen_PASTE2(McTemplateCoU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnload"
//
#define EventXplatEnabledMethodUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodUnload"
//
#define FireEtXplatMethodUnload(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodUnload) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodUnload_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define FireEtXplatMethodUnload_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnload) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload(&(pContext)->Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodUnload_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnload _mcgen_PASTE2(McTemplateCoU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnload_V1"
//
#define EventXplatEnabledMethodUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodUnload_V1"
//
#define FireEtXplatMethodUnload_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodUnload_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define FireEtXplatMethodUnload_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V1(&(pContext)->Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodUnload_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnload_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnload_V2"
//
#define EventXplatEnabledMethodUnload_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodUnload_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodUnload_V2"
//
#define FireEtXplatMethodUnload_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodUnload_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define FireEtXplatMethodUnload_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V2(&(pContext)->Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodUnload_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnload_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoadVerbose"
//
#define EventXplatEnabledMethodLoadVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodLoadVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodLoadVerbose"
//
#define FireEtXplatMethodLoadVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodLoadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodLoadVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMethodLoadVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&(pContext)->Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodLoadVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoadVerbose _mcgen_PASTE2(McTemplateCoU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoadVerbose_V1"
//
#define EventXplatEnabledMethodLoadVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodLoadVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodLoadVerbose_V1"
//
#define FireEtXplatMethodLoadVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodLoadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodLoadVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define FireEtXplatMethodLoadVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&(pContext)->Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodLoadVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoadVerbose_V2"
//
#define EventXplatEnabledMethodLoadVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodLoadVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodLoadVerbose_V2"
//
#define FireEtXplatMethodLoadVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodLoadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodLoadVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define FireEtXplatMethodLoadVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&(pContext)->Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodLoadVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnloadVerbose"
//
#define EventXplatEnabledMethodUnloadVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodUnloadVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodUnloadVerbose"
//
#define FireEtXplatMethodUnloadVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodUnloadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodUnloadVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMethodUnloadVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnloadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&(pContext)->Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodUnloadVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnloadVerbose _mcgen_PASTE2(McTemplateCoU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnloadVerbose_V1"
//
#define EventXplatEnabledMethodUnloadVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodUnloadVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodUnloadVerbose_V1"
//
#define FireEtXplatMethodUnloadVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodUnloadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodUnloadVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define FireEtXplatMethodUnloadVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnloadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&(pContext)->Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodUnloadVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnloadVerbose_V2"
//
#define EventXplatEnabledMethodUnloadVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventXplatEnabledMethodUnloadVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodUnloadVerbose_V2"
//
#define FireEtXplatMethodUnloadVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodUnloadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodUnloadVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define FireEtXplatMethodUnloadVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnloadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&(pContext)->Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodUnloadVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJittingStarted"
//
#define EventXplatEnabledMethodJittingStarted() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventXplatEnabledMethodJittingStarted_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "MethodJittingStarted"
//
#define FireEtXplatMethodJittingStarted(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodJittingStarted) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodJittingStarted_AssumeEnabled(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMethodJittingStarted_ForContext(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJittingStarted) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted(&(pContext)->Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodJittingStarted_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJittingStarted _mcgen_PASTE2(McTemplateCoU0xxqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJittingStarted_V1"
//
#define EventXplatEnabledMethodJittingStarted_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventXplatEnabledMethodJittingStarted_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "MethodJittingStarted_V1"
//
#define FireEtXplatMethodJittingStarted_V1(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJittingStarted_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodJittingStarted_V1_AssumeEnabled(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define FireEtXplatMethodJittingStarted_V1_ForContext(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJittingStarted_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&(pContext)->Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodJittingStarted_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1 _mcgen_PASTE2(McTemplateCoU0xxqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitMemoryAllocatedForCode"
//
#define EventXplatEnabledMethodJitMemoryAllocatedForCode() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventXplatEnabledMethodJitMemoryAllocatedForCode_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "MethodJitMemoryAllocatedForCode"
//
#define FireEtXplatMethodJitMemoryAllocatedForCode(MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitMemoryAllocatedForCode) \
        ? _mcgen_TEMPLATE_FOR_MethodJitMemoryAllocatedForCode(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitMemoryAllocatedForCode, MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID) : 0
#define FireEtXplatMethodJitMemoryAllocatedForCode_AssumeEnabled(MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitMemoryAllocatedForCode(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitMemoryAllocatedForCode, MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID)
#define FireEtXplatMethodJitMemoryAllocatedForCode_ForContext(pContext, MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitMemoryAllocatedForCode) \
        ? _mcgen_TEMPLATE_FOR_MethodJitMemoryAllocatedForCode(&(pContext)->Context, &MethodJitMemoryAllocatedForCode, MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID) : 0
#define FireEtXplatMethodJitMemoryAllocatedForCode_ForContextAssumeEnabled(pContext, MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitMemoryAllocatedForCode(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitMemoryAllocatedForCode, MethodID, ModuleID, JitHotCodeRequestSize, JitRODataRequestSize, AllocatedSizeForJitCode, JitAllocFlag, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitMemoryAllocatedForCode _mcgen_PASTE2(McTemplateCoU0xxxxxqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitInliningSucceeded"
//
#define EventXplatEnabledMethodJitInliningSucceeded() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventXplatEnabledMethodJitInliningSucceeded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "MethodJitInliningSucceeded"
//
#define FireEtXplatMethodJitInliningSucceeded(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitInliningSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) : 0
#define FireEtXplatMethodJitInliningSucceeded_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID)
#define FireEtXplatMethodJitInliningSucceeded_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitInliningSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&(pContext)->Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) : 0
#define FireEtXplatMethodJitInliningSucceeded_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded _mcgen_PASTE2(McTemplateCoU0zzzzzzzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitInliningFailedAnsi"
//
#define EventXplatEnabledMethodJitInliningFailedAnsi() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventXplatEnabledMethodJitInliningFailedAnsi_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "MethodJitInliningFailedAnsi"
//
#define FireEtXplatMethodJitInliningFailedAnsi(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitInliningFailedAnsi) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningFailedAnsi(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitInliningFailedAnsi_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningFailedAnsi(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID)
#define FireEtXplatMethodJitInliningFailedAnsi_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitInliningFailedAnsi) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningFailedAnsi(&(pContext)->Context, &MethodJitInliningFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitInliningFailedAnsi_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningFailedAnsi(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitInliningFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitInliningFailedAnsi _mcgen_PASTE2(McTemplateCoU0zzzzzzzzztsh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitTailCallSucceeded"
//
#define EventXplatEnabledMethodJitTailCallSucceeded() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventXplatEnabledMethodJitTailCallSucceeded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "MethodJitTailCallSucceeded"
//
#define FireEtXplatMethodJitTailCallSucceeded(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitTailCallSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) : 0
#define FireEtXplatMethodJitTailCallSucceeded_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID)
#define FireEtXplatMethodJitTailCallSucceeded_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitTailCallSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&(pContext)->Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) : 0
#define FireEtXplatMethodJitTailCallSucceeded_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded _mcgen_PASTE2(McTemplateCoU0zzzzzzzzztqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitTailCallFailedAnsi"
//
#define EventXplatEnabledMethodJitTailCallFailedAnsi() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventXplatEnabledMethodJitTailCallFailedAnsi_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "MethodJitTailCallFailedAnsi"
//
#define FireEtXplatMethodJitTailCallFailedAnsi(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitTailCallFailedAnsi) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallFailedAnsi(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitTailCallFailedAnsi_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallFailedAnsi(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID)
#define FireEtXplatMethodJitTailCallFailedAnsi_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitTailCallFailedAnsi) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallFailedAnsi(&(pContext)->Context, &MethodJitTailCallFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitTailCallFailedAnsi_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallFailedAnsi(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitTailCallFailedAnsi, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitTailCallFailedAnsi _mcgen_PASTE2(McTemplateCoU0zzzzzzzzztsh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodILToNativeMap"
//
#define EventXplatEnabledMethodILToNativeMap() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 28)
#define EventXplatEnabledMethodILToNativeMap_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 28)

//
// Event write macros for event "MethodILToNativeMap"
//
#define FireEtXplatMethodILToNativeMap(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define FireEtXplatMethodILToNativeMap_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)
#define FireEtXplatMethodILToNativeMap_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&(pContext)->Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define FireEtXplatMethodILToNativeMap_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodILToNativeMap _mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodILToNativeMap_V1"
//
#define EventXplatEnabledMethodILToNativeMap_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 28)
#define EventXplatEnabledMethodILToNativeMap_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 28)

//
// Event write macros for event "MethodILToNativeMap_V1"
//
#define FireEtXplatMethodILToNativeMap_V1(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        MCGEN_EVENT_ENABLED(MethodILToNativeMap_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodILToNativeMap_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) : 0
#define FireEtXplatMethodILToNativeMap_V1_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        _mcgen_TEMPLATE_FOR_MethodILToNativeMap_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID)
#define FireEtXplatMethodILToNativeMap_V1_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodILToNativeMap_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodILToNativeMap_V1(&(pContext)->Context, &MethodILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) : 0
#define FireEtXplatMethodILToNativeMap_V1_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        _mcgen_TEMPLATE_FOR_MethodILToNativeMap_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodILToNativeMap_V1 _mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3hx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitTailCallFailed"
//
#define EventXplatEnabledMethodJitTailCallFailed() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventXplatEnabledMethodJitTailCallFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "MethodJitTailCallFailed"
//
#define FireEtXplatMethodJitTailCallFailed(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitTailCallFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitTailCallFailed_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID)
#define FireEtXplatMethodJitTailCallFailed_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitTailCallFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&(pContext)->Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitTailCallFailed_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed _mcgen_PASTE2(McTemplateCoU0zzzzzzzzztzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitInliningFailed"
//
#define EventXplatEnabledMethodJitInliningFailed() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventXplatEnabledMethodJitInliningFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "MethodJitInliningFailed"
//
#define FireEtXplatMethodJitInliningFailed(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitInliningFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitInliningFailed_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID)
#define FireEtXplatMethodJitInliningFailed_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitInliningFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&(pContext)->Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) : 0
#define FireEtXplatMethodJitInliningFailed_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitInliningFailed _mcgen_PASTE2(McTemplateCoU0zzzzzzzzztzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStartV2"
//
#define EventXplatEnabledModuleDCStartV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledModuleDCStartV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "ModuleDCStartV2"
//
#define FireEtXplatModuleDCStartV2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCStartV2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatModuleDCStartV2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&(pContext)->Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCStartV2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStartV2 _mcgen_PASTE2(McTemplateCoU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEndV2"
//
#define EventXplatEnabledModuleDCEndV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledModuleDCEndV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "ModuleDCEndV2"
//
#define FireEtXplatModuleDCEndV2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCEndV2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatModuleDCEndV2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&(pContext)->Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCEndV2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEndV2 _mcgen_PASTE2(McTemplateCoU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleLoad"
//
#define EventXplatEnabledDomainModuleLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledDomainModuleLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "DomainModuleLoad"
//
#define FireEtXplatDomainModuleLoad(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(DomainModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatDomainModuleLoad_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatDomainModuleLoad_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad(&(pContext)->Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatDomainModuleLoad_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleLoad _mcgen_PASTE2(McTemplateCoU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleLoad_V1"
//
#define EventXplatEnabledDomainModuleLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledDomainModuleLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "DomainModuleLoad_V1"
//
#define FireEtXplatDomainModuleLoad_V1(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DomainModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatDomainModuleLoad_V1_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define FireEtXplatDomainModuleLoad_V1_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&(pContext)->Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatDomainModuleLoad_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleLoad"
//
#define EventXplatEnabledModuleLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledModuleLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "ModuleLoad"
//
#define FireEtXplatModuleLoad(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleLoad_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatModuleLoad_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad(&(pContext)->Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleLoad_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleLoad _mcgen_PASTE2(McTemplateCoU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleLoad_V1"
//
#define EventXplatEnabledModuleLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventXplatEnabledModuleLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "ModuleLoad_V1"
//
#define FireEtXplatModuleLoad_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleLoad_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define FireEtXplatModuleLoad_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&(pContext)->Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleLoad_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleLoad_V1 _mcgen_PASTE2(McTemplateCoU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleLoad_V2"
//
#define EventXplatEnabledModuleLoad_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventXplatEnabledModuleLoad_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "ModuleLoad_V2"
//
#define FireEtXplatModuleLoad_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleLoad_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define FireEtXplatModuleLoad_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&(pContext)->Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleLoad_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleLoad_V2 _mcgen_PASTE2(McTemplateCoU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleUnload"
//
#define EventXplatEnabledModuleUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledModuleUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "ModuleUnload"
//
#define FireEtXplatModuleUnload(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleUnload) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleUnload_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatModuleUnload_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleUnload) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload(&(pContext)->Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleUnload_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleUnload _mcgen_PASTE2(McTemplateCoU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleUnload_V1"
//
#define EventXplatEnabledModuleUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventXplatEnabledModuleUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "ModuleUnload_V1"
//
#define FireEtXplatModuleUnload_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleUnload_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define FireEtXplatModuleUnload_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&(pContext)->Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleUnload_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleUnload_V1 _mcgen_PASTE2(McTemplateCoU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleUnload_V2"
//
#define EventXplatEnabledModuleUnload_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventXplatEnabledModuleUnload_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "ModuleUnload_V2"
//
#define FireEtXplatModuleUnload_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleUnload_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define FireEtXplatModuleUnload_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&(pContext)->Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleUnload_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleUnload_V2 _mcgen_PASTE2(McTemplateCoU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoad"
//
#define EventXplatEnabledAssemblyLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAssemblyLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AssemblyLoad"
//
#define FireEtXplatAssemblyLoad(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyLoad) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyLoad_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define FireEtXplatAssemblyLoad_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoad) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad(&(pContext)->Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyLoad_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoad _mcgen_PASTE2(McTemplateCoU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoad_V1"
//
#define EventXplatEnabledAssemblyLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAssemblyLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AssemblyLoad_V1"
//
#define FireEtXplatAssemblyLoad_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyLoad_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define FireEtXplatAssemblyLoad_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&(pContext)->Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyLoad_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoad_V1 _mcgen_PASTE2(McTemplateCoU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyUnload"
//
#define EventXplatEnabledAssemblyUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAssemblyUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AssemblyUnload"
//
#define FireEtXplatAssemblyUnload(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyUnload) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyUnload_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define FireEtXplatAssemblyUnload_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyUnload) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload(&(pContext)->Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyUnload_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyUnload _mcgen_PASTE2(McTemplateCoU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyUnload_V1"
//
#define EventXplatEnabledAssemblyUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAssemblyUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AssemblyUnload_V1"
//
#define FireEtXplatAssemblyUnload_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyUnload_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define FireEtXplatAssemblyUnload_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&(pContext)->Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyUnload_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyUnload_V1 _mcgen_PASTE2(McTemplateCoU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainLoad"
//
#define EventXplatEnabledAppDomainLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAppDomainLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AppDomainLoad"
//
#define FireEtXplatAppDomainLoad(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainLoad) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainLoad_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName)
#define FireEtXplatAppDomainLoad_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainLoad) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad(&(pContext)->Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainLoad_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainLoad _mcgen_PASTE2(McTemplateCoU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainLoad_V1"
//
#define EventXplatEnabledAppDomainLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAppDomainLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AppDomainLoad_V1"
//
#define FireEtXplatAppDomainLoad_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainLoad_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define FireEtXplatAppDomainLoad_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&(pContext)->Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainLoad_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainLoad_V1 _mcgen_PASTE2(McTemplateCoU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainUnload"
//
#define EventXplatEnabledAppDomainUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAppDomainUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AppDomainUnload"
//
#define FireEtXplatAppDomainUnload(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainUnload) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainUnload_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName)
#define FireEtXplatAppDomainUnload_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainUnload) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload(&(pContext)->Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainUnload_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainUnload _mcgen_PASTE2(McTemplateCoU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainUnload_V1"
//
#define EventXplatEnabledAppDomainUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventXplatEnabledAppDomainUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AppDomainUnload_V1"
//
#define FireEtXplatAppDomainUnload_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainUnload_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define FireEtXplatAppDomainUnload_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&(pContext)->Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainUnload_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainUnload_V1 _mcgen_PASTE2(McTemplateCoU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleRangeLoad"
//
#define EventXplatEnabledModuleRangeLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 31)
#define EventXplatEnabledModuleRangeLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 31)

//
// Event write macros for event "ModuleRangeLoad"
//
#define FireEtXplatModuleRangeLoad(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED(ModuleRangeLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define FireEtXplatModuleRangeLoad_AssumeEnabled(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)
#define FireEtXplatModuleRangeLoad_ForContext(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleRangeLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&(pContext)->Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define FireEtXplatModuleRangeLoad_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleRangeLoad _mcgen_PASTE2(McTemplateCoU0hxqqu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStart"
//
#define EventXplatEnabledStrongNameVerificationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 32)
#define EventXplatEnabledStrongNameVerificationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 32)

//
// Event write macros for event "StrongNameVerificationStart"
//
#define FireEtXplatStrongNameVerificationStart(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define FireEtXplatStrongNameVerificationStart_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)
#define FireEtXplatStrongNameVerificationStart_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&(pContext)->Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define FireEtXplatStrongNameVerificationStart_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStart _mcgen_PASTE2(McTemplateCoU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStart_V1"
//
#define EventXplatEnabledStrongNameVerificationStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 32)
#define EventXplatEnabledStrongNameVerificationStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 32)

//
// Event write macros for event "StrongNameVerificationStart_V1"
//
#define FireEtXplatStrongNameVerificationStart_V1(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatStrongNameVerificationStart_V1_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)
#define FireEtXplatStrongNameVerificationStart_V1_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&(pContext)->Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatStrongNameVerificationStart_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1 _mcgen_PASTE2(McTemplateCoU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStop"
//
#define EventXplatEnabledStrongNameVerificationStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 33)
#define EventXplatEnabledStrongNameVerificationStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 33)

//
// Event write macros for event "StrongNameVerificationStop"
//
#define FireEtXplatStrongNameVerificationStop(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define FireEtXplatStrongNameVerificationStop_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)
#define FireEtXplatStrongNameVerificationStop_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&(pContext)->Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define FireEtXplatStrongNameVerificationStop_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStop _mcgen_PASTE2(McTemplateCoU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStop_V1"
//
#define EventXplatEnabledStrongNameVerificationStop_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 33)
#define EventXplatEnabledStrongNameVerificationStop_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 33)

//
// Event write macros for event "StrongNameVerificationStop_V1"
//
#define FireEtXplatStrongNameVerificationStop_V1(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatStrongNameVerificationStop_V1_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)
#define FireEtXplatStrongNameVerificationStop_V1_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&(pContext)->Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatStrongNameVerificationStop_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1 _mcgen_PASTE2(McTemplateCoU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStart"
//
#define EventXplatEnabledAuthenticodeVerificationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 32)
#define EventXplatEnabledAuthenticodeVerificationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 32)

//
// Event write macros for event "AuthenticodeVerificationStart"
//
#define FireEtXplatAuthenticodeVerificationStart(VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath) : 0
#define FireEtXplatAuthenticodeVerificationStart_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath)
#define FireEtXplatAuthenticodeVerificationStart_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&(pContext)->Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath) : 0
#define FireEtXplatAuthenticodeVerificationStart_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart _mcgen_PASTE2(McTemplateCoU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStart_V1"
//
#define EventXplatEnabledAuthenticodeVerificationStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 32)
#define EventXplatEnabledAuthenticodeVerificationStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 32)

//
// Event write macros for event "AuthenticodeVerificationStart_V1"
//
#define FireEtXplatAuthenticodeVerificationStart_V1(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define FireEtXplatAuthenticodeVerificationStart_V1_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)
#define FireEtXplatAuthenticodeVerificationStart_V1_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&(pContext)->Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define FireEtXplatAuthenticodeVerificationStart_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1 _mcgen_PASTE2(McTemplateCoU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStop"
//
#define EventXplatEnabledAuthenticodeVerificationStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 33)
#define EventXplatEnabledAuthenticodeVerificationStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 33)

//
// Event write macros for event "AuthenticodeVerificationStop"
//
#define FireEtXplatAuthenticodeVerificationStop(VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath) : 0
#define FireEtXplatAuthenticodeVerificationStop_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath)
#define FireEtXplatAuthenticodeVerificationStop_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&(pContext)->Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath) : 0
#define FireEtXplatAuthenticodeVerificationStop_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop _mcgen_PASTE2(McTemplateCoU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStop_V1"
//
#define EventXplatEnabledAuthenticodeVerificationStop_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 33)
#define EventXplatEnabledAuthenticodeVerificationStop_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 33)

//
// Event write macros for event "AuthenticodeVerificationStop_V1"
//
#define FireEtXplatAuthenticodeVerificationStop_V1(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define FireEtXplatAuthenticodeVerificationStop_V1_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)
#define FireEtXplatAuthenticodeVerificationStop_V1_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&(pContext)->Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define FireEtXplatAuthenticodeVerificationStop_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1 _mcgen_PASTE2(McTemplateCoU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RuntimeInformationStart"
//
#define EventXplatEnabledRuntimeInformationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventXplatEnabledRuntimeInformationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "RuntimeInformationStart"
//
#define FireEtXplatRuntimeInformationStart(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED(RuntimeInformationStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define FireEtXplatRuntimeInformationStart_AssumeEnabled(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)
#define FireEtXplatRuntimeInformationStart_ForContext(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RuntimeInformationStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&(pContext)->Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define FireEtXplatRuntimeInformationStart_ForContextAssumeEnabled(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RuntimeInformationStart _mcgen_PASTE2(McTemplateCoU0hhhhhhhhhhquzjz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IncreaseMemoryPressure"
//
#define EventXplatEnabledIncreaseMemoryPressure() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledIncreaseMemoryPressure_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "IncreaseMemoryPressure"
//
#define FireEtXplatIncreaseMemoryPressure(BytesAllocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IncreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID) : 0
#define FireEtXplatIncreaseMemoryPressure_AssumeEnabled(BytesAllocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID)
#define FireEtXplatIncreaseMemoryPressure_ForContext(pContext, BytesAllocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IncreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&(pContext)->Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID) : 0
#define FireEtXplatIncreaseMemoryPressure_ForContextAssumeEnabled(pContext, BytesAllocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure _mcgen_PASTE2(McTemplateCoU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DecreaseMemoryPressure"
//
#define EventXplatEnabledDecreaseMemoryPressure() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledDecreaseMemoryPressure_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "DecreaseMemoryPressure"
//
#define FireEtXplatDecreaseMemoryPressure(BytesFreed, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DecreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID) : 0
#define FireEtXplatDecreaseMemoryPressure_AssumeEnabled(BytesFreed, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID)
#define FireEtXplatDecreaseMemoryPressure_ForContext(pContext, BytesFreed, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DecreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&(pContext)->Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID) : 0
#define FireEtXplatDecreaseMemoryPressure_ForContextAssumeEnabled(pContext, BytesFreed, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure _mcgen_PASTE2(McTemplateCoU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkWithType"
//
#define EventXplatEnabledGCMarkWithType() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCMarkWithType_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkWithType"
//
#define FireEtXplatGCMarkWithType(HeapNum, ClrInstanceID, Type, Bytes) \
        MCGEN_EVENT_ENABLED(GCMarkWithType) \
        ? _mcgen_TEMPLATE_FOR_GCMarkWithType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes) : 0
#define FireEtXplatGCMarkWithType_AssumeEnabled(HeapNum, ClrInstanceID, Type, Bytes) \
        _mcgen_TEMPLATE_FOR_GCMarkWithType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes)
#define FireEtXplatGCMarkWithType_ForContext(pContext, HeapNum, ClrInstanceID, Type, Bytes) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkWithType) \
        ? _mcgen_TEMPLATE_FOR_GCMarkWithType(&(pContext)->Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes) : 0
#define FireEtXplatGCMarkWithType_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID, Type, Bytes) \
        _mcgen_TEMPLATE_FOR_GCMarkWithType(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkWithType _mcgen_PASTE2(McTemplateCoU0qhqx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCJoin_V2"
//
#define EventXplatEnabledGCJoin_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledGCJoin_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCJoin_V2"
//
#define FireEtXplatGCJoin_V2(Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        MCGEN_EVENT_ENABLED(GCJoin_V2) \
        ? _mcgen_TEMPLATE_FOR_GCJoin_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) : 0
#define FireEtXplatGCJoin_V2_AssumeEnabled(Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        _mcgen_TEMPLATE_FOR_GCJoin_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID)
#define FireEtXplatGCJoin_V2_ForContext(pContext, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCJoin_V2) \
        ? _mcgen_TEMPLATE_FOR_GCJoin_V2(&(pContext)->Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) : 0
#define FireEtXplatGCJoin_V2_ForContextAssumeEnabled(pContext, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        _mcgen_TEMPLATE_FOR_GCJoin_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCJoin_V2 _mcgen_PASTE2(McTemplateCoU0qqqhq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCPerHeapHistory_V3"
//
#define EventXplatEnabledGCPerHeapHistory_V3() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCPerHeapHistory_V3_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCPerHeapHistory_V3"
//
#define FireEtXplatGCPerHeapHistory_V3(ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCPerHeapHistory_V3) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) : 0
#define FireEtXplatGCPerHeapHistory_V3_AssumeEnabled(ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values)
#define FireEtXplatGCPerHeapHistory_V3_ForContext(pContext, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCPerHeapHistory_V3) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&(pContext)->Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) : 0
#define FireEtXplatGCPerHeapHistory_V3_ForContextAssumeEnabled(pContext, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3 _mcgen_PASTE2(McTemplateCoU0hppppppqqqqqqpqNR14_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGlobalHeapHistory_V2"
//
#define EventXplatEnabledGCGlobalHeapHistory_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCGlobalHeapHistory_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCGlobalHeapHistory_V2"
//
#define FireEtXplatGCGlobalHeapHistory_V2(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        MCGEN_EVENT_ENABLED(GCGlobalHeapHistory_V2) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) : 0
#define FireEtXplatGCGlobalHeapHistory_V2_AssumeEnabled(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure)
#define FireEtXplatGCGlobalHeapHistory_V2_ForContext(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGlobalHeapHistory_V2) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&(pContext)->Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) : 0
#define FireEtXplatGCGlobalHeapHistory_V2_ForContextAssumeEnabled(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2 _mcgen_PASTE2(McTemplateCoU0xdqqqqhqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGlobalHeapHistory_V3"
//
#define EventXplatEnabledGCGlobalHeapHistory_V3() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCGlobalHeapHistory_V3_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCGlobalHeapHistory_V3"
//
#define FireEtXplatGCGlobalHeapHistory_V3(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1) \
        MCGEN_EVENT_ENABLED(GCGlobalHeapHistory_V3) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V3, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1) : 0
#define FireEtXplatGCGlobalHeapHistory_V3_AssumeEnabled(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V3, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1)
#define FireEtXplatGCGlobalHeapHistory_V3_ForContext(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGlobalHeapHistory_V3) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V3(&(pContext)->Context, &GCGlobalHeapHistory_V3, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1) : 0
#define FireEtXplatGCGlobalHeapHistory_V3_ForContextAssumeEnabled(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V3(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCGlobalHeapHistory_V3, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V3 _mcgen_PASTE2(McTemplateCoU0xdqqqqhqqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGlobalHeapHistory_V4"
//
#define EventXplatEnabledGCGlobalHeapHistory_V4() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCGlobalHeapHistory_V4_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCGlobalHeapHistory_V4"
//
#define FireEtXplatGCGlobalHeapHistory_V4(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCGlobalHeapHistory_V4) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V4(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V4, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values) : 0
#define FireEtXplatGCGlobalHeapHistory_V4_AssumeEnabled(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V4(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V4, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values)
#define FireEtXplatGCGlobalHeapHistory_V4_ForContext(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGlobalHeapHistory_V4) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V4(&(pContext)->Context, &GCGlobalHeapHistory_V4, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values) : 0
#define FireEtXplatGCGlobalHeapHistory_V4_ForContextAssumeEnabled(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V4(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCGlobalHeapHistory_V4, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure, CondemnReasons0, CondemnReasons1, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V4 _mcgen_PASTE2(McTemplateCoU0xdqqqqhqqqqqNR11_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GenAwareBegin"
//
#define EventXplatEnabledGenAwareBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGenAwareBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GenAwareBegin"
//
#define FireEtXplatGenAwareBegin(Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GenAwareBegin) \
        ? _mcgen_TEMPLATE_FOR_GenAwareBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GenAwareBegin, Count, ClrInstanceID) : 0
#define FireEtXplatGenAwareBegin_AssumeEnabled(Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GenAwareBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GenAwareBegin, Count, ClrInstanceID)
#define FireEtXplatGenAwareBegin_ForContext(pContext, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GenAwareBegin) \
        ? _mcgen_TEMPLATE_FOR_GenAwareBegin(&(pContext)->Context, &GenAwareBegin, Count, ClrInstanceID) : 0
#define FireEtXplatGenAwareBegin_ForContextAssumeEnabled(pContext, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GenAwareBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GenAwareBegin, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GenAwareBegin _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GenAwareEnd"
//
#define EventXplatEnabledGenAwareEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventXplatEnabledGenAwareEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GenAwareEnd"
//
#define FireEtXplatGenAwareEnd(Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GenAwareEnd) \
        ? _mcgen_TEMPLATE_FOR_GenAwareEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GenAwareEnd, Count, ClrInstanceID) : 0
#define FireEtXplatGenAwareEnd_AssumeEnabled(Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GenAwareEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GenAwareEnd, Count, ClrInstanceID)
#define FireEtXplatGenAwareEnd_ForContext(pContext, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GenAwareEnd) \
        ? _mcgen_TEMPLATE_FOR_GenAwareEnd(&(pContext)->Context, &GenAwareEnd, Count, ClrInstanceID) : 0
#define FireEtXplatGenAwareEnd_ForContextAssumeEnabled(pContext, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GenAwareEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GenAwareEnd, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GenAwareEnd _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCLOHCompact"
//
#define EventXplatEnabledGCLOHCompact() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventXplatEnabledGCLOHCompact_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCLOHCompact"
//
#define FireEtXplatGCLOHCompact(ClrInstanceID, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCLOHCompact) \
        ? _mcgen_TEMPLATE_FOR_GCLOHCompact(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCLOHCompact, ClrInstanceID, Count, Values_Len_, Values) : 0
#define FireEtXplatGCLOHCompact_AssumeEnabled(ClrInstanceID, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCLOHCompact(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCLOHCompact, ClrInstanceID, Count, Values_Len_, Values)
#define FireEtXplatGCLOHCompact_ForContext(pContext, ClrInstanceID, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCLOHCompact) \
        ? _mcgen_TEMPLATE_FOR_GCLOHCompact(&(pContext)->Context, &GCLOHCompact, ClrInstanceID, Count, Values_Len_, Values) : 0
#define FireEtXplatGCLOHCompact_ForContextAssumeEnabled(pContext, ClrInstanceID, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCLOHCompact(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCLOHCompact, ClrInstanceID, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCLOHCompact _mcgen_PASTE2(McTemplateCoU0hhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFitBucketInfo"
//
#define EventXplatEnabledGCFitBucketInfo() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventXplatEnabledGCFitBucketInfo_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCFitBucketInfo"
//
#define FireEtXplatGCFitBucketInfo(ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCFitBucketInfo) \
        ? _mcgen_TEMPLATE_FOR_GCFitBucketInfo(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFitBucketInfo, ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values) : 0
#define FireEtXplatGCFitBucketInfo_AssumeEnabled(ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCFitBucketInfo(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFitBucketInfo, ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values)
#define FireEtXplatGCFitBucketInfo_ForContext(pContext, ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFitBucketInfo) \
        ? _mcgen_TEMPLATE_FOR_GCFitBucketInfo(&(pContext)->Context, &GCFitBucketInfo, ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values) : 0
#define FireEtXplatGCFitBucketInfo_ForContextAssumeEnabled(pContext, ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCFitBucketInfo(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFitBucketInfo, ClrInstanceID, BucketKind, TotalSize, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFitBucketInfo _mcgen_PASTE2(McTemplateCoU0hhxhNR3_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugIPCEventStart"
//
#define EventXplatEnabledDebugIPCEventStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 34)
#define EventXplatEnabledDebugIPCEventStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 34)

//
// Event write macros for event "DebugIPCEventStart"
//
#define FireEtXplatDebugIPCEventStart() \
        MCGEN_EVENT_ENABLED(DebugIPCEventStart) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventStart) : 0
#define FireEtXplatDebugIPCEventStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventStart)
#define FireEtXplatDebugIPCEventStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugIPCEventStart) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&(pContext)->Context, &DebugIPCEventStart) : 0
#define FireEtXplatDebugIPCEventStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugIPCEventStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugIPCEventStart _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugIPCEventEnd"
//
#define EventXplatEnabledDebugIPCEventEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 34)
#define EventXplatEnabledDebugIPCEventEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 34)

//
// Event write macros for event "DebugIPCEventEnd"
//
#define FireEtXplatDebugIPCEventEnd() \
        MCGEN_EVENT_ENABLED(DebugIPCEventEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventEnd) : 0
#define FireEtXplatDebugIPCEventEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventEnd)
#define FireEtXplatDebugIPCEventEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugIPCEventEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&(pContext)->Context, &DebugIPCEventEnd) : 0
#define FireEtXplatDebugIPCEventEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugIPCEventEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugIPCEventEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugExceptionProcessingStart"
//
#define EventXplatEnabledDebugExceptionProcessingStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 34)
#define EventXplatEnabledDebugExceptionProcessingStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 34)

//
// Event write macros for event "DebugExceptionProcessingStart"
//
#define FireEtXplatDebugExceptionProcessingStart() \
        MCGEN_EVENT_ENABLED(DebugExceptionProcessingStart) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingStart) : 0
#define FireEtXplatDebugExceptionProcessingStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingStart)
#define FireEtXplatDebugExceptionProcessingStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugExceptionProcessingStart) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&(pContext)->Context, &DebugExceptionProcessingStart) : 0
#define FireEtXplatDebugExceptionProcessingStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugExceptionProcessingStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugExceptionProcessingEnd"
//
#define EventXplatEnabledDebugExceptionProcessingEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 34)
#define EventXplatEnabledDebugExceptionProcessingEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 34)

//
// Event write macros for event "DebugExceptionProcessingEnd"
//
#define FireEtXplatDebugExceptionProcessingEnd() \
        MCGEN_EVENT_ENABLED(DebugExceptionProcessingEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingEnd) : 0
#define FireEtXplatDebugExceptionProcessingEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingEnd)
#define FireEtXplatDebugExceptionProcessingEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugExceptionProcessingEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&(pContext)->Context, &DebugExceptionProcessingEnd) : 0
#define FireEtXplatDebugExceptionProcessingEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugExceptionProcessingEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CodeSymbols"
//
#define EventXplatEnabledCodeSymbols() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 35)
#define EventXplatEnabledCodeSymbols_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 35)

//
// Event write macros for event "CodeSymbols"
//
#define FireEtXplatCodeSymbols(ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(CodeSymbols) \
        ? _mcgen_TEMPLATE_FOR_CodeSymbols(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &CodeSymbols, ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID) : 0
#define FireEtXplatCodeSymbols_AssumeEnabled(ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CodeSymbols(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &CodeSymbols, ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID)
#define FireEtXplatCodeSymbols_ForContext(pContext, ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CodeSymbols) \
        ? _mcgen_TEMPLATE_FOR_CodeSymbols(&(pContext)->Context, &CodeSymbols, ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID) : 0
#define FireEtXplatCodeSymbols_ForContextAssumeEnabled(pContext, ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CodeSymbols(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &CodeSymbols, ModuleId, TotalChunks, ChunkNumber, ChunkLength, Chunk, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CodeSymbols _mcgen_PASTE2(McTemplateCoU0xhhqbr3h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EventSource"
//
#define EventXplatEnabledEventSource() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 36)
#define EventXplatEnabledEventSource_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 36)

//
// Event write macros for event "EventSource"
//
#define FireEtXplatEventSource(EventID, EventName, EventSourceName, Payload) \
        MCGEN_EVENT_ENABLED(EventSource) \
        ? _mcgen_TEMPLATE_FOR_EventSource(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &EventSource, EventID, EventName, EventSourceName, Payload) : 0
#define FireEtXplatEventSource_AssumeEnabled(EventID, EventName, EventSourceName, Payload) \
        _mcgen_TEMPLATE_FOR_EventSource(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &EventSource, EventID, EventName, EventSourceName, Payload)
#define FireEtXplatEventSource_ForContext(pContext, EventID, EventName, EventSourceName, Payload) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EventSource) \
        ? _mcgen_TEMPLATE_FOR_EventSource(&(pContext)->Context, &EventSource, EventID, EventName, EventSourceName, Payload) : 0
#define FireEtXplatEventSource_ForContextAssumeEnabled(pContext, EventID, EventName, EventSourceName, Payload) \
        _mcgen_TEMPLATE_FOR_EventSource(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &EventSource, EventID, EventName, EventSourceName, Payload)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EventSource _mcgen_PASTE2(McTemplateCoU0dzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TieredCompilationSettings"
//
#define EventXplatEnabledTieredCompilationSettings() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 37)
#define EventXplatEnabledTieredCompilationSettings_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 37)

//
// Event write macros for event "TieredCompilationSettings"
//
#define FireEtXplatTieredCompilationSettings(ClrInstanceID, Flags) \
        MCGEN_EVENT_ENABLED(TieredCompilationSettings) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationSettings(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationSettings, ClrInstanceID, Flags) : 0
#define FireEtXplatTieredCompilationSettings_AssumeEnabled(ClrInstanceID, Flags) \
        _mcgen_TEMPLATE_FOR_TieredCompilationSettings(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationSettings, ClrInstanceID, Flags)
#define FireEtXplatTieredCompilationSettings_ForContext(pContext, ClrInstanceID, Flags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TieredCompilationSettings) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationSettings(&(pContext)->Context, &TieredCompilationSettings, ClrInstanceID, Flags) : 0
#define FireEtXplatTieredCompilationSettings_ForContextAssumeEnabled(pContext, ClrInstanceID, Flags) \
        _mcgen_TEMPLATE_FOR_TieredCompilationSettings(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &TieredCompilationSettings, ClrInstanceID, Flags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TieredCompilationSettings _mcgen_PASTE2(McTemplateCoU0hq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TieredCompilationPause"
//
#define EventXplatEnabledTieredCompilationPause() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 37)
#define EventXplatEnabledTieredCompilationPause_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 37)

//
// Event write macros for event "TieredCompilationPause"
//
#define FireEtXplatTieredCompilationPause(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(TieredCompilationPause) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationPause(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationPause, ClrInstanceID) : 0
#define FireEtXplatTieredCompilationPause_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TieredCompilationPause(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationPause, ClrInstanceID)
#define FireEtXplatTieredCompilationPause_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TieredCompilationPause) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationPause(&(pContext)->Context, &TieredCompilationPause, ClrInstanceID) : 0
#define FireEtXplatTieredCompilationPause_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TieredCompilationPause(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &TieredCompilationPause, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TieredCompilationPause _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TieredCompilationResume"
//
#define EventXplatEnabledTieredCompilationResume() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 37)
#define EventXplatEnabledTieredCompilationResume_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 37)

//
// Event write macros for event "TieredCompilationResume"
//
#define FireEtXplatTieredCompilationResume(ClrInstanceID, NewMethodCount) \
        MCGEN_EVENT_ENABLED(TieredCompilationResume) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationResume(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationResume, ClrInstanceID, NewMethodCount) : 0
#define FireEtXplatTieredCompilationResume_AssumeEnabled(ClrInstanceID, NewMethodCount) \
        _mcgen_TEMPLATE_FOR_TieredCompilationResume(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationResume, ClrInstanceID, NewMethodCount)
#define FireEtXplatTieredCompilationResume_ForContext(pContext, ClrInstanceID, NewMethodCount) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TieredCompilationResume) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationResume(&(pContext)->Context, &TieredCompilationResume, ClrInstanceID, NewMethodCount) : 0
#define FireEtXplatTieredCompilationResume_ForContextAssumeEnabled(pContext, ClrInstanceID, NewMethodCount) \
        _mcgen_TEMPLATE_FOR_TieredCompilationResume(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &TieredCompilationResume, ClrInstanceID, NewMethodCount)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TieredCompilationResume _mcgen_PASTE2(McTemplateCoU0hq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TieredCompilationBackgroundJitStart"
//
#define EventXplatEnabledTieredCompilationBackgroundJitStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 37)
#define EventXplatEnabledTieredCompilationBackgroundJitStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 37)

//
// Event write macros for event "TieredCompilationBackgroundJitStart"
//
#define FireEtXplatTieredCompilationBackgroundJitStart(ClrInstanceID, PendingMethodCount) \
        MCGEN_EVENT_ENABLED(TieredCompilationBackgroundJitStart) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationBackgroundJitStart, ClrInstanceID, PendingMethodCount) : 0
#define FireEtXplatTieredCompilationBackgroundJitStart_AssumeEnabled(ClrInstanceID, PendingMethodCount) \
        _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationBackgroundJitStart, ClrInstanceID, PendingMethodCount)
#define FireEtXplatTieredCompilationBackgroundJitStart_ForContext(pContext, ClrInstanceID, PendingMethodCount) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TieredCompilationBackgroundJitStart) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStart(&(pContext)->Context, &TieredCompilationBackgroundJitStart, ClrInstanceID, PendingMethodCount) : 0
#define FireEtXplatTieredCompilationBackgroundJitStart_ForContextAssumeEnabled(pContext, ClrInstanceID, PendingMethodCount) \
        _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &TieredCompilationBackgroundJitStart, ClrInstanceID, PendingMethodCount)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStart _mcgen_PASTE2(McTemplateCoU0hq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TieredCompilationBackgroundJitStop"
//
#define EventXplatEnabledTieredCompilationBackgroundJitStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 37)
#define EventXplatEnabledTieredCompilationBackgroundJitStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 37)

//
// Event write macros for event "TieredCompilationBackgroundJitStop"
//
#define FireEtXplatTieredCompilationBackgroundJitStop(ClrInstanceID, PendingMethodCount, JittedMethodCount) \
        MCGEN_EVENT_ENABLED(TieredCompilationBackgroundJitStop) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationBackgroundJitStop, ClrInstanceID, PendingMethodCount, JittedMethodCount) : 0
#define FireEtXplatTieredCompilationBackgroundJitStop_AssumeEnabled(ClrInstanceID, PendingMethodCount, JittedMethodCount) \
        _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &TieredCompilationBackgroundJitStop, ClrInstanceID, PendingMethodCount, JittedMethodCount)
#define FireEtXplatTieredCompilationBackgroundJitStop_ForContext(pContext, ClrInstanceID, PendingMethodCount, JittedMethodCount) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TieredCompilationBackgroundJitStop) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStop(&(pContext)->Context, &TieredCompilationBackgroundJitStop, ClrInstanceID, PendingMethodCount, JittedMethodCount) : 0
#define FireEtXplatTieredCompilationBackgroundJitStop_ForContextAssumeEnabled(pContext, ClrInstanceID, PendingMethodCount, JittedMethodCount) \
        _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &TieredCompilationBackgroundJitStop, ClrInstanceID, PendingMethodCount, JittedMethodCount)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TieredCompilationBackgroundJitStop _mcgen_PASTE2(McTemplateCoU0hqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoadStart"
//
#define EventXplatEnabledAssemblyLoadStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 38)
#define EventXplatEnabledAssemblyLoadStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 38)

//
// Event write macros for event "AssemblyLoadStart"
//
#define FireEtXplatAssemblyLoadStart(ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext) \
        MCGEN_EVENT_ENABLED(AssemblyLoadStart) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadStart, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext) : 0
#define FireEtXplatAssemblyLoadStart_AssumeEnabled(ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadStart, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext)
#define FireEtXplatAssemblyLoadStart_ForContext(pContext, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoadStart) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadStart(&(pContext)->Context, &AssemblyLoadStart, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext) : 0
#define FireEtXplatAssemblyLoadStart_ForContextAssumeEnabled(pContext, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoadStart, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoadStart _mcgen_PASTE2(McTemplateCoU0hzzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoadStop"
//
#define EventXplatEnabledAssemblyLoadStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 38)
#define EventXplatEnabledAssemblyLoadStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 38)

//
// Event write macros for event "AssemblyLoadStop"
//
#define FireEtXplatAssemblyLoadStop(ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached) \
        MCGEN_EVENT_ENABLED(AssemblyLoadStop) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadStop, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached) : 0
#define FireEtXplatAssemblyLoadStop_AssumeEnabled(ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadStop, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached)
#define FireEtXplatAssemblyLoadStop_ForContext(pContext, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoadStop) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadStop(&(pContext)->Context, &AssemblyLoadStop, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached) : 0
#define FireEtXplatAssemblyLoadStop_ForContextAssumeEnabled(pContext, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoadStop, ClrInstanceID, AssemblyName, AssemblyPath, RequestingAssembly, AssemblyLoadContext, RequestingAssemblyLoadContext, Success, ResultAssemblyName, ResultAssemblyPath, Cached)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoadStop _mcgen_PASTE2(McTemplateCoU0hzzzzztzzt_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ResolutionAttempted"
//
#define EventXplatEnabledResolutionAttempted() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 38)
#define EventXplatEnabledResolutionAttempted_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 38)

//
// Event write macros for event "ResolutionAttempted"
//
#define FireEtXplatResolutionAttempted(ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage) \
        MCGEN_EVENT_ENABLED(ResolutionAttempted) \
        ? _mcgen_TEMPLATE_FOR_ResolutionAttempted(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ResolutionAttempted, ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage) : 0
#define FireEtXplatResolutionAttempted_AssumeEnabled(ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage) \
        _mcgen_TEMPLATE_FOR_ResolutionAttempted(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ResolutionAttempted, ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage)
#define FireEtXplatResolutionAttempted_ForContext(pContext, ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ResolutionAttempted) \
        ? _mcgen_TEMPLATE_FOR_ResolutionAttempted(&(pContext)->Context, &ResolutionAttempted, ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage) : 0
#define FireEtXplatResolutionAttempted_ForContextAssumeEnabled(pContext, ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage) \
        _mcgen_TEMPLATE_FOR_ResolutionAttempted(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ResolutionAttempted, ClrInstanceID, AssemblyName, Stage, AssemblyLoadContext, Result, ResultAssemblyName, ResultAssemblyPath, ErrorMessage)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ResolutionAttempted _mcgen_PASTE2(McTemplateCoU0hzhzhzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoadContextResolvingHandlerInvoked"
//
#define EventXplatEnabledAssemblyLoadContextResolvingHandlerInvoked() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 38)
#define EventXplatEnabledAssemblyLoadContextResolvingHandlerInvoked_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 38)

//
// Event write macros for event "AssemblyLoadContextResolvingHandlerInvoked"
//
#define FireEtXplatAssemblyLoadContextResolvingHandlerInvoked(ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath) \
        MCGEN_EVENT_ENABLED(AssemblyLoadContextResolvingHandlerInvoked) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadContextResolvingHandlerInvoked(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadContextResolvingHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath) : 0
#define FireEtXplatAssemblyLoadContextResolvingHandlerInvoked_AssumeEnabled(ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadContextResolvingHandlerInvoked(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadContextResolvingHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath)
#define FireEtXplatAssemblyLoadContextResolvingHandlerInvoked_ForContext(pContext, ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoadContextResolvingHandlerInvoked) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadContextResolvingHandlerInvoked(&(pContext)->Context, &AssemblyLoadContextResolvingHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath) : 0
#define FireEtXplatAssemblyLoadContextResolvingHandlerInvoked_ForContextAssumeEnabled(pContext, ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadContextResolvingHandlerInvoked(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoadContextResolvingHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, AssemblyLoadContext, ResultAssemblyName, ResultAssemblyPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoadContextResolvingHandlerInvoked _mcgen_PASTE2(McTemplateCoU0hzzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainAssemblyResolveHandlerInvoked"
//
#define EventXplatEnabledAppDomainAssemblyResolveHandlerInvoked() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 38)
#define EventXplatEnabledAppDomainAssemblyResolveHandlerInvoked_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 38)

//
// Event write macros for event "AppDomainAssemblyResolveHandlerInvoked"
//
#define FireEtXplatAppDomainAssemblyResolveHandlerInvoked(ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath) \
        MCGEN_EVENT_ENABLED(AppDomainAssemblyResolveHandlerInvoked) \
        ? _mcgen_TEMPLATE_FOR_AppDomainAssemblyResolveHandlerInvoked(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainAssemblyResolveHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath) : 0
#define FireEtXplatAppDomainAssemblyResolveHandlerInvoked_AssumeEnabled(ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath) \
        _mcgen_TEMPLATE_FOR_AppDomainAssemblyResolveHandlerInvoked(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainAssemblyResolveHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath)
#define FireEtXplatAppDomainAssemblyResolveHandlerInvoked_ForContext(pContext, ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainAssemblyResolveHandlerInvoked) \
        ? _mcgen_TEMPLATE_FOR_AppDomainAssemblyResolveHandlerInvoked(&(pContext)->Context, &AppDomainAssemblyResolveHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath) : 0
#define FireEtXplatAppDomainAssemblyResolveHandlerInvoked_ForContextAssumeEnabled(pContext, ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath) \
        _mcgen_TEMPLATE_FOR_AppDomainAssemblyResolveHandlerInvoked(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainAssemblyResolveHandlerInvoked, ClrInstanceID, AssemblyName, HandlerName, ResultAssemblyName, ResultAssemblyPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainAssemblyResolveHandlerInvoked _mcgen_PASTE2(McTemplateCoU0hzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoadFromResolveHandlerInvoked"
//
#define EventXplatEnabledAssemblyLoadFromResolveHandlerInvoked() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 38)
#define EventXplatEnabledAssemblyLoadFromResolveHandlerInvoked_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 38)

//
// Event write macros for event "AssemblyLoadFromResolveHandlerInvoked"
//
#define FireEtXplatAssemblyLoadFromResolveHandlerInvoked(ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath) \
        MCGEN_EVENT_ENABLED(AssemblyLoadFromResolveHandlerInvoked) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadFromResolveHandlerInvoked(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadFromResolveHandlerInvoked, ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath) : 0
#define FireEtXplatAssemblyLoadFromResolveHandlerInvoked_AssumeEnabled(ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadFromResolveHandlerInvoked(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoadFromResolveHandlerInvoked, ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath)
#define FireEtXplatAssemblyLoadFromResolveHandlerInvoked_ForContext(pContext, ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoadFromResolveHandlerInvoked) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoadFromResolveHandlerInvoked(&(pContext)->Context, &AssemblyLoadFromResolveHandlerInvoked, ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath) : 0
#define FireEtXplatAssemblyLoadFromResolveHandlerInvoked_ForContextAssumeEnabled(pContext, ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath) \
        _mcgen_TEMPLATE_FOR_AssemblyLoadFromResolveHandlerInvoked(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoadFromResolveHandlerInvoked, ClrInstanceID, AssemblyName, IsTrackedLoad, RequestingAssemblyPath, ComputedRequestedAssemblyPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoadFromResolveHandlerInvoked _mcgen_PASTE2(McTemplateCoU0hztzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "KnownPathProbed"
//
#define EventXplatEnabledKnownPathProbed() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 38)
#define EventXplatEnabledKnownPathProbed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 38)

//
// Event write macros for event "KnownPathProbed"
//
#define FireEtXplatKnownPathProbed(ClrInstanceID, FilePath, Source, Result) \
        MCGEN_EVENT_ENABLED(KnownPathProbed) \
        ? _mcgen_TEMPLATE_FOR_KnownPathProbed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &KnownPathProbed, ClrInstanceID, FilePath, Source, Result) : 0
#define FireEtXplatKnownPathProbed_AssumeEnabled(ClrInstanceID, FilePath, Source, Result) \
        _mcgen_TEMPLATE_FOR_KnownPathProbed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &KnownPathProbed, ClrInstanceID, FilePath, Source, Result)
#define FireEtXplatKnownPathProbed_ForContext(pContext, ClrInstanceID, FilePath, Source, Result) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, KnownPathProbed) \
        ? _mcgen_TEMPLATE_FOR_KnownPathProbed(&(pContext)->Context, &KnownPathProbed, ClrInstanceID, FilePath, Source, Result) : 0
#define FireEtXplatKnownPathProbed_ForContextAssumeEnabled(pContext, ClrInstanceID, FilePath, Source, Result) \
        _mcgen_TEMPLATE_FOR_KnownPathProbed(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &KnownPathProbed, ClrInstanceID, FilePath, Source, Result)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_KnownPathProbed _mcgen_PASTE2(McTemplateCoU0hzhd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "JitInstrumentationData"
//
#define EventXplatEnabledJitInstrumentationData() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 39)
#define EventXplatEnabledJitInstrumentationData_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 39)

//
// Event write macros for event "JitInstrumentationData"
//
#define FireEtXplatJitInstrumentationData(ClrInstanceID, MethodFlags, DataSize, MethodID, Data) \
        MCGEN_EVENT_ENABLED(JitInstrumentationData) \
        ? _mcgen_TEMPLATE_FOR_JitInstrumentationData(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &JitInstrumentationData, ClrInstanceID, MethodFlags, DataSize, MethodID, Data) : 0
#define FireEtXplatJitInstrumentationData_AssumeEnabled(ClrInstanceID, MethodFlags, DataSize, MethodID, Data) \
        _mcgen_TEMPLATE_FOR_JitInstrumentationData(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &JitInstrumentationData, ClrInstanceID, MethodFlags, DataSize, MethodID, Data)
#define FireEtXplatJitInstrumentationData_ForContext(pContext, ClrInstanceID, MethodFlags, DataSize, MethodID, Data) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, JitInstrumentationData) \
        ? _mcgen_TEMPLATE_FOR_JitInstrumentationData(&(pContext)->Context, &JitInstrumentationData, ClrInstanceID, MethodFlags, DataSize, MethodID, Data) : 0
#define FireEtXplatJitInstrumentationData_ForContextAssumeEnabled(pContext, ClrInstanceID, MethodFlags, DataSize, MethodID, Data) \
        _mcgen_TEMPLATE_FOR_JitInstrumentationData(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &JitInstrumentationData, ClrInstanceID, MethodFlags, DataSize, MethodID, Data)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_JitInstrumentationData _mcgen_PASTE2(McTemplateCoU0hqqxbr2_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "JitInstrumentationDataVerbose"
//
#define EventXplatEnabledJitInstrumentationDataVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 39)
#define EventXplatEnabledJitInstrumentationDataVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 39)

//
// Event write macros for event "JitInstrumentationDataVerbose"
//
#define FireEtXplatJitInstrumentationDataVerbose(ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data) \
        MCGEN_EVENT_ENABLED(JitInstrumentationDataVerbose) \
        ? _mcgen_TEMPLATE_FOR_JitInstrumentationDataVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &JitInstrumentationDataVerbose, ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data) : 0
#define FireEtXplatJitInstrumentationDataVerbose_AssumeEnabled(ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data) \
        _mcgen_TEMPLATE_FOR_JitInstrumentationDataVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &JitInstrumentationDataVerbose, ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data)
#define FireEtXplatJitInstrumentationDataVerbose_ForContext(pContext, ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, JitInstrumentationDataVerbose) \
        ? _mcgen_TEMPLATE_FOR_JitInstrumentationDataVerbose(&(pContext)->Context, &JitInstrumentationDataVerbose, ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data) : 0
#define FireEtXplatJitInstrumentationDataVerbose_ForContextAssumeEnabled(pContext, ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data) \
        _mcgen_TEMPLATE_FOR_JitInstrumentationDataVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &JitInstrumentationDataVerbose, ClrInstanceID, MethodFlags, DataSize, MethodID, ModuleID, MethodToken, MethodNamespace, MethodName, MethodSignature, Data)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_JitInstrumentationDataVerbose _mcgen_PASTE2(McTemplateCoU0hqqxxqzzzbr2_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ProfilerMessage"
//
#define EventXplatEnabledProfilerMessage() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 40)
#define EventXplatEnabledProfilerMessage_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 40)

//
// Event write macros for event "ProfilerMessage"
//
#define FireEtXplatProfilerMessage(ClrInstanceID, Message) \
        MCGEN_EVENT_ENABLED(ProfilerMessage) \
        ? _mcgen_TEMPLATE_FOR_ProfilerMessage(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ProfilerMessage, ClrInstanceID, Message) : 0
#define FireEtXplatProfilerMessage_AssumeEnabled(ClrInstanceID, Message) \
        _mcgen_TEMPLATE_FOR_ProfilerMessage(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ProfilerMessage, ClrInstanceID, Message)
#define FireEtXplatProfilerMessage_ForContext(pContext, ClrInstanceID, Message) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ProfilerMessage) \
        ? _mcgen_TEMPLATE_FOR_ProfilerMessage(&(pContext)->Context, &ProfilerMessage, ClrInstanceID, Message) : 0
#define FireEtXplatProfilerMessage_ForContextAssumeEnabled(pContext, ClrInstanceID, Message) \
        _mcgen_TEMPLATE_FOR_ProfilerMessage(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ProfilerMessage, ClrInstanceID, Message)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ProfilerMessage _mcgen_PASTE2(McTemplateCoU0hz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExecutionCheckpoint"
//
#define EventXplatEnabledExecutionCheckpoint() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 31)
#define EventXplatEnabledExecutionCheckpoint_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 31)

//
// Event write macros for event "ExecutionCheckpoint"
//
#define FireEtXplatExecutionCheckpoint(ClrInstanceID, Name, Timestamp) \
        MCGEN_EVENT_ENABLED(ExecutionCheckpoint) \
        ? _mcgen_TEMPLATE_FOR_ExecutionCheckpoint(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExecutionCheckpoint, ClrInstanceID, Name, Timestamp) : 0
#define FireEtXplatExecutionCheckpoint_AssumeEnabled(ClrInstanceID, Name, Timestamp) \
        _mcgen_TEMPLATE_FOR_ExecutionCheckpoint(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExecutionCheckpoint, ClrInstanceID, Name, Timestamp)
#define FireEtXplatExecutionCheckpoint_ForContext(pContext, ClrInstanceID, Name, Timestamp) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExecutionCheckpoint) \
        ? _mcgen_TEMPLATE_FOR_ExecutionCheckpoint(&(pContext)->Context, &ExecutionCheckpoint, ClrInstanceID, Name, Timestamp) : 0
#define FireEtXplatExecutionCheckpoint_ForContextAssumeEnabled(pContext, ClrInstanceID, Name, Timestamp) \
        _mcgen_TEMPLATE_FOR_ExecutionCheckpoint(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExecutionCheckpoint, ClrInstanceID, Name, Timestamp)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExecutionCheckpoint _mcgen_PASTE2(McTemplateCoU0hzi_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Microsoft-Windows-DotNETRuntimeRundown" event count 50
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = a669021c-c450-4609-a035-5af59af4df18
EXTERN_C __declspec(selectany) const GUID MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER = {0xa669021c, 0xc450, 0x4609, {0xa0, 0x35, 0x5a, 0xf5, 0x9a, 0xf4, 0xdf, 0x18}};

#ifndef MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits NULL
#endif // MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits

//
// Opcodes
//
#define CLR_METHODDC_METHODDCSTART_OPCODE 0x23
#define CLR_METHODDC_METHODDCEND_OPCODE 0x24
#define CLR_METHODDC_METHODDCSTARTVERBOSE_OPCODE 0x27
#define CLR_METHODDC_METHODDCENDVERBOSE_OPCODE 0x28
#define CLR_METHODDC_METHODDCSTARTILTONATIVEMAP_OPCODE 0x29
#define CLR_METHODDC_METHODDCENDILTONATIVEMAP_OPCODE 0x2a
#define CLR_METHODDC_DCSTARTCOMPLETE_OPCODE 0xe
#define CLR_METHODDC_DCENDCOMPLETE_OPCODE 0xf
#define CLR_METHODDC_DCSTARTINIT_OPCODE 0x10
#define CLR_METHODDC_DCENDINIT_OPCODE 0x11
#define CLR_LOADERDC_MODULEDCSTART_OPCODE 0x23
#define CLR_LOADERDC_MODULEDCEND_OPCODE 0x24
#define CLR_LOADERDC_ASSEMBLYDCSTART_OPCODE 0x27
#define CLR_LOADERDC_ASSEMBLYDCEND_OPCODE 0x28
#define CLR_LOADERDC_APPDOMAINDCSTART_OPCODE 0x2b
#define CLR_LOADERDC_APPDOMAINDCEND_OPCODE 0x2c
#define CLR_LOADERDC_DOMAINMODULEDCSTART_OPCODE 0x2e
#define CLR_LOADERDC_DOMAINMODULEDCEND_OPCODE 0x2f
#define CLR_LOADERDC_THREADDC_OPCODE 0x30
#define CLR_RUNDOWNSTACK_STACKWALK_OPCODE 0x52
#define CLR_PERFTRACKRUNDOWN_MODULERANGEDCSTART_OPCODE 0xa
#define CLR_PERFTRACKRUNDOWN_MODULERANGEDCEND_OPCODE 0xb
#define CLR_TIERED_COMPILATION_SETTINGS_DCSTART_OPCODE 0xb
#define CLR_EXECUTIONCHECKPOINT_DCSTART_OPCODE 0xb
#define CLR_GC_GCSETTINGS_OPCODE 0xa

//
// Tasks
//
#define CLR_METHODRUNDOWN_TASK 0x1
EXTERN_C __declspec(selectany) const GUID CLRMethodRundownId = {0x0bcd91db, 0xf943, 0x454a, {0xa6, 0x62, 0x6e, 0xdb, 0xcf, 0xbb, 0x76, 0xd2}};
#define CLR_LOADERRUNDOWN_TASK 0x2
EXTERN_C __declspec(selectany) const GUID CLRLoaderRundownId = {0x5a54f4df, 0xd302, 0x4fee, {0xa2, 0x11, 0x6c, 0x2c, 0x0c, 0x1d, 0xcb, 0x1a}};
#define CLR_STACKRUNDOWN_TASK 0xb
EXTERN_C __declspec(selectany) const GUID CLRStackRundownId = {0xd3363dc0, 0x243a, 0x4620, {0xa4, 0xd0, 0x8a, 0x07, 0xd7, 0x72, 0xf5, 0x33}};
#define CLR_RuntimeInformation_TASK 0x13
EXTERN_C __declspec(selectany) const GUID CLRRuntimeInformationRundownId = {0xcd7d3e32, 0x65fe, 0x40cd, {0x92, 0x25, 0xa2, 0x57, 0x7d, 0x20, 0x3f, 0xc3}};
#define CLR_PERFTRACKRUNDOWN_TASK 0x14
EXTERN_C __declspec(selectany) const GUID CLRPerfTrackRundownId = {0xeac685f6, 0x2104, 0x4dec, {0x88, 0xfd, 0x91, 0xe4, 0x25, 0x42, 0x21, 0xec}};
#define CLR_TIERED_COMPILATION_RUNDOWN_TASK 0x1f
EXTERN_C __declspec(selectany) const GUID TieredCompilationRundownId = {0xa1673472, 0x0564, 0x48ea, {0xa9, 0x5d, 0xb4, 0x9d, 0x41, 0x73, 0xf1, 0x05}};
#define CLR_EXECUTION_CHECKPOINT_RUNDOWN_TASK 0x23
EXTERN_C __declspec(selectany) const GUID ExecutionCheckpointRundownId = {0xdff63eca, 0xadaa, 0x431f, {0x8f, 0x91, 0x72, 0x82, 0x0c, 0x72, 0x17, 0xdb}};
#define CLR_GC_RUNDOWN_TASK 0x28
EXTERN_C __declspec(selectany) const GUID CLRGCRundownId = {0x51b6c146, 0x777f, 0x4375, {0xa0, 0xf8, 0x13, 0x49, 0xd0, 0x76, 0xe2, 0x15}};

//
// Keyword
//
#define CLR_RUNDOWNGC_KEYWORD 0x1
#define CLR_RUNDOWNLOADER_KEYWORD 0x8
#define CLR_RUNDOWNJIT_KEYWORD 0x10
#define CLR_RUNDOWNNGEN_KEYWORD 0x20
#define CLR_RUNDOWNSTART_KEYWORD 0x40
#define CLR_RUNDOWNEND_KEYWORD 0x100
#define CLR_RUNDOWNAPPDOMAINRESOURCEMANAGEMENT_KEYWORD 0x800
#define CLR_RUNDOWNTHREADING_KEYWORD 0x10000
#define CLR_RUNDOWNJITTEDMETHODILTONATIVEMAP_KEYWORD 0x20000
#define CLR_RUNDOWNOVERRIDEANDSUPPRESSNGENEVENTS_KEYWORD 0x40000
#define CLR_RUNDOWNPERFTRACK_KEYWORD 0x20000000
#define CLR_RUNDOWNSTACK_KEYWORD 0x40000000
#define CLR_COMPILATION_RUNDOWN_KEYWORD 0x1000000000

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CLRStackWalkDCStart = {0x0, 0x0, 0x0, 0x0, 0x52, 0xb, 0x40000000};
#define CLRStackWalkDCStart_value 0x0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSettingsRundown = {0xa, 0x0, 0x0, 0x4, 0xa, 0x28, 0x0};
#define GCSettingsRundown_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStart = {0x8d, 0x0, 0x0, 0x4, 0x23, 0x1, 0x30};
#define MethodDCStart_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStart_V1 = {0x8d, 0x1, 0x0, 0x4, 0x23, 0x1, 0x30};
#define MethodDCStart_V1_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStart_V2 = {0x8d, 0x2, 0x0, 0x4, 0x23, 0x1, 0x30};
#define MethodDCStart_V2_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEnd = {0x8e, 0x0, 0x0, 0x4, 0x24, 0x1, 0x30};
#define MethodDCEnd_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEnd_V1 = {0x8e, 0x1, 0x0, 0x4, 0x24, 0x1, 0x30};
#define MethodDCEnd_V1_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEnd_V2 = {0x8e, 0x2, 0x0, 0x4, 0x24, 0x1, 0x30};
#define MethodDCEnd_V2_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerbose = {0x8f, 0x0, 0x0, 0x4, 0x27, 0x1, 0x30};
#define MethodDCStartVerbose_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerbose_V1 = {0x8f, 0x1, 0x0, 0x4, 0x27, 0x1, 0x30};
#define MethodDCStartVerbose_V1_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerbose_V2 = {0x8f, 0x2, 0x0, 0x4, 0x27, 0x1, 0x30};
#define MethodDCStartVerbose_V2_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerbose = {0x90, 0x0, 0x0, 0x4, 0x28, 0x1, 0x30};
#define MethodDCEndVerbose_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerbose_V1 = {0x90, 0x1, 0x0, 0x4, 0x28, 0x1, 0x30};
#define MethodDCEndVerbose_V1_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerbose_V2 = {0x90, 0x2, 0x0, 0x4, 0x28, 0x1, 0x30};
#define MethodDCEndVerbose_V2_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartComplete = {0x91, 0x0, 0x0, 0x4, 0xe, 0x1, 0x20038};
#define DCStartComplete_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartComplete_V1 = {0x91, 0x1, 0x0, 0x4, 0xe, 0x1, 0x20038};
#define DCStartComplete_V1_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndComplete = {0x92, 0x0, 0x0, 0x4, 0xf, 0x1, 0x20038};
#define DCEndComplete_value 0x92
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndComplete_V1 = {0x92, 0x1, 0x0, 0x4, 0xf, 0x1, 0x20038};
#define DCEndComplete_V1_value 0x92
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartInit = {0x93, 0x0, 0x0, 0x4, 0x10, 0x1, 0x20038};
#define DCStartInit_value 0x93
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartInit_V1 = {0x93, 0x1, 0x0, 0x4, 0x10, 0x1, 0x20038};
#define DCStartInit_V1_value 0x93
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndInit = {0x94, 0x0, 0x0, 0x4, 0x11, 0x1, 0x20038};
#define DCEndInit_value 0x94
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndInit_V1 = {0x94, 0x1, 0x0, 0x4, 0x11, 0x1, 0x20038};
#define DCEndInit_V1_value 0x94
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartILToNativeMap = {0x95, 0x0, 0x0, 0x5, 0x29, 0x1, 0x20000};
#define MethodDCStartILToNativeMap_value 0x95
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartILToNativeMap_V1 = {0x95, 0x1, 0x0, 0x5, 0x29, 0x1, 0x20000};
#define MethodDCStartILToNativeMap_V1_value 0x95
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndILToNativeMap = {0x96, 0x0, 0x0, 0x5, 0x2a, 0x1, 0x20000};
#define MethodDCEndILToNativeMap_value 0x96
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndILToNativeMap_V1 = {0x96, 0x1, 0x0, 0x5, 0x2a, 0x1, 0x20000};
#define MethodDCEndILToNativeMap_V1_value 0x96
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCStart = {0x97, 0x0, 0x0, 0x4, 0x2e, 0x2, 0x8};
#define DomainModuleDCStart_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCStart_V1 = {0x97, 0x1, 0x0, 0x4, 0x2e, 0x2, 0x8};
#define DomainModuleDCStart_V1_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCEnd = {0x98, 0x0, 0x0, 0x4, 0x2f, 0x2, 0x8};
#define DomainModuleDCEnd_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCEnd_V1 = {0x98, 0x1, 0x0, 0x4, 0x2f, 0x2, 0x8};
#define DomainModuleDCEnd_V1_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStart = {0x99, 0x0, 0x0, 0x4, 0x23, 0x2, 0x8};
#define ModuleDCStart_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStart_V1 = {0x99, 0x1, 0x0, 0x4, 0x23, 0x2, 0x20000008};
#define ModuleDCStart_V1_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStart_V2 = {0x99, 0x2, 0x0, 0x4, 0x23, 0x2, 0x20000008};
#define ModuleDCStart_V2_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEnd = {0x9a, 0x0, 0x0, 0x4, 0x24, 0x2, 0x8};
#define ModuleDCEnd_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEnd_V1 = {0x9a, 0x1, 0x0, 0x4, 0x24, 0x2, 0x20000008};
#define ModuleDCEnd_V1_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEnd_V2 = {0x9a, 0x2, 0x0, 0x4, 0x24, 0x2, 0x20000008};
#define ModuleDCEnd_V2_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCStart = {0x9b, 0x0, 0x0, 0x4, 0x27, 0x2, 0x8};
#define AssemblyDCStart_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCStart_V1 = {0x9b, 0x1, 0x0, 0x4, 0x27, 0x2, 0x8};
#define AssemblyDCStart_V1_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCEnd = {0x9c, 0x0, 0x0, 0x4, 0x28, 0x2, 0x8};
#define AssemblyDCEnd_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCEnd_V1 = {0x9c, 0x1, 0x0, 0x4, 0x28, 0x2, 0x8};
#define AssemblyDCEnd_V1_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCStart = {0x9d, 0x0, 0x0, 0x4, 0x2b, 0x2, 0x8};
#define AppDomainDCStart_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCStart_V1 = {0x9d, 0x1, 0x0, 0x4, 0x2b, 0x2, 0x8};
#define AppDomainDCStart_V1_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCEnd = {0x9e, 0x0, 0x0, 0x4, 0x2c, 0x2, 0x8};
#define AppDomainDCEnd_value 0x9e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCEnd_V1 = {0x9e, 0x1, 0x0, 0x4, 0x2c, 0x2, 0x8};
#define AppDomainDCEnd_V1_value 0x9e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadDC = {0x9f, 0x0, 0x0, 0x4, 0x30, 0x2, 0x10800};
#define ThreadDC_value 0x9f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleRangeDCStart = {0xa0, 0x0, 0x0, 0x4, 0xa, 0x14, 0x20000000};
#define ModuleRangeDCStart_value 0xa0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleRangeDCEnd = {0xa1, 0x0, 0x0, 0x4, 0xb, 0x14, 0x20000000};
#define ModuleRangeDCEnd_value 0xa1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RuntimeInformationDCStart = {0xbb, 0x0, 0x0, 0x4, 0x1, 0x13, 0x0};
#define RuntimeInformationDCStart_value 0xbb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TieredCompilationSettingsDCStart = {0x118, 0x0, 0x0, 0x4, 0xb, 0x1f, 0x1000000000};
#define TieredCompilationSettingsDCStart_value 0x118
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExecutionCheckpointDCEnd = {0x12c, 0x0, 0x0, 0x4, 0xb, 0x23, 0x0};
#define ExecutionCheckpointDCEnd_value 0x12c

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Microsoft_Windows_DotNETRuntimeRundownEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Microsoft_Windows_DotNETRuntimeRundownKeywords[10] = {0x40000000, 0x0, 0x30, 0x20038, 0x20000, 0x8, 0x20000008, 0x10800, 0x20000000, 0x1000000000};
EXTERN_C __declspec(selectany) const unsigned char Microsoft_Windows_DotNETRuntimeRundownLevels[10] = {0, 4, 4, 4, 5, 4, 4, 4, 4, 4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context = {0, (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 10, Microsoft_Windows_DotNETRuntimeRundownEnableBits, Microsoft_Windows_DotNETRuntimeRundownKeywords, Microsoft_Windows_DotNETRuntimeRundownLevels};

//
// Provider REGHANDLE
//
#define Microsoft_Windows_DotNETRuntimeRundownHandle (MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterMicrosoft_Windows_DotNETRuntimeRundown
#define EventRegisterMicrosoft_Windows_DotNETRuntimeRundown() McGenEventRegister(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER, McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeRundownHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeRundown
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeRundown(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeRundownHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown
#define EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown() McGenEventUnregister(&Microsoft_Windows_DotNETRuntimeRundownHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Microsoft_Windows_DotNETRuntimeRundown));
// - Caller registers the provider, e.g. EventRegisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Microsoft_Windows_DotNETRuntimeRundown {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Microsoft_Windows_DotNETRuntimeRundownHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Microsoft_Windows_DotNETRuntimeRundown;

#define EventRegisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeRundown_, MCGEN_EVENTREGISTER)(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER, pContext)
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeRundown_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeRundown_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Microsoft_Windows_DotNETRuntimeRundownHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeRundown_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Microsoft_Windows_DotNETRuntimeRundown* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits;
    pContext->Context.EnableBitsCount = 10;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Microsoft_Windows_DotNETRuntimeRundownKeywords;
    pContext->Context.EnableLevel = Microsoft_Windows_DotNETRuntimeRundownLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Microsoft_Windows_DotNETRuntimeRundown*
_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(_In_ McGenContext_Microsoft_Windows_DotNETRuntimeRundown* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "CLRStackWalkDCStart"
//
#define EventXplatEnabledCLRStackWalkDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 0)
#define EventXplatEnabledCLRStackWalkDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 0)

//
// Event write macros for event "CLRStackWalkDCStart"
//
#define FireEtXplatCLRStackWalkDCStart(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED(CLRStackWalkDCStart) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalkDCStart_AssumeEnabled(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)
#define FireEtXplatCLRStackWalkDCStart_ForContext(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CLRStackWalkDCStart) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&(pContext)->Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalkDCStart_ForContextAssumeEnabled(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart _mcgen_PASTE2(McTemplateCoU0huuqP2_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSettingsRundown"
//
#define EventXplatEnabledGCSettingsRundown() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventXplatEnabledGCSettingsRundown_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "GCSettingsRundown"
//
#define FireEtXplatGCSettingsRundown(HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSettingsRundown) \
        ? _mcgen_TEMPLATE_FOR_GCSettingsRundown(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &GCSettingsRundown, HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID) : 0
#define FireEtXplatGCSettingsRundown_AssumeEnabled(HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSettingsRundown(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &GCSettingsRundown, HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID)
#define FireEtXplatGCSettingsRundown_ForContext(pContext, HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSettingsRundown) \
        ? _mcgen_TEMPLATE_FOR_GCSettingsRundown(&(pContext)->Context, &GCSettingsRundown, HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID) : 0
#define FireEtXplatGCSettingsRundown_ForContextAssumeEnabled(pContext, HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSettingsRundown(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &GCSettingsRundown, HardLimit, LOHThreshold, PhysicalMemoryConfig, Gen0MinBudgetConfig, Gen0MaxBudgetConfig, HighMemPercentConfig, BitSettings, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSettingsRundown _mcgen_PASTE2(McTemplateCoU0xxxxxqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStart"
//
#define EventXplatEnabledMethodDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCStart"
//
#define FireEtXplatMethodDCStart(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCStart) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCStart_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define FireEtXplatMethodDCStart_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStart) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart(&(pContext)->Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCStart_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStart _mcgen_PASTE2(McTemplateCoU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStart_V1"
//
#define EventXplatEnabledMethodDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCStart_V1"
//
#define FireEtXplatMethodDCStart_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodDCStart_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define FireEtXplatMethodDCStart_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&(pContext)->Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodDCStart_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStart_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStart_V2"
//
#define EventXplatEnabledMethodDCStart_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCStart_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCStart_V2"
//
#define FireEtXplatMethodDCStart_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCStart_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define FireEtXplatMethodDCStart_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&(pContext)->Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCStart_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStart_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEnd"
//
#define EventXplatEnabledMethodDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCEnd"
//
#define FireEtXplatMethodDCEnd(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCEnd) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCEnd_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define FireEtXplatMethodDCEnd_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEnd) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd(&(pContext)->Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define FireEtXplatMethodDCEnd_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEnd _mcgen_PASTE2(McTemplateCoU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEnd_V1"
//
#define EventXplatEnabledMethodDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCEnd_V1"
//
#define FireEtXplatMethodDCEnd_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodDCEnd_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define FireEtXplatMethodDCEnd_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&(pContext)->Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define FireEtXplatMethodDCEnd_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEnd_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEnd_V2"
//
#define EventXplatEnabledMethodDCEnd_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCEnd_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCEnd_V2"
//
#define FireEtXplatMethodDCEnd_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCEnd_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define FireEtXplatMethodDCEnd_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&(pContext)->Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCEnd_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEnd_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerbose"
//
#define EventXplatEnabledMethodDCStartVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCStartVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCStartVerbose"
//
#define FireEtXplatMethodDCStartVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCStartVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMethodDCStartVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&(pContext)->Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCStartVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerbose _mcgen_PASTE2(McTemplateCoU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerbose_V1"
//
#define EventXplatEnabledMethodDCStartVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCStartVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCStartVerbose_V1"
//
#define FireEtXplatMethodDCStartVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodDCStartVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define FireEtXplatMethodDCStartVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&(pContext)->Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodDCStartVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerbose_V2"
//
#define EventXplatEnabledMethodDCStartVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCStartVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCStartVerbose_V2"
//
#define FireEtXplatMethodDCStartVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCStartVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define FireEtXplatMethodDCStartVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&(pContext)->Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCStartVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerbose"
//
#define EventXplatEnabledMethodDCEndVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCEndVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCEndVerbose"
//
#define FireEtXplatMethodDCEndVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCEndVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMethodDCEndVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&(pContext)->Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMethodDCEndVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerbose _mcgen_PASTE2(McTemplateCoU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerbose_V1"
//
#define EventXplatEnabledMethodDCEndVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCEndVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCEndVerbose_V1"
//
#define FireEtXplatMethodDCEndVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodDCEndVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define FireEtXplatMethodDCEndVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&(pContext)->Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define FireEtXplatMethodDCEndVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerbose_V2"
//
#define EventXplatEnabledMethodDCEndVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventXplatEnabledMethodDCEndVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "MethodDCEndVerbose_V2"
//
#define FireEtXplatMethodDCEndVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCEndVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define FireEtXplatMethodDCEndVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&(pContext)->Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define FireEtXplatMethodDCEndVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2 _mcgen_PASTE2(McTemplateCoU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartComplete"
//
#define EventXplatEnabledDCStartComplete() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCStartComplete_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCStartComplete"
//
#define FireEtXplatDCStartComplete() \
        MCGEN_EVENT_ENABLED(DCStartComplete) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete) : 0
#define FireEtXplatDCStartComplete_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCStartComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete)
#define FireEtXplatDCStartComplete_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartComplete) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete(&(pContext)->Context, &DCStartComplete) : 0
#define FireEtXplatDCStartComplete_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCStartComplete(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartComplete)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartComplete _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartComplete_V1"
//
#define EventXplatEnabledDCStartComplete_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCStartComplete_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCStartComplete_V1"
//
#define FireEtXplatDCStartComplete_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCStartComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete_V1, ClrInstanceID) : 0
#define FireEtXplatDCStartComplete_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete_V1, ClrInstanceID)
#define FireEtXplatDCStartComplete_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&(pContext)->Context, &DCStartComplete_V1, ClrInstanceID) : 0
#define FireEtXplatDCStartComplete_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartComplete_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartComplete_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndComplete"
//
#define EventXplatEnabledDCEndComplete() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCEndComplete_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCEndComplete"
//
#define FireEtXplatDCEndComplete() \
        MCGEN_EVENT_ENABLED(DCEndComplete) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete) : 0
#define FireEtXplatDCEndComplete_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCEndComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete)
#define FireEtXplatDCEndComplete_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndComplete) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete(&(pContext)->Context, &DCEndComplete) : 0
#define FireEtXplatDCEndComplete_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCEndComplete(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndComplete)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndComplete _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndComplete_V1"
//
#define EventXplatEnabledDCEndComplete_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCEndComplete_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCEndComplete_V1"
//
#define FireEtXplatDCEndComplete_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCEndComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete_V1, ClrInstanceID) : 0
#define FireEtXplatDCEndComplete_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete_V1, ClrInstanceID)
#define FireEtXplatDCEndComplete_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&(pContext)->Context, &DCEndComplete_V1, ClrInstanceID) : 0
#define FireEtXplatDCEndComplete_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndComplete_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndComplete_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartInit"
//
#define EventXplatEnabledDCStartInit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCStartInit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCStartInit"
//
#define FireEtXplatDCStartInit() \
        MCGEN_EVENT_ENABLED(DCStartInit) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit) : 0
#define FireEtXplatDCStartInit_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCStartInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit)
#define FireEtXplatDCStartInit_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartInit) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit(&(pContext)->Context, &DCStartInit) : 0
#define FireEtXplatDCStartInit_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCStartInit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartInit)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartInit _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartInit_V1"
//
#define EventXplatEnabledDCStartInit_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCStartInit_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCStartInit_V1"
//
#define FireEtXplatDCStartInit_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCStartInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit_V1, ClrInstanceID) : 0
#define FireEtXplatDCStartInit_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit_V1, ClrInstanceID)
#define FireEtXplatDCStartInit_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit_V1(&(pContext)->Context, &DCStartInit_V1, ClrInstanceID) : 0
#define FireEtXplatDCStartInit_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartInit_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartInit_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartInit_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndInit"
//
#define EventXplatEnabledDCEndInit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCEndInit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCEndInit"
//
#define FireEtXplatDCEndInit() \
        MCGEN_EVENT_ENABLED(DCEndInit) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit) : 0
#define FireEtXplatDCEndInit_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCEndInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit)
#define FireEtXplatDCEndInit_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndInit) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit(&(pContext)->Context, &DCEndInit) : 0
#define FireEtXplatDCEndInit_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCEndInit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndInit)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndInit _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndInit_V1"
//
#define EventXplatEnabledDCEndInit_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventXplatEnabledDCEndInit_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "DCEndInit_V1"
//
#define FireEtXplatDCEndInit_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCEndInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit_V1, ClrInstanceID) : 0
#define FireEtXplatDCEndInit_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit_V1, ClrInstanceID)
#define FireEtXplatDCEndInit_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit_V1(&(pContext)->Context, &DCEndInit_V1, ClrInstanceID) : 0
#define FireEtXplatDCEndInit_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndInit_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndInit_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndInit_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartILToNativeMap"
//
#define EventXplatEnabledMethodDCStartILToNativeMap() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventXplatEnabledMethodDCStartILToNativeMap_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "MethodDCStartILToNativeMap"
//
#define FireEtXplatMethodDCStartILToNativeMap(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCStartILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define FireEtXplatMethodDCStartILToNativeMap_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)
#define FireEtXplatMethodDCStartILToNativeMap_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&(pContext)->Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define FireEtXplatMethodDCStartILToNativeMap_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap _mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartILToNativeMap_V1"
//
#define EventXplatEnabledMethodDCStartILToNativeMap_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventXplatEnabledMethodDCStartILToNativeMap_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "MethodDCStartILToNativeMap_V1"
//
#define FireEtXplatMethodDCStartILToNativeMap_V1(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        MCGEN_EVENT_ENABLED(MethodDCStartILToNativeMap_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) : 0
#define FireEtXplatMethodDCStartILToNativeMap_V1_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID)
#define FireEtXplatMethodDCStartILToNativeMap_V1_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartILToNativeMap_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap_V1(&(pContext)->Context, &MethodDCStartILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) : 0
#define FireEtXplatMethodDCStartILToNativeMap_V1_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap_V1 _mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3hx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndILToNativeMap"
//
#define EventXplatEnabledMethodDCEndILToNativeMap() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventXplatEnabledMethodDCEndILToNativeMap_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "MethodDCEndILToNativeMap"
//
#define FireEtXplatMethodDCEndILToNativeMap(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCEndILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define FireEtXplatMethodDCEndILToNativeMap_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)
#define FireEtXplatMethodDCEndILToNativeMap_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&(pContext)->Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define FireEtXplatMethodDCEndILToNativeMap_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap _mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndILToNativeMap_V1"
//
#define EventXplatEnabledMethodDCEndILToNativeMap_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventXplatEnabledMethodDCEndILToNativeMap_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "MethodDCEndILToNativeMap_V1"
//
#define FireEtXplatMethodDCEndILToNativeMap_V1(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        MCGEN_EVENT_ENABLED(MethodDCEndILToNativeMap_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) : 0
#define FireEtXplatMethodDCEndILToNativeMap_V1_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID)
#define FireEtXplatMethodDCEndILToNativeMap_V1_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndILToNativeMap_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap_V1(&(pContext)->Context, &MethodDCEndILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) : 0
#define FireEtXplatMethodDCEndILToNativeMap_V1_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndILToNativeMap_V1, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID, ILVersionID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap_V1 _mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3hx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCStart"
//
#define EventXplatEnabledDomainModuleDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledDomainModuleDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "DomainModuleDCStart"
//
#define FireEtXplatDomainModuleDCStart(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(DomainModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatDomainModuleDCStart_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatDomainModuleDCStart_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&(pContext)->Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatDomainModuleDCStart_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCStart _mcgen_PASTE2(McTemplateCoU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCStart_V1"
//
#define EventXplatEnabledDomainModuleDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledDomainModuleDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "DomainModuleDCStart_V1"
//
#define FireEtXplatDomainModuleDCStart_V1(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DomainModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatDomainModuleDCStart_V1_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define FireEtXplatDomainModuleDCStart_V1_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&(pContext)->Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatDomainModuleDCStart_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCEnd"
//
#define EventXplatEnabledDomainModuleDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledDomainModuleDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "DomainModuleDCEnd"
//
#define FireEtXplatDomainModuleDCEnd(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(DomainModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatDomainModuleDCEnd_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatDomainModuleDCEnd_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&(pContext)->Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatDomainModuleDCEnd_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCEnd _mcgen_PASTE2(McTemplateCoU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCEnd_V1"
//
#define EventXplatEnabledDomainModuleDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledDomainModuleDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "DomainModuleDCEnd_V1"
//
#define FireEtXplatDomainModuleDCEnd_V1(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DomainModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatDomainModuleDCEnd_V1_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define FireEtXplatDomainModuleDCEnd_V1_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&(pContext)->Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatDomainModuleDCEnd_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1 _mcgen_PASTE2(McTemplateCoU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStart"
//
#define EventXplatEnabledModuleDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledModuleDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "ModuleDCStart"
//
#define FireEtXplatModuleDCStart(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCStart_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatModuleDCStart_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart(&(pContext)->Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCStart_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStart _mcgen_PASTE2(McTemplateCoU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStart_V1"
//
#define EventXplatEnabledModuleDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 6)
#define EventXplatEnabledModuleDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 6)

//
// Event write macros for event "ModuleDCStart_V1"
//
#define FireEtXplatModuleDCStart_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleDCStart_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define FireEtXplatModuleDCStart_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&(pContext)->Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleDCStart_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStart_V1 _mcgen_PASTE2(McTemplateCoU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStart_V2"
//
#define EventXplatEnabledModuleDCStart_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 6)
#define EventXplatEnabledModuleDCStart_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 6)

//
// Event write macros for event "ModuleDCStart_V2"
//
#define FireEtXplatModuleDCStart_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleDCStart_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define FireEtXplatModuleDCStart_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&(pContext)->Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleDCStart_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStart_V2 _mcgen_PASTE2(McTemplateCoU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEnd"
//
#define EventXplatEnabledModuleDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledModuleDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "ModuleDCEnd"
//
#define FireEtXplatModuleDCEnd(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCEnd_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define FireEtXplatModuleDCEnd_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd(&(pContext)->Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define FireEtXplatModuleDCEnd_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEnd _mcgen_PASTE2(McTemplateCoU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEnd_V1"
//
#define EventXplatEnabledModuleDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 6)
#define EventXplatEnabledModuleDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 6)

//
// Event write macros for event "ModuleDCEnd_V1"
//
#define FireEtXplatModuleDCEnd_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleDCEnd_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define FireEtXplatModuleDCEnd_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&(pContext)->Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define FireEtXplatModuleDCEnd_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1 _mcgen_PASTE2(McTemplateCoU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEnd_V2"
//
#define EventXplatEnabledModuleDCEnd_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 6)
#define EventXplatEnabledModuleDCEnd_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 6)

//
// Event write macros for event "ModuleDCEnd_V2"
//
#define FireEtXplatModuleDCEnd_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleDCEnd_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define FireEtXplatModuleDCEnd_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&(pContext)->Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define FireEtXplatModuleDCEnd_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2 _mcgen_PASTE2(McTemplateCoU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCStart"
//
#define EventXplatEnabledAssemblyDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAssemblyDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AssemblyDCStart"
//
#define FireEtXplatAssemblyDCStart(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyDCStart) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyDCStart_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define FireEtXplatAssemblyDCStart_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCStart) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart(&(pContext)->Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyDCStart_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCStart _mcgen_PASTE2(McTemplateCoU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCStart_V1"
//
#define EventXplatEnabledAssemblyDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAssemblyDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AssemblyDCStart_V1"
//
#define FireEtXplatAssemblyDCStart_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyDCStart_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define FireEtXplatAssemblyDCStart_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&(pContext)->Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyDCStart_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1 _mcgen_PASTE2(McTemplateCoU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCEnd"
//
#define EventXplatEnabledAssemblyDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAssemblyDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AssemblyDCEnd"
//
#define FireEtXplatAssemblyDCEnd(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyDCEnd_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define FireEtXplatAssemblyDCEnd_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&(pContext)->Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define FireEtXplatAssemblyDCEnd_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCEnd _mcgen_PASTE2(McTemplateCoU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCEnd_V1"
//
#define EventXplatEnabledAssemblyDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAssemblyDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AssemblyDCEnd_V1"
//
#define FireEtXplatAssemblyDCEnd_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyDCEnd_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define FireEtXplatAssemblyDCEnd_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&(pContext)->Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define FireEtXplatAssemblyDCEnd_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1 _mcgen_PASTE2(McTemplateCoU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCStart"
//
#define EventXplatEnabledAppDomainDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAppDomainDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AppDomainDCStart"
//
#define FireEtXplatAppDomainDCStart(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainDCStart) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainDCStart_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName)
#define FireEtXplatAppDomainDCStart_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCStart) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart(&(pContext)->Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainDCStart_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCStart _mcgen_PASTE2(McTemplateCoU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCStart_V1"
//
#define EventXplatEnabledAppDomainDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAppDomainDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AppDomainDCStart_V1"
//
#define FireEtXplatAppDomainDCStart_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainDCStart_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define FireEtXplatAppDomainDCStart_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&(pContext)->Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainDCStart_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1 _mcgen_PASTE2(McTemplateCoU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCEnd"
//
#define EventXplatEnabledAppDomainDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAppDomainDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AppDomainDCEnd"
//
#define FireEtXplatAppDomainDCEnd(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainDCEnd_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName)
#define FireEtXplatAppDomainDCEnd_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&(pContext)->Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define FireEtXplatAppDomainDCEnd_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCEnd _mcgen_PASTE2(McTemplateCoU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCEnd_V1"
//
#define EventXplatEnabledAppDomainDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventXplatEnabledAppDomainDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "AppDomainDCEnd_V1"
//
#define FireEtXplatAppDomainDCEnd_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainDCEnd_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define FireEtXplatAppDomainDCEnd_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&(pContext)->Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define FireEtXplatAppDomainDCEnd_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1 _mcgen_PASTE2(McTemplateCoU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadDC"
//
#define EventXplatEnabledThreadDC() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 7)
#define EventXplatEnabledThreadDC_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 7)

//
// Event write macros for event "ThreadDC"
//
#define FireEtXplatThreadDC(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadDC) \
        ? _mcgen_TEMPLATE_FOR_ThreadDC(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define FireEtXplatThreadDC_AssumeEnabled(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDC(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)
#define FireEtXplatThreadDC_ForContext(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadDC) \
        ? _mcgen_TEMPLATE_FOR_ThreadDC(&(pContext)->Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define FireEtXplatThreadDC_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDC(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadDC _mcgen_PASTE2(McTemplateCoU0xxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleRangeDCStart"
//
#define EventXplatEnabledModuleRangeDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 8)
#define EventXplatEnabledModuleRangeDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 8)

//
// Event write macros for event "ModuleRangeDCStart"
//
#define FireEtXplatModuleRangeDCStart(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED(ModuleRangeDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define FireEtXplatModuleRangeDCStart_AssumeEnabled(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)
#define FireEtXplatModuleRangeDCStart_ForContext(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleRangeDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&(pContext)->Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define FireEtXplatModuleRangeDCStart_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleRangeDCStart _mcgen_PASTE2(McTemplateCoU0hxqqu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleRangeDCEnd"
//
#define EventXplatEnabledModuleRangeDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 8)
#define EventXplatEnabledModuleRangeDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 8)

//
// Event write macros for event "ModuleRangeDCEnd"
//
#define FireEtXplatModuleRangeDCEnd(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED(ModuleRangeDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define FireEtXplatModuleRangeDCEnd_AssumeEnabled(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)
#define FireEtXplatModuleRangeDCEnd_ForContext(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleRangeDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&(pContext)->Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define FireEtXplatModuleRangeDCEnd_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd _mcgen_PASTE2(McTemplateCoU0hxqqu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RuntimeInformationDCStart"
//
#define EventXplatEnabledRuntimeInformationDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventXplatEnabledRuntimeInformationDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "RuntimeInformationDCStart"
//
#define FireEtXplatRuntimeInformationDCStart(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED(RuntimeInformationDCStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define FireEtXplatRuntimeInformationDCStart_AssumeEnabled(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)
#define FireEtXplatRuntimeInformationDCStart_ForContext(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RuntimeInformationDCStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&(pContext)->Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define FireEtXplatRuntimeInformationDCStart_ForContextAssumeEnabled(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart _mcgen_PASTE2(McTemplateCoU0hhhhhhhhhhquzjz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TieredCompilationSettingsDCStart"
//
#define EventXplatEnabledTieredCompilationSettingsDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 9)
#define EventXplatEnabledTieredCompilationSettingsDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 9)

//
// Event write macros for event "TieredCompilationSettingsDCStart"
//
#define FireEtXplatTieredCompilationSettingsDCStart(ClrInstanceID, Flags) \
        MCGEN_EVENT_ENABLED(TieredCompilationSettingsDCStart) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationSettingsDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &TieredCompilationSettingsDCStart, ClrInstanceID, Flags) : 0
#define FireEtXplatTieredCompilationSettingsDCStart_AssumeEnabled(ClrInstanceID, Flags) \
        _mcgen_TEMPLATE_FOR_TieredCompilationSettingsDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &TieredCompilationSettingsDCStart, ClrInstanceID, Flags)
#define FireEtXplatTieredCompilationSettingsDCStart_ForContext(pContext, ClrInstanceID, Flags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TieredCompilationSettingsDCStart) \
        ? _mcgen_TEMPLATE_FOR_TieredCompilationSettingsDCStart(&(pContext)->Context, &TieredCompilationSettingsDCStart, ClrInstanceID, Flags) : 0
#define FireEtXplatTieredCompilationSettingsDCStart_ForContextAssumeEnabled(pContext, ClrInstanceID, Flags) \
        _mcgen_TEMPLATE_FOR_TieredCompilationSettingsDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &TieredCompilationSettingsDCStart, ClrInstanceID, Flags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TieredCompilationSettingsDCStart _mcgen_PASTE2(McTemplateCoU0hq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExecutionCheckpointDCEnd"
//
#define EventXplatEnabledExecutionCheckpointDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventXplatEnabledExecutionCheckpointDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "ExecutionCheckpointDCEnd"
//
#define FireEtXplatExecutionCheckpointDCEnd(ClrInstanceID, Name, Timestamp) \
        MCGEN_EVENT_ENABLED(ExecutionCheckpointDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ExecutionCheckpointDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ExecutionCheckpointDCEnd, ClrInstanceID, Name, Timestamp) : 0
#define FireEtXplatExecutionCheckpointDCEnd_AssumeEnabled(ClrInstanceID, Name, Timestamp) \
        _mcgen_TEMPLATE_FOR_ExecutionCheckpointDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ExecutionCheckpointDCEnd, ClrInstanceID, Name, Timestamp)
#define FireEtXplatExecutionCheckpointDCEnd_ForContext(pContext, ClrInstanceID, Name, Timestamp) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExecutionCheckpointDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ExecutionCheckpointDCEnd(&(pContext)->Context, &ExecutionCheckpointDCEnd, ClrInstanceID, Name, Timestamp) : 0
#define FireEtXplatExecutionCheckpointDCEnd_ForContextAssumeEnabled(pContext, ClrInstanceID, Name, Timestamp) \
        _mcgen_TEMPLATE_FOR_ExecutionCheckpointDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ExecutionCheckpointDCEnd, ClrInstanceID, Name, Timestamp)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExecutionCheckpointDCEnd _mcgen_PASTE2(McTemplateCoU0hzi_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Microsoft-Windows-DotNETRuntimeStress" event count 3
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = cc2bcbba-16b6-4cf3-8990-d74c2e8af500
EXTERN_C __declspec(selectany) const GUID MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER = {0xcc2bcbba, 0x16b6, 0x4cf3, {0x89, 0x90, 0xd7, 0x4c, 0x2e, 0x8a, 0xf5, 0x00}};

#ifndef MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Traits
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Traits NULL
#endif // MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Traits

//
// Opcodes
//
#define CLR_STRESSSTACK_STACKWALK_OPCODE 0x52

//
// Tasks
//
#define CLR_STRESSLOG_TASK 0x1
EXTERN_C __declspec(selectany) const GUID StressLogTaskId = {0xea40c74d, 0x4f65, 0x4561, {0xbb, 0x26, 0x65, 0x62, 0x31, 0xc8, 0x96, 0x7f}};
#define CLR_STACKSTRESS_TASK 0xb
EXTERN_C __declspec(selectany) const GUID CLRStackStressId = {0xd3363dc0, 0x243a, 0x4620, {0xa4, 0xd0, 0x8a, 0x07, 0xd7, 0x72, 0xf5, 0x33}};

//
// Keyword
//
#define CLR_STRESSSTACK_KEYWORD 0x40000000

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StressLogEvent = {0x0, 0x0, 0x0, 0x4, 0x1, 0x1, 0x0};
#define StressLogEvent_value 0x0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StressLogEvent_V1 = {0x0, 0x1, 0x0, 0x4, 0x1, 0x1, 0x0};
#define StressLogEvent_V1_value 0x0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CLRStackWalkStress = {0x1, 0x0, 0x0, 0x0, 0x52, 0xb, 0x40000000};
#define CLRStackWalkStress_value 0x1

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Microsoft_Windows_DotNETRuntimeStressEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Microsoft_Windows_DotNETRuntimeStressKeywords[2] = {0x0, 0x40000000};
EXTERN_C __declspec(selectany) const unsigned char Microsoft_Windows_DotNETRuntimeStressLevels[2] = {4, 0};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context = {0, (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 2, Microsoft_Windows_DotNETRuntimeStressEnableBits, Microsoft_Windows_DotNETRuntimeStressKeywords, Microsoft_Windows_DotNETRuntimeStressLevels};

//
// Provider REGHANDLE
//
#define Microsoft_Windows_DotNETRuntimeStressHandle (MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterMicrosoft_Windows_DotNETRuntimeStress
#define EventRegisterMicrosoft_Windows_DotNETRuntimeStress() McGenEventRegister(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER, McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeStressHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeStress
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeStress(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeStressHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterMicrosoft_Windows_DotNETRuntimeStress
#define EventUnregisterMicrosoft_Windows_DotNETRuntimeStress() McGenEventUnregister(&Microsoft_Windows_DotNETRuntimeStressHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Microsoft_Windows_DotNETRuntimeStress));
// - Caller registers the provider, e.g. EventRegisterMicrosoft_Windows_DotNETRuntimeStress_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterMicrosoft_Windows_DotNETRuntimeStress_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Microsoft_Windows_DotNETRuntimeStress {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Microsoft_Windows_DotNETRuntimeStressHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Microsoft_Windows_DotNETRuntimeStress;

#define EventRegisterMicrosoft_Windows_DotNETRuntimeStress_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeStress_, MCGEN_EVENTREGISTER)(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER, pContext)
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeStress_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeStress_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterMicrosoft_Windows_DotNETRuntimeStress_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Microsoft_Windows_DotNETRuntimeStressHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeStress_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Microsoft_Windows_DotNETRuntimeStress* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Traits;
    pContext->Context.EnableBitsCount = 2;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Microsoft_Windows_DotNETRuntimeStressKeywords;
    pContext->Context.EnableLevel = Microsoft_Windows_DotNETRuntimeStressLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Microsoft_Windows_DotNETRuntimeStress*
_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeStress(_In_ McGenContext_Microsoft_Windows_DotNETRuntimeStress* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "StressLogEvent"
//
#define EventXplatEnabledStressLogEvent() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeStressEnableBits, 0)
#define EventXplatEnabledStressLogEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeStress(pContext)->EnableBits, 0)

//
// Event write macros for event "StressLogEvent"
//
#define FireEtXplatStressLogEvent(Facility, LogLevel, Message) \
        MCGEN_EVENT_ENABLED(StressLogEvent) \
        ? _mcgen_TEMPLATE_FOR_StressLogEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &StressLogEvent, Facility, LogLevel, Message) : 0
#define FireEtXplatStressLogEvent_AssumeEnabled(Facility, LogLevel, Message) \
        _mcgen_TEMPLATE_FOR_StressLogEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &StressLogEvent, Facility, LogLevel, Message)
#define FireEtXplatStressLogEvent_ForContext(pContext, Facility, LogLevel, Message) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StressLogEvent) \
        ? _mcgen_TEMPLATE_FOR_StressLogEvent(&(pContext)->Context, &StressLogEvent, Facility, LogLevel, Message) : 0
#define FireEtXplatStressLogEvent_ForContextAssumeEnabled(pContext, Facility, LogLevel, Message) \
        _mcgen_TEMPLATE_FOR_StressLogEvent(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeStress(pContext)->Context, &StressLogEvent, Facility, LogLevel, Message)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StressLogEvent _mcgen_PASTE2(McTemplateCoU0qus_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StressLogEvent_V1"
//
#define EventXplatEnabledStressLogEvent_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeStressEnableBits, 0)
#define EventXplatEnabledStressLogEvent_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeStress(pContext)->EnableBits, 0)

//
// Event write macros for event "StressLogEvent_V1"
//
#define FireEtXplatStressLogEvent_V1(Facility, LogLevel, Message, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(StressLogEvent_V1) \
        ? _mcgen_TEMPLATE_FOR_StressLogEvent_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &StressLogEvent_V1, Facility, LogLevel, Message, ClrInstanceID) : 0
#define FireEtXplatStressLogEvent_V1_AssumeEnabled(Facility, LogLevel, Message, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StressLogEvent_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &StressLogEvent_V1, Facility, LogLevel, Message, ClrInstanceID)
#define FireEtXplatStressLogEvent_V1_ForContext(pContext, Facility, LogLevel, Message, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StressLogEvent_V1) \
        ? _mcgen_TEMPLATE_FOR_StressLogEvent_V1(&(pContext)->Context, &StressLogEvent_V1, Facility, LogLevel, Message, ClrInstanceID) : 0
#define FireEtXplatStressLogEvent_V1_ForContextAssumeEnabled(pContext, Facility, LogLevel, Message, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StressLogEvent_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeStress(pContext)->Context, &StressLogEvent_V1, Facility, LogLevel, Message, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StressLogEvent_V1 _mcgen_PASTE2(McTemplateCoU0qush_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CLRStackWalkStress"
//
#define EventXplatEnabledCLRStackWalkStress() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeStressEnableBits, 1)
#define EventXplatEnabledCLRStackWalkStress_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeStress(pContext)->EnableBits, 1)

//
// Event write macros for event "CLRStackWalkStress"
//
#define FireEtXplatCLRStackWalkStress(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED(CLRStackWalkStress) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkStress(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &CLRStackWalkStress, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalkStress_AssumeEnabled(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkStress(&MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_Context, &CLRStackWalkStress, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)
#define FireEtXplatCLRStackWalkStress_ForContext(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CLRStackWalkStress) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkStress(&(pContext)->Context, &CLRStackWalkStress, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalkStress_ForContextAssumeEnabled(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkStress(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeStress(pContext)->Context, &CLRStackWalkStress, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CLRStackWalkStress _mcgen_PASTE2(McTemplateCoU0huuqP2_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Microsoft-Windows-DotNETRuntimePrivate" event count 185
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 763fd754-7086-4dfe-95eb-c01a46faf4ca
EXTERN_C __declspec(selectany) const GUID MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER = {0x763fd754, 0x7086, 0x4dfe, {0x95, 0xeb, 0xc0, 0x1a, 0x46, 0xfa, 0xf4, 0xca}};

#ifndef MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Traits
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Traits NULL
#endif // MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Traits

//
// Opcodes
//
#define CLR_PRIVATEGC_GCDECISION_OPCODE 0x84
#define CLR_PRIVATEGC_GCSETTINGS_OPCODE 0xe
#define CLR_PRIVATEGC_GCOPTIMIZED_OPCODE 0x10
#define CLR_PRIVATEGC_GCPERHEAPHISTORY_OPCODE 0x11
#define CLR_PRIVATEGC_GCGLOBALHEAPHISTORY_OPCODE 0x12
#define CLR_PRIVATEGC_GCFULLNOTIFY_OPCODE 0x13
#define CLR_PRIVATEGC_JOIN_OPCODE 0x14
#define CLR_PRIVATEGC_MARKSTACKROOTS_OPCODE 0x15
#define CLR_PRIVATEGC_MARKFINALIZEQUEUEROOTS_OPCODE 0x16
#define CLR_PRIVATEGC_MARKHANDLES_OPCODE 0x17
#define CLR_PRIVATEGC_MARKCARDS_OPCODE 0x18
#define CLR_PRIVATEGC_BGCBEGIN_OPCODE 0x19
#define CLR_PRIVATEGC_BGC1STNONCONEND_OPCODE 0x1a
#define CLR_PRIVATEGC_BGC1STCONEND_OPCODE 0x1b
#define CLR_PRIVATEGC_BGC2NDNONCONBEGIN_OPCODE 0x1c
#define CLR_PRIVATEGC_BGC2NDNONCONEND_OPCODE 0x1d
#define CLR_PRIVATEGC_BGC2NDCONBEGIN_OPCODE 0x1e
#define CLR_PRIVATEGC_BGC2NDCONEND_OPCODE 0x1f
#define CLR_PRIVATEGC_BGCPLANEND_OPCODE 0x20
#define CLR_PRIVATEGC_BGCSWEEPEND_OPCODE 0x21
#define CLR_PRIVATEGC_BGCDRAINMARK_OPCODE 0x22
#define CLR_PRIVATEGC_BGCREVISIT_OPCODE 0x23
#define CLR_PRIVATEGC_BGCOVERFLOW_OPCODE 0x24
#define CLR_PRIVATEGC_BGCALLOCWAITBEGIN_OPCODE 0x25
#define CLR_PRIVATEGC_BGCALLOCWAITEND_OPCODE 0x26
#define CLR_PRIVATEGC_FINALIZEOBJECT_OPCODE 0x27
#define CLR_PRIVATEGC_CCWREFCOUNTCHANGE_OPCODE 0x28
#define CLR_PRIVATEGC_SETGCHANDLE_OPCODE 0x2a
#define CLR_PRIVATEGC_DESTROYGCHANDLE_OPCODE 0x2b
#define CLR_PRIVATEGC_PINGCPLUG_OPCODE 0x2c
#define CLR_PRIVATEGC_BGC1STSWEEPEND_OPCODE 0x2d
#define CLR_FAILFAST_FAILFAST_OPCODE 0x34
#define CLR_PRIVATESTARTUP_EESTARTUPSTART_OPCODE 0x80
#define CLR_PRIVATESTARTUP_EESTARTUPEND_OPCODE 0x81
#define CLR_PRIVATESTARTUP_EECONFIGSETUP_OPCODE 0x82
#define CLR_PRIVATESTARTUP_EECONFIGSETUPEND_OPCODE 0x83
#define CLR_PRIVATESTARTUP_LOADSYSTEMBASES_OPCODE 0x84
#define CLR_PRIVATESTARTUP_LOADSYSTEMBASESEND_OPCODE 0x85
#define CLR_PRIVATESTARTUP_EXEEXE_OPCODE 0x86
#define CLR_PRIVATESTARTUP_EXEEXEEND_OPCODE 0x87
#define CLR_PRIVATESTARTUP_MAIN_OPCODE 0x88
#define CLR_PRIVATESTARTUP_MAINEND_OPCODE 0x89
#define CLR_PRIVATESTARTUP_APPLYPOLICYSTART_OPCODE 0xa
#define CLR_PRIVATESTARTUP_APPLYPOLICYEND_OPCODE 0xb
#define CLR_PRIVATESTARTUP_LDLIBSHFOLDER_OPCODE 0xc
#define CLR_PRIVATESTARTUP_LDLIBSHFOLDEREND_OPCODE 0xd
#define CLR_PRIVATESTARTUP_PRESTUBWORKER_OPCODE 0xe
#define CLR_PRIVATESTARTUP_PRESTUBWORKEREND_OPCODE 0xf
#define CLR_PRIVATESTARTUP_GETINSTALLATIONSTART_OPCODE 0x10
#define CLR_PRIVATESTARTUP_GETINSTALLATIONEND_OPCODE 0x11
#define CLR_PRIVATESTARTUP_OPENHMODULE_OPCODE 0x12
#define CLR_PRIVATESTARTUP_OPENHMODULEEND_OPCODE 0x13
#define CLR_PRIVATESTARTUP_EXPLICITBINDSTART_OPCODE 0x14
#define CLR_PRIVATESTARTUP_EXPLICITBINDEND_OPCODE 0x15
#define CLR_PRIVATESTARTUP_PARSEXML_OPCODE 0x16
#define CLR_PRIVATESTARTUP_PARSEXMLEND_OPCODE 0x17
#define CLR_PRIVATESTARTUP_INITDEFAULTDOMAIN_OPCODE 0x18
#define CLR_PRIVATESTARTUP_INITDEFAULTDOMAINEND_OPCODE 0x19
#define CLR_PRIVATESTARTUP_INITSECURITY_OPCODE 0x1a
#define CLR_PRIVATESTARTUP_INITSECURITYEND_OPCODE 0x1b
#define CLR_PRIVATESTARTUP_ALLOWBINDINGREDIRS_OPCODE 0x1c
#define CLR_PRIVATESTARTUP_ALLOWBINDINGREDIRSEND_OPCODE 0x1d
#define CLR_PRIVATESTARTUP_EECONFIGSYNC_OPCODE 0x1e
#define CLR_PRIVATESTARTUP_EECONFIGSYNCEND_OPCODE 0x1f
#define CLR_PRIVATESTARTUP_FUSIONBINDING_OPCODE 0x20
#define CLR_PRIVATESTARTUP_FUSIONBINDINGEND_OPCODE 0x21
#define CLR_PRIVATESTARTUP_LOADERCATCHCALL_OPCODE 0x22
#define CLR_PRIVATESTARTUP_LOADERCATCHCALLEND_OPCODE 0x23
#define CLR_PRIVATESTARTUP_FUSIONINIT_OPCODE 0x24
#define CLR_PRIVATESTARTUP_FUSIONINITEND_OPCODE 0x25
#define CLR_PRIVATESTARTUP_FUSIONAPPCTX_OPCODE 0x26
#define CLR_PRIVATESTARTUP_FUSIONAPPCTXEND_OPCODE 0x27
#define CLR_PRIVATESTARTUP_FUSION2EE_OPCODE 0x28
#define CLR_PRIVATESTARTUP_FUSION2EEEND_OPCODE 0x29
#define CLR_PRIVATESTARTUP_SECURITYCATCHCALL_OPCODE 0x2a
#define CLR_PRIVATESTARTUP_SECURITYCATCHCALLEND_OPCODE 0x2b
#define CLR_PRIVATEBINDING_BINDINGPOLICYPHASESTART_OPCODE 0x33
#define CLR_PRIVATEBINDING_BINDINGPOLICYPHASEEND_OPCODE 0x34
#define CLR_PRIVATEBINDING_BINDINGNGENPHASESTART_OPCODE 0x35
#define CLR_PRIVATEBINDING_BINDINGNGENPHASEEND_OPCODE 0x36
#define CLR_PRIVATEBINDING_BINDINGLOOKUPANDPROBINGPHASESTART_OPCODE 0x37
#define CLR_PRIVATEBINDING_BINDINGLOOKUPANDPROBINGPHASEEND_OPCODE 0x38
#define CLR_PRIVATEBINDING_LOADERPHASESTART_OPCODE 0x39
#define CLR_PRIVATEBINDING_LOADERPHASEEND_OPCODE 0x3a
#define CLR_PRIVATEBINDING_BINDINGPHASESTART_OPCODE 0x3b
#define CLR_PRIVATEBINDING_BINDINGPHASEEND_OPCODE 0x3c
#define CLR_PRIVATEBINDING_BINDINGDOWNLOADPHASESTART_OPCODE 0x3d
#define CLR_PRIVATEBINDING_BINDINGDOWNLOADPHASEEND_OPCODE 0x3e
#define CLR_PRIVATEBINDING_LOADERASSEMBLYINITPHASESTART_OPCODE 0x3f
#define CLR_PRIVATEBINDING_LOADERASSEMBLYINITPHASEEND_OPCODE 0x40
#define CLR_PRIVATEBINDING_LOADERMAPPINGPHASESTART_OPCODE 0x41
#define CLR_PRIVATEBINDING_LOADERMAPPINGPHASEEND_OPCODE 0x42
#define CLR_PRIVATEBINDING_LOADERDELIVERYEVENTSPHASESTART_OPCODE 0x43
#define CLR_PRIVATEBINDING_LOADERDELIVERYEVENTSPHASEEND_OPCODE 0x44
#define CLR_PRIVATEBINDING_FUSIONMESSAGE_OPCODE 0x46
#define CLR_PRIVATEBINDING_FUSIONERRORCODE_OPCODE 0x47
#define CLR_PRIVATESTACK_STACKWALK_OPCODE 0x52
#define CLR_EVIDENCEGENERATED_OPCODE 0xa
#define CLR_NGEN_BINDER_OPCODE 0x45
#define CLR_MODULE_TRANSPARENCY_COMPUTATION_START_OPCODE 0x53
#define CLR_MODULE_TRANSPARENCY_COMPUTATION_END_OPCODE 0x54
#define CLR_TYPE_TRANSPARENCY_COMPUTATION_START_OPCODE 0x55
#define CLR_TYPE_TRANSPARENCY_COMPUTATION_END_OPCODE 0x56
#define CLR_METHOD_TRANSPARENCY_COMPUTATION_START_OPCODE 0x57
#define CLR_METHOD_TRANSPARENCY_COMPUTATION_END_OPCODE 0x58
#define CLR_FIELD_TRANSPARENCY_COMPUTATION_START_OPCODE 0x59
#define CLR_FIELD_TRANSPARENCY_COMPUTATION_END_OPCODE 0x5a
#define CLR_TOKEN_TRANSPARENCY_COMPUTATION_START_OPCODE 0x5b
#define CLR_TOKEN_TRANSPARENCY_COMPUTATION_END_OPCODE 0x5c
#define CLR_LOADERHEAP_ALLOCREQUEST_OPCODE 0x61
#define CLR_MULTICOREJIT_COMMON_OPCODE 0xa
#define CLR_MULTICOREJIT_METHODCODERETURNED_OPCODE 0xb
#define CLR_PERFTRACK_PRIVATE_MODULE_RANGE_LOAD_OPCODE 0xa
#define CLR_METHOD_PRIVATE_JITTED_METHOD_RICH_DEBUG_INFO_OPCODE 0xa
#define CLR_DYNAMICTYPEUSAGE_IINSPECTABLERUNTIMECLASSNAME_OPCODE 0xb
#define CLR_DYNAMICTYPEUSAGE_WINRTUNBOX_OPCODE 0xc
#define CLR_DYNAMICTYPEUSAGE_CREATERCW_OPCODE 0xd
#define CLR_DYNAMICTYPEUSAGE_RCWVARIANCE_OPCODE 0xe
#define CLR_DYNAMICTYPEUSAGE_RCWIENUMERABLECASTING_OPCODE 0xf
#define CLR_DYNAMICTYPEUSAGE_CREATECCW_OPCODE 0x10
#define CLR_DYNAMICTYPEUSAGE_CCWVARIANCE_OPCODE 0x11
#define CLR_DYNAMICTYPEUSAGE_OBJECTVARIANTMARSHALLINGTONATIVE_OPCODE 0x12
#define CLR_DYNAMICTYPEUSAGE_GETTYPEFROMGUID_OPCODE 0x13
#define CLR_DYNAMICTYPEUSAGE_GETTYPEFROMPROGID_OPCODE 0x14
#define CLR_DYNAMICTYPEUSAGE_CONVERTTOCALLBACKETW_OPCODE 0x15
#define CLR_DYNAMICTYPEUSAGE_BEGINCREATEMANAGEDREFERENCE_OPCODE 0x16
#define CLR_DYNAMICTYPEUSAGE_ENDCREATEMANAGEDREFERENCE_OPCODE 0x17
#define CLR_DYNAMICTYPEUSAGE_OBJECTVARIANTMARSHALLINGTOMANAGED_OPCODE 0x18

//
// Tasks
//
#define CLR_GCPRIVATE_TASK 0x1
EXTERN_C __declspec(selectany) const GUID GarbageCollectionPrivateId = {0x2f1b6bf6, 0x18ff, 0x4645, {0x95, 0x01, 0x15, 0xdf, 0x6c, 0x64, 0xc2, 0xcf}};
#define CLR_FAILFAST_TASK 0x2
EXTERN_C __declspec(selectany) const GUID CLRFailFastId = {0xee9ede12, 0xc5f5, 0x4995, {0x81, 0xa2, 0xdc, 0xfb, 0x5f, 0x6b, 0x80, 0xc8}};
#define CLR_STARTUP_TASK 0x9
EXTERN_C __declspec(selectany) const GUID StartupId = {0x02d08a4f, 0xfd01, 0x4538, {0x98, 0x9b, 0x03, 0xe4, 0x37, 0xb9, 0x50, 0xf4}};
#define CLR_BINDING_TASK 0xa
EXTERN_C __declspec(selectany) const GUID BindingId = {0xe90e32ba, 0xe396, 0x4e6a, {0xa7, 0x90, 0x0a, 0x08, 0xc6, 0xc9, 0x25, 0xdc}};
#define CLR_STACKPRIVATE_TASK 0xb
EXTERN_C __declspec(selectany) const GUID CLRStackPrivateId = {0xd3363dc0, 0x243a, 0x4620, {0xa4, 0xd0, 0x8a, 0x07, 0xd7, 0x72, 0xf5, 0x33}};
#define CLR_EVIDENCE_GENERATED_TASK 0xc
EXTERN_C __declspec(selectany) const GUID EvidenceGeneratedTaskId = {0x24333617, 0x5ae4, 0x4f9e, {0xa5, 0xc5, 0x5e, 0xde, 0x1b, 0xc5, 0x92, 0x07}};
#define CLR_NGEN_BINDER_TASK 0xd
EXTERN_C __declspec(selectany) const GUID CLRNgenBinderId = {0x861f5339, 0x19d6, 0x4873, {0xb3, 0x50, 0x7b, 0x03, 0x22, 0x8b, 0xda, 0x7c}};
#define CLR_TRANSPARENCY_COMPUTATION_TASK 0xe
EXTERN_C __declspec(selectany) const GUID TransparencyComputationId = {0xe2444377, 0xddf9, 0x4589, {0xa8, 0x85, 0x08, 0xd6, 0x09, 0x25, 0x21, 0xdf}};
#define CLR_LOADERHEAPALLOCATIONPRIVATE_TASK 0x10
EXTERN_C __declspec(selectany) const GUID LoaderHeapAllocationId = {0x87f1e966, 0xd604, 0x41ba, {0xb1, 0xab, 0x18, 0x38, 0x49, 0xdf, 0xf2, 0x9d}};
#define CLR_MULTICOREJIT_TASK 0x11
EXTERN_C __declspec(selectany) const GUID CLRMulticoreJitId = {0xb85ad9e5, 0x658b, 0x4215, {0x8d, 0xdb, 0x83, 0x40, 0x40, 0xf4, 0xbc, 0x10}};
#define CLR_PERFTRACK_PRIVATE_TASK 0x14
EXTERN_C __declspec(selectany) const GUID CLRPerfTrackPrivateId = {0xeac685f6, 0x2104, 0x4dec, {0x88, 0xfd, 0x91, 0xe4, 0x25, 0x42, 0x21, 0xec}};
#define CLR_METHOD_PRIVATE_TASK 0x15
EXTERN_C __declspec(selectany) const GUID CLRMethodPrivateId = {0xcbc6eebc, 0x2ed8, 0x4130, {0x95, 0x05, 0x88, 0x5e, 0xae, 0x51, 0xbe, 0x7e}};
#define CLR_DYNAMICTYPEUSAGE_TASK 0x16
EXTERN_C __declspec(selectany) const GUID DynamicTypeUsageId = {0x4f67e18d, 0xeedd, 0x4056, {0xb8, 0xce, 0xdd, 0x82, 0x2f, 0xe5, 0x45, 0x53}};

//
// Keyword
//
#define CLR_PRIVATEGC_KEYWORD 0x1
#define CLR_PRIVATEBINDING_KEYWORD 0x2
#define CLR_PRIVATENGENFORCERESTORE_KEYWORD 0x4
#define CLR_PRIVATEFUSION_KEYWORD 0x8
#define CLR_PRIVATELOADERHEAP_KEYWORD 0x10
#define CLR_PRIVATESECURITY_KEYWORD 0x400
#define CLR_INTEROP_KEYWORD 0x2000
#define CLR_PRIVATEGCHANDLE_KEYWORD 0x4000
#define CLR_PRIVATEMULTICOREJIT_KEYWORD 0x20000
#define CLR_JITTED_METHOD_RICH_DEBUG_INFO_KEYWORD 0x40000
#define CLR_PERFTRACK_PRIVATE_KEYWORD 0x20000000
#define CLR_PRIVATESTACK_KEYWORD 0x40000000
#define CLR_PRIVATESTARTUP_KEYWORD 0x80000000
#define CLR_PRIVATE_DYNAMICTYPEUSAGE_KEYWORD 0x20

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCDecision = {0x1, 0x0, 0x0, 0x4, 0x84, 0x1, 0x1};
#define GCDecision_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCDecision_V1 = {0x1, 0x1, 0x0, 0x4, 0x84, 0x1, 0x1};
#define GCDecision_V1_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSettings = {0x2, 0x0, 0x0, 0x4, 0xe, 0x1, 0x1};
#define GCSettings_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSettings_V1 = {0x2, 0x1, 0x0, 0x4, 0xe, 0x1, 0x1};
#define GCSettings_V1_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCOptimized = {0x3, 0x0, 0x0, 0x5, 0x10, 0x1, 0x1};
#define GCOptimized_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCOptimized_V1 = {0x3, 0x1, 0x0, 0x5, 0x10, 0x1, 0x1};
#define GCOptimized_V1_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCPerHeapHistory = {0x4, 0x2, 0x0, 0x4, 0x11, 0x1, 0x1};
#define GCPerHeapHistory_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCPerHeapHistory_V1 = {0x4, 0x1, 0x0, 0x4, 0x11, 0x1, 0x1};
#define GCPerHeapHistory_V1_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGlobalHeapHistory = {0x5, 0x0, 0x0, 0x4, 0x12, 0x1, 0x1};
#define GCGlobalHeapHistory_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGlobalHeapHistory_V1 = {0x5, 0x1, 0x0, 0x4, 0x12, 0x1, 0x1};
#define GCGlobalHeapHistory_V1_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCJoin = {0x6, 0x0, 0x0, 0x5, 0x14, 0x1, 0x1};
#define GCJoin_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCJoin_V1 = {0x6, 0x1, 0x0, 0x5, 0x14, 0x1, 0x1};
#define GCJoin_V1_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkStackRoots = {0x7, 0x0, 0x0, 0x4, 0x15, 0x1, 0x1};
#define PrvGCMarkStackRoots_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkStackRoots_V1 = {0x7, 0x1, 0x0, 0x4, 0x15, 0x1, 0x1};
#define PrvGCMarkStackRoots_V1_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkFinalizeQueueRoots = {0x8, 0x0, 0x0, 0x4, 0x16, 0x1, 0x1};
#define PrvGCMarkFinalizeQueueRoots_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkFinalizeQueueRoots_V1 = {0x8, 0x1, 0x0, 0x4, 0x16, 0x1, 0x1};
#define PrvGCMarkFinalizeQueueRoots_V1_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkHandles = {0x9, 0x0, 0x0, 0x4, 0x17, 0x1, 0x1};
#define PrvGCMarkHandles_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkHandles_V1 = {0x9, 0x1, 0x0, 0x4, 0x17, 0x1, 0x1};
#define PrvGCMarkHandles_V1_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkCards = {0xa, 0x0, 0x0, 0x4, 0x18, 0x1, 0x1};
#define PrvGCMarkCards_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvGCMarkCards_V1 = {0xa, 0x1, 0x0, 0x4, 0x18, 0x1, 0x1};
#define PrvGCMarkCards_V1_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCBegin = {0xb, 0x0, 0x0, 0x4, 0x19, 0x1, 0x1};
#define BGCBegin_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGC1stNonConEnd = {0xc, 0x0, 0x0, 0x4, 0x1a, 0x1, 0x1};
#define BGC1stNonConEnd_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGC1stConEnd = {0xd, 0x0, 0x0, 0x4, 0x1b, 0x1, 0x1};
#define BGC1stConEnd_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGC2ndNonConBegin = {0xe, 0x0, 0x0, 0x4, 0x1c, 0x1, 0x1};
#define BGC2ndNonConBegin_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGC2ndNonConEnd = {0xf, 0x0, 0x0, 0x4, 0x1d, 0x1, 0x1};
#define BGC2ndNonConEnd_value 0xf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGC2ndConBegin = {0x10, 0x0, 0x0, 0x4, 0x1e, 0x1, 0x1};
#define BGC2ndConBegin_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGC2ndConEnd = {0x11, 0x0, 0x0, 0x4, 0x1f, 0x1, 0x1};
#define BGC2ndConEnd_value 0x11
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCPlanEnd = {0x12, 0x0, 0x0, 0x4, 0x20, 0x1, 0x1};
#define BGCPlanEnd_value 0x12
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCSweepEnd = {0x13, 0x0, 0x0, 0x4, 0x21, 0x1, 0x1};
#define BGCSweepEnd_value 0x13
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCDrainMark = {0x14, 0x0, 0x0, 0x4, 0x22, 0x1, 0x1};
#define BGCDrainMark_value 0x14
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCRevisit = {0x15, 0x0, 0x0, 0x4, 0x23, 0x1, 0x1};
#define BGCRevisit_value 0x15
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCOverflow = {0x16, 0x0, 0x0, 0x4, 0x24, 0x1, 0x1};
#define BGCOverflow_value 0x16
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCOverflow_V1 = {0x16, 0x1, 0x0, 0x4, 0x24, 0x1, 0x1};
#define BGCOverflow_V1_value 0x16
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCAllocWaitBegin = {0x17, 0x0, 0x0, 0x4, 0x25, 0x1, 0x1};
#define BGCAllocWaitBegin_value 0x17
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGCAllocWaitEnd = {0x18, 0x0, 0x0, 0x4, 0x26, 0x1, 0x1};
#define BGCAllocWaitEnd_value 0x18
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFullNotify = {0x19, 0x0, 0x0, 0x4, 0x13, 0x1, 0x1};
#define GCFullNotify_value 0x19
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFullNotify_V1 = {0x19, 0x1, 0x0, 0x4, 0x13, 0x1, 0x1};
#define GCFullNotify_V1_value 0x19
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BGC1stSweepEnd = {0x1a, 0x0, 0x0, 0x4, 0x2d, 0x1, 0x1};
#define BGC1stSweepEnd_value 0x1a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEStartupStart = {0x50, 0x0, 0x0, 0x4, 0x80, 0x9, 0x80000000};
#define EEStartupStart_value 0x50
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEStartupStart_V1 = {0x50, 0x1, 0x0, 0x4, 0x80, 0x9, 0x80000000};
#define EEStartupStart_V1_value 0x50
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEStartupEnd = {0x51, 0x0, 0x0, 0x4, 0x81, 0x9, 0x80000000};
#define EEStartupEnd_value 0x51
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEStartupEnd_V1 = {0x51, 0x1, 0x0, 0x4, 0x81, 0x9, 0x80000000};
#define EEStartupEnd_V1_value 0x51
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSetup = {0x52, 0x0, 0x0, 0x4, 0x82, 0x9, 0x80000000};
#define EEConfigSetup_value 0x52
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSetup_V1 = {0x52, 0x1, 0x0, 0x4, 0x82, 0x9, 0x80000000};
#define EEConfigSetup_V1_value 0x52
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSetupEnd = {0x53, 0x0, 0x0, 0x4, 0x83, 0x9, 0x80000000};
#define EEConfigSetupEnd_value 0x53
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSetupEnd_V1 = {0x53, 0x1, 0x0, 0x4, 0x83, 0x9, 0x80000000};
#define EEConfigSetupEnd_V1_value 0x53
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdSysBases = {0x54, 0x0, 0x0, 0x4, 0x84, 0x9, 0x80000000};
#define LdSysBases_value 0x54
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdSysBases_V1 = {0x54, 0x1, 0x0, 0x4, 0x84, 0x9, 0x80000000};
#define LdSysBases_V1_value 0x54
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdSysBasesEnd = {0x55, 0x0, 0x0, 0x4, 0x85, 0x9, 0x80000000};
#define LdSysBasesEnd_value 0x55
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdSysBasesEnd_V1 = {0x55, 0x1, 0x0, 0x4, 0x85, 0x9, 0x80000000};
#define LdSysBasesEnd_V1_value 0x55
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExecExe = {0x56, 0x0, 0x0, 0x4, 0x86, 0x9, 0x80000000};
#define ExecExe_value 0x56
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExecExe_V1 = {0x56, 0x1, 0x0, 0x4, 0x86, 0x9, 0x80000000};
#define ExecExe_V1_value 0x56
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExecExeEnd = {0x57, 0x0, 0x0, 0x4, 0x87, 0x9, 0x80000000};
#define ExecExeEnd_value 0x57
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExecExeEnd_V1 = {0x57, 0x1, 0x0, 0x4, 0x87, 0x9, 0x80000000};
#define ExecExeEnd_V1_value 0x57
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Main = {0x58, 0x0, 0x0, 0x4, 0x88, 0x9, 0x80000000};
#define Main_value 0x58
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Main_V1 = {0x58, 0x1, 0x0, 0x4, 0x88, 0x9, 0x80000000};
#define Main_V1_value 0x58
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MainEnd = {0x59, 0x0, 0x0, 0x4, 0x89, 0x9, 0x80000000};
#define MainEnd_value 0x59
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MainEnd_V1 = {0x59, 0x1, 0x0, 0x4, 0x89, 0x9, 0x80000000};
#define MainEnd_V1_value 0x59
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ApplyPolicyStart = {0x5a, 0x0, 0x0, 0x4, 0xa, 0x9, 0x80000000};
#define ApplyPolicyStart_value 0x5a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ApplyPolicyStart_V1 = {0x5a, 0x1, 0x0, 0x4, 0xa, 0x9, 0x80000000};
#define ApplyPolicyStart_V1_value 0x5a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ApplyPolicyEnd = {0x5b, 0x0, 0x0, 0x4, 0xb, 0x9, 0x80000000};
#define ApplyPolicyEnd_value 0x5b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ApplyPolicyEnd_V1 = {0x5b, 0x1, 0x0, 0x4, 0xb, 0x9, 0x80000000};
#define ApplyPolicyEnd_V1_value 0x5b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdLibShFolder = {0x5c, 0x0, 0x0, 0x4, 0xc, 0x9, 0x80000000};
#define LdLibShFolder_value 0x5c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdLibShFolder_V1 = {0x5c, 0x1, 0x0, 0x4, 0xc, 0x9, 0x80000000};
#define LdLibShFolder_V1_value 0x5c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdLibShFolderEnd = {0x5d, 0x0, 0x0, 0x4, 0xd, 0x9, 0x80000000};
#define LdLibShFolderEnd_value 0x5d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LdLibShFolderEnd_V1 = {0x5d, 0x1, 0x0, 0x4, 0xd, 0x9, 0x80000000};
#define LdLibShFolderEnd_V1_value 0x5d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrestubWorker = {0x5e, 0x0, 0x0, 0x4, 0xe, 0x9, 0x80000000};
#define PrestubWorker_value 0x5e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrestubWorker_V1 = {0x5e, 0x1, 0x0, 0x4, 0xe, 0x9, 0x80000000};
#define PrestubWorker_V1_value 0x5e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrestubWorkerEnd = {0x5f, 0x0, 0x0, 0x4, 0xf, 0x9, 0x80000000};
#define PrestubWorkerEnd_value 0x5f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrestubWorkerEnd_V1 = {0x5f, 0x1, 0x0, 0x4, 0xf, 0x9, 0x80000000};
#define PrestubWorkerEnd_V1_value 0x5f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GetInstallationStart = {0x60, 0x0, 0x0, 0x4, 0x10, 0x9, 0x80000000};
#define GetInstallationStart_value 0x60
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GetInstallationStart_V1 = {0x60, 0x1, 0x0, 0x4, 0x10, 0x9, 0x80000000};
#define GetInstallationStart_V1_value 0x60
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GetInstallationEnd = {0x61, 0x0, 0x0, 0x4, 0x11, 0x9, 0x80000000};
#define GetInstallationEnd_value 0x61
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GetInstallationEnd_V1 = {0x61, 0x1, 0x0, 0x4, 0x11, 0x9, 0x80000000};
#define GetInstallationEnd_V1_value 0x61
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR OpenHModule = {0x62, 0x0, 0x0, 0x4, 0x12, 0x9, 0x80000000};
#define OpenHModule_value 0x62
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR OpenHModule_V1 = {0x62, 0x1, 0x0, 0x4, 0x12, 0x9, 0x80000000};
#define OpenHModule_V1_value 0x62
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR OpenHModuleEnd = {0x63, 0x0, 0x0, 0x4, 0x13, 0x9, 0x80000000};
#define OpenHModuleEnd_value 0x63
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR OpenHModuleEnd_V1 = {0x63, 0x1, 0x0, 0x4, 0x13, 0x9, 0x80000000};
#define OpenHModuleEnd_V1_value 0x63
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExplicitBindStart = {0x64, 0x0, 0x0, 0x4, 0x14, 0x9, 0x80000000};
#define ExplicitBindStart_value 0x64
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExplicitBindStart_V1 = {0x64, 0x1, 0x0, 0x4, 0x14, 0x9, 0x80000000};
#define ExplicitBindStart_V1_value 0x64
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExplicitBindEnd = {0x65, 0x0, 0x0, 0x4, 0x15, 0x9, 0x80000000};
#define ExplicitBindEnd_value 0x65
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExplicitBindEnd_V1 = {0x65, 0x1, 0x0, 0x4, 0x15, 0x9, 0x80000000};
#define ExplicitBindEnd_V1_value 0x65
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ParseXml = {0x66, 0x0, 0x0, 0x4, 0x16, 0x9, 0x80000000};
#define ParseXml_value 0x66
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ParseXml_V1 = {0x66, 0x1, 0x0, 0x4, 0x16, 0x9, 0x80000000};
#define ParseXml_V1_value 0x66
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ParseXmlEnd = {0x67, 0x0, 0x0, 0x4, 0x17, 0x9, 0x80000000};
#define ParseXmlEnd_value 0x67
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ParseXmlEnd_V1 = {0x67, 0x1, 0x0, 0x4, 0x17, 0x9, 0x80000000};
#define ParseXmlEnd_V1_value 0x67
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitDefaultDomain = {0x68, 0x0, 0x0, 0x4, 0x18, 0x9, 0x80000000};
#define InitDefaultDomain_value 0x68
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitDefaultDomain_V1 = {0x68, 0x1, 0x0, 0x4, 0x18, 0x9, 0x80000000};
#define InitDefaultDomain_V1_value 0x68
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitDefaultDomainEnd = {0x69, 0x0, 0x0, 0x4, 0x19, 0x9, 0x80000000};
#define InitDefaultDomainEnd_value 0x69
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitDefaultDomainEnd_V1 = {0x69, 0x1, 0x0, 0x4, 0x19, 0x9, 0x80000000};
#define InitDefaultDomainEnd_V1_value 0x69
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitSecurity = {0x6a, 0x0, 0x0, 0x4, 0x1a, 0x9, 0x80000000};
#define InitSecurity_value 0x6a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitSecurity_V1 = {0x6a, 0x1, 0x0, 0x4, 0x1a, 0x9, 0x80000000};
#define InitSecurity_V1_value 0x6a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitSecurityEnd = {0x6b, 0x0, 0x0, 0x4, 0x1b, 0x9, 0x80000000};
#define InitSecurityEnd_value 0x6b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR InitSecurityEnd_V1 = {0x6b, 0x1, 0x0, 0x4, 0x1b, 0x9, 0x80000000};
#define InitSecurityEnd_V1_value 0x6b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AllowBindingRedirs = {0x6c, 0x0, 0x0, 0x4, 0x1c, 0x9, 0x80000000};
#define AllowBindingRedirs_value 0x6c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AllowBindingRedirs_V1 = {0x6c, 0x1, 0x0, 0x4, 0x1c, 0x9, 0x80000000};
#define AllowBindingRedirs_V1_value 0x6c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AllowBindingRedirsEnd = {0x6d, 0x0, 0x0, 0x4, 0x1d, 0x9, 0x80000000};
#define AllowBindingRedirsEnd_value 0x6d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AllowBindingRedirsEnd_V1 = {0x6d, 0x1, 0x0, 0x4, 0x1d, 0x9, 0x80000000};
#define AllowBindingRedirsEnd_V1_value 0x6d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSync = {0x6e, 0x0, 0x0, 0x4, 0x1e, 0x9, 0x80000000};
#define EEConfigSync_value 0x6e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSync_V1 = {0x6e, 0x1, 0x0, 0x4, 0x1e, 0x9, 0x80000000};
#define EEConfigSync_V1_value 0x6e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSyncEnd = {0x6f, 0x0, 0x0, 0x4, 0x1f, 0x9, 0x80000000};
#define EEConfigSyncEnd_value 0x6f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EEConfigSyncEnd_V1 = {0x6f, 0x1, 0x0, 0x4, 0x1f, 0x9, 0x80000000};
#define EEConfigSyncEnd_V1_value 0x6f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionBinding = {0x70, 0x0, 0x0, 0x4, 0x20, 0x9, 0x80000000};
#define FusionBinding_value 0x70
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionBinding_V1 = {0x70, 0x1, 0x0, 0x4, 0x20, 0x9, 0x80000000};
#define FusionBinding_V1_value 0x70
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionBindingEnd = {0x71, 0x0, 0x0, 0x4, 0x21, 0x9, 0x80000000};
#define FusionBindingEnd_value 0x71
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionBindingEnd_V1 = {0x71, 0x1, 0x0, 0x4, 0x21, 0x9, 0x80000000};
#define FusionBindingEnd_V1_value 0x71
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderCatchCall = {0x72, 0x0, 0x0, 0x4, 0x22, 0x9, 0x80000000};
#define LoaderCatchCall_value 0x72
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderCatchCall_V1 = {0x72, 0x1, 0x0, 0x4, 0x22, 0x9, 0x80000000};
#define LoaderCatchCall_V1_value 0x72
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderCatchCallEnd = {0x73, 0x0, 0x0, 0x4, 0x23, 0x9, 0x80000000};
#define LoaderCatchCallEnd_value 0x73
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderCatchCallEnd_V1 = {0x73, 0x1, 0x0, 0x4, 0x23, 0x9, 0x80000000};
#define LoaderCatchCallEnd_V1_value 0x73
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionInit = {0x74, 0x0, 0x0, 0x4, 0x24, 0x9, 0x80000000};
#define FusionInit_value 0x74
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionInit_V1 = {0x74, 0x1, 0x0, 0x4, 0x24, 0x9, 0x80000000};
#define FusionInit_V1_value 0x74
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionInitEnd = {0x75, 0x0, 0x0, 0x4, 0x25, 0x9, 0x80000000};
#define FusionInitEnd_value 0x75
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionInitEnd_V1 = {0x75, 0x1, 0x0, 0x4, 0x25, 0x9, 0x80000000};
#define FusionInitEnd_V1_value 0x75
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionAppCtx = {0x76, 0x0, 0x0, 0x4, 0x26, 0x9, 0x80000000};
#define FusionAppCtx_value 0x76
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionAppCtx_V1 = {0x76, 0x1, 0x0, 0x4, 0x26, 0x9, 0x80000000};
#define FusionAppCtx_V1_value 0x76
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionAppCtxEnd = {0x77, 0x0, 0x0, 0x4, 0x27, 0x9, 0x80000000};
#define FusionAppCtxEnd_value 0x77
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionAppCtxEnd_V1 = {0x77, 0x1, 0x0, 0x4, 0x27, 0x9, 0x80000000};
#define FusionAppCtxEnd_V1_value 0x77
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Fusion2EE = {0x78, 0x0, 0x0, 0x4, 0x28, 0x9, 0x80000000};
#define Fusion2EE_value 0x78
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Fusion2EE_V1 = {0x78, 0x1, 0x0, 0x4, 0x28, 0x9, 0x80000000};
#define Fusion2EE_V1_value 0x78
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Fusion2EEEnd = {0x79, 0x0, 0x0, 0x4, 0x29, 0x9, 0x80000000};
#define Fusion2EEEnd_value 0x79
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Fusion2EEEnd_V1 = {0x79, 0x1, 0x0, 0x4, 0x29, 0x9, 0x80000000};
#define Fusion2EEEnd_V1_value 0x79
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SecurityCatchCall = {0x7a, 0x0, 0x0, 0x4, 0x2a, 0x9, 0x80000000};
#define SecurityCatchCall_value 0x7a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SecurityCatchCall_V1 = {0x7a, 0x1, 0x0, 0x4, 0x2a, 0x9, 0x80000000};
#define SecurityCatchCall_V1_value 0x7a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SecurityCatchCallEnd = {0x7b, 0x0, 0x0, 0x4, 0x2b, 0x9, 0x80000000};
#define SecurityCatchCallEnd_value 0x7b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SecurityCatchCallEnd_V1 = {0x7b, 0x1, 0x0, 0x4, 0x2b, 0x9, 0x80000000};
#define SecurityCatchCallEnd_V1_value 0x7b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CLRStackWalkPrivate = {0x97, 0x0, 0x0, 0x0, 0x52, 0xb, 0x40000000};
#define CLRStackWalkPrivate_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleRangeLoadPrivate = {0x9e, 0x0, 0x0, 0x4, 0xa, 0x14, 0x20000000};
#define ModuleRangeLoadPrivate_value 0x9e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingPolicyPhaseStart = {0x9f, 0x0, 0x0, 0x4, 0x33, 0xa, 0x2};
#define BindingPolicyPhaseStart_value 0x9f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingPolicyPhaseEnd = {0xa0, 0x0, 0x0, 0x4, 0x34, 0xa, 0x2};
#define BindingPolicyPhaseEnd_value 0xa0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingNgenPhaseStart = {0xa1, 0x0, 0x0, 0x4, 0x35, 0xa, 0x2};
#define BindingNgenPhaseStart_value 0xa1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingNgenPhaseEnd = {0xa2, 0x0, 0x0, 0x4, 0x36, 0xa, 0x2};
#define BindingNgenPhaseEnd_value 0xa2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingLookupAndProbingPhaseStart = {0xa3, 0x0, 0x0, 0x4, 0x37, 0xa, 0x2};
#define BindingLookupAndProbingPhaseStart_value 0xa3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingLookupAndProbingPhaseEnd = {0xa4, 0x0, 0x0, 0x4, 0x38, 0xa, 0x2};
#define BindingLookupAndProbingPhaseEnd_value 0xa4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderPhaseStart = {0xa5, 0x0, 0x0, 0x4, 0x39, 0xa, 0x2};
#define LoaderPhaseStart_value 0xa5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderPhaseEnd = {0xa6, 0x0, 0x0, 0x4, 0x3a, 0xa, 0x2};
#define LoaderPhaseEnd_value 0xa6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingPhaseStart = {0xa7, 0x0, 0x0, 0x4, 0x3b, 0xa, 0x2};
#define BindingPhaseStart_value 0xa7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingPhaseEnd = {0xa8, 0x0, 0x0, 0x4, 0x3c, 0xa, 0x2};
#define BindingPhaseEnd_value 0xa8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingDownloadPhaseStart = {0xa9, 0x0, 0x0, 0x4, 0x3d, 0xa, 0x2};
#define BindingDownloadPhaseStart_value 0xa9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BindingDownloadPhaseEnd = {0xaa, 0x0, 0x0, 0x4, 0x3e, 0xa, 0x2};
#define BindingDownloadPhaseEnd_value 0xaa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderAssemblyInitPhaseStart = {0xab, 0x0, 0x0, 0x4, 0x3f, 0xa, 0x2};
#define LoaderAssemblyInitPhaseStart_value 0xab
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderAssemblyInitPhaseEnd = {0xac, 0x0, 0x0, 0x4, 0x40, 0xa, 0x2};
#define LoaderAssemblyInitPhaseEnd_value 0xac
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderMappingPhaseStart = {0xad, 0x0, 0x0, 0x4, 0x41, 0xa, 0x2};
#define LoaderMappingPhaseStart_value 0xad
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderMappingPhaseEnd = {0xae, 0x0, 0x0, 0x4, 0x42, 0xa, 0x2};
#define LoaderMappingPhaseEnd_value 0xae
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderDeliverEventsPhaseStart = {0xaf, 0x0, 0x0, 0x4, 0x43, 0xa, 0x2};
#define LoaderDeliverEventsPhaseStart_value 0xaf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR LoaderDeliverEventsPhaseEnd = {0xb0, 0x0, 0x0, 0x4, 0x44, 0xa, 0x2};
#define LoaderDeliverEventsPhaseEnd_value 0xb0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EvidenceGenerated = {0xb1, 0x0, 0x0, 0x4, 0xa, 0xc, 0x400};
#define EvidenceGenerated_value 0xb1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleTransparencyComputationStart = {0xb2, 0x0, 0x0, 0x4, 0x53, 0xe, 0x400};
#define ModuleTransparencyComputationStart_value 0xb2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleTransparencyComputationEnd = {0xb3, 0x0, 0x0, 0x4, 0x54, 0xe, 0x400};
#define ModuleTransparencyComputationEnd_value 0xb3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TypeTransparencyComputationStart = {0xb4, 0x0, 0x0, 0x4, 0x55, 0xe, 0x400};
#define TypeTransparencyComputationStart_value 0xb4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TypeTransparencyComputationEnd = {0xb5, 0x0, 0x0, 0x4, 0x56, 0xe, 0x400};
#define TypeTransparencyComputationEnd_value 0xb5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodTransparencyComputationStart = {0xb6, 0x0, 0x0, 0x4, 0x57, 0xe, 0x400};
#define MethodTransparencyComputationStart_value 0xb6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodTransparencyComputationEnd = {0xb7, 0x0, 0x0, 0x4, 0x58, 0xe, 0x400};
#define MethodTransparencyComputationEnd_value 0xb7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FieldTransparencyComputationStart = {0xb8, 0x0, 0x0, 0x4, 0x59, 0xe, 0x400};
#define FieldTransparencyComputationStart_value 0xb8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FieldTransparencyComputationEnd = {0xb9, 0x0, 0x0, 0x4, 0x5a, 0xe, 0x400};
#define FieldTransparencyComputationEnd_value 0xb9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TokenTransparencyComputationStart = {0xba, 0x0, 0x0, 0x4, 0x5b, 0xe, 0x400};
#define TokenTransparencyComputationStart_value 0xba
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TokenTransparencyComputationEnd = {0xbb, 0x0, 0x0, 0x4, 0x5c, 0xe, 0x400};
#define TokenTransparencyComputationEnd_value 0xbb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR NgenBindEvent = {0xbc, 0x0, 0x0, 0x4, 0x45, 0xd, 0x8};
#define NgenBindEvent_value 0xbc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR JittedMethodRichDebugInfo = {0xbd, 0x0, 0x0, 0x4, 0xa, 0x15, 0x40000};
#define JittedMethodRichDebugInfo_value 0xbd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FailFast = {0xbf, 0x0, 0x0, 0x1, 0x34, 0x2, 0x0};
#define FailFast_value 0xbf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvFinalizeObject = {0xc0, 0x0, 0x0, 0x5, 0x27, 0x1, 0x1};
#define PrvFinalizeObject_value 0xc0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CCWRefCountChangeAnsi = {0xc1, 0x0, 0x0, 0x5, 0x28, 0x1, 0x2000};
#define CCWRefCountChangeAnsi_value 0xc1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvSetGCHandle = {0xc2, 0x0, 0x0, 0x5, 0x2a, 0x1, 0x4000};
#define PrvSetGCHandle_value 0xc2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PrvDestroyGCHandle = {0xc3, 0x0, 0x0, 0x5, 0x2b, 0x1, 0x4000};
#define PrvDestroyGCHandle_value 0xc3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionMessageEvent = {0xc4, 0x0, 0x0, 0x4, 0x46, 0xa, 0x2};
#define FusionMessageEvent_value 0xc4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FusionErrorCodeEvent = {0xc5, 0x0, 0x0, 0x4, 0x47, 0xa, 0x2};
#define FusionErrorCodeEvent_value 0xc5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PinPlugAtGCTime = {0xc7, 0x0, 0x0, 0x5, 0x2c, 0x1, 0x1};
#define PinPlugAtGCTime_value 0xc7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CCWRefCountChange = {0xc8, 0x0, 0x0, 0x5, 0x28, 0x1, 0x2000};
#define CCWRefCountChange_value 0xc8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AllocRequest = {0x136, 0x0, 0x0, 0x5, 0x61, 0x10, 0x10};
#define AllocRequest_value 0x136
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MulticoreJit = {0xc9, 0x0, 0x0, 0x4, 0xa, 0x11, 0x20000};
#define MulticoreJit_value 0xc9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MulticoreJitMethodCodeReturned = {0xca, 0x0, 0x0, 0x4, 0xb, 0x11, 0x20000};
#define MulticoreJitMethodCodeReturned_value 0xca
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IInspectableRuntimeClassName = {0x190, 0x0, 0x0, 0x4, 0xb, 0x16, 0x20};
#define IInspectableRuntimeClassName_value 0x190
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WinRTUnbox = {0x191, 0x0, 0x0, 0x4, 0xc, 0x16, 0x20};
#define WinRTUnbox_value 0x191
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CreateRCW = {0x192, 0x0, 0x0, 0x4, 0xd, 0x16, 0x20};
#define CreateRCW_value 0x192
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RCWVariance = {0x193, 0x0, 0x0, 0x4, 0xe, 0x16, 0x20};
#define RCWVariance_value 0x193
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RCWIEnumerableCasting = {0x194, 0x0, 0x0, 0x4, 0xf, 0x16, 0x20};
#define RCWIEnumerableCasting_value 0x194
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CreateCCW = {0x195, 0x0, 0x0, 0x4, 0x10, 0x16, 0x20};
#define CreateCCW_value 0x195
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CCWVariance = {0x196, 0x0, 0x0, 0x4, 0x11, 0x16, 0x20};
#define CCWVariance_value 0x196
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ObjectVariantMarshallingToNative = {0x197, 0x0, 0x0, 0x4, 0x12, 0x16, 0x20};
#define ObjectVariantMarshallingToNative_value 0x197
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GetTypeFromGUID = {0x198, 0x0, 0x0, 0x4, 0x13, 0x16, 0x20};
#define GetTypeFromGUID_value 0x198
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GetTypeFromProgID = {0x199, 0x0, 0x0, 0x4, 0x14, 0x16, 0x20};
#define GetTypeFromProgID_value 0x199
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ConvertToCallbackEtw = {0x19a, 0x0, 0x0, 0x4, 0x15, 0x16, 0x20};
#define ConvertToCallbackEtw_value 0x19a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BeginCreateManagedReference = {0x19b, 0x0, 0x0, 0x4, 0x16, 0x16, 0x20};
#define BeginCreateManagedReference_value 0x19b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EndCreateManagedReference = {0x19c, 0x0, 0x0, 0x4, 0x17, 0x16, 0x20};
#define EndCreateManagedReference_value 0x19c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ObjectVariantMarshallingToManaged = {0x19d, 0x0, 0x0, 0x4, 0x18, 0x16, 0x20};
#define ObjectVariantMarshallingToManaged_value 0x19d

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Microsoft_Windows_DotNETRuntimePrivateEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Microsoft_Windows_DotNETRuntimePrivateKeywords[15] = {0x1, 0x1, 0x80000000, 0x40000000, 0x20000000, 0x2, 0x400, 0x8, 0x40000, 0x0, 0x2000, 0x4000, 0x10, 0x20000, 0x20};
EXTERN_C __declspec(selectany) const unsigned char Microsoft_Windows_DotNETRuntimePrivateLevels[15] = {4, 5, 4, 0, 4, 4, 4, 4, 4, 1, 5, 5, 5, 4, 4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context = {0, (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 15, Microsoft_Windows_DotNETRuntimePrivateEnableBits, Microsoft_Windows_DotNETRuntimePrivateKeywords, Microsoft_Windows_DotNETRuntimePrivateLevels};

//
// Provider REGHANDLE
//
#define Microsoft_Windows_DotNETRuntimePrivateHandle (MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterMicrosoft_Windows_DotNETRuntimePrivate
#define EventRegisterMicrosoft_Windows_DotNETRuntimePrivate() McGenEventRegister(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER, McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimePrivateHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidMicrosoft_Windows_DotNETRuntimePrivate
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimePrivate(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimePrivateHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterMicrosoft_Windows_DotNETRuntimePrivate
#define EventUnregisterMicrosoft_Windows_DotNETRuntimePrivate() McGenEventUnregister(&Microsoft_Windows_DotNETRuntimePrivateHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Microsoft_Windows_DotNETRuntimePrivate));
// - Caller registers the provider, e.g. EventRegisterMicrosoft_Windows_DotNETRuntimePrivate_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterMicrosoft_Windows_DotNETRuntimePrivate_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Microsoft_Windows_DotNETRuntimePrivate {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Microsoft_Windows_DotNETRuntimePrivateHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Microsoft_Windows_DotNETRuntimePrivate;

#define EventRegisterMicrosoft_Windows_DotNETRuntimePrivate_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimePrivate_, MCGEN_EVENTREGISTER)(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER, pContext)
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimePrivate_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimePrivate_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterMicrosoft_Windows_DotNETRuntimePrivate_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Microsoft_Windows_DotNETRuntimePrivateHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimePrivate_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Microsoft_Windows_DotNETRuntimePrivate* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Traits;
    pContext->Context.EnableBitsCount = 15;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Microsoft_Windows_DotNETRuntimePrivateKeywords;
    pContext->Context.EnableLevel = Microsoft_Windows_DotNETRuntimePrivateLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Microsoft_Windows_DotNETRuntimePrivate*
_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(_In_ McGenContext_Microsoft_Windows_DotNETRuntimePrivate* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "GCDecision"
//
#define EventXplatEnabledGCDecision() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCDecision_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCDecision"
//
#define FireEtXplatGCDecision(DoCompact) \
        MCGEN_EVENT_ENABLED(GCDecision) \
        ? _mcgen_TEMPLATE_FOR_GCDecision(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCDecision, DoCompact) : 0
#define FireEtXplatGCDecision_AssumeEnabled(DoCompact) \
        _mcgen_TEMPLATE_FOR_GCDecision(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCDecision, DoCompact)
#define FireEtXplatGCDecision_ForContext(pContext, DoCompact) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCDecision) \
        ? _mcgen_TEMPLATE_FOR_GCDecision(&(pContext)->Context, &GCDecision, DoCompact) : 0
#define FireEtXplatGCDecision_ForContextAssumeEnabled(pContext, DoCompact) \
        _mcgen_TEMPLATE_FOR_GCDecision(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCDecision, DoCompact)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCDecision _mcgen_PASTE2(McTemplateCoU0t_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCDecision_V1"
//
#define EventXplatEnabledGCDecision_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCDecision_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCDecision_V1"
//
#define FireEtXplatGCDecision_V1(DoCompact, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCDecision_V1) \
        ? _mcgen_TEMPLATE_FOR_GCDecision_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCDecision_V1, DoCompact, ClrInstanceID) : 0
#define FireEtXplatGCDecision_V1_AssumeEnabled(DoCompact, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCDecision_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCDecision_V1, DoCompact, ClrInstanceID)
#define FireEtXplatGCDecision_V1_ForContext(pContext, DoCompact, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCDecision_V1) \
        ? _mcgen_TEMPLATE_FOR_GCDecision_V1(&(pContext)->Context, &GCDecision_V1, DoCompact, ClrInstanceID) : 0
#define FireEtXplatGCDecision_V1_ForContextAssumeEnabled(pContext, DoCompact, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCDecision_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCDecision_V1, DoCompact, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCDecision_V1 _mcgen_PASTE2(McTemplateCoU0th_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSettings"
//
#define EventXplatEnabledGCSettings() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCSettings_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSettings"
//
#define FireEtXplatGCSettings(SegmentSize, LargeObjectSegmentSize, ServerGC) \
        MCGEN_EVENT_ENABLED(GCSettings) \
        ? _mcgen_TEMPLATE_FOR_GCSettings(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCSettings, SegmentSize, LargeObjectSegmentSize, ServerGC) : 0
#define FireEtXplatGCSettings_AssumeEnabled(SegmentSize, LargeObjectSegmentSize, ServerGC) \
        _mcgen_TEMPLATE_FOR_GCSettings(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCSettings, SegmentSize, LargeObjectSegmentSize, ServerGC)
#define FireEtXplatGCSettings_ForContext(pContext, SegmentSize, LargeObjectSegmentSize, ServerGC) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSettings) \
        ? _mcgen_TEMPLATE_FOR_GCSettings(&(pContext)->Context, &GCSettings, SegmentSize, LargeObjectSegmentSize, ServerGC) : 0
#define FireEtXplatGCSettings_ForContextAssumeEnabled(pContext, SegmentSize, LargeObjectSegmentSize, ServerGC) \
        _mcgen_TEMPLATE_FOR_GCSettings(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCSettings, SegmentSize, LargeObjectSegmentSize, ServerGC)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSettings _mcgen_PASTE2(McTemplateCoU0xxt_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSettings_V1"
//
#define EventXplatEnabledGCSettings_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCSettings_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSettings_V1"
//
#define FireEtXplatGCSettings_V1(SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSettings_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSettings_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCSettings_V1, SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID) : 0
#define FireEtXplatGCSettings_V1_AssumeEnabled(SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSettings_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCSettings_V1, SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID)
#define FireEtXplatGCSettings_V1_ForContext(pContext, SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSettings_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSettings_V1(&(pContext)->Context, &GCSettings_V1, SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID) : 0
#define FireEtXplatGCSettings_V1_ForContextAssumeEnabled(pContext, SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSettings_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCSettings_V1, SegmentSize, LargeObjectSegmentSize, ServerGC, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSettings_V1 _mcgen_PASTE2(McTemplateCoU0xxth_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCOptimized"
//
#define EventXplatEnabledGCOptimized() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 1)
#define EventXplatEnabledGCOptimized_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 1)

//
// Event write macros for event "GCOptimized"
//
#define FireEtXplatGCOptimized(DesiredAllocation, NewAllocation, GenerationNumber) \
        MCGEN_EVENT_ENABLED(GCOptimized) \
        ? _mcgen_TEMPLATE_FOR_GCOptimized(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCOptimized, DesiredAllocation, NewAllocation, GenerationNumber) : 0
#define FireEtXplatGCOptimized_AssumeEnabled(DesiredAllocation, NewAllocation, GenerationNumber) \
        _mcgen_TEMPLATE_FOR_GCOptimized(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCOptimized, DesiredAllocation, NewAllocation, GenerationNumber)
#define FireEtXplatGCOptimized_ForContext(pContext, DesiredAllocation, NewAllocation, GenerationNumber) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCOptimized) \
        ? _mcgen_TEMPLATE_FOR_GCOptimized(&(pContext)->Context, &GCOptimized, DesiredAllocation, NewAllocation, GenerationNumber) : 0
#define FireEtXplatGCOptimized_ForContextAssumeEnabled(pContext, DesiredAllocation, NewAllocation, GenerationNumber) \
        _mcgen_TEMPLATE_FOR_GCOptimized(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCOptimized, DesiredAllocation, NewAllocation, GenerationNumber)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCOptimized _mcgen_PASTE2(McTemplateCoU0xxq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCOptimized_V1"
//
#define EventXplatEnabledGCOptimized_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 1)
#define EventXplatEnabledGCOptimized_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 1)

//
// Event write macros for event "GCOptimized_V1"
//
#define FireEtXplatGCOptimized_V1(DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCOptimized_V1) \
        ? _mcgen_TEMPLATE_FOR_GCOptimized_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCOptimized_V1, DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID) : 0
#define FireEtXplatGCOptimized_V1_AssumeEnabled(DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCOptimized_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCOptimized_V1, DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID)
#define FireEtXplatGCOptimized_V1_ForContext(pContext, DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCOptimized_V1) \
        ? _mcgen_TEMPLATE_FOR_GCOptimized_V1(&(pContext)->Context, &GCOptimized_V1, DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID) : 0
#define FireEtXplatGCOptimized_V1_ForContextAssumeEnabled(pContext, DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCOptimized_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCOptimized_V1, DesiredAllocation, NewAllocation, GenerationNumber, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCOptimized_V1 _mcgen_PASTE2(McTemplateCoU0xxqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCPerHeapHistory"
//
#define EventXplatEnabledGCPerHeapHistory() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCPerHeapHistory_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCPerHeapHistory"
//
#define FireEtXplatGCPerHeapHistory() \
        MCGEN_EVENT_ENABLED(GCPerHeapHistory) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCPerHeapHistory) : 0
#define FireEtXplatGCPerHeapHistory_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCPerHeapHistory)
#define FireEtXplatGCPerHeapHistory_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCPerHeapHistory) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory(&(pContext)->Context, &GCPerHeapHistory) : 0
#define FireEtXplatGCPerHeapHistory_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCPerHeapHistory)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCPerHeapHistory _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCPerHeapHistory_V1"
//
#define EventXplatEnabledGCPerHeapHistory_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCPerHeapHistory_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCPerHeapHistory_V1"
//
#define FireEtXplatGCPerHeapHistory_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCPerHeapHistory_V1) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCPerHeapHistory_V1, ClrInstanceID) : 0
#define FireEtXplatGCPerHeapHistory_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCPerHeapHistory_V1, ClrInstanceID)
#define FireEtXplatGCPerHeapHistory_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCPerHeapHistory_V1) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V1(&(pContext)->Context, &GCPerHeapHistory_V1, ClrInstanceID) : 0
#define FireEtXplatGCPerHeapHistory_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCPerHeapHistory_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGlobalHeapHistory"
//
#define EventXplatEnabledGCGlobalHeapHistory() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCGlobalHeapHistory_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCGlobalHeapHistory"
//
#define FireEtXplatGCGlobalHeapHistory(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms) \
        MCGEN_EVENT_ENABLED(GCGlobalHeapHistory) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCGlobalHeapHistory, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms) : 0
#define FireEtXplatGCGlobalHeapHistory_AssumeEnabled(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCGlobalHeapHistory, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms)
#define FireEtXplatGCGlobalHeapHistory_ForContext(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGlobalHeapHistory) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory(&(pContext)->Context, &GCGlobalHeapHistory, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms) : 0
#define FireEtXplatGCGlobalHeapHistory_ForContextAssumeEnabled(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCGlobalHeapHistory, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory _mcgen_PASTE2(McTemplateCoU0xdqqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGlobalHeapHistory_V1"
//
#define EventXplatEnabledGCGlobalHeapHistory_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCGlobalHeapHistory_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCGlobalHeapHistory_V1"
//
#define FireEtXplatGCGlobalHeapHistory_V1(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCGlobalHeapHistory_V1) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCGlobalHeapHistory_V1, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID) : 0
#define FireEtXplatGCGlobalHeapHistory_V1_AssumeEnabled(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCGlobalHeapHistory_V1, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID)
#define FireEtXplatGCGlobalHeapHistory_V1_ForContext(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGlobalHeapHistory_V1) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V1(&(pContext)->Context, &GCGlobalHeapHistory_V1, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID) : 0
#define FireEtXplatGCGlobalHeapHistory_V1_ForContextAssumeEnabled(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCGlobalHeapHistory_V1, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V1 _mcgen_PASTE2(McTemplateCoU0xdqqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCJoin"
//
#define EventXplatEnabledGCJoin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 1)
#define EventXplatEnabledGCJoin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 1)

//
// Event write macros for event "GCJoin"
//
#define FireEtXplatGCJoin(Heap, JoinTime, JoinType) \
        MCGEN_EVENT_ENABLED(GCJoin) \
        ? _mcgen_TEMPLATE_FOR_GCJoin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCJoin, Heap, JoinTime, JoinType) : 0
#define FireEtXplatGCJoin_AssumeEnabled(Heap, JoinTime, JoinType) \
        _mcgen_TEMPLATE_FOR_GCJoin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCJoin, Heap, JoinTime, JoinType)
#define FireEtXplatGCJoin_ForContext(pContext, Heap, JoinTime, JoinType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCJoin) \
        ? _mcgen_TEMPLATE_FOR_GCJoin(&(pContext)->Context, &GCJoin, Heap, JoinTime, JoinType) : 0
#define FireEtXplatGCJoin_ForContextAssumeEnabled(pContext, Heap, JoinTime, JoinType) \
        _mcgen_TEMPLATE_FOR_GCJoin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCJoin, Heap, JoinTime, JoinType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCJoin _mcgen_PASTE2(McTemplateCoU0qqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCJoin_V1"
//
#define EventXplatEnabledGCJoin_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 1)
#define EventXplatEnabledGCJoin_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 1)

//
// Event write macros for event "GCJoin_V1"
//
#define FireEtXplatGCJoin_V1(Heap, JoinTime, JoinType, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCJoin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCJoin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCJoin_V1, Heap, JoinTime, JoinType, ClrInstanceID) : 0
#define FireEtXplatGCJoin_V1_AssumeEnabled(Heap, JoinTime, JoinType, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCJoin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCJoin_V1, Heap, JoinTime, JoinType, ClrInstanceID)
#define FireEtXplatGCJoin_V1_ForContext(pContext, Heap, JoinTime, JoinType, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCJoin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCJoin_V1(&(pContext)->Context, &GCJoin_V1, Heap, JoinTime, JoinType, ClrInstanceID) : 0
#define FireEtXplatGCJoin_V1_ForContextAssumeEnabled(pContext, Heap, JoinTime, JoinType, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCJoin_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCJoin_V1, Heap, JoinTime, JoinType, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCJoin_V1 _mcgen_PASTE2(McTemplateCoU0qqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkStackRoots"
//
#define EventXplatEnabledPrvGCMarkStackRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkStackRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkStackRoots"
//
#define FireEtXplatPrvGCMarkStackRoots(HeapNum) \
        MCGEN_EVENT_ENABLED(PrvGCMarkStackRoots) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkStackRoots, HeapNum) : 0
#define FireEtXplatPrvGCMarkStackRoots_AssumeEnabled(HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkStackRoots, HeapNum)
#define FireEtXplatPrvGCMarkStackRoots_ForContext(pContext, HeapNum) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkStackRoots) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots(&(pContext)->Context, &PrvGCMarkStackRoots, HeapNum) : 0
#define FireEtXplatPrvGCMarkStackRoots_ForContextAssumeEnabled(pContext, HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkStackRoots, HeapNum)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots _mcgen_PASTE2(McTemplateCoU0q_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkStackRoots_V1"
//
#define EventXplatEnabledPrvGCMarkStackRoots_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkStackRoots_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkStackRoots_V1"
//
#define FireEtXplatPrvGCMarkStackRoots_V1(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrvGCMarkStackRoots_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkStackRoots_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkStackRoots_V1_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkStackRoots_V1, HeapNum, ClrInstanceID)
#define FireEtXplatPrvGCMarkStackRoots_V1_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkStackRoots_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots_V1(&(pContext)->Context, &PrvGCMarkStackRoots_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkStackRoots_V1_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkStackRoots_V1, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkStackRoots_V1 _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkFinalizeQueueRoots"
//
#define EventXplatEnabledPrvGCMarkFinalizeQueueRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkFinalizeQueueRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkFinalizeQueueRoots"
//
#define FireEtXplatPrvGCMarkFinalizeQueueRoots(HeapNum) \
        MCGEN_EVENT_ENABLED(PrvGCMarkFinalizeQueueRoots) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkFinalizeQueueRoots, HeapNum) : 0
#define FireEtXplatPrvGCMarkFinalizeQueueRoots_AssumeEnabled(HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkFinalizeQueueRoots, HeapNum)
#define FireEtXplatPrvGCMarkFinalizeQueueRoots_ForContext(pContext, HeapNum) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkFinalizeQueueRoots) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots(&(pContext)->Context, &PrvGCMarkFinalizeQueueRoots, HeapNum) : 0
#define FireEtXplatPrvGCMarkFinalizeQueueRoots_ForContextAssumeEnabled(pContext, HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkFinalizeQueueRoots, HeapNum)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots _mcgen_PASTE2(McTemplateCoU0q_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkFinalizeQueueRoots_V1"
//
#define EventXplatEnabledPrvGCMarkFinalizeQueueRoots_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkFinalizeQueueRoots_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkFinalizeQueueRoots_V1"
//
#define FireEtXplatPrvGCMarkFinalizeQueueRoots_V1(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrvGCMarkFinalizeQueueRoots_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkFinalizeQueueRoots_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkFinalizeQueueRoots_V1_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkFinalizeQueueRoots_V1, HeapNum, ClrInstanceID)
#define FireEtXplatPrvGCMarkFinalizeQueueRoots_V1_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkFinalizeQueueRoots_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots_V1(&(pContext)->Context, &PrvGCMarkFinalizeQueueRoots_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkFinalizeQueueRoots_V1_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkFinalizeQueueRoots_V1, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkFinalizeQueueRoots_V1 _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkHandles"
//
#define EventXplatEnabledPrvGCMarkHandles() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkHandles_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkHandles"
//
#define FireEtXplatPrvGCMarkHandles(HeapNum) \
        MCGEN_EVENT_ENABLED(PrvGCMarkHandles) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkHandles(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkHandles, HeapNum) : 0
#define FireEtXplatPrvGCMarkHandles_AssumeEnabled(HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkHandles(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkHandles, HeapNum)
#define FireEtXplatPrvGCMarkHandles_ForContext(pContext, HeapNum) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkHandles) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkHandles(&(pContext)->Context, &PrvGCMarkHandles, HeapNum) : 0
#define FireEtXplatPrvGCMarkHandles_ForContextAssumeEnabled(pContext, HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkHandles(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkHandles, HeapNum)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkHandles _mcgen_PASTE2(McTemplateCoU0q_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkHandles_V1"
//
#define EventXplatEnabledPrvGCMarkHandles_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkHandles_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkHandles_V1"
//
#define FireEtXplatPrvGCMarkHandles_V1(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrvGCMarkHandles_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkHandles_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkHandles_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkHandles_V1_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkHandles_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkHandles_V1, HeapNum, ClrInstanceID)
#define FireEtXplatPrvGCMarkHandles_V1_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkHandles_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkHandles_V1(&(pContext)->Context, &PrvGCMarkHandles_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkHandles_V1_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkHandles_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkHandles_V1, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkHandles_V1 _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkCards"
//
#define EventXplatEnabledPrvGCMarkCards() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkCards_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkCards"
//
#define FireEtXplatPrvGCMarkCards(HeapNum) \
        MCGEN_EVENT_ENABLED(PrvGCMarkCards) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkCards(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkCards, HeapNum) : 0
#define FireEtXplatPrvGCMarkCards_AssumeEnabled(HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkCards(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkCards, HeapNum)
#define FireEtXplatPrvGCMarkCards_ForContext(pContext, HeapNum) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkCards) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkCards(&(pContext)->Context, &PrvGCMarkCards, HeapNum) : 0
#define FireEtXplatPrvGCMarkCards_ForContextAssumeEnabled(pContext, HeapNum) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkCards(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkCards, HeapNum)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkCards _mcgen_PASTE2(McTemplateCoU0q_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvGCMarkCards_V1"
//
#define EventXplatEnabledPrvGCMarkCards_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledPrvGCMarkCards_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "PrvGCMarkCards_V1"
//
#define FireEtXplatPrvGCMarkCards_V1(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrvGCMarkCards_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkCards_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkCards_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkCards_V1_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkCards_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvGCMarkCards_V1, HeapNum, ClrInstanceID)
#define FireEtXplatPrvGCMarkCards_V1_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvGCMarkCards_V1) \
        ? _mcgen_TEMPLATE_FOR_PrvGCMarkCards_V1(&(pContext)->Context, &PrvGCMarkCards_V1, HeapNum, ClrInstanceID) : 0
#define FireEtXplatPrvGCMarkCards_V1_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvGCMarkCards_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvGCMarkCards_V1, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvGCMarkCards_V1 _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCBegin"
//
#define EventXplatEnabledBGCBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCBegin"
//
#define FireEtXplatBGCBegin(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCBegin) \
        ? _mcgen_TEMPLATE_FOR_BGCBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCBegin, ClrInstanceID) : 0
#define FireEtXplatBGCBegin_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCBegin, ClrInstanceID)
#define FireEtXplatBGCBegin_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCBegin) \
        ? _mcgen_TEMPLATE_FOR_BGCBegin(&(pContext)->Context, &BGCBegin, ClrInstanceID) : 0
#define FireEtXplatBGCBegin_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCBegin, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCBegin _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGC1stNonConEnd"
//
#define EventXplatEnabledBGC1stNonConEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGC1stNonConEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGC1stNonConEnd"
//
#define FireEtXplatBGC1stNonConEnd(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGC1stNonConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC1stNonConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC1stNonConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC1stNonConEnd_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC1stNonConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC1stNonConEnd, ClrInstanceID)
#define FireEtXplatBGC1stNonConEnd_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGC1stNonConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC1stNonConEnd(&(pContext)->Context, &BGC1stNonConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC1stNonConEnd_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC1stNonConEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGC1stNonConEnd, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGC1stNonConEnd _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGC1stConEnd"
//
#define EventXplatEnabledBGC1stConEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGC1stConEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGC1stConEnd"
//
#define FireEtXplatBGC1stConEnd(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGC1stConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC1stConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC1stConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC1stConEnd_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC1stConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC1stConEnd, ClrInstanceID)
#define FireEtXplatBGC1stConEnd_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGC1stConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC1stConEnd(&(pContext)->Context, &BGC1stConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC1stConEnd_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC1stConEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGC1stConEnd, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGC1stConEnd _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGC2ndNonConBegin"
//
#define EventXplatEnabledBGC2ndNonConBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGC2ndNonConBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGC2ndNonConBegin"
//
#define FireEtXplatBGC2ndNonConBegin(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGC2ndNonConBegin) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndNonConBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndNonConBegin, ClrInstanceID) : 0
#define FireEtXplatBGC2ndNonConBegin_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndNonConBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndNonConBegin, ClrInstanceID)
#define FireEtXplatBGC2ndNonConBegin_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGC2ndNonConBegin) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndNonConBegin(&(pContext)->Context, &BGC2ndNonConBegin, ClrInstanceID) : 0
#define FireEtXplatBGC2ndNonConBegin_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndNonConBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGC2ndNonConBegin, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGC2ndNonConBegin _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGC2ndNonConEnd"
//
#define EventXplatEnabledBGC2ndNonConEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGC2ndNonConEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGC2ndNonConEnd"
//
#define FireEtXplatBGC2ndNonConEnd(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGC2ndNonConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndNonConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndNonConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC2ndNonConEnd_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndNonConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndNonConEnd, ClrInstanceID)
#define FireEtXplatBGC2ndNonConEnd_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGC2ndNonConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndNonConEnd(&(pContext)->Context, &BGC2ndNonConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC2ndNonConEnd_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndNonConEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGC2ndNonConEnd, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGC2ndNonConEnd _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGC2ndConBegin"
//
#define EventXplatEnabledBGC2ndConBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGC2ndConBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGC2ndConBegin"
//
#define FireEtXplatBGC2ndConBegin(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGC2ndConBegin) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndConBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndConBegin, ClrInstanceID) : 0
#define FireEtXplatBGC2ndConBegin_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndConBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndConBegin, ClrInstanceID)
#define FireEtXplatBGC2ndConBegin_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGC2ndConBegin) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndConBegin(&(pContext)->Context, &BGC2ndConBegin, ClrInstanceID) : 0
#define FireEtXplatBGC2ndConBegin_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndConBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGC2ndConBegin, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGC2ndConBegin _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGC2ndConEnd"
//
#define EventXplatEnabledBGC2ndConEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGC2ndConEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGC2ndConEnd"
//
#define FireEtXplatBGC2ndConEnd(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGC2ndConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC2ndConEnd_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndConEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC2ndConEnd, ClrInstanceID)
#define FireEtXplatBGC2ndConEnd_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGC2ndConEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC2ndConEnd(&(pContext)->Context, &BGC2ndConEnd, ClrInstanceID) : 0
#define FireEtXplatBGC2ndConEnd_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC2ndConEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGC2ndConEnd, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGC2ndConEnd _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCPlanEnd"
//
#define EventXplatEnabledBGCPlanEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCPlanEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCPlanEnd"
//
#define FireEtXplatBGCPlanEnd(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCPlanEnd) \
        ? _mcgen_TEMPLATE_FOR_BGCPlanEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCPlanEnd, ClrInstanceID) : 0
#define FireEtXplatBGCPlanEnd_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCPlanEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCPlanEnd, ClrInstanceID)
#define FireEtXplatBGCPlanEnd_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCPlanEnd) \
        ? _mcgen_TEMPLATE_FOR_BGCPlanEnd(&(pContext)->Context, &BGCPlanEnd, ClrInstanceID) : 0
#define FireEtXplatBGCPlanEnd_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCPlanEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCPlanEnd, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCPlanEnd _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCSweepEnd"
//
#define EventXplatEnabledBGCSweepEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCSweepEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCSweepEnd"
//
#define FireEtXplatBGCSweepEnd(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCSweepEnd) \
        ? _mcgen_TEMPLATE_FOR_BGCSweepEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCSweepEnd, ClrInstanceID) : 0
#define FireEtXplatBGCSweepEnd_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCSweepEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCSweepEnd, ClrInstanceID)
#define FireEtXplatBGCSweepEnd_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCSweepEnd) \
        ? _mcgen_TEMPLATE_FOR_BGCSweepEnd(&(pContext)->Context, &BGCSweepEnd, ClrInstanceID) : 0
#define FireEtXplatBGCSweepEnd_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCSweepEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCSweepEnd, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCSweepEnd _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCDrainMark"
//
#define EventXplatEnabledBGCDrainMark() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCDrainMark_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCDrainMark"
//
#define FireEtXplatBGCDrainMark(Objects, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCDrainMark) \
        ? _mcgen_TEMPLATE_FOR_BGCDrainMark(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCDrainMark, Objects, ClrInstanceID) : 0
#define FireEtXplatBGCDrainMark_AssumeEnabled(Objects, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCDrainMark(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCDrainMark, Objects, ClrInstanceID)
#define FireEtXplatBGCDrainMark_ForContext(pContext, Objects, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCDrainMark) \
        ? _mcgen_TEMPLATE_FOR_BGCDrainMark(&(pContext)->Context, &BGCDrainMark, Objects, ClrInstanceID) : 0
#define FireEtXplatBGCDrainMark_ForContextAssumeEnabled(pContext, Objects, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCDrainMark(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCDrainMark, Objects, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCDrainMark _mcgen_PASTE2(McTemplateCoU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCRevisit"
//
#define EventXplatEnabledBGCRevisit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCRevisit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCRevisit"
//
#define FireEtXplatBGCRevisit(Pages, Objects, IsLarge, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCRevisit) \
        ? _mcgen_TEMPLATE_FOR_BGCRevisit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCRevisit, Pages, Objects, IsLarge, ClrInstanceID) : 0
#define FireEtXplatBGCRevisit_AssumeEnabled(Pages, Objects, IsLarge, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCRevisit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCRevisit, Pages, Objects, IsLarge, ClrInstanceID)
#define FireEtXplatBGCRevisit_ForContext(pContext, Pages, Objects, IsLarge, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCRevisit) \
        ? _mcgen_TEMPLATE_FOR_BGCRevisit(&(pContext)->Context, &BGCRevisit, Pages, Objects, IsLarge, ClrInstanceID) : 0
#define FireEtXplatBGCRevisit_ForContextAssumeEnabled(pContext, Pages, Objects, IsLarge, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCRevisit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCRevisit, Pages, Objects, IsLarge, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCRevisit _mcgen_PASTE2(McTemplateCoU0xxqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCOverflow"
//
#define EventXplatEnabledBGCOverflow() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCOverflow_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCOverflow"
//
#define FireEtXplatBGCOverflow(Min, Max, Objects, IsLarge, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCOverflow) \
        ? _mcgen_TEMPLATE_FOR_BGCOverflow(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCOverflow, Min, Max, Objects, IsLarge, ClrInstanceID) : 0
#define FireEtXplatBGCOverflow_AssumeEnabled(Min, Max, Objects, IsLarge, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCOverflow(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCOverflow, Min, Max, Objects, IsLarge, ClrInstanceID)
#define FireEtXplatBGCOverflow_ForContext(pContext, Min, Max, Objects, IsLarge, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCOverflow) \
        ? _mcgen_TEMPLATE_FOR_BGCOverflow(&(pContext)->Context, &BGCOverflow, Min, Max, Objects, IsLarge, ClrInstanceID) : 0
#define FireEtXplatBGCOverflow_ForContextAssumeEnabled(pContext, Min, Max, Objects, IsLarge, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCOverflow(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCOverflow, Min, Max, Objects, IsLarge, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCOverflow _mcgen_PASTE2(McTemplateCoU0xxxqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCOverflow_V1"
//
#define EventXplatEnabledBGCOverflow_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCOverflow_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCOverflow_V1"
//
#define FireEtXplatBGCOverflow_V1(Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber) \
        MCGEN_EVENT_ENABLED(BGCOverflow_V1) \
        ? _mcgen_TEMPLATE_FOR_BGCOverflow_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCOverflow_V1, Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber) : 0
#define FireEtXplatBGCOverflow_V1_AssumeEnabled(Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber) \
        _mcgen_TEMPLATE_FOR_BGCOverflow_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCOverflow_V1, Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber)
#define FireEtXplatBGCOverflow_V1_ForContext(pContext, Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCOverflow_V1) \
        ? _mcgen_TEMPLATE_FOR_BGCOverflow_V1(&(pContext)->Context, &BGCOverflow_V1, Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber) : 0
#define FireEtXplatBGCOverflow_V1_ForContextAssumeEnabled(pContext, Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber) \
        _mcgen_TEMPLATE_FOR_BGCOverflow_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCOverflow_V1, Min, Max, Objects, IsLarge, ClrInstanceID, GenNumber)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCOverflow_V1 _mcgen_PASTE2(McTemplateCoU0xxxqhq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCAllocWaitBegin"
//
#define EventXplatEnabledBGCAllocWaitBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCAllocWaitBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCAllocWaitBegin"
//
#define FireEtXplatBGCAllocWaitBegin(Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCAllocWaitBegin) \
        ? _mcgen_TEMPLATE_FOR_BGCAllocWaitBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCAllocWaitBegin, Reason, ClrInstanceID) : 0
#define FireEtXplatBGCAllocWaitBegin_AssumeEnabled(Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCAllocWaitBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCAllocWaitBegin, Reason, ClrInstanceID)
#define FireEtXplatBGCAllocWaitBegin_ForContext(pContext, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCAllocWaitBegin) \
        ? _mcgen_TEMPLATE_FOR_BGCAllocWaitBegin(&(pContext)->Context, &BGCAllocWaitBegin, Reason, ClrInstanceID) : 0
#define FireEtXplatBGCAllocWaitBegin_ForContextAssumeEnabled(pContext, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCAllocWaitBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCAllocWaitBegin, Reason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCAllocWaitBegin _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGCAllocWaitEnd"
//
#define EventXplatEnabledBGCAllocWaitEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGCAllocWaitEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGCAllocWaitEnd"
//
#define FireEtXplatBGCAllocWaitEnd(Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGCAllocWaitEnd) \
        ? _mcgen_TEMPLATE_FOR_BGCAllocWaitEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCAllocWaitEnd, Reason, ClrInstanceID) : 0
#define FireEtXplatBGCAllocWaitEnd_AssumeEnabled(Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCAllocWaitEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGCAllocWaitEnd, Reason, ClrInstanceID)
#define FireEtXplatBGCAllocWaitEnd_ForContext(pContext, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGCAllocWaitEnd) \
        ? _mcgen_TEMPLATE_FOR_BGCAllocWaitEnd(&(pContext)->Context, &BGCAllocWaitEnd, Reason, ClrInstanceID) : 0
#define FireEtXplatBGCAllocWaitEnd_ForContextAssumeEnabled(pContext, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGCAllocWaitEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGCAllocWaitEnd, Reason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGCAllocWaitEnd _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFullNotify"
//
#define EventXplatEnabledGCFullNotify() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCFullNotify_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFullNotify"
//
#define FireEtXplatGCFullNotify(GenNumber, IsAlloc) \
        MCGEN_EVENT_ENABLED(GCFullNotify) \
        ? _mcgen_TEMPLATE_FOR_GCFullNotify(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCFullNotify, GenNumber, IsAlloc) : 0
#define FireEtXplatGCFullNotify_AssumeEnabled(GenNumber, IsAlloc) \
        _mcgen_TEMPLATE_FOR_GCFullNotify(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCFullNotify, GenNumber, IsAlloc)
#define FireEtXplatGCFullNotify_ForContext(pContext, GenNumber, IsAlloc) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFullNotify) \
        ? _mcgen_TEMPLATE_FOR_GCFullNotify(&(pContext)->Context, &GCFullNotify, GenNumber, IsAlloc) : 0
#define FireEtXplatGCFullNotify_ForContextAssumeEnabled(pContext, GenNumber, IsAlloc) \
        _mcgen_TEMPLATE_FOR_GCFullNotify(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCFullNotify, GenNumber, IsAlloc)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFullNotify _mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFullNotify_V1"
//
#define EventXplatEnabledGCFullNotify_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledGCFullNotify_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFullNotify_V1"
//
#define FireEtXplatGCFullNotify_V1(GenNumber, IsAlloc, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCFullNotify_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFullNotify_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCFullNotify_V1, GenNumber, IsAlloc, ClrInstanceID) : 0
#define FireEtXplatGCFullNotify_V1_AssumeEnabled(GenNumber, IsAlloc, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFullNotify_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GCFullNotify_V1, GenNumber, IsAlloc, ClrInstanceID)
#define FireEtXplatGCFullNotify_V1_ForContext(pContext, GenNumber, IsAlloc, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFullNotify_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFullNotify_V1(&(pContext)->Context, &GCFullNotify_V1, GenNumber, IsAlloc, ClrInstanceID) : 0
#define FireEtXplatGCFullNotify_V1_ForContextAssumeEnabled(pContext, GenNumber, IsAlloc, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFullNotify_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GCFullNotify_V1, GenNumber, IsAlloc, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFullNotify_V1 _mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BGC1stSweepEnd"
//
#define EventXplatEnabledBGC1stSweepEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 0)
#define EventXplatEnabledBGC1stSweepEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 0)

//
// Event write macros for event "BGC1stSweepEnd"
//
#define FireEtXplatBGC1stSweepEnd(GenNumber, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BGC1stSweepEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC1stSweepEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC1stSweepEnd, GenNumber, ClrInstanceID) : 0
#define FireEtXplatBGC1stSweepEnd_AssumeEnabled(GenNumber, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC1stSweepEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BGC1stSweepEnd, GenNumber, ClrInstanceID)
#define FireEtXplatBGC1stSweepEnd_ForContext(pContext, GenNumber, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BGC1stSweepEnd) \
        ? _mcgen_TEMPLATE_FOR_BGC1stSweepEnd(&(pContext)->Context, &BGC1stSweepEnd, GenNumber, ClrInstanceID) : 0
#define FireEtXplatBGC1stSweepEnd_ForContextAssumeEnabled(pContext, GenNumber, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BGC1stSweepEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BGC1stSweepEnd, GenNumber, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BGC1stSweepEnd _mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEStartupStart"
//
#define EventXplatEnabledEEStartupStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEStartupStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEStartupStart"
//
#define FireEtXplatEEStartupStart() \
        MCGEN_EVENT_ENABLED(EEStartupStart) \
        ? _mcgen_TEMPLATE_FOR_EEStartupStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupStart) : 0
#define FireEtXplatEEStartupStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_EEStartupStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupStart)
#define FireEtXplatEEStartupStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEStartupStart) \
        ? _mcgen_TEMPLATE_FOR_EEStartupStart(&(pContext)->Context, &EEStartupStart) : 0
#define FireEtXplatEEStartupStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_EEStartupStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEStartupStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEStartupStart _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEStartupStart_V1"
//
#define EventXplatEnabledEEStartupStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEStartupStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEStartupStart_V1"
//
#define FireEtXplatEEStartupStart_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EEStartupStart_V1) \
        ? _mcgen_TEMPLATE_FOR_EEStartupStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupStart_V1, ClrInstanceID) : 0
#define FireEtXplatEEStartupStart_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEStartupStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupStart_V1, ClrInstanceID)
#define FireEtXplatEEStartupStart_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEStartupStart_V1) \
        ? _mcgen_TEMPLATE_FOR_EEStartupStart_V1(&(pContext)->Context, &EEStartupStart_V1, ClrInstanceID) : 0
#define FireEtXplatEEStartupStart_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEStartupStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEStartupStart_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEStartupStart_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEStartupEnd"
//
#define EventXplatEnabledEEStartupEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEStartupEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEStartupEnd"
//
#define FireEtXplatEEStartupEnd() \
        MCGEN_EVENT_ENABLED(EEStartupEnd) \
        ? _mcgen_TEMPLATE_FOR_EEStartupEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupEnd) : 0
#define FireEtXplatEEStartupEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_EEStartupEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupEnd)
#define FireEtXplatEEStartupEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEStartupEnd) \
        ? _mcgen_TEMPLATE_FOR_EEStartupEnd(&(pContext)->Context, &EEStartupEnd) : 0
#define FireEtXplatEEStartupEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_EEStartupEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEStartupEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEStartupEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEStartupEnd_V1"
//
#define EventXplatEnabledEEStartupEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEStartupEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEStartupEnd_V1"
//
#define FireEtXplatEEStartupEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EEStartupEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_EEStartupEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupEnd_V1, ClrInstanceID) : 0
#define FireEtXplatEEStartupEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEStartupEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEStartupEnd_V1, ClrInstanceID)
#define FireEtXplatEEStartupEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEStartupEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_EEStartupEnd_V1(&(pContext)->Context, &EEStartupEnd_V1, ClrInstanceID) : 0
#define FireEtXplatEEStartupEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEStartupEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEStartupEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEStartupEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSetup"
//
#define EventXplatEnabledEEConfigSetup() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSetup_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSetup"
//
#define FireEtXplatEEConfigSetup() \
        MCGEN_EVENT_ENABLED(EEConfigSetup) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetup(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetup) : 0
#define FireEtXplatEEConfigSetup_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_EEConfigSetup(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetup)
#define FireEtXplatEEConfigSetup_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSetup) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetup(&(pContext)->Context, &EEConfigSetup) : 0
#define FireEtXplatEEConfigSetup_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_EEConfigSetup(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSetup)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSetup _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSetup_V1"
//
#define EventXplatEnabledEEConfigSetup_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSetup_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSetup_V1"
//
#define FireEtXplatEEConfigSetup_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EEConfigSetup_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetup_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetup_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSetup_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSetup_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetup_V1, ClrInstanceID)
#define FireEtXplatEEConfigSetup_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSetup_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetup_V1(&(pContext)->Context, &EEConfigSetup_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSetup_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSetup_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSetup_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSetup_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSetupEnd"
//
#define EventXplatEnabledEEConfigSetupEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSetupEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSetupEnd"
//
#define FireEtXplatEEConfigSetupEnd() \
        MCGEN_EVENT_ENABLED(EEConfigSetupEnd) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetupEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetupEnd) : 0
#define FireEtXplatEEConfigSetupEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_EEConfigSetupEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetupEnd)
#define FireEtXplatEEConfigSetupEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSetupEnd) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetupEnd(&(pContext)->Context, &EEConfigSetupEnd) : 0
#define FireEtXplatEEConfigSetupEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_EEConfigSetupEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSetupEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSetupEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSetupEnd_V1"
//
#define EventXplatEnabledEEConfigSetupEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSetupEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSetupEnd_V1"
//
#define FireEtXplatEEConfigSetupEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EEConfigSetupEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetupEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetupEnd_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSetupEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSetupEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSetupEnd_V1, ClrInstanceID)
#define FireEtXplatEEConfigSetupEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSetupEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSetupEnd_V1(&(pContext)->Context, &EEConfigSetupEnd_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSetupEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSetupEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSetupEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSetupEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdSysBases"
//
#define EventXplatEnabledLdSysBases() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdSysBases_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdSysBases"
//
#define FireEtXplatLdSysBases() \
        MCGEN_EVENT_ENABLED(LdSysBases) \
        ? _mcgen_TEMPLATE_FOR_LdSysBases(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBases) : 0
#define FireEtXplatLdSysBases_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_LdSysBases(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBases)
#define FireEtXplatLdSysBases_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdSysBases) \
        ? _mcgen_TEMPLATE_FOR_LdSysBases(&(pContext)->Context, &LdSysBases) : 0
#define FireEtXplatLdSysBases_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_LdSysBases(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdSysBases)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdSysBases _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdSysBases_V1"
//
#define EventXplatEnabledLdSysBases_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdSysBases_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdSysBases_V1"
//
#define FireEtXplatLdSysBases_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LdSysBases_V1) \
        ? _mcgen_TEMPLATE_FOR_LdSysBases_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBases_V1, ClrInstanceID) : 0
#define FireEtXplatLdSysBases_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdSysBases_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBases_V1, ClrInstanceID)
#define FireEtXplatLdSysBases_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdSysBases_V1) \
        ? _mcgen_TEMPLATE_FOR_LdSysBases_V1(&(pContext)->Context, &LdSysBases_V1, ClrInstanceID) : 0
#define FireEtXplatLdSysBases_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdSysBases_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdSysBases_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdSysBases_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdSysBasesEnd"
//
#define EventXplatEnabledLdSysBasesEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdSysBasesEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdSysBasesEnd"
//
#define FireEtXplatLdSysBasesEnd() \
        MCGEN_EVENT_ENABLED(LdSysBasesEnd) \
        ? _mcgen_TEMPLATE_FOR_LdSysBasesEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBasesEnd) : 0
#define FireEtXplatLdSysBasesEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_LdSysBasesEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBasesEnd)
#define FireEtXplatLdSysBasesEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdSysBasesEnd) \
        ? _mcgen_TEMPLATE_FOR_LdSysBasesEnd(&(pContext)->Context, &LdSysBasesEnd) : 0
#define FireEtXplatLdSysBasesEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_LdSysBasesEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdSysBasesEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdSysBasesEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdSysBasesEnd_V1"
//
#define EventXplatEnabledLdSysBasesEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdSysBasesEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdSysBasesEnd_V1"
//
#define FireEtXplatLdSysBasesEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LdSysBasesEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_LdSysBasesEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBasesEnd_V1, ClrInstanceID) : 0
#define FireEtXplatLdSysBasesEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdSysBasesEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdSysBasesEnd_V1, ClrInstanceID)
#define FireEtXplatLdSysBasesEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdSysBasesEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_LdSysBasesEnd_V1(&(pContext)->Context, &LdSysBasesEnd_V1, ClrInstanceID) : 0
#define FireEtXplatLdSysBasesEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdSysBasesEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdSysBasesEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdSysBasesEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExecExe"
//
#define EventXplatEnabledExecExe() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExecExe_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExecExe"
//
#define FireEtXplatExecExe() \
        MCGEN_EVENT_ENABLED(ExecExe) \
        ? _mcgen_TEMPLATE_FOR_ExecExe(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExe) : 0
#define FireEtXplatExecExe_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExecExe(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExe)
#define FireEtXplatExecExe_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExecExe) \
        ? _mcgen_TEMPLATE_FOR_ExecExe(&(pContext)->Context, &ExecExe) : 0
#define FireEtXplatExecExe_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExecExe(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExecExe)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExecExe _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExecExe_V1"
//
#define EventXplatEnabledExecExe_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExecExe_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExecExe_V1"
//
#define FireEtXplatExecExe_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExecExe_V1) \
        ? _mcgen_TEMPLATE_FOR_ExecExe_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExe_V1, ClrInstanceID) : 0
#define FireEtXplatExecExe_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExecExe_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExe_V1, ClrInstanceID)
#define FireEtXplatExecExe_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExecExe_V1) \
        ? _mcgen_TEMPLATE_FOR_ExecExe_V1(&(pContext)->Context, &ExecExe_V1, ClrInstanceID) : 0
#define FireEtXplatExecExe_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExecExe_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExecExe_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExecExe_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExecExeEnd"
//
#define EventXplatEnabledExecExeEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExecExeEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExecExeEnd"
//
#define FireEtXplatExecExeEnd() \
        MCGEN_EVENT_ENABLED(ExecExeEnd) \
        ? _mcgen_TEMPLATE_FOR_ExecExeEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExeEnd) : 0
#define FireEtXplatExecExeEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExecExeEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExeEnd)
#define FireEtXplatExecExeEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExecExeEnd) \
        ? _mcgen_TEMPLATE_FOR_ExecExeEnd(&(pContext)->Context, &ExecExeEnd) : 0
#define FireEtXplatExecExeEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExecExeEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExecExeEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExecExeEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExecExeEnd_V1"
//
#define EventXplatEnabledExecExeEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExecExeEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExecExeEnd_V1"
//
#define FireEtXplatExecExeEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExecExeEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ExecExeEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExeEnd_V1, ClrInstanceID) : 0
#define FireEtXplatExecExeEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExecExeEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExecExeEnd_V1, ClrInstanceID)
#define FireEtXplatExecExeEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExecExeEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ExecExeEnd_V1(&(pContext)->Context, &ExecExeEnd_V1, ClrInstanceID) : 0
#define FireEtXplatExecExeEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExecExeEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExecExeEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExecExeEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Main"
//
#define EventXplatEnabledMain() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledMain_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "Main"
//
#define FireEtXplatMain() \
        MCGEN_EVENT_ENABLED(Main) \
        ? _mcgen_TEMPLATE_FOR_Main(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Main) : 0
#define FireEtXplatMain_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_Main(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Main)
#define FireEtXplatMain_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Main) \
        ? _mcgen_TEMPLATE_FOR_Main(&(pContext)->Context, &Main) : 0
#define FireEtXplatMain_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_Main(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &Main)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Main _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Main_V1"
//
#define EventXplatEnabledMain_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledMain_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "Main_V1"
//
#define FireEtXplatMain_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(Main_V1) \
        ? _mcgen_TEMPLATE_FOR_Main_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Main_V1, ClrInstanceID) : 0
#define FireEtXplatMain_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_Main_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Main_V1, ClrInstanceID)
#define FireEtXplatMain_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Main_V1) \
        ? _mcgen_TEMPLATE_FOR_Main_V1(&(pContext)->Context, &Main_V1, ClrInstanceID) : 0
#define FireEtXplatMain_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_Main_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &Main_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Main_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MainEnd"
//
#define EventXplatEnabledMainEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledMainEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "MainEnd"
//
#define FireEtXplatMainEnd() \
        MCGEN_EVENT_ENABLED(MainEnd) \
        ? _mcgen_TEMPLATE_FOR_MainEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MainEnd) : 0
#define FireEtXplatMainEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_MainEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MainEnd)
#define FireEtXplatMainEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MainEnd) \
        ? _mcgen_TEMPLATE_FOR_MainEnd(&(pContext)->Context, &MainEnd) : 0
#define FireEtXplatMainEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_MainEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &MainEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MainEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MainEnd_V1"
//
#define EventXplatEnabledMainEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledMainEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "MainEnd_V1"
//
#define FireEtXplatMainEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MainEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_MainEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MainEnd_V1, ClrInstanceID) : 0
#define FireEtXplatMainEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MainEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MainEnd_V1, ClrInstanceID)
#define FireEtXplatMainEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MainEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_MainEnd_V1(&(pContext)->Context, &MainEnd_V1, ClrInstanceID) : 0
#define FireEtXplatMainEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MainEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &MainEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MainEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ApplyPolicyStart"
//
#define EventXplatEnabledApplyPolicyStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledApplyPolicyStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ApplyPolicyStart"
//
#define FireEtXplatApplyPolicyStart() \
        MCGEN_EVENT_ENABLED(ApplyPolicyStart) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyStart) : 0
#define FireEtXplatApplyPolicyStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ApplyPolicyStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyStart)
#define FireEtXplatApplyPolicyStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ApplyPolicyStart) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyStart(&(pContext)->Context, &ApplyPolicyStart) : 0
#define FireEtXplatApplyPolicyStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ApplyPolicyStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ApplyPolicyStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ApplyPolicyStart _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ApplyPolicyStart_V1"
//
#define EventXplatEnabledApplyPolicyStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledApplyPolicyStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ApplyPolicyStart_V1"
//
#define FireEtXplatApplyPolicyStart_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ApplyPolicyStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyStart_V1, ClrInstanceID) : 0
#define FireEtXplatApplyPolicyStart_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ApplyPolicyStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyStart_V1, ClrInstanceID)
#define FireEtXplatApplyPolicyStart_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ApplyPolicyStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyStart_V1(&(pContext)->Context, &ApplyPolicyStart_V1, ClrInstanceID) : 0
#define FireEtXplatApplyPolicyStart_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ApplyPolicyStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ApplyPolicyStart_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ApplyPolicyStart_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ApplyPolicyEnd"
//
#define EventXplatEnabledApplyPolicyEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledApplyPolicyEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ApplyPolicyEnd"
//
#define FireEtXplatApplyPolicyEnd() \
        MCGEN_EVENT_ENABLED(ApplyPolicyEnd) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyEnd) : 0
#define FireEtXplatApplyPolicyEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ApplyPolicyEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyEnd)
#define FireEtXplatApplyPolicyEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ApplyPolicyEnd) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyEnd(&(pContext)->Context, &ApplyPolicyEnd) : 0
#define FireEtXplatApplyPolicyEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ApplyPolicyEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ApplyPolicyEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ApplyPolicyEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ApplyPolicyEnd_V1"
//
#define EventXplatEnabledApplyPolicyEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledApplyPolicyEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ApplyPolicyEnd_V1"
//
#define FireEtXplatApplyPolicyEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ApplyPolicyEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyEnd_V1, ClrInstanceID) : 0
#define FireEtXplatApplyPolicyEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ApplyPolicyEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ApplyPolicyEnd_V1, ClrInstanceID)
#define FireEtXplatApplyPolicyEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ApplyPolicyEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ApplyPolicyEnd_V1(&(pContext)->Context, &ApplyPolicyEnd_V1, ClrInstanceID) : 0
#define FireEtXplatApplyPolicyEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ApplyPolicyEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ApplyPolicyEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ApplyPolicyEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdLibShFolder"
//
#define EventXplatEnabledLdLibShFolder() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdLibShFolder_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdLibShFolder"
//
#define FireEtXplatLdLibShFolder() \
        MCGEN_EVENT_ENABLED(LdLibShFolder) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolder(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolder) : 0
#define FireEtXplatLdLibShFolder_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_LdLibShFolder(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolder)
#define FireEtXplatLdLibShFolder_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdLibShFolder) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolder(&(pContext)->Context, &LdLibShFolder) : 0
#define FireEtXplatLdLibShFolder_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_LdLibShFolder(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdLibShFolder)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdLibShFolder _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdLibShFolder_V1"
//
#define EventXplatEnabledLdLibShFolder_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdLibShFolder_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdLibShFolder_V1"
//
#define FireEtXplatLdLibShFolder_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LdLibShFolder_V1) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolder_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolder_V1, ClrInstanceID) : 0
#define FireEtXplatLdLibShFolder_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdLibShFolder_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolder_V1, ClrInstanceID)
#define FireEtXplatLdLibShFolder_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdLibShFolder_V1) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolder_V1(&(pContext)->Context, &LdLibShFolder_V1, ClrInstanceID) : 0
#define FireEtXplatLdLibShFolder_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdLibShFolder_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdLibShFolder_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdLibShFolder_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdLibShFolderEnd"
//
#define EventXplatEnabledLdLibShFolderEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdLibShFolderEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdLibShFolderEnd"
//
#define FireEtXplatLdLibShFolderEnd() \
        MCGEN_EVENT_ENABLED(LdLibShFolderEnd) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolderEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolderEnd) : 0
#define FireEtXplatLdLibShFolderEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_LdLibShFolderEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolderEnd)
#define FireEtXplatLdLibShFolderEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdLibShFolderEnd) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolderEnd(&(pContext)->Context, &LdLibShFolderEnd) : 0
#define FireEtXplatLdLibShFolderEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_LdLibShFolderEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdLibShFolderEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdLibShFolderEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LdLibShFolderEnd_V1"
//
#define EventXplatEnabledLdLibShFolderEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLdLibShFolderEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LdLibShFolderEnd_V1"
//
#define FireEtXplatLdLibShFolderEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LdLibShFolderEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolderEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolderEnd_V1, ClrInstanceID) : 0
#define FireEtXplatLdLibShFolderEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdLibShFolderEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LdLibShFolderEnd_V1, ClrInstanceID)
#define FireEtXplatLdLibShFolderEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LdLibShFolderEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_LdLibShFolderEnd_V1(&(pContext)->Context, &LdLibShFolderEnd_V1, ClrInstanceID) : 0
#define FireEtXplatLdLibShFolderEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LdLibShFolderEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LdLibShFolderEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LdLibShFolderEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrestubWorker"
//
#define EventXplatEnabledPrestubWorker() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledPrestubWorker_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "PrestubWorker"
//
#define FireEtXplatPrestubWorker() \
        MCGEN_EVENT_ENABLED(PrestubWorker) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorker(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorker) : 0
#define FireEtXplatPrestubWorker_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_PrestubWorker(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorker)
#define FireEtXplatPrestubWorker_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrestubWorker) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorker(&(pContext)->Context, &PrestubWorker) : 0
#define FireEtXplatPrestubWorker_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_PrestubWorker(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrestubWorker)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrestubWorker _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrestubWorker_V1"
//
#define EventXplatEnabledPrestubWorker_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledPrestubWorker_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "PrestubWorker_V1"
//
#define FireEtXplatPrestubWorker_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrestubWorker_V1) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorker_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorker_V1, ClrInstanceID) : 0
#define FireEtXplatPrestubWorker_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrestubWorker_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorker_V1, ClrInstanceID)
#define FireEtXplatPrestubWorker_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrestubWorker_V1) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorker_V1(&(pContext)->Context, &PrestubWorker_V1, ClrInstanceID) : 0
#define FireEtXplatPrestubWorker_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrestubWorker_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrestubWorker_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrestubWorker_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrestubWorkerEnd"
//
#define EventXplatEnabledPrestubWorkerEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledPrestubWorkerEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "PrestubWorkerEnd"
//
#define FireEtXplatPrestubWorkerEnd() \
        MCGEN_EVENT_ENABLED(PrestubWorkerEnd) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorkerEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorkerEnd) : 0
#define FireEtXplatPrestubWorkerEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_PrestubWorkerEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorkerEnd)
#define FireEtXplatPrestubWorkerEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrestubWorkerEnd) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorkerEnd(&(pContext)->Context, &PrestubWorkerEnd) : 0
#define FireEtXplatPrestubWorkerEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_PrestubWorkerEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrestubWorkerEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrestubWorkerEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrestubWorkerEnd_V1"
//
#define EventXplatEnabledPrestubWorkerEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledPrestubWorkerEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "PrestubWorkerEnd_V1"
//
#define FireEtXplatPrestubWorkerEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrestubWorkerEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorkerEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorkerEnd_V1, ClrInstanceID) : 0
#define FireEtXplatPrestubWorkerEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrestubWorkerEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrestubWorkerEnd_V1, ClrInstanceID)
#define FireEtXplatPrestubWorkerEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrestubWorkerEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_PrestubWorkerEnd_V1(&(pContext)->Context, &PrestubWorkerEnd_V1, ClrInstanceID) : 0
#define FireEtXplatPrestubWorkerEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrestubWorkerEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrestubWorkerEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrestubWorkerEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GetInstallationStart"
//
#define EventXplatEnabledGetInstallationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledGetInstallationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "GetInstallationStart"
//
#define FireEtXplatGetInstallationStart() \
        MCGEN_EVENT_ENABLED(GetInstallationStart) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationStart) : 0
#define FireEtXplatGetInstallationStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GetInstallationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationStart)
#define FireEtXplatGetInstallationStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GetInstallationStart) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationStart(&(pContext)->Context, &GetInstallationStart) : 0
#define FireEtXplatGetInstallationStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GetInstallationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GetInstallationStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GetInstallationStart _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GetInstallationStart_V1"
//
#define EventXplatEnabledGetInstallationStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledGetInstallationStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "GetInstallationStart_V1"
//
#define FireEtXplatGetInstallationStart_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GetInstallationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationStart_V1, ClrInstanceID) : 0
#define FireEtXplatGetInstallationStart_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetInstallationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationStart_V1, ClrInstanceID)
#define FireEtXplatGetInstallationStart_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GetInstallationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationStart_V1(&(pContext)->Context, &GetInstallationStart_V1, ClrInstanceID) : 0
#define FireEtXplatGetInstallationStart_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetInstallationStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GetInstallationStart_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GetInstallationStart_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GetInstallationEnd"
//
#define EventXplatEnabledGetInstallationEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledGetInstallationEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "GetInstallationEnd"
//
#define FireEtXplatGetInstallationEnd() \
        MCGEN_EVENT_ENABLED(GetInstallationEnd) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationEnd) : 0
#define FireEtXplatGetInstallationEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GetInstallationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationEnd)
#define FireEtXplatGetInstallationEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GetInstallationEnd) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationEnd(&(pContext)->Context, &GetInstallationEnd) : 0
#define FireEtXplatGetInstallationEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GetInstallationEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GetInstallationEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GetInstallationEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GetInstallationEnd_V1"
//
#define EventXplatEnabledGetInstallationEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledGetInstallationEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "GetInstallationEnd_V1"
//
#define FireEtXplatGetInstallationEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GetInstallationEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationEnd_V1, ClrInstanceID) : 0
#define FireEtXplatGetInstallationEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetInstallationEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetInstallationEnd_V1, ClrInstanceID)
#define FireEtXplatGetInstallationEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GetInstallationEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GetInstallationEnd_V1(&(pContext)->Context, &GetInstallationEnd_V1, ClrInstanceID) : 0
#define FireEtXplatGetInstallationEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetInstallationEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GetInstallationEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GetInstallationEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "OpenHModule"
//
#define EventXplatEnabledOpenHModule() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledOpenHModule_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "OpenHModule"
//
#define FireEtXplatOpenHModule() \
        MCGEN_EVENT_ENABLED(OpenHModule) \
        ? _mcgen_TEMPLATE_FOR_OpenHModule(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModule) : 0
#define FireEtXplatOpenHModule_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_OpenHModule(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModule)
#define FireEtXplatOpenHModule_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, OpenHModule) \
        ? _mcgen_TEMPLATE_FOR_OpenHModule(&(pContext)->Context, &OpenHModule) : 0
#define FireEtXplatOpenHModule_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_OpenHModule(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &OpenHModule)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_OpenHModule _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "OpenHModule_V1"
//
#define EventXplatEnabledOpenHModule_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledOpenHModule_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "OpenHModule_V1"
//
#define FireEtXplatOpenHModule_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(OpenHModule_V1) \
        ? _mcgen_TEMPLATE_FOR_OpenHModule_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModule_V1, ClrInstanceID) : 0
#define FireEtXplatOpenHModule_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_OpenHModule_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModule_V1, ClrInstanceID)
#define FireEtXplatOpenHModule_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, OpenHModule_V1) \
        ? _mcgen_TEMPLATE_FOR_OpenHModule_V1(&(pContext)->Context, &OpenHModule_V1, ClrInstanceID) : 0
#define FireEtXplatOpenHModule_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_OpenHModule_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &OpenHModule_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_OpenHModule_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "OpenHModuleEnd"
//
#define EventXplatEnabledOpenHModuleEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledOpenHModuleEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "OpenHModuleEnd"
//
#define FireEtXplatOpenHModuleEnd() \
        MCGEN_EVENT_ENABLED(OpenHModuleEnd) \
        ? _mcgen_TEMPLATE_FOR_OpenHModuleEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModuleEnd) : 0
#define FireEtXplatOpenHModuleEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_OpenHModuleEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModuleEnd)
#define FireEtXplatOpenHModuleEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, OpenHModuleEnd) \
        ? _mcgen_TEMPLATE_FOR_OpenHModuleEnd(&(pContext)->Context, &OpenHModuleEnd) : 0
#define FireEtXplatOpenHModuleEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_OpenHModuleEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &OpenHModuleEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_OpenHModuleEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "OpenHModuleEnd_V1"
//
#define EventXplatEnabledOpenHModuleEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledOpenHModuleEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "OpenHModuleEnd_V1"
//
#define FireEtXplatOpenHModuleEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(OpenHModuleEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_OpenHModuleEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModuleEnd_V1, ClrInstanceID) : 0
#define FireEtXplatOpenHModuleEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_OpenHModuleEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &OpenHModuleEnd_V1, ClrInstanceID)
#define FireEtXplatOpenHModuleEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, OpenHModuleEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_OpenHModuleEnd_V1(&(pContext)->Context, &OpenHModuleEnd_V1, ClrInstanceID) : 0
#define FireEtXplatOpenHModuleEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_OpenHModuleEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &OpenHModuleEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_OpenHModuleEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExplicitBindStart"
//
#define EventXplatEnabledExplicitBindStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExplicitBindStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExplicitBindStart"
//
#define FireEtXplatExplicitBindStart() \
        MCGEN_EVENT_ENABLED(ExplicitBindStart) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindStart) : 0
#define FireEtXplatExplicitBindStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExplicitBindStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindStart)
#define FireEtXplatExplicitBindStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExplicitBindStart) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindStart(&(pContext)->Context, &ExplicitBindStart) : 0
#define FireEtXplatExplicitBindStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExplicitBindStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExplicitBindStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExplicitBindStart _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExplicitBindStart_V1"
//
#define EventXplatEnabledExplicitBindStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExplicitBindStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExplicitBindStart_V1"
//
#define FireEtXplatExplicitBindStart_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExplicitBindStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindStart_V1, ClrInstanceID) : 0
#define FireEtXplatExplicitBindStart_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExplicitBindStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindStart_V1, ClrInstanceID)
#define FireEtXplatExplicitBindStart_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExplicitBindStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindStart_V1(&(pContext)->Context, &ExplicitBindStart_V1, ClrInstanceID) : 0
#define FireEtXplatExplicitBindStart_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExplicitBindStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExplicitBindStart_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExplicitBindStart_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExplicitBindEnd"
//
#define EventXplatEnabledExplicitBindEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExplicitBindEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExplicitBindEnd"
//
#define FireEtXplatExplicitBindEnd() \
        MCGEN_EVENT_ENABLED(ExplicitBindEnd) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindEnd) : 0
#define FireEtXplatExplicitBindEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExplicitBindEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindEnd)
#define FireEtXplatExplicitBindEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExplicitBindEnd) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindEnd(&(pContext)->Context, &ExplicitBindEnd) : 0
#define FireEtXplatExplicitBindEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExplicitBindEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExplicitBindEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExplicitBindEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExplicitBindEnd_V1"
//
#define EventXplatEnabledExplicitBindEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledExplicitBindEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ExplicitBindEnd_V1"
//
#define FireEtXplatExplicitBindEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExplicitBindEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindEnd_V1, ClrInstanceID) : 0
#define FireEtXplatExplicitBindEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExplicitBindEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ExplicitBindEnd_V1, ClrInstanceID)
#define FireEtXplatExplicitBindEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExplicitBindEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ExplicitBindEnd_V1(&(pContext)->Context, &ExplicitBindEnd_V1, ClrInstanceID) : 0
#define FireEtXplatExplicitBindEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExplicitBindEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ExplicitBindEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExplicitBindEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ParseXml"
//
#define EventXplatEnabledParseXml() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledParseXml_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ParseXml"
//
#define FireEtXplatParseXml() \
        MCGEN_EVENT_ENABLED(ParseXml) \
        ? _mcgen_TEMPLATE_FOR_ParseXml(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXml) : 0
#define FireEtXplatParseXml_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ParseXml(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXml)
#define FireEtXplatParseXml_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ParseXml) \
        ? _mcgen_TEMPLATE_FOR_ParseXml(&(pContext)->Context, &ParseXml) : 0
#define FireEtXplatParseXml_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ParseXml(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ParseXml)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ParseXml _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ParseXml_V1"
//
#define EventXplatEnabledParseXml_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledParseXml_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ParseXml_V1"
//
#define FireEtXplatParseXml_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ParseXml_V1) \
        ? _mcgen_TEMPLATE_FOR_ParseXml_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXml_V1, ClrInstanceID) : 0
#define FireEtXplatParseXml_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ParseXml_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXml_V1, ClrInstanceID)
#define FireEtXplatParseXml_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ParseXml_V1) \
        ? _mcgen_TEMPLATE_FOR_ParseXml_V1(&(pContext)->Context, &ParseXml_V1, ClrInstanceID) : 0
#define FireEtXplatParseXml_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ParseXml_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ParseXml_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ParseXml_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ParseXmlEnd"
//
#define EventXplatEnabledParseXmlEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledParseXmlEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ParseXmlEnd"
//
#define FireEtXplatParseXmlEnd() \
        MCGEN_EVENT_ENABLED(ParseXmlEnd) \
        ? _mcgen_TEMPLATE_FOR_ParseXmlEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXmlEnd) : 0
#define FireEtXplatParseXmlEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ParseXmlEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXmlEnd)
#define FireEtXplatParseXmlEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ParseXmlEnd) \
        ? _mcgen_TEMPLATE_FOR_ParseXmlEnd(&(pContext)->Context, &ParseXmlEnd) : 0
#define FireEtXplatParseXmlEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ParseXmlEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ParseXmlEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ParseXmlEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ParseXmlEnd_V1"
//
#define EventXplatEnabledParseXmlEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledParseXmlEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "ParseXmlEnd_V1"
//
#define FireEtXplatParseXmlEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ParseXmlEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ParseXmlEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXmlEnd_V1, ClrInstanceID) : 0
#define FireEtXplatParseXmlEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ParseXmlEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ParseXmlEnd_V1, ClrInstanceID)
#define FireEtXplatParseXmlEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ParseXmlEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ParseXmlEnd_V1(&(pContext)->Context, &ParseXmlEnd_V1, ClrInstanceID) : 0
#define FireEtXplatParseXmlEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ParseXmlEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ParseXmlEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ParseXmlEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitDefaultDomain"
//
#define EventXplatEnabledInitDefaultDomain() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitDefaultDomain_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitDefaultDomain"
//
#define FireEtXplatInitDefaultDomain() \
        MCGEN_EVENT_ENABLED(InitDefaultDomain) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomain(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomain) : 0
#define FireEtXplatInitDefaultDomain_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_InitDefaultDomain(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomain)
#define FireEtXplatInitDefaultDomain_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitDefaultDomain) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomain(&(pContext)->Context, &InitDefaultDomain) : 0
#define FireEtXplatInitDefaultDomain_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_InitDefaultDomain(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitDefaultDomain)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitDefaultDomain _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitDefaultDomain_V1"
//
#define EventXplatEnabledInitDefaultDomain_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitDefaultDomain_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitDefaultDomain_V1"
//
#define FireEtXplatInitDefaultDomain_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(InitDefaultDomain_V1) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomain_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomain_V1, ClrInstanceID) : 0
#define FireEtXplatInitDefaultDomain_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitDefaultDomain_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomain_V1, ClrInstanceID)
#define FireEtXplatInitDefaultDomain_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitDefaultDomain_V1) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomain_V1(&(pContext)->Context, &InitDefaultDomain_V1, ClrInstanceID) : 0
#define FireEtXplatInitDefaultDomain_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitDefaultDomain_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitDefaultDomain_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitDefaultDomain_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitDefaultDomainEnd"
//
#define EventXplatEnabledInitDefaultDomainEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitDefaultDomainEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitDefaultDomainEnd"
//
#define FireEtXplatInitDefaultDomainEnd() \
        MCGEN_EVENT_ENABLED(InitDefaultDomainEnd) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomainEnd) : 0
#define FireEtXplatInitDefaultDomainEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomainEnd)
#define FireEtXplatInitDefaultDomainEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitDefaultDomainEnd) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd(&(pContext)->Context, &InitDefaultDomainEnd) : 0
#define FireEtXplatInitDefaultDomainEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitDefaultDomainEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitDefaultDomainEnd_V1"
//
#define EventXplatEnabledInitDefaultDomainEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitDefaultDomainEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitDefaultDomainEnd_V1"
//
#define FireEtXplatInitDefaultDomainEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(InitDefaultDomainEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomainEnd_V1, ClrInstanceID) : 0
#define FireEtXplatInitDefaultDomainEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitDefaultDomainEnd_V1, ClrInstanceID)
#define FireEtXplatInitDefaultDomainEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitDefaultDomainEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd_V1(&(pContext)->Context, &InitDefaultDomainEnd_V1, ClrInstanceID) : 0
#define FireEtXplatInitDefaultDomainEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitDefaultDomainEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitDefaultDomainEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitSecurity"
//
#define EventXplatEnabledInitSecurity() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitSecurity_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitSecurity"
//
#define FireEtXplatInitSecurity() \
        MCGEN_EVENT_ENABLED(InitSecurity) \
        ? _mcgen_TEMPLATE_FOR_InitSecurity(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurity) : 0
#define FireEtXplatInitSecurity_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_InitSecurity(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurity)
#define FireEtXplatInitSecurity_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitSecurity) \
        ? _mcgen_TEMPLATE_FOR_InitSecurity(&(pContext)->Context, &InitSecurity) : 0
#define FireEtXplatInitSecurity_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_InitSecurity(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitSecurity)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitSecurity _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitSecurity_V1"
//
#define EventXplatEnabledInitSecurity_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitSecurity_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitSecurity_V1"
//
#define FireEtXplatInitSecurity_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(InitSecurity_V1) \
        ? _mcgen_TEMPLATE_FOR_InitSecurity_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurity_V1, ClrInstanceID) : 0
#define FireEtXplatInitSecurity_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitSecurity_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurity_V1, ClrInstanceID)
#define FireEtXplatInitSecurity_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitSecurity_V1) \
        ? _mcgen_TEMPLATE_FOR_InitSecurity_V1(&(pContext)->Context, &InitSecurity_V1, ClrInstanceID) : 0
#define FireEtXplatInitSecurity_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitSecurity_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitSecurity_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitSecurity_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitSecurityEnd"
//
#define EventXplatEnabledInitSecurityEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitSecurityEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitSecurityEnd"
//
#define FireEtXplatInitSecurityEnd() \
        MCGEN_EVENT_ENABLED(InitSecurityEnd) \
        ? _mcgen_TEMPLATE_FOR_InitSecurityEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurityEnd) : 0
#define FireEtXplatInitSecurityEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_InitSecurityEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurityEnd)
#define FireEtXplatInitSecurityEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitSecurityEnd) \
        ? _mcgen_TEMPLATE_FOR_InitSecurityEnd(&(pContext)->Context, &InitSecurityEnd) : 0
#define FireEtXplatInitSecurityEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_InitSecurityEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitSecurityEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitSecurityEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "InitSecurityEnd_V1"
//
#define EventXplatEnabledInitSecurityEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledInitSecurityEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "InitSecurityEnd_V1"
//
#define FireEtXplatInitSecurityEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(InitSecurityEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_InitSecurityEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurityEnd_V1, ClrInstanceID) : 0
#define FireEtXplatInitSecurityEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitSecurityEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &InitSecurityEnd_V1, ClrInstanceID)
#define FireEtXplatInitSecurityEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, InitSecurityEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_InitSecurityEnd_V1(&(pContext)->Context, &InitSecurityEnd_V1, ClrInstanceID) : 0
#define FireEtXplatInitSecurityEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_InitSecurityEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &InitSecurityEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_InitSecurityEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AllowBindingRedirs"
//
#define EventXplatEnabledAllowBindingRedirs() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledAllowBindingRedirs_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "AllowBindingRedirs"
//
#define FireEtXplatAllowBindingRedirs() \
        MCGEN_EVENT_ENABLED(AllowBindingRedirs) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirs(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirs) : 0
#define FireEtXplatAllowBindingRedirs_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirs(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirs)
#define FireEtXplatAllowBindingRedirs_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AllowBindingRedirs) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirs(&(pContext)->Context, &AllowBindingRedirs) : 0
#define FireEtXplatAllowBindingRedirs_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirs(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &AllowBindingRedirs)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AllowBindingRedirs _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AllowBindingRedirs_V1"
//
#define EventXplatEnabledAllowBindingRedirs_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledAllowBindingRedirs_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "AllowBindingRedirs_V1"
//
#define FireEtXplatAllowBindingRedirs_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AllowBindingRedirs_V1) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirs_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirs_V1, ClrInstanceID) : 0
#define FireEtXplatAllowBindingRedirs_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirs_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirs_V1, ClrInstanceID)
#define FireEtXplatAllowBindingRedirs_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AllowBindingRedirs_V1) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirs_V1(&(pContext)->Context, &AllowBindingRedirs_V1, ClrInstanceID) : 0
#define FireEtXplatAllowBindingRedirs_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirs_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &AllowBindingRedirs_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AllowBindingRedirs_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AllowBindingRedirsEnd"
//
#define EventXplatEnabledAllowBindingRedirsEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledAllowBindingRedirsEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "AllowBindingRedirsEnd"
//
#define FireEtXplatAllowBindingRedirsEnd() \
        MCGEN_EVENT_ENABLED(AllowBindingRedirsEnd) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirsEnd) : 0
#define FireEtXplatAllowBindingRedirsEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirsEnd)
#define FireEtXplatAllowBindingRedirsEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AllowBindingRedirsEnd) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd(&(pContext)->Context, &AllowBindingRedirsEnd) : 0
#define FireEtXplatAllowBindingRedirsEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &AllowBindingRedirsEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AllowBindingRedirsEnd_V1"
//
#define EventXplatEnabledAllowBindingRedirsEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledAllowBindingRedirsEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "AllowBindingRedirsEnd_V1"
//
#define FireEtXplatAllowBindingRedirsEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AllowBindingRedirsEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirsEnd_V1, ClrInstanceID) : 0
#define FireEtXplatAllowBindingRedirsEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllowBindingRedirsEnd_V1, ClrInstanceID)
#define FireEtXplatAllowBindingRedirsEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AllowBindingRedirsEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd_V1(&(pContext)->Context, &AllowBindingRedirsEnd_V1, ClrInstanceID) : 0
#define FireEtXplatAllowBindingRedirsEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &AllowBindingRedirsEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AllowBindingRedirsEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSync"
//
#define EventXplatEnabledEEConfigSync() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSync_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSync"
//
#define FireEtXplatEEConfigSync() \
        MCGEN_EVENT_ENABLED(EEConfigSync) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSync(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSync) : 0
#define FireEtXplatEEConfigSync_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_EEConfigSync(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSync)
#define FireEtXplatEEConfigSync_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSync) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSync(&(pContext)->Context, &EEConfigSync) : 0
#define FireEtXplatEEConfigSync_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_EEConfigSync(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSync)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSync _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSync_V1"
//
#define EventXplatEnabledEEConfigSync_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSync_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSync_V1"
//
#define FireEtXplatEEConfigSync_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EEConfigSync_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSync_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSync_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSync_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSync_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSync_V1, ClrInstanceID)
#define FireEtXplatEEConfigSync_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSync_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSync_V1(&(pContext)->Context, &EEConfigSync_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSync_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSync_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSync_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSync_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSyncEnd"
//
#define EventXplatEnabledEEConfigSyncEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSyncEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSyncEnd"
//
#define FireEtXplatEEConfigSyncEnd() \
        MCGEN_EVENT_ENABLED(EEConfigSyncEnd) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSyncEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSyncEnd) : 0
#define FireEtXplatEEConfigSyncEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_EEConfigSyncEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSyncEnd)
#define FireEtXplatEEConfigSyncEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSyncEnd) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSyncEnd(&(pContext)->Context, &EEConfigSyncEnd) : 0
#define FireEtXplatEEConfigSyncEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_EEConfigSyncEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSyncEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSyncEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EEConfigSyncEnd_V1"
//
#define EventXplatEnabledEEConfigSyncEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledEEConfigSyncEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "EEConfigSyncEnd_V1"
//
#define FireEtXplatEEConfigSyncEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EEConfigSyncEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSyncEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSyncEnd_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSyncEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSyncEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EEConfigSyncEnd_V1, ClrInstanceID)
#define FireEtXplatEEConfigSyncEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EEConfigSyncEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_EEConfigSyncEnd_V1(&(pContext)->Context, &EEConfigSyncEnd_V1, ClrInstanceID) : 0
#define FireEtXplatEEConfigSyncEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EEConfigSyncEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EEConfigSyncEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EEConfigSyncEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionBinding"
//
#define EventXplatEnabledFusionBinding() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionBinding_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionBinding"
//
#define FireEtXplatFusionBinding() \
        MCGEN_EVENT_ENABLED(FusionBinding) \
        ? _mcgen_TEMPLATE_FOR_FusionBinding(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBinding) : 0
#define FireEtXplatFusionBinding_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_FusionBinding(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBinding)
#define FireEtXplatFusionBinding_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionBinding) \
        ? _mcgen_TEMPLATE_FOR_FusionBinding(&(pContext)->Context, &FusionBinding) : 0
#define FireEtXplatFusionBinding_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_FusionBinding(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionBinding)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionBinding _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionBinding_V1"
//
#define EventXplatEnabledFusionBinding_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionBinding_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionBinding_V1"
//
#define FireEtXplatFusionBinding_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FusionBinding_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionBinding_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBinding_V1, ClrInstanceID) : 0
#define FireEtXplatFusionBinding_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionBinding_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBinding_V1, ClrInstanceID)
#define FireEtXplatFusionBinding_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionBinding_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionBinding_V1(&(pContext)->Context, &FusionBinding_V1, ClrInstanceID) : 0
#define FireEtXplatFusionBinding_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionBinding_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionBinding_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionBinding_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionBindingEnd"
//
#define EventXplatEnabledFusionBindingEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionBindingEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionBindingEnd"
//
#define FireEtXplatFusionBindingEnd() \
        MCGEN_EVENT_ENABLED(FusionBindingEnd) \
        ? _mcgen_TEMPLATE_FOR_FusionBindingEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBindingEnd) : 0
#define FireEtXplatFusionBindingEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_FusionBindingEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBindingEnd)
#define FireEtXplatFusionBindingEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionBindingEnd) \
        ? _mcgen_TEMPLATE_FOR_FusionBindingEnd(&(pContext)->Context, &FusionBindingEnd) : 0
#define FireEtXplatFusionBindingEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_FusionBindingEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionBindingEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionBindingEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionBindingEnd_V1"
//
#define EventXplatEnabledFusionBindingEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionBindingEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionBindingEnd_V1"
//
#define FireEtXplatFusionBindingEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FusionBindingEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionBindingEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBindingEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusionBindingEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionBindingEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionBindingEnd_V1, ClrInstanceID)
#define FireEtXplatFusionBindingEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionBindingEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionBindingEnd_V1(&(pContext)->Context, &FusionBindingEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusionBindingEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionBindingEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionBindingEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionBindingEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderCatchCall"
//
#define EventXplatEnabledLoaderCatchCall() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLoaderCatchCall_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LoaderCatchCall"
//
#define FireEtXplatLoaderCatchCall() \
        MCGEN_EVENT_ENABLED(LoaderCatchCall) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCall(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCall) : 0
#define FireEtXplatLoaderCatchCall_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_LoaderCatchCall(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCall)
#define FireEtXplatLoaderCatchCall_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderCatchCall) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCall(&(pContext)->Context, &LoaderCatchCall) : 0
#define FireEtXplatLoaderCatchCall_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_LoaderCatchCall(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderCatchCall)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderCatchCall _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderCatchCall_V1"
//
#define EventXplatEnabledLoaderCatchCall_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLoaderCatchCall_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LoaderCatchCall_V1"
//
#define FireEtXplatLoaderCatchCall_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderCatchCall_V1) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCall_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCall_V1, ClrInstanceID) : 0
#define FireEtXplatLoaderCatchCall_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderCatchCall_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCall_V1, ClrInstanceID)
#define FireEtXplatLoaderCatchCall_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderCatchCall_V1) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCall_V1(&(pContext)->Context, &LoaderCatchCall_V1, ClrInstanceID) : 0
#define FireEtXplatLoaderCatchCall_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderCatchCall_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderCatchCall_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderCatchCall_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderCatchCallEnd"
//
#define EventXplatEnabledLoaderCatchCallEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLoaderCatchCallEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LoaderCatchCallEnd"
//
#define FireEtXplatLoaderCatchCallEnd() \
        MCGEN_EVENT_ENABLED(LoaderCatchCallEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCallEnd) : 0
#define FireEtXplatLoaderCatchCallEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCallEnd)
#define FireEtXplatLoaderCatchCallEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderCatchCallEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd(&(pContext)->Context, &LoaderCatchCallEnd) : 0
#define FireEtXplatLoaderCatchCallEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderCatchCallEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderCatchCallEnd_V1"
//
#define EventXplatEnabledLoaderCatchCallEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledLoaderCatchCallEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "LoaderCatchCallEnd_V1"
//
#define FireEtXplatLoaderCatchCallEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderCatchCallEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCallEnd_V1, ClrInstanceID) : 0
#define FireEtXplatLoaderCatchCallEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderCatchCallEnd_V1, ClrInstanceID)
#define FireEtXplatLoaderCatchCallEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderCatchCallEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd_V1(&(pContext)->Context, &LoaderCatchCallEnd_V1, ClrInstanceID) : 0
#define FireEtXplatLoaderCatchCallEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderCatchCallEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderCatchCallEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionInit"
//
#define EventXplatEnabledFusionInit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionInit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionInit"
//
#define FireEtXplatFusionInit() \
        MCGEN_EVENT_ENABLED(FusionInit) \
        ? _mcgen_TEMPLATE_FOR_FusionInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInit) : 0
#define FireEtXplatFusionInit_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_FusionInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInit)
#define FireEtXplatFusionInit_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionInit) \
        ? _mcgen_TEMPLATE_FOR_FusionInit(&(pContext)->Context, &FusionInit) : 0
#define FireEtXplatFusionInit_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_FusionInit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionInit)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionInit _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionInit_V1"
//
#define EventXplatEnabledFusionInit_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionInit_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionInit_V1"
//
#define FireEtXplatFusionInit_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FusionInit_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInit_V1, ClrInstanceID) : 0
#define FireEtXplatFusionInit_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInit_V1, ClrInstanceID)
#define FireEtXplatFusionInit_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionInit_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionInit_V1(&(pContext)->Context, &FusionInit_V1, ClrInstanceID) : 0
#define FireEtXplatFusionInit_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionInit_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionInit_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionInit_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionInitEnd"
//
#define EventXplatEnabledFusionInitEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionInitEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionInitEnd"
//
#define FireEtXplatFusionInitEnd() \
        MCGEN_EVENT_ENABLED(FusionInitEnd) \
        ? _mcgen_TEMPLATE_FOR_FusionInitEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInitEnd) : 0
#define FireEtXplatFusionInitEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_FusionInitEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInitEnd)
#define FireEtXplatFusionInitEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionInitEnd) \
        ? _mcgen_TEMPLATE_FOR_FusionInitEnd(&(pContext)->Context, &FusionInitEnd) : 0
#define FireEtXplatFusionInitEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_FusionInitEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionInitEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionInitEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionInitEnd_V1"
//
#define EventXplatEnabledFusionInitEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionInitEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionInitEnd_V1"
//
#define FireEtXplatFusionInitEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FusionInitEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionInitEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInitEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusionInitEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionInitEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionInitEnd_V1, ClrInstanceID)
#define FireEtXplatFusionInitEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionInitEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionInitEnd_V1(&(pContext)->Context, &FusionInitEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusionInitEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionInitEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionInitEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionInitEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionAppCtx"
//
#define EventXplatEnabledFusionAppCtx() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionAppCtx_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionAppCtx"
//
#define FireEtXplatFusionAppCtx() \
        MCGEN_EVENT_ENABLED(FusionAppCtx) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtx(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtx) : 0
#define FireEtXplatFusionAppCtx_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_FusionAppCtx(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtx)
#define FireEtXplatFusionAppCtx_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionAppCtx) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtx(&(pContext)->Context, &FusionAppCtx) : 0
#define FireEtXplatFusionAppCtx_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_FusionAppCtx(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionAppCtx)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionAppCtx _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionAppCtx_V1"
//
#define EventXplatEnabledFusionAppCtx_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionAppCtx_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionAppCtx_V1"
//
#define FireEtXplatFusionAppCtx_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FusionAppCtx_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtx_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtx_V1, ClrInstanceID) : 0
#define FireEtXplatFusionAppCtx_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionAppCtx_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtx_V1, ClrInstanceID)
#define FireEtXplatFusionAppCtx_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionAppCtx_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtx_V1(&(pContext)->Context, &FusionAppCtx_V1, ClrInstanceID) : 0
#define FireEtXplatFusionAppCtx_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionAppCtx_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionAppCtx_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionAppCtx_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionAppCtxEnd"
//
#define EventXplatEnabledFusionAppCtxEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionAppCtxEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionAppCtxEnd"
//
#define FireEtXplatFusionAppCtxEnd() \
        MCGEN_EVENT_ENABLED(FusionAppCtxEnd) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtxEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtxEnd) : 0
#define FireEtXplatFusionAppCtxEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_FusionAppCtxEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtxEnd)
#define FireEtXplatFusionAppCtxEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionAppCtxEnd) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtxEnd(&(pContext)->Context, &FusionAppCtxEnd) : 0
#define FireEtXplatFusionAppCtxEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_FusionAppCtxEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionAppCtxEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionAppCtxEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionAppCtxEnd_V1"
//
#define EventXplatEnabledFusionAppCtxEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusionAppCtxEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "FusionAppCtxEnd_V1"
//
#define FireEtXplatFusionAppCtxEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FusionAppCtxEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtxEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtxEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusionAppCtxEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionAppCtxEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionAppCtxEnd_V1, ClrInstanceID)
#define FireEtXplatFusionAppCtxEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionAppCtxEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_FusionAppCtxEnd_V1(&(pContext)->Context, &FusionAppCtxEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusionAppCtxEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FusionAppCtxEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionAppCtxEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionAppCtxEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Fusion2EE"
//
#define EventXplatEnabledFusion2EE() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusion2EE_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "Fusion2EE"
//
#define FireEtXplatFusion2EE() \
        MCGEN_EVENT_ENABLED(Fusion2EE) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EE(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EE) : 0
#define FireEtXplatFusion2EE_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_Fusion2EE(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EE)
#define FireEtXplatFusion2EE_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Fusion2EE) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EE(&(pContext)->Context, &Fusion2EE) : 0
#define FireEtXplatFusion2EE_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_Fusion2EE(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &Fusion2EE)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Fusion2EE _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Fusion2EE_V1"
//
#define EventXplatEnabledFusion2EE_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusion2EE_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "Fusion2EE_V1"
//
#define FireEtXplatFusion2EE_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(Fusion2EE_V1) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EE_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EE_V1, ClrInstanceID) : 0
#define FireEtXplatFusion2EE_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_Fusion2EE_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EE_V1, ClrInstanceID)
#define FireEtXplatFusion2EE_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Fusion2EE_V1) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EE_V1(&(pContext)->Context, &Fusion2EE_V1, ClrInstanceID) : 0
#define FireEtXplatFusion2EE_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_Fusion2EE_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &Fusion2EE_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Fusion2EE_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Fusion2EEEnd"
//
#define EventXplatEnabledFusion2EEEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusion2EEEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "Fusion2EEEnd"
//
#define FireEtXplatFusion2EEEnd() \
        MCGEN_EVENT_ENABLED(Fusion2EEEnd) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EEEnd) : 0
#define FireEtXplatFusion2EEEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_Fusion2EEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EEEnd)
#define FireEtXplatFusion2EEEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Fusion2EEEnd) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EEEnd(&(pContext)->Context, &Fusion2EEEnd) : 0
#define FireEtXplatFusion2EEEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_Fusion2EEEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &Fusion2EEEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Fusion2EEEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Fusion2EEEnd_V1"
//
#define EventXplatEnabledFusion2EEEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledFusion2EEEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "Fusion2EEEnd_V1"
//
#define FireEtXplatFusion2EEEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(Fusion2EEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EEEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusion2EEEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_Fusion2EEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &Fusion2EEEnd_V1, ClrInstanceID)
#define FireEtXplatFusion2EEEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Fusion2EEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_Fusion2EEEnd_V1(&(pContext)->Context, &Fusion2EEEnd_V1, ClrInstanceID) : 0
#define FireEtXplatFusion2EEEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_Fusion2EEEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &Fusion2EEEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Fusion2EEEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SecurityCatchCall"
//
#define EventXplatEnabledSecurityCatchCall() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledSecurityCatchCall_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "SecurityCatchCall"
//
#define FireEtXplatSecurityCatchCall() \
        MCGEN_EVENT_ENABLED(SecurityCatchCall) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCall(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCall) : 0
#define FireEtXplatSecurityCatchCall_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_SecurityCatchCall(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCall)
#define FireEtXplatSecurityCatchCall_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SecurityCatchCall) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCall(&(pContext)->Context, &SecurityCatchCall) : 0
#define FireEtXplatSecurityCatchCall_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_SecurityCatchCall(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &SecurityCatchCall)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SecurityCatchCall _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SecurityCatchCall_V1"
//
#define EventXplatEnabledSecurityCatchCall_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledSecurityCatchCall_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "SecurityCatchCall_V1"
//
#define FireEtXplatSecurityCatchCall_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(SecurityCatchCall_V1) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCall_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCall_V1, ClrInstanceID) : 0
#define FireEtXplatSecurityCatchCall_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SecurityCatchCall_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCall_V1, ClrInstanceID)
#define FireEtXplatSecurityCatchCall_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SecurityCatchCall_V1) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCall_V1(&(pContext)->Context, &SecurityCatchCall_V1, ClrInstanceID) : 0
#define FireEtXplatSecurityCatchCall_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SecurityCatchCall_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &SecurityCatchCall_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SecurityCatchCall_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SecurityCatchCallEnd"
//
#define EventXplatEnabledSecurityCatchCallEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledSecurityCatchCallEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "SecurityCatchCallEnd"
//
#define FireEtXplatSecurityCatchCallEnd() \
        MCGEN_EVENT_ENABLED(SecurityCatchCallEnd) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCallEnd) : 0
#define FireEtXplatSecurityCatchCallEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCallEnd)
#define FireEtXplatSecurityCatchCallEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SecurityCatchCallEnd) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd(&(pContext)->Context, &SecurityCatchCallEnd) : 0
#define FireEtXplatSecurityCatchCallEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &SecurityCatchCallEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SecurityCatchCallEnd_V1"
//
#define EventXplatEnabledSecurityCatchCallEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 2)
#define EventXplatEnabledSecurityCatchCallEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 2)

//
// Event write macros for event "SecurityCatchCallEnd_V1"
//
#define FireEtXplatSecurityCatchCallEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(SecurityCatchCallEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCallEnd_V1, ClrInstanceID) : 0
#define FireEtXplatSecurityCatchCallEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &SecurityCatchCallEnd_V1, ClrInstanceID)
#define FireEtXplatSecurityCatchCallEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SecurityCatchCallEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd_V1(&(pContext)->Context, &SecurityCatchCallEnd_V1, ClrInstanceID) : 0
#define FireEtXplatSecurityCatchCallEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &SecurityCatchCallEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SecurityCatchCallEnd_V1 _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CLRStackWalkPrivate"
//
#define EventXplatEnabledCLRStackWalkPrivate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 3)
#define EventXplatEnabledCLRStackWalkPrivate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 3)

//
// Event write macros for event "CLRStackWalkPrivate"
//
#define FireEtXplatCLRStackWalkPrivate(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED(CLRStackWalkPrivate) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkPrivate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CLRStackWalkPrivate, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalkPrivate_AssumeEnabled(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkPrivate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CLRStackWalkPrivate, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)
#define FireEtXplatCLRStackWalkPrivate_ForContext(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CLRStackWalkPrivate) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkPrivate(&(pContext)->Context, &CLRStackWalkPrivate, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define FireEtXplatCLRStackWalkPrivate_ForContextAssumeEnabled(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkPrivate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &CLRStackWalkPrivate, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CLRStackWalkPrivate _mcgen_PASTE2(McTemplateCoU0huuqP2_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleRangeLoadPrivate"
//
#define EventXplatEnabledModuleRangeLoadPrivate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 4)
#define EventXplatEnabledModuleRangeLoadPrivate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 4)

//
// Event write macros for event "ModuleRangeLoadPrivate"
//
#define FireEtXplatModuleRangeLoadPrivate(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType) \
        MCGEN_EVENT_ENABLED(ModuleRangeLoadPrivate) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeLoadPrivate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ModuleRangeLoadPrivate, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType) : 0
#define FireEtXplatModuleRangeLoadPrivate_AssumeEnabled(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeLoadPrivate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ModuleRangeLoadPrivate, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType)
#define FireEtXplatModuleRangeLoadPrivate_ForContext(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleRangeLoadPrivate) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeLoadPrivate(&(pContext)->Context, &ModuleRangeLoadPrivate, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType) : 0
#define FireEtXplatModuleRangeLoadPrivate_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeLoadPrivate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ModuleRangeLoadPrivate, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType, IBCType, SectionType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleRangeLoadPrivate _mcgen_PASTE2(McTemplateCoU0hxqquuh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingPolicyPhaseStart"
//
#define EventXplatEnabledBindingPolicyPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingPolicyPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingPolicyPhaseStart"
//
#define FireEtXplatBindingPolicyPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingPolicyPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingPolicyPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPolicyPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPolicyPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPolicyPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPolicyPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingPolicyPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingPolicyPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingPolicyPhaseStart(&(pContext)->Context, &BindingPolicyPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPolicyPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPolicyPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingPolicyPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingPolicyPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingPolicyPhaseEnd"
//
#define EventXplatEnabledBindingPolicyPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingPolicyPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingPolicyPhaseEnd"
//
#define FireEtXplatBindingPolicyPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingPolicyPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingPolicyPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPolicyPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPolicyPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPolicyPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPolicyPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingPolicyPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingPolicyPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingPolicyPhaseEnd(&(pContext)->Context, &BindingPolicyPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPolicyPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPolicyPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingPolicyPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingPolicyPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingNgenPhaseStart"
//
#define EventXplatEnabledBindingNgenPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingNgenPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingNgenPhaseStart"
//
#define FireEtXplatBindingNgenPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingNgenPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingNgenPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingNgenPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingNgenPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingNgenPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingNgenPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingNgenPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingNgenPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingNgenPhaseStart(&(pContext)->Context, &BindingNgenPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingNgenPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingNgenPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingNgenPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingNgenPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingNgenPhaseEnd"
//
#define EventXplatEnabledBindingNgenPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingNgenPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingNgenPhaseEnd"
//
#define FireEtXplatBindingNgenPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingNgenPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingNgenPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingNgenPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingNgenPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingNgenPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingNgenPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingNgenPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingNgenPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingNgenPhaseEnd(&(pContext)->Context, &BindingNgenPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingNgenPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingNgenPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingNgenPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingNgenPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingLookupAndProbingPhaseStart"
//
#define EventXplatEnabledBindingLookupAndProbingPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingLookupAndProbingPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingLookupAndProbingPhaseStart"
//
#define FireEtXplatBindingLookupAndProbingPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingLookupAndProbingPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingLookupAndProbingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingLookupAndProbingPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingLookupAndProbingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingLookupAndProbingPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingLookupAndProbingPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseStart(&(pContext)->Context, &BindingLookupAndProbingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingLookupAndProbingPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingLookupAndProbingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingLookupAndProbingPhaseEnd"
//
#define EventXplatEnabledBindingLookupAndProbingPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingLookupAndProbingPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingLookupAndProbingPhaseEnd"
//
#define FireEtXplatBindingLookupAndProbingPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingLookupAndProbingPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingLookupAndProbingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingLookupAndProbingPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingLookupAndProbingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingLookupAndProbingPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingLookupAndProbingPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseEnd(&(pContext)->Context, &BindingLookupAndProbingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingLookupAndProbingPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingLookupAndProbingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingLookupAndProbingPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderPhaseStart"
//
#define EventXplatEnabledLoaderPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderPhaseStart"
//
#define FireEtXplatLoaderPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderPhaseStart(&(pContext)->Context, &LoaderPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderPhaseEnd"
//
#define EventXplatEnabledLoaderPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderPhaseEnd"
//
#define FireEtXplatLoaderPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderPhaseEnd(&(pContext)->Context, &LoaderPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingPhaseStart"
//
#define EventXplatEnabledBindingPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingPhaseStart"
//
#define FireEtXplatBindingPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingPhaseStart(&(pContext)->Context, &BindingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingPhaseEnd"
//
#define EventXplatEnabledBindingPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingPhaseEnd"
//
#define FireEtXplatBindingPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingPhaseEnd(&(pContext)->Context, &BindingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingDownloadPhaseStart"
//
#define EventXplatEnabledBindingDownloadPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingDownloadPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingDownloadPhaseStart"
//
#define FireEtXplatBindingDownloadPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingDownloadPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingDownloadPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingDownloadPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingDownloadPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingDownloadPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingDownloadPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingDownloadPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingDownloadPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_BindingDownloadPhaseStart(&(pContext)->Context, &BindingDownloadPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingDownloadPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingDownloadPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingDownloadPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingDownloadPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BindingDownloadPhaseEnd"
//
#define EventXplatEnabledBindingDownloadPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledBindingDownloadPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "BindingDownloadPhaseEnd"
//
#define FireEtXplatBindingDownloadPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BindingDownloadPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingDownloadPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingDownloadPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingDownloadPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingDownloadPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BindingDownloadPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatBindingDownloadPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BindingDownloadPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_BindingDownloadPhaseEnd(&(pContext)->Context, &BindingDownloadPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatBindingDownloadPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BindingDownloadPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BindingDownloadPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BindingDownloadPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderAssemblyInitPhaseStart"
//
#define EventXplatEnabledLoaderAssemblyInitPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderAssemblyInitPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderAssemblyInitPhaseStart"
//
#define FireEtXplatLoaderAssemblyInitPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderAssemblyInitPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderAssemblyInitPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderAssemblyInitPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderAssemblyInitPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderAssemblyInitPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderAssemblyInitPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseStart(&(pContext)->Context, &LoaderAssemblyInitPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderAssemblyInitPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderAssemblyInitPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderAssemblyInitPhaseEnd"
//
#define EventXplatEnabledLoaderAssemblyInitPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderAssemblyInitPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderAssemblyInitPhaseEnd"
//
#define FireEtXplatLoaderAssemblyInitPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderAssemblyInitPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderAssemblyInitPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderAssemblyInitPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderAssemblyInitPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderAssemblyInitPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderAssemblyInitPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseEnd(&(pContext)->Context, &LoaderAssemblyInitPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderAssemblyInitPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderAssemblyInitPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderAssemblyInitPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderMappingPhaseStart"
//
#define EventXplatEnabledLoaderMappingPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderMappingPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderMappingPhaseStart"
//
#define FireEtXplatLoaderMappingPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderMappingPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderMappingPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderMappingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderMappingPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderMappingPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderMappingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderMappingPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderMappingPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderMappingPhaseStart(&(pContext)->Context, &LoaderMappingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderMappingPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderMappingPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderMappingPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderMappingPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderMappingPhaseEnd"
//
#define EventXplatEnabledLoaderMappingPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderMappingPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderMappingPhaseEnd"
//
#define FireEtXplatLoaderMappingPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderMappingPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderMappingPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderMappingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderMappingPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderMappingPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderMappingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderMappingPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderMappingPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderMappingPhaseEnd(&(pContext)->Context, &LoaderMappingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderMappingPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderMappingPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderMappingPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderMappingPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderDeliverEventsPhaseStart"
//
#define EventXplatEnabledLoaderDeliverEventsPhaseStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderDeliverEventsPhaseStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderDeliverEventsPhaseStart"
//
#define FireEtXplatLoaderDeliverEventsPhaseStart(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderDeliverEventsPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderDeliverEventsPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderDeliverEventsPhaseStart_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderDeliverEventsPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderDeliverEventsPhaseStart_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderDeliverEventsPhaseStart) \
        ? _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseStart(&(pContext)->Context, &LoaderDeliverEventsPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderDeliverEventsPhaseStart_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderDeliverEventsPhaseStart, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseStart _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "LoaderDeliverEventsPhaseEnd"
//
#define EventXplatEnabledLoaderDeliverEventsPhaseEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledLoaderDeliverEventsPhaseEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "LoaderDeliverEventsPhaseEnd"
//
#define FireEtXplatLoaderDeliverEventsPhaseEnd(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(LoaderDeliverEventsPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderDeliverEventsPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderDeliverEventsPhaseEnd_AssumeEnabled(AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &LoaderDeliverEventsPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)
#define FireEtXplatLoaderDeliverEventsPhaseEnd_ForContext(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, LoaderDeliverEventsPhaseEnd) \
        ? _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseEnd(&(pContext)->Context, &LoaderDeliverEventsPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) : 0
#define FireEtXplatLoaderDeliverEventsPhaseEnd_ForContextAssumeEnabled(pContext, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &LoaderDeliverEventsPhaseEnd, AppDomainID, LoadContextID, FromLoaderCache, DynamicLoad, AssemblyCodebase, AssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_LoaderDeliverEventsPhaseEnd _mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EvidenceGenerated"
//
#define EventXplatEnabledEvidenceGenerated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledEvidenceGenerated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "EvidenceGenerated"
//
#define FireEtXplatEvidenceGenerated(Type, AppDomain, ILImage, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EvidenceGenerated) \
        ? _mcgen_TEMPLATE_FOR_EvidenceGenerated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EvidenceGenerated, Type, AppDomain, ILImage, ClrInstanceID) : 0
#define FireEtXplatEvidenceGenerated_AssumeEnabled(Type, AppDomain, ILImage, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EvidenceGenerated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EvidenceGenerated, Type, AppDomain, ILImage, ClrInstanceID)
#define FireEtXplatEvidenceGenerated_ForContext(pContext, Type, AppDomain, ILImage, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EvidenceGenerated) \
        ? _mcgen_TEMPLATE_FOR_EvidenceGenerated(&(pContext)->Context, &EvidenceGenerated, Type, AppDomain, ILImage, ClrInstanceID) : 0
#define FireEtXplatEvidenceGenerated_ForContextAssumeEnabled(pContext, Type, AppDomain, ILImage, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EvidenceGenerated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EvidenceGenerated, Type, AppDomain, ILImage, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EvidenceGenerated _mcgen_PASTE2(McTemplateCoU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleTransparencyComputationStart"
//
#define EventXplatEnabledModuleTransparencyComputationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledModuleTransparencyComputationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "ModuleTransparencyComputationStart"
//
#define FireEtXplatModuleTransparencyComputationStart(Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ModuleTransparencyComputationStart, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatModuleTransparencyComputationStart_AssumeEnabled(Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ModuleTransparencyComputationStart, Module, AppDomainID, ClrInstanceID)
#define FireEtXplatModuleTransparencyComputationStart_ForContext(pContext, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationStart(&(pContext)->Context, &ModuleTransparencyComputationStart, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatModuleTransparencyComputationStart_ForContextAssumeEnabled(pContext, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ModuleTransparencyComputationStart, Module, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationStart _mcgen_PASTE2(McTemplateCoU0zqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleTransparencyComputationEnd"
//
#define EventXplatEnabledModuleTransparencyComputationEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledModuleTransparencyComputationEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "ModuleTransparencyComputationEnd"
//
#define FireEtXplatModuleTransparencyComputationEnd(Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ModuleTransparencyComputationEnd, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID) : 0
#define FireEtXplatModuleTransparencyComputationEnd_AssumeEnabled(Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ModuleTransparencyComputationEnd, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID)
#define FireEtXplatModuleTransparencyComputationEnd_ForContext(pContext, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationEnd(&(pContext)->Context, &ModuleTransparencyComputationEnd, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID) : 0
#define FireEtXplatModuleTransparencyComputationEnd_ForContextAssumeEnabled(pContext, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ModuleTransparencyComputationEnd, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsTreatAsSafe, IsOpportunisticallyCritical, SecurityRuleSet, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleTransparencyComputationEnd _mcgen_PASTE2(McTemplateCoU0zqttttqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TypeTransparencyComputationStart"
//
#define EventXplatEnabledTypeTransparencyComputationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledTypeTransparencyComputationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "TypeTransparencyComputationStart"
//
#define FireEtXplatTypeTransparencyComputationStart(Type, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(TypeTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_TypeTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TypeTransparencyComputationStart, Type, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatTypeTransparencyComputationStart_AssumeEnabled(Type, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TypeTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TypeTransparencyComputationStart, Type, Module, AppDomainID, ClrInstanceID)
#define FireEtXplatTypeTransparencyComputationStart_ForContext(pContext, Type, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TypeTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_TypeTransparencyComputationStart(&(pContext)->Context, &TypeTransparencyComputationStart, Type, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatTypeTransparencyComputationStart_ForContextAssumeEnabled(pContext, Type, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TypeTransparencyComputationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &TypeTransparencyComputationStart, Type, Module, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TypeTransparencyComputationStart _mcgen_PASTE2(McTemplateCoU0zzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TypeTransparencyComputationEnd"
//
#define EventXplatEnabledTypeTransparencyComputationEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledTypeTransparencyComputationEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "TypeTransparencyComputationEnd"
//
#define FireEtXplatTypeTransparencyComputationEnd(Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(TypeTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_TypeTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TypeTransparencyComputationEnd, Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatTypeTransparencyComputationEnd_AssumeEnabled(Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TypeTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TypeTransparencyComputationEnd, Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID)
#define FireEtXplatTypeTransparencyComputationEnd_ForContext(pContext, Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TypeTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_TypeTransparencyComputationEnd(&(pContext)->Context, &TypeTransparencyComputationEnd, Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatTypeTransparencyComputationEnd_ForContextAssumeEnabled(pContext, Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TypeTransparencyComputationEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &TypeTransparencyComputationEnd, Type, Module, AppDomainID, IsAllCritical, IsAllTransparent, IsCritical, IsTreatAsSafe, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TypeTransparencyComputationEnd _mcgen_PASTE2(McTemplateCoU0zzqtttth_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodTransparencyComputationStart"
//
#define EventXplatEnabledMethodTransparencyComputationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledMethodTransparencyComputationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "MethodTransparencyComputationStart"
//
#define FireEtXplatMethodTransparencyComputationStart(Method, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_MethodTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MethodTransparencyComputationStart, Method, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatMethodTransparencyComputationStart_AssumeEnabled(Method, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MethodTransparencyComputationStart, Method, Module, AppDomainID, ClrInstanceID)
#define FireEtXplatMethodTransparencyComputationStart_ForContext(pContext, Method, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_MethodTransparencyComputationStart(&(pContext)->Context, &MethodTransparencyComputationStart, Method, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatMethodTransparencyComputationStart_ForContextAssumeEnabled(pContext, Method, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodTransparencyComputationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &MethodTransparencyComputationStart, Method, Module, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodTransparencyComputationStart _mcgen_PASTE2(McTemplateCoU0zzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodTransparencyComputationEnd"
//
#define EventXplatEnabledMethodTransparencyComputationEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledMethodTransparencyComputationEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "MethodTransparencyComputationEnd"
//
#define FireEtXplatMethodTransparencyComputationEnd(Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_MethodTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MethodTransparencyComputationEnd, Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatMethodTransparencyComputationEnd_AssumeEnabled(Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MethodTransparencyComputationEnd, Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID)
#define FireEtXplatMethodTransparencyComputationEnd_ForContext(pContext, Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_MethodTransparencyComputationEnd(&(pContext)->Context, &MethodTransparencyComputationEnd, Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatMethodTransparencyComputationEnd_ForContextAssumeEnabled(pContext, Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodTransparencyComputationEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &MethodTransparencyComputationEnd, Method, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodTransparencyComputationEnd _mcgen_PASTE2(McTemplateCoU0zzqtth_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FieldTransparencyComputationStart"
//
#define EventXplatEnabledFieldTransparencyComputationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledFieldTransparencyComputationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "FieldTransparencyComputationStart"
//
#define FireEtXplatFieldTransparencyComputationStart(Field, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FieldTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_FieldTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FieldTransparencyComputationStart, Field, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatFieldTransparencyComputationStart_AssumeEnabled(Field, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FieldTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FieldTransparencyComputationStart, Field, Module, AppDomainID, ClrInstanceID)
#define FireEtXplatFieldTransparencyComputationStart_ForContext(pContext, Field, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FieldTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_FieldTransparencyComputationStart(&(pContext)->Context, &FieldTransparencyComputationStart, Field, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatFieldTransparencyComputationStart_ForContextAssumeEnabled(pContext, Field, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FieldTransparencyComputationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FieldTransparencyComputationStart, Field, Module, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FieldTransparencyComputationStart _mcgen_PASTE2(McTemplateCoU0zzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FieldTransparencyComputationEnd"
//
#define EventXplatEnabledFieldTransparencyComputationEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledFieldTransparencyComputationEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "FieldTransparencyComputationEnd"
//
#define FireEtXplatFieldTransparencyComputationEnd(Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FieldTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_FieldTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FieldTransparencyComputationEnd, Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatFieldTransparencyComputationEnd_AssumeEnabled(Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FieldTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FieldTransparencyComputationEnd, Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID)
#define FireEtXplatFieldTransparencyComputationEnd_ForContext(pContext, Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FieldTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_FieldTransparencyComputationEnd(&(pContext)->Context, &FieldTransparencyComputationEnd, Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatFieldTransparencyComputationEnd_ForContextAssumeEnabled(pContext, Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FieldTransparencyComputationEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FieldTransparencyComputationEnd, Field, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FieldTransparencyComputationEnd _mcgen_PASTE2(McTemplateCoU0zzqtth_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TokenTransparencyComputationStart"
//
#define EventXplatEnabledTokenTransparencyComputationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledTokenTransparencyComputationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "TokenTransparencyComputationStart"
//
#define FireEtXplatTokenTransparencyComputationStart(Token, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(TokenTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_TokenTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TokenTransparencyComputationStart, Token, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatTokenTransparencyComputationStart_AssumeEnabled(Token, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TokenTransparencyComputationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TokenTransparencyComputationStart, Token, Module, AppDomainID, ClrInstanceID)
#define FireEtXplatTokenTransparencyComputationStart_ForContext(pContext, Token, Module, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TokenTransparencyComputationStart) \
        ? _mcgen_TEMPLATE_FOR_TokenTransparencyComputationStart(&(pContext)->Context, &TokenTransparencyComputationStart, Token, Module, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatTokenTransparencyComputationStart_ForContextAssumeEnabled(pContext, Token, Module, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TokenTransparencyComputationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &TokenTransparencyComputationStart, Token, Module, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TokenTransparencyComputationStart _mcgen_PASTE2(McTemplateCoU0qzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TokenTransparencyComputationEnd"
//
#define EventXplatEnabledTokenTransparencyComputationEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 6)
#define EventXplatEnabledTokenTransparencyComputationEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 6)

//
// Event write macros for event "TokenTransparencyComputationEnd"
//
#define FireEtXplatTokenTransparencyComputationEnd(Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(TokenTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_TokenTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TokenTransparencyComputationEnd, Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatTokenTransparencyComputationEnd_AssumeEnabled(Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TokenTransparencyComputationEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &TokenTransparencyComputationEnd, Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID)
#define FireEtXplatTokenTransparencyComputationEnd_ForContext(pContext, Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TokenTransparencyComputationEnd) \
        ? _mcgen_TEMPLATE_FOR_TokenTransparencyComputationEnd(&(pContext)->Context, &TokenTransparencyComputationEnd, Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) : 0
#define FireEtXplatTokenTransparencyComputationEnd_ForContextAssumeEnabled(pContext, Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_TokenTransparencyComputationEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &TokenTransparencyComputationEnd, Token, Module, AppDomainID, IsCritical, IsTreatAsSafe, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TokenTransparencyComputationEnd _mcgen_PASTE2(McTemplateCoU0qzqtth_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "NgenBindEvent"
//
#define EventXplatEnabledNgenBindEvent() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 7)
#define EventXplatEnabledNgenBindEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 7)

//
// Event write macros for event "NgenBindEvent"
//
#define FireEtXplatNgenBindEvent(ClrInstanceID, BindingID, ReasonCode, AssemblyName) \
        MCGEN_EVENT_ENABLED(NgenBindEvent) \
        ? _mcgen_TEMPLATE_FOR_NgenBindEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &NgenBindEvent, ClrInstanceID, BindingID, ReasonCode, AssemblyName) : 0
#define FireEtXplatNgenBindEvent_AssumeEnabled(ClrInstanceID, BindingID, ReasonCode, AssemblyName) \
        _mcgen_TEMPLATE_FOR_NgenBindEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &NgenBindEvent, ClrInstanceID, BindingID, ReasonCode, AssemblyName)
#define FireEtXplatNgenBindEvent_ForContext(pContext, ClrInstanceID, BindingID, ReasonCode, AssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, NgenBindEvent) \
        ? _mcgen_TEMPLATE_FOR_NgenBindEvent(&(pContext)->Context, &NgenBindEvent, ClrInstanceID, BindingID, ReasonCode, AssemblyName) : 0
#define FireEtXplatNgenBindEvent_ForContextAssumeEnabled(pContext, ClrInstanceID, BindingID, ReasonCode, AssemblyName) \
        _mcgen_TEMPLATE_FOR_NgenBindEvent(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &NgenBindEvent, ClrInstanceID, BindingID, ReasonCode, AssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_NgenBindEvent _mcgen_PASTE2(McTemplateCoU0hxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "JittedMethodRichDebugInfo"
//
#define EventXplatEnabledJittedMethodRichDebugInfo() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 8)
#define EventXplatEnabledJittedMethodRichDebugInfo_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 8)

//
// Event write macros for event "JittedMethodRichDebugInfo"
//
#define FireEtXplatJittedMethodRichDebugInfo(ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data) \
        MCGEN_EVENT_ENABLED(JittedMethodRichDebugInfo) \
        ? _mcgen_TEMPLATE_FOR_JittedMethodRichDebugInfo(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &JittedMethodRichDebugInfo, ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data) : 0
#define FireEtXplatJittedMethodRichDebugInfo_AssumeEnabled(ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data) \
        _mcgen_TEMPLATE_FOR_JittedMethodRichDebugInfo(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &JittedMethodRichDebugInfo, ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data)
#define FireEtXplatJittedMethodRichDebugInfo_ForContext(pContext, ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, JittedMethodRichDebugInfo) \
        ? _mcgen_TEMPLATE_FOR_JittedMethodRichDebugInfo(&(pContext)->Context, &JittedMethodRichDebugInfo, ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data) : 0
#define FireEtXplatJittedMethodRichDebugInfo_ForContextAssumeEnabled(pContext, ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data) \
        _mcgen_TEMPLATE_FOR_JittedMethodRichDebugInfo(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &JittedMethodRichDebugInfo, ClrInstanceID, MethodID, ReJITID, ILVersionID, ChunkIndex, DataSize, Data)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_JittedMethodRichDebugInfo _mcgen_PASTE2(McTemplateCoU0hxxxqqbr5_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FailFast"
//
#define EventXplatEnabledFailFast() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 9)
#define EventXplatEnabledFailFast_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 9)

//
// Event write macros for event "FailFast"
//
#define FireEtXplatFailFast(FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FailFast) \
        ? _mcgen_TEMPLATE_FOR_FailFast(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FailFast, FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID) : 0
#define FireEtXplatFailFast_AssumeEnabled(FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FailFast(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FailFast, FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID)
#define FireEtXplatFailFast_ForContext(pContext, FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FailFast) \
        ? _mcgen_TEMPLATE_FOR_FailFast(&(pContext)->Context, &FailFast, FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID) : 0
#define FireEtXplatFailFast_ForContextAssumeEnabled(pContext, FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FailFast(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FailFast, FailFastUserMessage, FailedEIP, OSExitCode, ClrExitCode, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FailFast _mcgen_PASTE2(McTemplateCoU0zpqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvFinalizeObject"
//
#define EventXplatEnabledPrvFinalizeObject() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 1)
#define EventXplatEnabledPrvFinalizeObject_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 1)

//
// Event write macros for event "PrvFinalizeObject"
//
#define FireEtXplatPrvFinalizeObject(TypeID, ObjectID, ClrInstanceID, TypeName) \
        MCGEN_EVENT_ENABLED(PrvFinalizeObject) \
        ? _mcgen_TEMPLATE_FOR_PrvFinalizeObject(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvFinalizeObject, TypeID, ObjectID, ClrInstanceID, TypeName) : 0
#define FireEtXplatPrvFinalizeObject_AssumeEnabled(TypeID, ObjectID, ClrInstanceID, TypeName) \
        _mcgen_TEMPLATE_FOR_PrvFinalizeObject(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvFinalizeObject, TypeID, ObjectID, ClrInstanceID, TypeName)
#define FireEtXplatPrvFinalizeObject_ForContext(pContext, TypeID, ObjectID, ClrInstanceID, TypeName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvFinalizeObject) \
        ? _mcgen_TEMPLATE_FOR_PrvFinalizeObject(&(pContext)->Context, &PrvFinalizeObject, TypeID, ObjectID, ClrInstanceID, TypeName) : 0
#define FireEtXplatPrvFinalizeObject_ForContextAssumeEnabled(pContext, TypeID, ObjectID, ClrInstanceID, TypeName) \
        _mcgen_TEMPLATE_FOR_PrvFinalizeObject(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvFinalizeObject, TypeID, ObjectID, ClrInstanceID, TypeName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvFinalizeObject _mcgen_PASTE2(McTemplateCoU0pphz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CCWRefCountChangeAnsi"
//
#define EventXplatEnabledCCWRefCountChangeAnsi() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 10)
#define EventXplatEnabledCCWRefCountChangeAnsi_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 10)

//
// Event write macros for event "CCWRefCountChangeAnsi"
//
#define FireEtXplatCCWRefCountChangeAnsi(HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(CCWRefCountChangeAnsi) \
        ? _mcgen_TEMPLATE_FOR_CCWRefCountChangeAnsi(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CCWRefCountChangeAnsi, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) : 0
#define FireEtXplatCCWRefCountChangeAnsi_AssumeEnabled(HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CCWRefCountChangeAnsi(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CCWRefCountChangeAnsi, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID)
#define FireEtXplatCCWRefCountChangeAnsi_ForContext(pContext, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CCWRefCountChangeAnsi) \
        ? _mcgen_TEMPLATE_FOR_CCWRefCountChangeAnsi(&(pContext)->Context, &CCWRefCountChangeAnsi, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) : 0
#define FireEtXplatCCWRefCountChangeAnsi_ForContextAssumeEnabled(pContext, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CCWRefCountChangeAnsi(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &CCWRefCountChangeAnsi, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CCWRefCountChangeAnsi _mcgen_PASTE2(McTemplateCoU0pppqxsszh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvSetGCHandle"
//
#define EventXplatEnabledPrvSetGCHandle() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 11)
#define EventXplatEnabledPrvSetGCHandle_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 11)

//
// Event write macros for event "PrvSetGCHandle"
//
#define FireEtXplatPrvSetGCHandle(HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrvSetGCHandle) \
        ? _mcgen_TEMPLATE_FOR_PrvSetGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvSetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatPrvSetGCHandle_AssumeEnabled(HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvSetGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvSetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID)
#define FireEtXplatPrvSetGCHandle_ForContext(pContext, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvSetGCHandle) \
        ? _mcgen_TEMPLATE_FOR_PrvSetGCHandle(&(pContext)->Context, &PrvSetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) : 0
#define FireEtXplatPrvSetGCHandle_ForContextAssumeEnabled(pContext, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvSetGCHandle(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvSetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvSetGCHandle _mcgen_PASTE2(McTemplateCoU0ppqqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PrvDestroyGCHandle"
//
#define EventXplatEnabledPrvDestroyGCHandle() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 11)
#define EventXplatEnabledPrvDestroyGCHandle_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 11)

//
// Event write macros for event "PrvDestroyGCHandle"
//
#define FireEtXplatPrvDestroyGCHandle(HandleID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PrvDestroyGCHandle) \
        ? _mcgen_TEMPLATE_FOR_PrvDestroyGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvDestroyGCHandle, HandleID, ClrInstanceID) : 0
#define FireEtXplatPrvDestroyGCHandle_AssumeEnabled(HandleID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvDestroyGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PrvDestroyGCHandle, HandleID, ClrInstanceID)
#define FireEtXplatPrvDestroyGCHandle_ForContext(pContext, HandleID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PrvDestroyGCHandle) \
        ? _mcgen_TEMPLATE_FOR_PrvDestroyGCHandle(&(pContext)->Context, &PrvDestroyGCHandle, HandleID, ClrInstanceID) : 0
#define FireEtXplatPrvDestroyGCHandle_ForContextAssumeEnabled(pContext, HandleID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PrvDestroyGCHandle(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PrvDestroyGCHandle, HandleID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PrvDestroyGCHandle _mcgen_PASTE2(McTemplateCoU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionMessageEvent"
//
#define EventXplatEnabledFusionMessageEvent() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledFusionMessageEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "FusionMessageEvent"
//
#define FireEtXplatFusionMessageEvent(ClrInstanceID, Prepend, Message) \
        MCGEN_EVENT_ENABLED(FusionMessageEvent) \
        ? _mcgen_TEMPLATE_FOR_FusionMessageEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionMessageEvent, ClrInstanceID, Prepend, Message) : 0
#define FireEtXplatFusionMessageEvent_AssumeEnabled(ClrInstanceID, Prepend, Message) \
        _mcgen_TEMPLATE_FOR_FusionMessageEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionMessageEvent, ClrInstanceID, Prepend, Message)
#define FireEtXplatFusionMessageEvent_ForContext(pContext, ClrInstanceID, Prepend, Message) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionMessageEvent) \
        ? _mcgen_TEMPLATE_FOR_FusionMessageEvent(&(pContext)->Context, &FusionMessageEvent, ClrInstanceID, Prepend, Message) : 0
#define FireEtXplatFusionMessageEvent_ForContextAssumeEnabled(pContext, ClrInstanceID, Prepend, Message) \
        _mcgen_TEMPLATE_FOR_FusionMessageEvent(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionMessageEvent, ClrInstanceID, Prepend, Message)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionMessageEvent _mcgen_PASTE2(McTemplateCoU0htz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FusionErrorCodeEvent"
//
#define EventXplatEnabledFusionErrorCodeEvent() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 5)
#define EventXplatEnabledFusionErrorCodeEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 5)

//
// Event write macros for event "FusionErrorCodeEvent"
//
#define FireEtXplatFusionErrorCodeEvent(ClrInstanceID, Category, ErrorCode) \
        MCGEN_EVENT_ENABLED(FusionErrorCodeEvent) \
        ? _mcgen_TEMPLATE_FOR_FusionErrorCodeEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionErrorCodeEvent, ClrInstanceID, Category, ErrorCode) : 0
#define FireEtXplatFusionErrorCodeEvent_AssumeEnabled(ClrInstanceID, Category, ErrorCode) \
        _mcgen_TEMPLATE_FOR_FusionErrorCodeEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &FusionErrorCodeEvent, ClrInstanceID, Category, ErrorCode)
#define FireEtXplatFusionErrorCodeEvent_ForContext(pContext, ClrInstanceID, Category, ErrorCode) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FusionErrorCodeEvent) \
        ? _mcgen_TEMPLATE_FOR_FusionErrorCodeEvent(&(pContext)->Context, &FusionErrorCodeEvent, ClrInstanceID, Category, ErrorCode) : 0
#define FireEtXplatFusionErrorCodeEvent_ForContextAssumeEnabled(pContext, ClrInstanceID, Category, ErrorCode) \
        _mcgen_TEMPLATE_FOR_FusionErrorCodeEvent(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &FusionErrorCodeEvent, ClrInstanceID, Category, ErrorCode)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FusionErrorCodeEvent _mcgen_PASTE2(McTemplateCoU0hqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PinPlugAtGCTime"
//
#define EventXplatEnabledPinPlugAtGCTime() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 1)
#define EventXplatEnabledPinPlugAtGCTime_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 1)

//
// Event write macros for event "PinPlugAtGCTime"
//
#define FireEtXplatPinPlugAtGCTime(PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PinPlugAtGCTime) \
        ? _mcgen_TEMPLATE_FOR_PinPlugAtGCTime(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PinPlugAtGCTime, PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID) : 0
#define FireEtXplatPinPlugAtGCTime_AssumeEnabled(PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PinPlugAtGCTime(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &PinPlugAtGCTime, PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID)
#define FireEtXplatPinPlugAtGCTime_ForContext(pContext, PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PinPlugAtGCTime) \
        ? _mcgen_TEMPLATE_FOR_PinPlugAtGCTime(&(pContext)->Context, &PinPlugAtGCTime, PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID) : 0
#define FireEtXplatPinPlugAtGCTime_ForContextAssumeEnabled(pContext, PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PinPlugAtGCTime(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &PinPlugAtGCTime, PlugStart, PlugEnd, GapBeforeSize, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PinPlugAtGCTime _mcgen_PASTE2(McTemplateCoU0ppph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CCWRefCountChange"
//
#define EventXplatEnabledCCWRefCountChange() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 10)
#define EventXplatEnabledCCWRefCountChange_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 10)

//
// Event write macros for event "CCWRefCountChange"
//
#define FireEtXplatCCWRefCountChange(HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(CCWRefCountChange) \
        ? _mcgen_TEMPLATE_FOR_CCWRefCountChange(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CCWRefCountChange, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) : 0
#define FireEtXplatCCWRefCountChange_AssumeEnabled(HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CCWRefCountChange(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CCWRefCountChange, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID)
#define FireEtXplatCCWRefCountChange_ForContext(pContext, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CCWRefCountChange) \
        ? _mcgen_TEMPLATE_FOR_CCWRefCountChange(&(pContext)->Context, &CCWRefCountChange, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) : 0
#define FireEtXplatCCWRefCountChange_ForContextAssumeEnabled(pContext, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CCWRefCountChange(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &CCWRefCountChange, HandleID, ObjectID, COMInterfacePointer, NewRefCount, AppDomainID, ClassName, NameSpace, Operation, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CCWRefCountChange _mcgen_PASTE2(McTemplateCoU0pppqxzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AllocRequest"
//
#define EventXplatEnabledAllocRequest() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 12)
#define EventXplatEnabledAllocRequest_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 12)

//
// Event write macros for event "AllocRequest"
//
#define FireEtXplatAllocRequest(LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AllocRequest) \
        ? _mcgen_TEMPLATE_FOR_AllocRequest(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllocRequest, LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID) : 0
#define FireEtXplatAllocRequest_AssumeEnabled(LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AllocRequest(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &AllocRequest, LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID)
#define FireEtXplatAllocRequest_ForContext(pContext, LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AllocRequest) \
        ? _mcgen_TEMPLATE_FOR_AllocRequest(&(pContext)->Context, &AllocRequest, LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID) : 0
#define FireEtXplatAllocRequest_ForContextAssumeEnabled(pContext, LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AllocRequest(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &AllocRequest, LoaderHeapPtr, MemoryAddress, RequestSize, Unused1, Unused2, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AllocRequest _mcgen_PASTE2(McTemplateCoU0ppqqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MulticoreJit"
//
#define EventXplatEnabledMulticoreJit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 13)
#define EventXplatEnabledMulticoreJit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 13)

//
// Event write macros for event "MulticoreJit"
//
#define FireEtXplatMulticoreJit(ClrInstanceID, String1, String2, Int1, Int2, Int3) \
        MCGEN_EVENT_ENABLED(MulticoreJit) \
        ? _mcgen_TEMPLATE_FOR_MulticoreJit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MulticoreJit, ClrInstanceID, String1, String2, Int1, Int2, Int3) : 0
#define FireEtXplatMulticoreJit_AssumeEnabled(ClrInstanceID, String1, String2, Int1, Int2, Int3) \
        _mcgen_TEMPLATE_FOR_MulticoreJit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MulticoreJit, ClrInstanceID, String1, String2, Int1, Int2, Int3)
#define FireEtXplatMulticoreJit_ForContext(pContext, ClrInstanceID, String1, String2, Int1, Int2, Int3) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MulticoreJit) \
        ? _mcgen_TEMPLATE_FOR_MulticoreJit(&(pContext)->Context, &MulticoreJit, ClrInstanceID, String1, String2, Int1, Int2, Int3) : 0
#define FireEtXplatMulticoreJit_ForContextAssumeEnabled(pContext, ClrInstanceID, String1, String2, Int1, Int2, Int3) \
        _mcgen_TEMPLATE_FOR_MulticoreJit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &MulticoreJit, ClrInstanceID, String1, String2, Int1, Int2, Int3)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MulticoreJit _mcgen_PASTE2(McTemplateCoU0hzzddd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MulticoreJitMethodCodeReturned"
//
#define EventXplatEnabledMulticoreJitMethodCodeReturned() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 13)
#define EventXplatEnabledMulticoreJitMethodCodeReturned_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 13)

//
// Event write macros for event "MulticoreJitMethodCodeReturned"
//
#define FireEtXplatMulticoreJitMethodCodeReturned(ClrInstanceID, ModuleID, MethodID) \
        MCGEN_EVENT_ENABLED(MulticoreJitMethodCodeReturned) \
        ? _mcgen_TEMPLATE_FOR_MulticoreJitMethodCodeReturned(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MulticoreJitMethodCodeReturned, ClrInstanceID, ModuleID, MethodID) : 0
#define FireEtXplatMulticoreJitMethodCodeReturned_AssumeEnabled(ClrInstanceID, ModuleID, MethodID) \
        _mcgen_TEMPLATE_FOR_MulticoreJitMethodCodeReturned(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &MulticoreJitMethodCodeReturned, ClrInstanceID, ModuleID, MethodID)
#define FireEtXplatMulticoreJitMethodCodeReturned_ForContext(pContext, ClrInstanceID, ModuleID, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MulticoreJitMethodCodeReturned) \
        ? _mcgen_TEMPLATE_FOR_MulticoreJitMethodCodeReturned(&(pContext)->Context, &MulticoreJitMethodCodeReturned, ClrInstanceID, ModuleID, MethodID) : 0
#define FireEtXplatMulticoreJitMethodCodeReturned_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, MethodID) \
        _mcgen_TEMPLATE_FOR_MulticoreJitMethodCodeReturned(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &MulticoreJitMethodCodeReturned, ClrInstanceID, ModuleID, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MulticoreJitMethodCodeReturned _mcgen_PASTE2(McTemplateCoU0hxx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IInspectableRuntimeClassName"
//
#define EventXplatEnabledIInspectableRuntimeClassName() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledIInspectableRuntimeClassName_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "IInspectableRuntimeClassName"
//
#define FireEtXplatIInspectableRuntimeClassName(TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IInspectableRuntimeClassName) \
        ? _mcgen_TEMPLATE_FOR_IInspectableRuntimeClassName(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &IInspectableRuntimeClassName, TypeName, ClrInstanceID) : 0
#define FireEtXplatIInspectableRuntimeClassName_AssumeEnabled(TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IInspectableRuntimeClassName(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &IInspectableRuntimeClassName, TypeName, ClrInstanceID)
#define FireEtXplatIInspectableRuntimeClassName_ForContext(pContext, TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IInspectableRuntimeClassName) \
        ? _mcgen_TEMPLATE_FOR_IInspectableRuntimeClassName(&(pContext)->Context, &IInspectableRuntimeClassName, TypeName, ClrInstanceID) : 0
#define FireEtXplatIInspectableRuntimeClassName_ForContextAssumeEnabled(pContext, TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IInspectableRuntimeClassName(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &IInspectableRuntimeClassName, TypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IInspectableRuntimeClassName _mcgen_PASTE2(McTemplateCoU0zh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WinRTUnbox"
//
#define EventXplatEnabledWinRTUnbox() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledWinRTUnbox_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "WinRTUnbox"
//
#define FireEtXplatWinRTUnbox(TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(WinRTUnbox) \
        ? _mcgen_TEMPLATE_FOR_WinRTUnbox(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &WinRTUnbox, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatWinRTUnbox_AssumeEnabled(TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_WinRTUnbox(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &WinRTUnbox, TypeName, SecondTypeName, ClrInstanceID)
#define FireEtXplatWinRTUnbox_ForContext(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WinRTUnbox) \
        ? _mcgen_TEMPLATE_FOR_WinRTUnbox(&(pContext)->Context, &WinRTUnbox, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatWinRTUnbox_ForContextAssumeEnabled(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_WinRTUnbox(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &WinRTUnbox, TypeName, SecondTypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WinRTUnbox _mcgen_PASTE2(McTemplateCoU0zzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CreateRCW"
//
#define EventXplatEnabledCreateRCW() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledCreateRCW_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "CreateRCW"
//
#define FireEtXplatCreateRCW(TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(CreateRCW) \
        ? _mcgen_TEMPLATE_FOR_CreateRCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CreateRCW, TypeName, ClrInstanceID) : 0
#define FireEtXplatCreateRCW_AssumeEnabled(TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CreateRCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CreateRCW, TypeName, ClrInstanceID)
#define FireEtXplatCreateRCW_ForContext(pContext, TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CreateRCW) \
        ? _mcgen_TEMPLATE_FOR_CreateRCW(&(pContext)->Context, &CreateRCW, TypeName, ClrInstanceID) : 0
#define FireEtXplatCreateRCW_ForContextAssumeEnabled(pContext, TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CreateRCW(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &CreateRCW, TypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CreateRCW _mcgen_PASTE2(McTemplateCoU0zh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RCWVariance"
//
#define EventXplatEnabledRCWVariance() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledRCWVariance_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "RCWVariance"
//
#define FireEtXplatRCWVariance(TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(RCWVariance) \
        ? _mcgen_TEMPLATE_FOR_RCWVariance(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &RCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) : 0
#define FireEtXplatRCWVariance_AssumeEnabled(TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_RCWVariance(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &RCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID)
#define FireEtXplatRCWVariance_ForContext(pContext, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RCWVariance) \
        ? _mcgen_TEMPLATE_FOR_RCWVariance(&(pContext)->Context, &RCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) : 0
#define FireEtXplatRCWVariance_ForContextAssumeEnabled(pContext, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_RCWVariance(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &RCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RCWVariance _mcgen_PASTE2(McTemplateCoU0zzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RCWIEnumerableCasting"
//
#define EventXplatEnabledRCWIEnumerableCasting() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledRCWIEnumerableCasting_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "RCWIEnumerableCasting"
//
#define FireEtXplatRCWIEnumerableCasting(TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(RCWIEnumerableCasting) \
        ? _mcgen_TEMPLATE_FOR_RCWIEnumerableCasting(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &RCWIEnumerableCasting, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatRCWIEnumerableCasting_AssumeEnabled(TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_RCWIEnumerableCasting(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &RCWIEnumerableCasting, TypeName, SecondTypeName, ClrInstanceID)
#define FireEtXplatRCWIEnumerableCasting_ForContext(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RCWIEnumerableCasting) \
        ? _mcgen_TEMPLATE_FOR_RCWIEnumerableCasting(&(pContext)->Context, &RCWIEnumerableCasting, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatRCWIEnumerableCasting_ForContextAssumeEnabled(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_RCWIEnumerableCasting(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &RCWIEnumerableCasting, TypeName, SecondTypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RCWIEnumerableCasting _mcgen_PASTE2(McTemplateCoU0zzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CreateCCW"
//
#define EventXplatEnabledCreateCCW() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledCreateCCW_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "CreateCCW"
//
#define FireEtXplatCreateCCW(TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(CreateCCW) \
        ? _mcgen_TEMPLATE_FOR_CreateCCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CreateCCW, TypeName, ClrInstanceID) : 0
#define FireEtXplatCreateCCW_AssumeEnabled(TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CreateCCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CreateCCW, TypeName, ClrInstanceID)
#define FireEtXplatCreateCCW_ForContext(pContext, TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CreateCCW) \
        ? _mcgen_TEMPLATE_FOR_CreateCCW(&(pContext)->Context, &CreateCCW, TypeName, ClrInstanceID) : 0
#define FireEtXplatCreateCCW_ForContextAssumeEnabled(pContext, TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CreateCCW(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &CreateCCW, TypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CreateCCW _mcgen_PASTE2(McTemplateCoU0zh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CCWVariance"
//
#define EventXplatEnabledCCWVariance() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledCCWVariance_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "CCWVariance"
//
#define FireEtXplatCCWVariance(TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(CCWVariance) \
        ? _mcgen_TEMPLATE_FOR_CCWVariance(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) : 0
#define FireEtXplatCCWVariance_AssumeEnabled(TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CCWVariance(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &CCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID)
#define FireEtXplatCCWVariance_ForContext(pContext, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CCWVariance) \
        ? _mcgen_TEMPLATE_FOR_CCWVariance(&(pContext)->Context, &CCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) : 0
#define FireEtXplatCCWVariance_ForContextAssumeEnabled(pContext, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_CCWVariance(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &CCWVariance, TypeName, InterfaceTypeName, VariantInterfaceTypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CCWVariance _mcgen_PASTE2(McTemplateCoU0zzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ObjectVariantMarshallingToNative"
//
#define EventXplatEnabledObjectVariantMarshallingToNative() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledObjectVariantMarshallingToNative_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "ObjectVariantMarshallingToNative"
//
#define FireEtXplatObjectVariantMarshallingToNative(TypeName, Int1, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ObjectVariantMarshallingToNative) \
        ? _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToNative(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ObjectVariantMarshallingToNative, TypeName, Int1, ClrInstanceID) : 0
#define FireEtXplatObjectVariantMarshallingToNative_AssumeEnabled(TypeName, Int1, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToNative(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ObjectVariantMarshallingToNative, TypeName, Int1, ClrInstanceID)
#define FireEtXplatObjectVariantMarshallingToNative_ForContext(pContext, TypeName, Int1, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ObjectVariantMarshallingToNative) \
        ? _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToNative(&(pContext)->Context, &ObjectVariantMarshallingToNative, TypeName, Int1, ClrInstanceID) : 0
#define FireEtXplatObjectVariantMarshallingToNative_ForContextAssumeEnabled(pContext, TypeName, Int1, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToNative(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ObjectVariantMarshallingToNative, TypeName, Int1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToNative _mcgen_PASTE2(McTemplateCoU0zdh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GetTypeFromGUID"
//
#define EventXplatEnabledGetTypeFromGUID() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledGetTypeFromGUID_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "GetTypeFromGUID"
//
#define FireEtXplatGetTypeFromGUID(TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GetTypeFromGUID) \
        ? _mcgen_TEMPLATE_FOR_GetTypeFromGUID(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetTypeFromGUID, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatGetTypeFromGUID_AssumeEnabled(TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetTypeFromGUID(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetTypeFromGUID, TypeName, SecondTypeName, ClrInstanceID)
#define FireEtXplatGetTypeFromGUID_ForContext(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GetTypeFromGUID) \
        ? _mcgen_TEMPLATE_FOR_GetTypeFromGUID(&(pContext)->Context, &GetTypeFromGUID, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatGetTypeFromGUID_ForContextAssumeEnabled(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetTypeFromGUID(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GetTypeFromGUID, TypeName, SecondTypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GetTypeFromGUID _mcgen_PASTE2(McTemplateCoU0zzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GetTypeFromProgID"
//
#define EventXplatEnabledGetTypeFromProgID() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledGetTypeFromProgID_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "GetTypeFromProgID"
//
#define FireEtXplatGetTypeFromProgID(TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GetTypeFromProgID) \
        ? _mcgen_TEMPLATE_FOR_GetTypeFromProgID(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetTypeFromProgID, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatGetTypeFromProgID_AssumeEnabled(TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetTypeFromProgID(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &GetTypeFromProgID, TypeName, SecondTypeName, ClrInstanceID)
#define FireEtXplatGetTypeFromProgID_ForContext(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GetTypeFromProgID) \
        ? _mcgen_TEMPLATE_FOR_GetTypeFromProgID(&(pContext)->Context, &GetTypeFromProgID, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatGetTypeFromProgID_ForContextAssumeEnabled(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GetTypeFromProgID(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &GetTypeFromProgID, TypeName, SecondTypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GetTypeFromProgID _mcgen_PASTE2(McTemplateCoU0zzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ConvertToCallbackEtw"
//
#define EventXplatEnabledConvertToCallbackEtw() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledConvertToCallbackEtw_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "ConvertToCallbackEtw"
//
#define FireEtXplatConvertToCallbackEtw(TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ConvertToCallbackEtw) \
        ? _mcgen_TEMPLATE_FOR_ConvertToCallbackEtw(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ConvertToCallbackEtw, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatConvertToCallbackEtw_AssumeEnabled(TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ConvertToCallbackEtw(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ConvertToCallbackEtw, TypeName, SecondTypeName, ClrInstanceID)
#define FireEtXplatConvertToCallbackEtw_ForContext(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ConvertToCallbackEtw) \
        ? _mcgen_TEMPLATE_FOR_ConvertToCallbackEtw(&(pContext)->Context, &ConvertToCallbackEtw, TypeName, SecondTypeName, ClrInstanceID) : 0
#define FireEtXplatConvertToCallbackEtw_ForContextAssumeEnabled(pContext, TypeName, SecondTypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ConvertToCallbackEtw(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ConvertToCallbackEtw, TypeName, SecondTypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ConvertToCallbackEtw _mcgen_PASTE2(McTemplateCoU0zzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BeginCreateManagedReference"
//
#define EventXplatEnabledBeginCreateManagedReference() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledBeginCreateManagedReference_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "BeginCreateManagedReference"
//
#define FireEtXplatBeginCreateManagedReference(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(BeginCreateManagedReference) \
        ? _mcgen_TEMPLATE_FOR_BeginCreateManagedReference(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BeginCreateManagedReference, ClrInstanceID) : 0
#define FireEtXplatBeginCreateManagedReference_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BeginCreateManagedReference(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &BeginCreateManagedReference, ClrInstanceID)
#define FireEtXplatBeginCreateManagedReference_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BeginCreateManagedReference) \
        ? _mcgen_TEMPLATE_FOR_BeginCreateManagedReference(&(pContext)->Context, &BeginCreateManagedReference, ClrInstanceID) : 0
#define FireEtXplatBeginCreateManagedReference_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_BeginCreateManagedReference(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &BeginCreateManagedReference, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BeginCreateManagedReference _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "EndCreateManagedReference"
//
#define EventXplatEnabledEndCreateManagedReference() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledEndCreateManagedReference_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "EndCreateManagedReference"
//
#define FireEtXplatEndCreateManagedReference(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(EndCreateManagedReference) \
        ? _mcgen_TEMPLATE_FOR_EndCreateManagedReference(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EndCreateManagedReference, ClrInstanceID) : 0
#define FireEtXplatEndCreateManagedReference_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EndCreateManagedReference(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &EndCreateManagedReference, ClrInstanceID)
#define FireEtXplatEndCreateManagedReference_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EndCreateManagedReference) \
        ? _mcgen_TEMPLATE_FOR_EndCreateManagedReference(&(pContext)->Context, &EndCreateManagedReference, ClrInstanceID) : 0
#define FireEtXplatEndCreateManagedReference_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_EndCreateManagedReference(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &EndCreateManagedReference, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_EndCreateManagedReference _mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ObjectVariantMarshallingToManaged"
//
#define EventXplatEnabledObjectVariantMarshallingToManaged() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimePrivateEnableBits, 14)
#define EventXplatEnabledObjectVariantMarshallingToManaged_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->EnableBits, 14)

//
// Event write macros for event "ObjectVariantMarshallingToManaged"
//
#define FireEtXplatObjectVariantMarshallingToManaged(TypeName, Int1, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ObjectVariantMarshallingToManaged) \
        ? _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToManaged(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ObjectVariantMarshallingToManaged, TypeName, Int1, ClrInstanceID) : 0
#define FireEtXplatObjectVariantMarshallingToManaged_AssumeEnabled(TypeName, Int1, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToManaged(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_Context, &ObjectVariantMarshallingToManaged, TypeName, Int1, ClrInstanceID)
#define FireEtXplatObjectVariantMarshallingToManaged_ForContext(pContext, TypeName, Int1, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ObjectVariantMarshallingToManaged) \
        ? _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToManaged(&(pContext)->Context, &ObjectVariantMarshallingToManaged, TypeName, Int1, ClrInstanceID) : 0
#define FireEtXplatObjectVariantMarshallingToManaged_ForContextAssumeEnabled(pContext, TypeName, Int1, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToManaged(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimePrivate(pContext)->Context, &ObjectVariantMarshallingToManaged, TypeName, Int1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ObjectVariantMarshallingToManaged _mcgen_PASTE2(McTemplateCoU0zdh_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Microsoft-DotNETRuntimeMonoProfiler" event count 65
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 7f442d82-0f1d-5155-4b8c-1529eb2e31c2
EXTERN_C __declspec(selectany) const GUID MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER = {0x7f442d82, 0x0f1d, 0x5155, {0x4b, 0x8c, 0x15, 0x29, 0xeb, 0x2e, 0x31, 0xc2}};

#ifndef MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Traits
#define MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Traits NULL
#endif // MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Traits

//
// Opcodes
//
#define CLR_MONO_PROFILER_CONTEXT_LOADED_OPCODE 0x12
#define CLR_MONO_PROFILER_CONTEXT_UNLOADED_OPCODE 0x13
#define CLR_MONO_PROFILER_APP_DOMAIN_LOADING_OPCODE 0x14
#define CLR_MONO_PROFILER_APP_DOMAIN_LOADED_OPCODE 0x15
#define CLR_MONO_PROFILER_APP_DOMAIN_UNLOADING_OPCODE 0x16
#define CLR_MONO_PROFILER_APP_DOMAIN_UNLOADED_OPCODE 0x17
#define CLR_MONO_PROFILER_APP_DOMAIN_NAME_OPCODE 0x18
#define CLR_MONO_PROFILER_JIT_BEGIN_OPCODE 0x19
#define CLR_MONO_PROFILER_JIT_FAILED_OPCODE 0x1a
#define CLR_MONO_PROFILER_JIT_DONE_OPCODE 0x1b
#define CLR_MONO_PROFILER_JIT_CHUNK_CREATED_OPCODE 0x1c
#define CLR_MONO_PROFILER_JIT_CHUNK_DESTROYED_OPCODE 0x1d
#define CLR_MONO_PROFILER_JIT_CODE_BUFFER_OPCODE 0x1e
#define CLR_MONO_PROFILER_CLASS_LOADING_OPCODE 0x1f
#define CLR_MONO_PROFILER_CLASS_FAILED_OPCODE 0x20
#define CLR_MONO_PROFILER_CLASS_LOADED_OPCODE 0x21
#define CLR_MONO_PROFILER_VTABLE_LOADING_OPCODE 0x22
#define CLR_MONO_PROFILER_VTABLE_FAILED_OPCODE 0x23
#define CLR_MONO_PROFILER_VTABLE_LOADED_OPCODE 0x24
#define CLR_MONO_PROFILER_MODULE_LOADING_OPCODE 0x25
#define CLR_MONO_PROFILER_MODULE_FAILED_OPCODE 0x26
#define CLR_MONO_PROFILER_MODULE_LOADED_OPCODE 0x27
#define CLR_MONO_PROFILER_MODULE_UNLOADING_OPCODE 0x28
#define CLR_MONO_PROFILER_MODULE_UNLOADED_OPCODE 0x29
#define CLR_MONO_PROFILER_ASSEMBLY_LOADING_OPCODE 0x2a
#define CLR_MONO_PROFILER_ASSEMBLY_LOADED_OPCODE 0x2b
#define CLR_MONO_PROFILER_ASSEMBLY_UNLOADING_OPCODE 0x2c
#define CLR_MONO_PROFILER_ASSEMBLY_UNLOADED_OPCODE 0x2d
#define CLR_MONO_PROFILER_METHOD_ENTER_OPCODE 0x2e
#define CLR_MONO_PROFILER_METHOD_LEAVE_OPCODE 0x2f
#define CLR_MONO_PROFILER_METHOD_TAIL_CALL_OPCODE 0x30
#define CLR_MONO_PROFILER_METHOD_EXCEPTION_LEAVE_OPCODE 0x31
#define CLR_MONO_PROFILER_METHOD_FREE_OPCODE 0x32
#define CLR_MONO_PROFILER_METHOD_BEGIN_INVOKE_OPCODE 0x33
#define CLR_MONO_PROFILER_METHOD_END_INVOKE_OPCODE 0x34
#define CLR_MONO_PROFILER_EXCEPTION_THROW_OPCODE 0x35
#define CLR_MONO_PROFILER_EXCEPTION_CLAUSE_OPCODE 0x36
#define CLR_MONO_PROFILER_GC_EVENT_OPCODE 0x37
#define CLR_MONO_PROFILER_GC_ALLOCATION_OPCODE 0x38
#define CLR_MONO_PROFILER_GC_MOVES_OPCODE 0x39
#define CLR_MONO_PROFILER_GC_RESIZE_OPCODE 0x3a
#define CLR_MONO_PROFILER_GC_HANDLE_CREATED_OPCODE 0x3b
#define CLR_MONO_PROFILER_GC_HANDLE_DELETED_OPCODE 0x3c
#define CLR_MONO_PROFILER_GC_FINALIZING_OPCODE 0x3d
#define CLR_MONO_PROFILER_GC_FINALIZED_OPCODE 0x3e
#define CLR_MONO_PROFILER_GC_FINALIZING_OBJECT_OPCODE 0x3f
#define CLR_MONO_PROFILER_GC_FINALIZED_OBJECT_OPCODE 0x40
#define CLR_MONO_PROFILER_GC_ROOT_REGISTER_OPCODE 0x41
#define CLR_MONO_PROFILER_GC_ROOT_UNREGISTER_OPCODE 0x42
#define CLR_MONO_PROFILER_GC_ROOTS_OPCODE 0x43
#define CLR_MONO_PROFILER_GC_HEAP_DUMP_START_OPCODE 0x44
#define CLR_MONO_PROFILER_GC_HEAP_DUMP_STOP_OPCODE 0x45
#define CLR_MONO_PROFILER_GC_HEAP_DUMP_OBJECT_REFERENCE_OPCODE 0x46
#define CLR_MONO_PROFILER_MONITOR_CONTENTION_OPCODE 0x47
#define CLR_MONO_PROFILER_MONITOR_FAILED_OPCODE 0x48
#define CLR_MONO_PROFILER_MONITOR_AQUIRED_OPCODE 0x49
#define CLR_MONO_PROFILER_THREAD_STARTED_OPCODE 0x4a
#define CLR_MONO_PROFILER_THREAD_STOPPING_OPCODE 0x4b
#define CLR_MONO_PROFILER_THREAD_STOPPED_OPCODE 0x4c
#define CLR_MONO_PROFILER_THREAD_EXITED_OPCODE 0x4d
#define CLR_MONO_PROFILER_THREAD_NAME_OPCODE 0x4e
#define CLR_MONO_PROFILER_JIT_DONE_VERBOSE_OPCODE 0x4f
#define CLR_MONO_PROFILER_GC_HEAP_DUMP_VTABLE_CLASS_REFERENCE_OPCODE 0x50

//
// Tasks
//
#define CLR_MONO_PROFILER_TASK 0x1
EXTERN_C __declspec(selectany) const GUID MonoProfilerId = {0x7ec39cc6, 0xc9e3, 0x4328, {0x9b, 0x32, 0xca, 0x6c, 0x5e, 0xc0, 0xef, 0x31}};

//
// Keyword
//
#define CLR_MONO_PROFILER_GC_KEYWORD 0x1
#define CLR_MONO_PROFILER_GC_HANDLE_KEYWORD 0x2
#define CLR_MONO_PROFILER_LOADER_KEYWORD 0x8
#define CLR_MONO_PROFILER_JIT_KEYWORD 0x10
#define CLR_MONO_PROFILER_CONTENTION_KEYWORD 0x4000
#define CLR_MONO_PROFILER_EXCEPTION_KEYWORD 0x8000
#define CLR_MONO_PROFILER_THREADING_KEYWORD 0x10000
#define CLR_MONO_PROFILER_GC_HEAPDUMP_KEYWORD 0x100000
#define CLR_MONO_PROFILER_GC_ALLOCATION_KEYWORD 0x200000
#define CLR_MONO_PROFILER_GC_MOVES_KEYWORD 0x400000
#define CLR_MONO_PROFILER_GC_HEAPCOLLECT_KEYWORD 0x800000
#define CLR_MONO_PROFILER_GC_FINALIZATION_KEYWORD 0x1000000
#define CLR_MONO_PROFILER_GC_RESIZE_KEYWORD 0x2000000
#define CLR_MONO_PROFILER_GC_ROOT_KEYWORD 0x4000000
#define CLR_MONO_PROFILER_GC_HEAPDUMP_VTABLE_CLASS_REFERENCE_KEYWORD 0x8000000
#define CLR_MONO_PROFILER_METHOD_TRACING_KEYWORD 0x20000000
#define CLR_MONO_PROFILER_TYPE_LOADING_KEYWORD 0x8000000000
#define CLR_MONO_PROFILER_MONITOR_KEYWORD 0x10000000000

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerContextLoaded = {0x1, 0x0, 0x0, 0x4, 0x12, 0x1, 0x8};
#define MonoProfilerContextLoaded_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerContextUnloaded = {0x2, 0x0, 0x0, 0x4, 0x13, 0x1, 0x8};
#define MonoProfilerContextUnloaded_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAppDomainLoading = {0x3, 0x0, 0x0, 0x5, 0x14, 0x1, 0x8};
#define MonoProfilerAppDomainLoading_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAppDomainLoaded = {0x4, 0x0, 0x0, 0x4, 0x15, 0x1, 0x8};
#define MonoProfilerAppDomainLoaded_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAppDomainUnloading = {0x5, 0x0, 0x0, 0x5, 0x16, 0x1, 0x8};
#define MonoProfilerAppDomainUnloading_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAppDomainUnloaded = {0x6, 0x0, 0x0, 0x4, 0x17, 0x1, 0x8};
#define MonoProfilerAppDomainUnloaded_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAppDomainName = {0x7, 0x0, 0x0, 0x5, 0x18, 0x1, 0x8};
#define MonoProfilerAppDomainName_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitBegin = {0x8, 0x0, 0x0, 0x4, 0x19, 0x1, 0x10};
#define MonoProfilerJitBegin_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitFailed = {0x9, 0x0, 0x0, 0x4, 0x1a, 0x1, 0x10};
#define MonoProfilerJitFailed_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitDone = {0xa, 0x0, 0x0, 0x4, 0x1b, 0x1, 0x10};
#define MonoProfilerJitDone_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitDone_V1 = {0xa, 0x1, 0x0, 0x4, 0x1b, 0x1, 0x10};
#define MonoProfilerJitDone_V1_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitChunkCreated = {0xb, 0x0, 0x0, 0x4, 0x1c, 0x1, 0x10};
#define MonoProfilerJitChunkCreated_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitChunkDestroyed = {0xc, 0x0, 0x0, 0x4, 0x1d, 0x1, 0x10};
#define MonoProfilerJitChunkDestroyed_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitCodeBuffer = {0xd, 0x0, 0x0, 0x4, 0x1e, 0x1, 0x10};
#define MonoProfilerJitCodeBuffer_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerClassLoading = {0xe, 0x0, 0x0, 0x5, 0x1f, 0x1, 0x8000000000};
#define MonoProfilerClassLoading_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerClassFailed = {0xf, 0x0, 0x0, 0x4, 0x20, 0x1, 0x8000000000};
#define MonoProfilerClassFailed_value 0xf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerClassLoaded = {0x10, 0x0, 0x0, 0x4, 0x21, 0x1, 0x8000000000};
#define MonoProfilerClassLoaded_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerClassLoaded_V1 = {0x10, 0x1, 0x0, 0x4, 0x21, 0x1, 0x8000000000};
#define MonoProfilerClassLoaded_V1_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerVTableLoading = {0x11, 0x0, 0x0, 0x5, 0x22, 0x1, 0x8000000000};
#define MonoProfilerVTableLoading_value 0x11
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerVTableFailed = {0x12, 0x0, 0x0, 0x4, 0x23, 0x1, 0x8000000000};
#define MonoProfilerVTableFailed_value 0x12
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerVTableLoaded = {0x13, 0x0, 0x0, 0x4, 0x24, 0x1, 0x8000000000};
#define MonoProfilerVTableLoaded_value 0x13
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerModuleLoading = {0x14, 0x0, 0x0, 0x5, 0x25, 0x1, 0x8};
#define MonoProfilerModuleLoading_value 0x14
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerModuleFailed = {0x15, 0x0, 0x0, 0x4, 0x26, 0x1, 0x8};
#define MonoProfilerModuleFailed_value 0x15
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerModuleLoaded = {0x16, 0x0, 0x0, 0x4, 0x27, 0x1, 0x8};
#define MonoProfilerModuleLoaded_value 0x16
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerModuleUnloading = {0x17, 0x0, 0x0, 0x5, 0x28, 0x1, 0x8};
#define MonoProfilerModuleUnloading_value 0x17
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerModuleUnloaded = {0x18, 0x0, 0x0, 0x4, 0x29, 0x1, 0x8};
#define MonoProfilerModuleUnloaded_value 0x18
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAssemblyLoading = {0x19, 0x0, 0x0, 0x5, 0x2a, 0x1, 0x8};
#define MonoProfilerAssemblyLoading_value 0x19
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAssemblyLoaded = {0x1a, 0x0, 0x0, 0x4, 0x2b, 0x1, 0x8};
#define MonoProfilerAssemblyLoaded_value 0x1a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAssemblyUnloading = {0x1b, 0x0, 0x0, 0x5, 0x2c, 0x1, 0x8};
#define MonoProfilerAssemblyUnloading_value 0x1b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerAssemblyUnloaded = {0x1c, 0x0, 0x0, 0x4, 0x2d, 0x1, 0x8};
#define MonoProfilerAssemblyUnloaded_value 0x1c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMethodEnter = {0x1d, 0x0, 0x0, 0x4, 0x2e, 0x1, 0x20000000};
#define MonoProfilerMethodEnter_value 0x1d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMethodLeave = {0x1e, 0x0, 0x0, 0x4, 0x2f, 0x1, 0x20000000};
#define MonoProfilerMethodLeave_value 0x1e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMethodTailCall = {0x1f, 0x0, 0x0, 0x4, 0x30, 0x1, 0x20000000};
#define MonoProfilerMethodTailCall_value 0x1f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMethodExceptionLeave = {0x20, 0x0, 0x0, 0x4, 0x31, 0x1, 0x20000000};
#define MonoProfilerMethodExceptionLeave_value 0x20
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMethodFree = {0x21, 0x0, 0x0, 0x4, 0x32, 0x1, 0x20000000};
#define MonoProfilerMethodFree_value 0x21
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMethodBeginInvoke = {0x22, 0x0, 0x0, 0x4, 0x33, 0x1, 0x20000000};
#define MonoProfilerMethodBeginInvoke_value 0x22
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMethodEndInvoke = {0x23, 0x0, 0x0, 0x4, 0x34, 0x1, 0x20000000};
#define MonoProfilerMethodEndInvoke_value 0x23
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerExceptionThrow = {0x24, 0x0, 0x0, 0x4, 0x35, 0x1, 0x8000};
#define MonoProfilerExceptionThrow_value 0x24
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerExceptionClause = {0x25, 0x0, 0x0, 0x4, 0x36, 0x1, 0x8000};
#define MonoProfilerExceptionClause_value 0x25
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCEvent = {0x26, 0x0, 0x0, 0x4, 0x37, 0x1, 0x1};
#define MonoProfilerGCEvent_value 0x26
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCAllocation = {0x27, 0x0, 0x0, 0x4, 0x38, 0x1, 0x200000};
#define MonoProfilerGCAllocation_value 0x27
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCMoves = {0x28, 0x0, 0x0, 0x4, 0x39, 0x1, 0x400000};
#define MonoProfilerGCMoves_value 0x28
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCResize = {0x29, 0x0, 0x0, 0x4, 0x3a, 0x1, 0x2000000};
#define MonoProfilerGCResize_value 0x29
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCHandleCreated = {0x2a, 0x0, 0x0, 0x4, 0x3b, 0x1, 0x2};
#define MonoProfilerGCHandleCreated_value 0x2a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCHandleDeleted = {0x2b, 0x0, 0x0, 0x4, 0x3c, 0x1, 0x2};
#define MonoProfilerGCHandleDeleted_value 0x2b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCFinalizing = {0x2c, 0x0, 0x0, 0x4, 0x3d, 0x1, 0x1000000};
#define MonoProfilerGCFinalizing_value 0x2c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCFinalized = {0x2d, 0x0, 0x0, 0x4, 0x3e, 0x1, 0x1000000};
#define MonoProfilerGCFinalized_value 0x2d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCFinalizingObject = {0x2e, 0x0, 0x0, 0x4, 0x3f, 0x1, 0x1000000};
#define MonoProfilerGCFinalizingObject_value 0x2e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCFinalizedObject = {0x2f, 0x0, 0x0, 0x4, 0x40, 0x1, 0x1000000};
#define MonoProfilerGCFinalizedObject_value 0x2f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCRootRegister = {0x30, 0x0, 0x0, 0x4, 0x41, 0x1, 0x4000000};
#define MonoProfilerGCRootRegister_value 0x30
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCRootUnregister = {0x31, 0x0, 0x0, 0x4, 0x42, 0x1, 0x4000000};
#define MonoProfilerGCRootUnregister_value 0x31
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCRoots = {0x32, 0x0, 0x0, 0x4, 0x43, 0x1, 0x4000000};
#define MonoProfilerGCRoots_value 0x32
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCHeapDumpStart = {0x33, 0x0, 0x0, 0x4, 0x44, 0x1, 0x100000};
#define MonoProfilerGCHeapDumpStart_value 0x33
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCHeapDumpStop = {0x34, 0x0, 0x0, 0x4, 0x45, 0x1, 0x100000};
#define MonoProfilerGCHeapDumpStop_value 0x34
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCHeapDumpObjectReference = {0x35, 0x0, 0x0, 0x4, 0x46, 0x1, 0x100000};
#define MonoProfilerGCHeapDumpObjectReference_value 0x35
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMonitorContention = {0x36, 0x0, 0x0, 0x4, 0x47, 0x1, 0x10000004000};
#define MonoProfilerMonitorContention_value 0x36
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMonitorFailed = {0x37, 0x0, 0x0, 0x4, 0x48, 0x1, 0x10000000000};
#define MonoProfilerMonitorFailed_value 0x37
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerMonitorAcquired = {0x38, 0x0, 0x0, 0x4, 0x49, 0x1, 0x10000000000};
#define MonoProfilerMonitorAcquired_value 0x38
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerThreadStarted = {0x39, 0x0, 0x0, 0x4, 0x4a, 0x1, 0x10000};
#define MonoProfilerThreadStarted_value 0x39
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerThreadStopping = {0x3a, 0x0, 0x0, 0x5, 0x4b, 0x1, 0x10000};
#define MonoProfilerThreadStopping_value 0x3a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerThreadStopped = {0x3b, 0x0, 0x0, 0x4, 0x4c, 0x1, 0x10000};
#define MonoProfilerThreadStopped_value 0x3b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerThreadExited = {0x3c, 0x0, 0x0, 0x4, 0x4d, 0x1, 0x10000};
#define MonoProfilerThreadExited_value 0x3c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerThreadName = {0x3d, 0x0, 0x0, 0x5, 0x4e, 0x1, 0x10000};
#define MonoProfilerThreadName_value 0x3d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerJitDoneVerbose = {0x3e, 0x0, 0x0, 0x5, 0x4f, 0x1, 0x10};
#define MonoProfilerJitDoneVerbose_value 0x3e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MonoProfilerGCHeapDumpVTableClassReference = {0x3f, 0x0, 0x0, 0x4, 0x50, 0x1, 0x8000000};
#define MonoProfilerGCHeapDumpVTableClassReference_value 0x3f

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Microsoft_DotNETRuntimeMonoProfilerEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Microsoft_DotNETRuntimeMonoProfilerKeywords[21] = {0x8, 0x8, 0x10, 0x8000000000, 0x8000000000, 0x20000000, 0x8000, 0x1, 0x200000, 0x400000, 0x2000000, 0x2, 0x1000000, 0x4000000, 0x100000, 0x10000004000, 0x10000000000, 0x10000, 0x10000, 0x10, 0x8000000};
EXTERN_C __declspec(selectany) const unsigned char Microsoft_DotNETRuntimeMonoProfilerLevels[21] = {4, 5, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context = {0, (ULONG_PTR)MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 21, Microsoft_DotNETRuntimeMonoProfilerEnableBits, Microsoft_DotNETRuntimeMonoProfilerKeywords, Microsoft_DotNETRuntimeMonoProfilerLevels};

//
// Provider REGHANDLE
//
#define Microsoft_DotNETRuntimeMonoProfilerHandle (MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterMicrosoft_DotNETRuntimeMonoProfiler
#define EventRegisterMicrosoft_DotNETRuntimeMonoProfiler() McGenEventRegister(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER, McGenControlCallbackV2, &MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &Microsoft_DotNETRuntimeMonoProfilerHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidMicrosoft_DotNETRuntimeMonoProfiler
#define EventRegisterByGuidMicrosoft_DotNETRuntimeMonoProfiler(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &Microsoft_DotNETRuntimeMonoProfilerHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterMicrosoft_DotNETRuntimeMonoProfiler
#define EventUnregisterMicrosoft_DotNETRuntimeMonoProfiler() McGenEventUnregister(&Microsoft_DotNETRuntimeMonoProfilerHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Microsoft_DotNETRuntimeMonoProfiler));
// - Caller registers the provider, e.g. EventRegisterMicrosoft_DotNETRuntimeMonoProfiler_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterMicrosoft_DotNETRuntimeMonoProfiler_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Microsoft_DotNETRuntimeMonoProfiler {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Microsoft_DotNETRuntimeMonoProfilerHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Microsoft_DotNETRuntimeMonoProfiler;

#define EventRegisterMicrosoft_DotNETRuntimeMonoProfiler_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_DotNETRuntimeMonoProfiler_, MCGEN_EVENTREGISTER)(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER, pContext)
#define EventRegisterByGuidMicrosoft_DotNETRuntimeMonoProfiler_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_DotNETRuntimeMonoProfiler_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterMicrosoft_DotNETRuntimeMonoProfiler_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Microsoft_DotNETRuntimeMonoProfilerHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_DotNETRuntimeMonoProfiler_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Microsoft_DotNETRuntimeMonoProfiler* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Traits;
    pContext->Context.EnableBitsCount = 21;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Microsoft_DotNETRuntimeMonoProfilerKeywords;
    pContext->Context.EnableLevel = Microsoft_DotNETRuntimeMonoProfilerLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Microsoft_DotNETRuntimeMonoProfiler*
_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(_In_ McGenContext_Microsoft_DotNETRuntimeMonoProfiler* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "MonoProfilerContextLoaded"
//
#define EventXplatEnabledMonoProfilerContextLoaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerContextLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerContextLoaded"
//
#define FireEtXplatMonoProfilerContextLoaded(ObjectID, AppDomainID, ContextID) \
        MCGEN_EVENT_ENABLED(MonoProfilerContextLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerContextLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerContextLoaded, ObjectID, AppDomainID, ContextID) : 0
#define FireEtXplatMonoProfilerContextLoaded_AssumeEnabled(ObjectID, AppDomainID, ContextID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerContextLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerContextLoaded, ObjectID, AppDomainID, ContextID)
#define FireEtXplatMonoProfilerContextLoaded_ForContext(pContext, ObjectID, AppDomainID, ContextID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerContextLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerContextLoaded(&(pContext)->Context, &MonoProfilerContextLoaded, ObjectID, AppDomainID, ContextID) : 0
#define FireEtXplatMonoProfilerContextLoaded_ForContextAssumeEnabled(pContext, ObjectID, AppDomainID, ContextID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerContextLoaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerContextLoaded, ObjectID, AppDomainID, ContextID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerContextLoaded _mcgen_PASTE2(McTemplateCoU0pxx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerContextUnloaded"
//
#define EventXplatEnabledMonoProfilerContextUnloaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerContextUnloaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerContextUnloaded"
//
#define FireEtXplatMonoProfilerContextUnloaded(ObjectID, AppDomainID, ContextID) \
        MCGEN_EVENT_ENABLED(MonoProfilerContextUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerContextUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerContextUnloaded, ObjectID, AppDomainID, ContextID) : 0
#define FireEtXplatMonoProfilerContextUnloaded_AssumeEnabled(ObjectID, AppDomainID, ContextID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerContextUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerContextUnloaded, ObjectID, AppDomainID, ContextID)
#define FireEtXplatMonoProfilerContextUnloaded_ForContext(pContext, ObjectID, AppDomainID, ContextID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerContextUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerContextUnloaded(&(pContext)->Context, &MonoProfilerContextUnloaded, ObjectID, AppDomainID, ContextID) : 0
#define FireEtXplatMonoProfilerContextUnloaded_ForContextAssumeEnabled(pContext, ObjectID, AppDomainID, ContextID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerContextUnloaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerContextUnloaded, ObjectID, AppDomainID, ContextID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerContextUnloaded _mcgen_PASTE2(McTemplateCoU0pxx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAppDomainLoading"
//
#define EventXplatEnabledMonoProfilerAppDomainLoading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 1)
#define EventXplatEnabledMonoProfilerAppDomainLoading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 1)

//
// Event write macros for event "MonoProfilerAppDomainLoading"
//
#define FireEtXplatMonoProfilerAppDomainLoading(AppDomainID) \
        MCGEN_EVENT_ENABLED(MonoProfilerAppDomainLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainLoading, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainLoading_AssumeEnabled(AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainLoading, AppDomainID)
#define FireEtXplatMonoProfilerAppDomainLoading_ForContext(pContext, AppDomainID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAppDomainLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoading(&(pContext)->Context, &MonoProfilerAppDomainLoading, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainLoading_ForContextAssumeEnabled(pContext, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAppDomainLoading, AppDomainID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoading _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAppDomainLoaded"
//
#define EventXplatEnabledMonoProfilerAppDomainLoaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerAppDomainLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerAppDomainLoaded"
//
#define FireEtXplatMonoProfilerAppDomainLoaded(AppDomainID) \
        MCGEN_EVENT_ENABLED(MonoProfilerAppDomainLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainLoaded, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainLoaded_AssumeEnabled(AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainLoaded, AppDomainID)
#define FireEtXplatMonoProfilerAppDomainLoaded_ForContext(pContext, AppDomainID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAppDomainLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoaded(&(pContext)->Context, &MonoProfilerAppDomainLoaded, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainLoaded_ForContextAssumeEnabled(pContext, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAppDomainLoaded, AppDomainID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainLoaded _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAppDomainUnloading"
//
#define EventXplatEnabledMonoProfilerAppDomainUnloading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 1)
#define EventXplatEnabledMonoProfilerAppDomainUnloading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 1)

//
// Event write macros for event "MonoProfilerAppDomainUnloading"
//
#define FireEtXplatMonoProfilerAppDomainUnloading(AppDomainID) \
        MCGEN_EVENT_ENABLED(MonoProfilerAppDomainUnloading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainUnloading, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainUnloading_AssumeEnabled(AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainUnloading, AppDomainID)
#define FireEtXplatMonoProfilerAppDomainUnloading_ForContext(pContext, AppDomainID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAppDomainUnloading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloading(&(pContext)->Context, &MonoProfilerAppDomainUnloading, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainUnloading_ForContextAssumeEnabled(pContext, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAppDomainUnloading, AppDomainID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloading _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAppDomainUnloaded"
//
#define EventXplatEnabledMonoProfilerAppDomainUnloaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerAppDomainUnloaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerAppDomainUnloaded"
//
#define FireEtXplatMonoProfilerAppDomainUnloaded(AppDomainID) \
        MCGEN_EVENT_ENABLED(MonoProfilerAppDomainUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainUnloaded, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainUnloaded_AssumeEnabled(AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainUnloaded, AppDomainID)
#define FireEtXplatMonoProfilerAppDomainUnloaded_ForContext(pContext, AppDomainID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAppDomainUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloaded(&(pContext)->Context, &MonoProfilerAppDomainUnloaded, AppDomainID) : 0
#define FireEtXplatMonoProfilerAppDomainUnloaded_ForContextAssumeEnabled(pContext, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAppDomainUnloaded, AppDomainID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainUnloaded _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAppDomainName"
//
#define EventXplatEnabledMonoProfilerAppDomainName() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 1)
#define EventXplatEnabledMonoProfilerAppDomainName_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 1)

//
// Event write macros for event "MonoProfilerAppDomainName"
//
#define FireEtXplatMonoProfilerAppDomainName(AppDomainID, AppDomainName) \
        MCGEN_EVENT_ENABLED(MonoProfilerAppDomainName) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainName(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainName, AppDomainID, AppDomainName) : 0
#define FireEtXplatMonoProfilerAppDomainName_AssumeEnabled(AppDomainID, AppDomainName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainName(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAppDomainName, AppDomainID, AppDomainName)
#define FireEtXplatMonoProfilerAppDomainName_ForContext(pContext, AppDomainID, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAppDomainName) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainName(&(pContext)->Context, &MonoProfilerAppDomainName, AppDomainID, AppDomainName) : 0
#define FireEtXplatMonoProfilerAppDomainName_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainName(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAppDomainName, AppDomainID, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAppDomainName _mcgen_PASTE2(McTemplateCoU0xz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitBegin"
//
#define EventXplatEnabledMonoProfilerJitBegin() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 2)
#define EventXplatEnabledMonoProfilerJitBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 2)

//
// Event write macros for event "MonoProfilerJitBegin"
//
#define FireEtXplatMonoProfilerJitBegin(MethodID, ModuleID, MethodToken) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitBegin) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitBegin(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitBegin, MethodID, ModuleID, MethodToken) : 0
#define FireEtXplatMonoProfilerJitBegin_AssumeEnabled(MethodID, ModuleID, MethodToken) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitBegin(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitBegin, MethodID, ModuleID, MethodToken)
#define FireEtXplatMonoProfilerJitBegin_ForContext(pContext, MethodID, ModuleID, MethodToken) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitBegin) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitBegin(&(pContext)->Context, &MonoProfilerJitBegin, MethodID, ModuleID, MethodToken) : 0
#define FireEtXplatMonoProfilerJitBegin_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitBegin(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitBegin, MethodID, ModuleID, MethodToken)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitBegin _mcgen_PASTE2(McTemplateCoU0xxq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitFailed"
//
#define EventXplatEnabledMonoProfilerJitFailed() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 2)
#define EventXplatEnabledMonoProfilerJitFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 2)

//
// Event write macros for event "MonoProfilerJitFailed"
//
#define FireEtXplatMonoProfilerJitFailed(MethodID, ModuleID, MethodToken) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitFailed, MethodID, ModuleID, MethodToken) : 0
#define FireEtXplatMonoProfilerJitFailed_AssumeEnabled(MethodID, ModuleID, MethodToken) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitFailed, MethodID, ModuleID, MethodToken)
#define FireEtXplatMonoProfilerJitFailed_ForContext(pContext, MethodID, ModuleID, MethodToken) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitFailed(&(pContext)->Context, &MonoProfilerJitFailed, MethodID, ModuleID, MethodToken) : 0
#define FireEtXplatMonoProfilerJitFailed_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitFailed(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitFailed, MethodID, ModuleID, MethodToken)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitFailed _mcgen_PASTE2(McTemplateCoU0xxq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitDone"
//
#define EventXplatEnabledMonoProfilerJitDone() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 2)
#define EventXplatEnabledMonoProfilerJitDone_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 2)

//
// Event write macros for event "MonoProfilerJitDone"
//
#define FireEtXplatMonoProfilerJitDone(MethodID, ModuleID, MethodToken) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitDone) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitDone(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitDone, MethodID, ModuleID, MethodToken) : 0
#define FireEtXplatMonoProfilerJitDone_AssumeEnabled(MethodID, ModuleID, MethodToken) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitDone(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitDone, MethodID, ModuleID, MethodToken)
#define FireEtXplatMonoProfilerJitDone_ForContext(pContext, MethodID, ModuleID, MethodToken) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitDone) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitDone(&(pContext)->Context, &MonoProfilerJitDone, MethodID, ModuleID, MethodToken) : 0
#define FireEtXplatMonoProfilerJitDone_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitDone(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitDone, MethodID, ModuleID, MethodToken)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitDone _mcgen_PASTE2(McTemplateCoU0xxq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitDone_V1"
//
#define EventXplatEnabledMonoProfilerJitDone_V1() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 2)
#define EventXplatEnabledMonoProfilerJitDone_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 2)

//
// Event write macros for event "MonoProfilerJitDone_V1"
//
#define FireEtXplatMonoProfilerJitDone_V1(MethodID, ModuleID, MethodToken, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitDone_V1) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitDone_V1(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitDone_V1, MethodID, ModuleID, MethodToken, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerJitDone_V1_AssumeEnabled(MethodID, ModuleID, MethodToken, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitDone_V1(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitDone_V1, MethodID, ModuleID, MethodToken, Count, Values_Len_, Values)
#define FireEtXplatMonoProfilerJitDone_V1_ForContext(pContext, MethodID, ModuleID, MethodToken, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitDone_V1) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitDone_V1(&(pContext)->Context, &MonoProfilerJitDone_V1, MethodID, ModuleID, MethodToken, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerJitDone_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitDone_V1(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitDone_V1, MethodID, ModuleID, MethodToken, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitDone_V1 _mcgen_PASTE2(McTemplateCoU0xxqqNR3_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitChunkCreated"
//
#define EventXplatEnabledMonoProfilerJitChunkCreated() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 2)
#define EventXplatEnabledMonoProfilerJitChunkCreated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 2)

//
// Event write macros for event "MonoProfilerJitChunkCreated"
//
#define FireEtXplatMonoProfilerJitChunkCreated(ChunkID, ChunkSize) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitChunkCreated) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkCreated(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitChunkCreated, ChunkID, ChunkSize) : 0
#define FireEtXplatMonoProfilerJitChunkCreated_AssumeEnabled(ChunkID, ChunkSize) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkCreated(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitChunkCreated, ChunkID, ChunkSize)
#define FireEtXplatMonoProfilerJitChunkCreated_ForContext(pContext, ChunkID, ChunkSize) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitChunkCreated) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkCreated(&(pContext)->Context, &MonoProfilerJitChunkCreated, ChunkID, ChunkSize) : 0
#define FireEtXplatMonoProfilerJitChunkCreated_ForContextAssumeEnabled(pContext, ChunkID, ChunkSize) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkCreated(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitChunkCreated, ChunkID, ChunkSize)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkCreated _mcgen_PASTE2(McTemplateCoU0px_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitChunkDestroyed"
//
#define EventXplatEnabledMonoProfilerJitChunkDestroyed() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 2)
#define EventXplatEnabledMonoProfilerJitChunkDestroyed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 2)

//
// Event write macros for event "MonoProfilerJitChunkDestroyed"
//
#define FireEtXplatMonoProfilerJitChunkDestroyed(ChunkID) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitChunkDestroyed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkDestroyed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitChunkDestroyed, ChunkID) : 0
#define FireEtXplatMonoProfilerJitChunkDestroyed_AssumeEnabled(ChunkID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkDestroyed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitChunkDestroyed, ChunkID)
#define FireEtXplatMonoProfilerJitChunkDestroyed_ForContext(pContext, ChunkID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitChunkDestroyed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkDestroyed(&(pContext)->Context, &MonoProfilerJitChunkDestroyed, ChunkID) : 0
#define FireEtXplatMonoProfilerJitChunkDestroyed_ForContextAssumeEnabled(pContext, ChunkID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkDestroyed(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitChunkDestroyed, ChunkID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitChunkDestroyed _mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitCodeBuffer"
//
#define EventXplatEnabledMonoProfilerJitCodeBuffer() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 2)
#define EventXplatEnabledMonoProfilerJitCodeBuffer_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 2)

//
// Event write macros for event "MonoProfilerJitCodeBuffer"
//
#define FireEtXplatMonoProfilerJitCodeBuffer(BufferID, BufferSize, BufferType) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitCodeBuffer) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitCodeBuffer(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitCodeBuffer, BufferID, BufferSize, BufferType) : 0
#define FireEtXplatMonoProfilerJitCodeBuffer_AssumeEnabled(BufferID, BufferSize, BufferType) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitCodeBuffer(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitCodeBuffer, BufferID, BufferSize, BufferType)
#define FireEtXplatMonoProfilerJitCodeBuffer_ForContext(pContext, BufferID, BufferSize, BufferType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitCodeBuffer) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitCodeBuffer(&(pContext)->Context, &MonoProfilerJitCodeBuffer, BufferID, BufferSize, BufferType) : 0
#define FireEtXplatMonoProfilerJitCodeBuffer_ForContextAssumeEnabled(pContext, BufferID, BufferSize, BufferType) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitCodeBuffer(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitCodeBuffer, BufferID, BufferSize, BufferType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitCodeBuffer _mcgen_PASTE2(McTemplateCoU0pxu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerClassLoading"
//
#define EventXplatEnabledMonoProfilerClassLoading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 3)
#define EventXplatEnabledMonoProfilerClassLoading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 3)

//
// Event write macros for event "MonoProfilerClassLoading"
//
#define FireEtXplatMonoProfilerClassLoading(ClassID, ModuleID) \
        MCGEN_EVENT_ENABLED(MonoProfilerClassLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassLoading, ClassID, ModuleID) : 0
#define FireEtXplatMonoProfilerClassLoading_AssumeEnabled(ClassID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassLoading, ClassID, ModuleID)
#define FireEtXplatMonoProfilerClassLoading_ForContext(pContext, ClassID, ModuleID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerClassLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassLoading(&(pContext)->Context, &MonoProfilerClassLoading, ClassID, ModuleID) : 0
#define FireEtXplatMonoProfilerClassLoading_ForContextAssumeEnabled(pContext, ClassID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassLoading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerClassLoading, ClassID, ModuleID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerClassLoading _mcgen_PASTE2(McTemplateCoU0xx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerClassFailed"
//
#define EventXplatEnabledMonoProfilerClassFailed() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 4)
#define EventXplatEnabledMonoProfilerClassFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 4)

//
// Event write macros for event "MonoProfilerClassFailed"
//
#define FireEtXplatMonoProfilerClassFailed(ClassID, ModuleID) \
        MCGEN_EVENT_ENABLED(MonoProfilerClassFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassFailed, ClassID, ModuleID) : 0
#define FireEtXplatMonoProfilerClassFailed_AssumeEnabled(ClassID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassFailed, ClassID, ModuleID)
#define FireEtXplatMonoProfilerClassFailed_ForContext(pContext, ClassID, ModuleID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerClassFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassFailed(&(pContext)->Context, &MonoProfilerClassFailed, ClassID, ModuleID) : 0
#define FireEtXplatMonoProfilerClassFailed_ForContextAssumeEnabled(pContext, ClassID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassFailed(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerClassFailed, ClassID, ModuleID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerClassFailed _mcgen_PASTE2(McTemplateCoU0xx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerClassLoaded"
//
#define EventXplatEnabledMonoProfilerClassLoaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 4)
#define EventXplatEnabledMonoProfilerClassLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 4)

//
// Event write macros for event "MonoProfilerClassLoaded"
//
#define FireEtXplatMonoProfilerClassLoaded(ClassID, ModuleID, ClassName) \
        MCGEN_EVENT_ENABLED(MonoProfilerClassLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassLoaded, ClassID, ModuleID, ClassName) : 0
#define FireEtXplatMonoProfilerClassLoaded_AssumeEnabled(ClassID, ModuleID, ClassName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassLoaded, ClassID, ModuleID, ClassName)
#define FireEtXplatMonoProfilerClassLoaded_ForContext(pContext, ClassID, ModuleID, ClassName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerClassLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded(&(pContext)->Context, &MonoProfilerClassLoaded, ClassID, ModuleID, ClassName) : 0
#define FireEtXplatMonoProfilerClassLoaded_ForContextAssumeEnabled(pContext, ClassID, ModuleID, ClassName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerClassLoaded, ClassID, ModuleID, ClassName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded _mcgen_PASTE2(McTemplateCoU0xxz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerClassLoaded_V1"
//
#define EventXplatEnabledMonoProfilerClassLoaded_V1() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 4)
#define EventXplatEnabledMonoProfilerClassLoaded_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 4)

//
// Event write macros for event "MonoProfilerClassLoaded_V1"
//
#define FireEtXplatMonoProfilerClassLoaded_V1(ClassID, ModuleID, ClassName, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(MonoProfilerClassLoaded_V1) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded_V1(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassLoaded_V1, ClassID, ModuleID, ClassName, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerClassLoaded_V1_AssumeEnabled(ClassID, ModuleID, ClassName, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded_V1(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerClassLoaded_V1, ClassID, ModuleID, ClassName, Count, Values_Len_, Values)
#define FireEtXplatMonoProfilerClassLoaded_V1_ForContext(pContext, ClassID, ModuleID, ClassName, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerClassLoaded_V1) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded_V1(&(pContext)->Context, &MonoProfilerClassLoaded_V1, ClassID, ModuleID, ClassName, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerClassLoaded_V1_ForContextAssumeEnabled(pContext, ClassID, ModuleID, ClassName, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded_V1(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerClassLoaded_V1, ClassID, ModuleID, ClassName, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerClassLoaded_V1 _mcgen_PASTE2(McTemplateCoU0xxzqNR3_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerVTableLoading"
//
#define EventXplatEnabledMonoProfilerVTableLoading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 3)
#define EventXplatEnabledMonoProfilerVTableLoading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 3)

//
// Event write macros for event "MonoProfilerVTableLoading"
//
#define FireEtXplatMonoProfilerVTableLoading(VTableID, ClassID, AppDomainID) \
        MCGEN_EVENT_ENABLED(MonoProfilerVTableLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerVTableLoading, VTableID, ClassID, AppDomainID) : 0
#define FireEtXplatMonoProfilerVTableLoading_AssumeEnabled(VTableID, ClassID, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerVTableLoading, VTableID, ClassID, AppDomainID)
#define FireEtXplatMonoProfilerVTableLoading_ForContext(pContext, VTableID, ClassID, AppDomainID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerVTableLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoading(&(pContext)->Context, &MonoProfilerVTableLoading, VTableID, ClassID, AppDomainID) : 0
#define FireEtXplatMonoProfilerVTableLoading_ForContextAssumeEnabled(pContext, VTableID, ClassID, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerVTableLoading, VTableID, ClassID, AppDomainID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoading _mcgen_PASTE2(McTemplateCoU0xxx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerVTableFailed"
//
#define EventXplatEnabledMonoProfilerVTableFailed() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 4)
#define EventXplatEnabledMonoProfilerVTableFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 4)

//
// Event write macros for event "MonoProfilerVTableFailed"
//
#define FireEtXplatMonoProfilerVTableFailed(VTableID, ClassID, AppDomainID) \
        MCGEN_EVENT_ENABLED(MonoProfilerVTableFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerVTableFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerVTableFailed, VTableID, ClassID, AppDomainID) : 0
#define FireEtXplatMonoProfilerVTableFailed_AssumeEnabled(VTableID, ClassID, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerVTableFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerVTableFailed, VTableID, ClassID, AppDomainID)
#define FireEtXplatMonoProfilerVTableFailed_ForContext(pContext, VTableID, ClassID, AppDomainID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerVTableFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerVTableFailed(&(pContext)->Context, &MonoProfilerVTableFailed, VTableID, ClassID, AppDomainID) : 0
#define FireEtXplatMonoProfilerVTableFailed_ForContextAssumeEnabled(pContext, VTableID, ClassID, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerVTableFailed(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerVTableFailed, VTableID, ClassID, AppDomainID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerVTableFailed _mcgen_PASTE2(McTemplateCoU0xxx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerVTableLoaded"
//
#define EventXplatEnabledMonoProfilerVTableLoaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 4)
#define EventXplatEnabledMonoProfilerVTableLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 4)

//
// Event write macros for event "MonoProfilerVTableLoaded"
//
#define FireEtXplatMonoProfilerVTableLoaded(VTableID, ClassID, AppDomainID) \
        MCGEN_EVENT_ENABLED(MonoProfilerVTableLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerVTableLoaded, VTableID, ClassID, AppDomainID) : 0
#define FireEtXplatMonoProfilerVTableLoaded_AssumeEnabled(VTableID, ClassID, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerVTableLoaded, VTableID, ClassID, AppDomainID)
#define FireEtXplatMonoProfilerVTableLoaded_ForContext(pContext, VTableID, ClassID, AppDomainID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerVTableLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoaded(&(pContext)->Context, &MonoProfilerVTableLoaded, VTableID, ClassID, AppDomainID) : 0
#define FireEtXplatMonoProfilerVTableLoaded_ForContextAssumeEnabled(pContext, VTableID, ClassID, AppDomainID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerVTableLoaded, VTableID, ClassID, AppDomainID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerVTableLoaded _mcgen_PASTE2(McTemplateCoU0xxx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerModuleLoading"
//
#define EventXplatEnabledMonoProfilerModuleLoading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 1)
#define EventXplatEnabledMonoProfilerModuleLoading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 1)

//
// Event write macros for event "MonoProfilerModuleLoading"
//
#define FireEtXplatMonoProfilerModuleLoading(ModuleID) \
        MCGEN_EVENT_ENABLED(MonoProfilerModuleLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleLoading, ModuleID) : 0
#define FireEtXplatMonoProfilerModuleLoading_AssumeEnabled(ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleLoading, ModuleID)
#define FireEtXplatMonoProfilerModuleLoading_ForContext(pContext, ModuleID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerModuleLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoading(&(pContext)->Context, &MonoProfilerModuleLoading, ModuleID) : 0
#define FireEtXplatMonoProfilerModuleLoading_ForContextAssumeEnabled(pContext, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerModuleLoading, ModuleID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoading _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerModuleFailed"
//
#define EventXplatEnabledMonoProfilerModuleFailed() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerModuleFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerModuleFailed"
//
#define FireEtXplatMonoProfilerModuleFailed(ModuleID) \
        MCGEN_EVENT_ENABLED(MonoProfilerModuleFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleFailed, ModuleID) : 0
#define FireEtXplatMonoProfilerModuleFailed_AssumeEnabled(ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleFailed, ModuleID)
#define FireEtXplatMonoProfilerModuleFailed_ForContext(pContext, ModuleID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerModuleFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleFailed(&(pContext)->Context, &MonoProfilerModuleFailed, ModuleID) : 0
#define FireEtXplatMonoProfilerModuleFailed_ForContextAssumeEnabled(pContext, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleFailed(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerModuleFailed, ModuleID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerModuleFailed _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerModuleLoaded"
//
#define EventXplatEnabledMonoProfilerModuleLoaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerModuleLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerModuleLoaded"
//
#define FireEtXplatMonoProfilerModuleLoaded(ModuleID, ModuleName, ModuleSignature) \
        MCGEN_EVENT_ENABLED(MonoProfilerModuleLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleLoaded, ModuleID, ModuleName, ModuleSignature) : 0
#define FireEtXplatMonoProfilerModuleLoaded_AssumeEnabled(ModuleID, ModuleName, ModuleSignature) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleLoaded, ModuleID, ModuleName, ModuleSignature)
#define FireEtXplatMonoProfilerModuleLoaded_ForContext(pContext, ModuleID, ModuleName, ModuleSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerModuleLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoaded(&(pContext)->Context, &MonoProfilerModuleLoaded, ModuleID, ModuleName, ModuleSignature) : 0
#define FireEtXplatMonoProfilerModuleLoaded_ForContextAssumeEnabled(pContext, ModuleID, ModuleName, ModuleSignature) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerModuleLoaded, ModuleID, ModuleName, ModuleSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerModuleLoaded _mcgen_PASTE2(McTemplateCoU0xzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerModuleUnloading"
//
#define EventXplatEnabledMonoProfilerModuleUnloading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 1)
#define EventXplatEnabledMonoProfilerModuleUnloading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 1)

//
// Event write macros for event "MonoProfilerModuleUnloading"
//
#define FireEtXplatMonoProfilerModuleUnloading(ModuleID) \
        MCGEN_EVENT_ENABLED(MonoProfilerModuleUnloading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleUnloading, ModuleID) : 0
#define FireEtXplatMonoProfilerModuleUnloading_AssumeEnabled(ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleUnloading, ModuleID)
#define FireEtXplatMonoProfilerModuleUnloading_ForContext(pContext, ModuleID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerModuleUnloading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloading(&(pContext)->Context, &MonoProfilerModuleUnloading, ModuleID) : 0
#define FireEtXplatMonoProfilerModuleUnloading_ForContextAssumeEnabled(pContext, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerModuleUnloading, ModuleID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloading _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerModuleUnloaded"
//
#define EventXplatEnabledMonoProfilerModuleUnloaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerModuleUnloaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerModuleUnloaded"
//
#define FireEtXplatMonoProfilerModuleUnloaded(ModuleID, ModuleName, ModuleSignature) \
        MCGEN_EVENT_ENABLED(MonoProfilerModuleUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleUnloaded, ModuleID, ModuleName, ModuleSignature) : 0
#define FireEtXplatMonoProfilerModuleUnloaded_AssumeEnabled(ModuleID, ModuleName, ModuleSignature) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerModuleUnloaded, ModuleID, ModuleName, ModuleSignature)
#define FireEtXplatMonoProfilerModuleUnloaded_ForContext(pContext, ModuleID, ModuleName, ModuleSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerModuleUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloaded(&(pContext)->Context, &MonoProfilerModuleUnloaded, ModuleID, ModuleName, ModuleSignature) : 0
#define FireEtXplatMonoProfilerModuleUnloaded_ForContextAssumeEnabled(pContext, ModuleID, ModuleName, ModuleSignature) \
        _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerModuleUnloaded, ModuleID, ModuleName, ModuleSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerModuleUnloaded _mcgen_PASTE2(McTemplateCoU0xzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAssemblyLoading"
//
#define EventXplatEnabledMonoProfilerAssemblyLoading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 1)
#define EventXplatEnabledMonoProfilerAssemblyLoading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 1)

//
// Event write macros for event "MonoProfilerAssemblyLoading"
//
#define FireEtXplatMonoProfilerAssemblyLoading(AssemblyID, ModuleID) \
        MCGEN_EVENT_ENABLED(MonoProfilerAssemblyLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyLoading, AssemblyID, ModuleID) : 0
#define FireEtXplatMonoProfilerAssemblyLoading_AssumeEnabled(AssemblyID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyLoading, AssemblyID, ModuleID)
#define FireEtXplatMonoProfilerAssemblyLoading_ForContext(pContext, AssemblyID, ModuleID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAssemblyLoading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoading(&(pContext)->Context, &MonoProfilerAssemblyLoading, AssemblyID, ModuleID) : 0
#define FireEtXplatMonoProfilerAssemblyLoading_ForContextAssumeEnabled(pContext, AssemblyID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAssemblyLoading, AssemblyID, ModuleID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoading _mcgen_PASTE2(McTemplateCoU0xx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAssemblyLoaded"
//
#define EventXplatEnabledMonoProfilerAssemblyLoaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerAssemblyLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerAssemblyLoaded"
//
#define FireEtXplatMonoProfilerAssemblyLoaded(AssemblyID, ModuleID, AssemblyName) \
        MCGEN_EVENT_ENABLED(MonoProfilerAssemblyLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyLoaded, AssemblyID, ModuleID, AssemblyName) : 0
#define FireEtXplatMonoProfilerAssemblyLoaded_AssumeEnabled(AssemblyID, ModuleID, AssemblyName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyLoaded, AssemblyID, ModuleID, AssemblyName)
#define FireEtXplatMonoProfilerAssemblyLoaded_ForContext(pContext, AssemblyID, ModuleID, AssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAssemblyLoaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoaded(&(pContext)->Context, &MonoProfilerAssemblyLoaded, AssemblyID, ModuleID, AssemblyName) : 0
#define FireEtXplatMonoProfilerAssemblyLoaded_ForContextAssumeEnabled(pContext, AssemblyID, ModuleID, AssemblyName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAssemblyLoaded, AssemblyID, ModuleID, AssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyLoaded _mcgen_PASTE2(McTemplateCoU0xxz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAssemblyUnloading"
//
#define EventXplatEnabledMonoProfilerAssemblyUnloading() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 1)
#define EventXplatEnabledMonoProfilerAssemblyUnloading_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 1)

//
// Event write macros for event "MonoProfilerAssemblyUnloading"
//
#define FireEtXplatMonoProfilerAssemblyUnloading(AssemblyID, ModuleID) \
        MCGEN_EVENT_ENABLED(MonoProfilerAssemblyUnloading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyUnloading, AssemblyID, ModuleID) : 0
#define FireEtXplatMonoProfilerAssemblyUnloading_AssumeEnabled(AssemblyID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloading(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyUnloading, AssemblyID, ModuleID)
#define FireEtXplatMonoProfilerAssemblyUnloading_ForContext(pContext, AssemblyID, ModuleID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAssemblyUnloading) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloading(&(pContext)->Context, &MonoProfilerAssemblyUnloading, AssemblyID, ModuleID) : 0
#define FireEtXplatMonoProfilerAssemblyUnloading_ForContextAssumeEnabled(pContext, AssemblyID, ModuleID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloading(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAssemblyUnloading, AssemblyID, ModuleID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloading _mcgen_PASTE2(McTemplateCoU0xx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerAssemblyUnloaded"
//
#define EventXplatEnabledMonoProfilerAssemblyUnloaded() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 0)
#define EventXplatEnabledMonoProfilerAssemblyUnloaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 0)

//
// Event write macros for event "MonoProfilerAssemblyUnloaded"
//
#define FireEtXplatMonoProfilerAssemblyUnloaded(AssemblyID, ModuleID, AssemblyName) \
        MCGEN_EVENT_ENABLED(MonoProfilerAssemblyUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyUnloaded, AssemblyID, ModuleID, AssemblyName) : 0
#define FireEtXplatMonoProfilerAssemblyUnloaded_AssumeEnabled(AssemblyID, ModuleID, AssemblyName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloaded(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerAssemblyUnloaded, AssemblyID, ModuleID, AssemblyName)
#define FireEtXplatMonoProfilerAssemblyUnloaded_ForContext(pContext, AssemblyID, ModuleID, AssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerAssemblyUnloaded) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloaded(&(pContext)->Context, &MonoProfilerAssemblyUnloaded, AssemblyID, ModuleID, AssemblyName) : 0
#define FireEtXplatMonoProfilerAssemblyUnloaded_ForContextAssumeEnabled(pContext, AssemblyID, ModuleID, AssemblyName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloaded(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerAssemblyUnloaded, AssemblyID, ModuleID, AssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerAssemblyUnloaded _mcgen_PASTE2(McTemplateCoU0xxz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMethodEnter"
//
#define EventXplatEnabledMonoProfilerMethodEnter() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 5)
#define EventXplatEnabledMonoProfilerMethodEnter_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 5)

//
// Event write macros for event "MonoProfilerMethodEnter"
//
#define FireEtXplatMonoProfilerMethodEnter(MethodID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMethodEnter) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodEnter(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodEnter, MethodID) : 0
#define FireEtXplatMonoProfilerMethodEnter_AssumeEnabled(MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodEnter(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodEnter, MethodID)
#define FireEtXplatMonoProfilerMethodEnter_ForContext(pContext, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMethodEnter) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodEnter(&(pContext)->Context, &MonoProfilerMethodEnter, MethodID) : 0
#define FireEtXplatMonoProfilerMethodEnter_ForContextAssumeEnabled(pContext, MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodEnter(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMethodEnter, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMethodEnter _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMethodLeave"
//
#define EventXplatEnabledMonoProfilerMethodLeave() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 5)
#define EventXplatEnabledMonoProfilerMethodLeave_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 5)

//
// Event write macros for event "MonoProfilerMethodLeave"
//
#define FireEtXplatMonoProfilerMethodLeave(MethodID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMethodLeave) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodLeave(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodLeave, MethodID) : 0
#define FireEtXplatMonoProfilerMethodLeave_AssumeEnabled(MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodLeave(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodLeave, MethodID)
#define FireEtXplatMonoProfilerMethodLeave_ForContext(pContext, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMethodLeave) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodLeave(&(pContext)->Context, &MonoProfilerMethodLeave, MethodID) : 0
#define FireEtXplatMonoProfilerMethodLeave_ForContextAssumeEnabled(pContext, MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodLeave(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMethodLeave, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMethodLeave _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMethodTailCall"
//
#define EventXplatEnabledMonoProfilerMethodTailCall() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 5)
#define EventXplatEnabledMonoProfilerMethodTailCall_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 5)

//
// Event write macros for event "MonoProfilerMethodTailCall"
//
#define FireEtXplatMonoProfilerMethodTailCall(MethodID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMethodTailCall) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodTailCall(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodTailCall, MethodID) : 0
#define FireEtXplatMonoProfilerMethodTailCall_AssumeEnabled(MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodTailCall(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodTailCall, MethodID)
#define FireEtXplatMonoProfilerMethodTailCall_ForContext(pContext, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMethodTailCall) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodTailCall(&(pContext)->Context, &MonoProfilerMethodTailCall, MethodID) : 0
#define FireEtXplatMonoProfilerMethodTailCall_ForContextAssumeEnabled(pContext, MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodTailCall(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMethodTailCall, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMethodTailCall _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMethodExceptionLeave"
//
#define EventXplatEnabledMonoProfilerMethodExceptionLeave() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 5)
#define EventXplatEnabledMonoProfilerMethodExceptionLeave_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 5)

//
// Event write macros for event "MonoProfilerMethodExceptionLeave"
//
#define FireEtXplatMonoProfilerMethodExceptionLeave(MethodID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMethodExceptionLeave) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodExceptionLeave(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodExceptionLeave, MethodID) : 0
#define FireEtXplatMonoProfilerMethodExceptionLeave_AssumeEnabled(MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodExceptionLeave(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodExceptionLeave, MethodID)
#define FireEtXplatMonoProfilerMethodExceptionLeave_ForContext(pContext, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMethodExceptionLeave) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodExceptionLeave(&(pContext)->Context, &MonoProfilerMethodExceptionLeave, MethodID) : 0
#define FireEtXplatMonoProfilerMethodExceptionLeave_ForContextAssumeEnabled(pContext, MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodExceptionLeave(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMethodExceptionLeave, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMethodExceptionLeave _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMethodFree"
//
#define EventXplatEnabledMonoProfilerMethodFree() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 5)
#define EventXplatEnabledMonoProfilerMethodFree_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 5)

//
// Event write macros for event "MonoProfilerMethodFree"
//
#define FireEtXplatMonoProfilerMethodFree(MethodID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMethodFree) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodFree(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodFree, MethodID) : 0
#define FireEtXplatMonoProfilerMethodFree_AssumeEnabled(MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodFree(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodFree, MethodID)
#define FireEtXplatMonoProfilerMethodFree_ForContext(pContext, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMethodFree) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodFree(&(pContext)->Context, &MonoProfilerMethodFree, MethodID) : 0
#define FireEtXplatMonoProfilerMethodFree_ForContextAssumeEnabled(pContext, MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodFree(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMethodFree, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMethodFree _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMethodBeginInvoke"
//
#define EventXplatEnabledMonoProfilerMethodBeginInvoke() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 5)
#define EventXplatEnabledMonoProfilerMethodBeginInvoke_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 5)

//
// Event write macros for event "MonoProfilerMethodBeginInvoke"
//
#define FireEtXplatMonoProfilerMethodBeginInvoke(MethodID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMethodBeginInvoke) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodBeginInvoke(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodBeginInvoke, MethodID) : 0
#define FireEtXplatMonoProfilerMethodBeginInvoke_AssumeEnabled(MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodBeginInvoke(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodBeginInvoke, MethodID)
#define FireEtXplatMonoProfilerMethodBeginInvoke_ForContext(pContext, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMethodBeginInvoke) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodBeginInvoke(&(pContext)->Context, &MonoProfilerMethodBeginInvoke, MethodID) : 0
#define FireEtXplatMonoProfilerMethodBeginInvoke_ForContextAssumeEnabled(pContext, MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodBeginInvoke(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMethodBeginInvoke, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMethodBeginInvoke _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMethodEndInvoke"
//
#define EventXplatEnabledMonoProfilerMethodEndInvoke() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 5)
#define EventXplatEnabledMonoProfilerMethodEndInvoke_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 5)

//
// Event write macros for event "MonoProfilerMethodEndInvoke"
//
#define FireEtXplatMonoProfilerMethodEndInvoke(MethodID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMethodEndInvoke) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodEndInvoke(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodEndInvoke, MethodID) : 0
#define FireEtXplatMonoProfilerMethodEndInvoke_AssumeEnabled(MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodEndInvoke(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMethodEndInvoke, MethodID)
#define FireEtXplatMonoProfilerMethodEndInvoke_ForContext(pContext, MethodID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMethodEndInvoke) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMethodEndInvoke(&(pContext)->Context, &MonoProfilerMethodEndInvoke, MethodID) : 0
#define FireEtXplatMonoProfilerMethodEndInvoke_ForContextAssumeEnabled(pContext, MethodID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMethodEndInvoke(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMethodEndInvoke, MethodID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMethodEndInvoke _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerExceptionThrow"
//
#define EventXplatEnabledMonoProfilerExceptionThrow() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 6)
#define EventXplatEnabledMonoProfilerExceptionThrow_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 6)

//
// Event write macros for event "MonoProfilerExceptionThrow"
//
#define FireEtXplatMonoProfilerExceptionThrow(TypeID, ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerExceptionThrow) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerExceptionThrow(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerExceptionThrow, TypeID, ObjectID) : 0
#define FireEtXplatMonoProfilerExceptionThrow_AssumeEnabled(TypeID, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerExceptionThrow(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerExceptionThrow, TypeID, ObjectID)
#define FireEtXplatMonoProfilerExceptionThrow_ForContext(pContext, TypeID, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerExceptionThrow) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerExceptionThrow(&(pContext)->Context, &MonoProfilerExceptionThrow, TypeID, ObjectID) : 0
#define FireEtXplatMonoProfilerExceptionThrow_ForContextAssumeEnabled(pContext, TypeID, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerExceptionThrow(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerExceptionThrow, TypeID, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerExceptionThrow _mcgen_PASTE2(McTemplateCoU0xp_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerExceptionClause"
//
#define EventXplatEnabledMonoProfilerExceptionClause() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 6)
#define EventXplatEnabledMonoProfilerExceptionClause_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 6)

//
// Event write macros for event "MonoProfilerExceptionClause"
//
#define FireEtXplatMonoProfilerExceptionClause(ClauseType, ClauseIdx, MethodID, TypeID, ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerExceptionClause) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerExceptionClause(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerExceptionClause, ClauseType, ClauseIdx, MethodID, TypeID, ObjectID) : 0
#define FireEtXplatMonoProfilerExceptionClause_AssumeEnabled(ClauseType, ClauseIdx, MethodID, TypeID, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerExceptionClause(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerExceptionClause, ClauseType, ClauseIdx, MethodID, TypeID, ObjectID)
#define FireEtXplatMonoProfilerExceptionClause_ForContext(pContext, ClauseType, ClauseIdx, MethodID, TypeID, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerExceptionClause) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerExceptionClause(&(pContext)->Context, &MonoProfilerExceptionClause, ClauseType, ClauseIdx, MethodID, TypeID, ObjectID) : 0
#define FireEtXplatMonoProfilerExceptionClause_ForContextAssumeEnabled(pContext, ClauseType, ClauseIdx, MethodID, TypeID, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerExceptionClause(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerExceptionClause, ClauseType, ClauseIdx, MethodID, TypeID, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerExceptionClause _mcgen_PASTE2(McTemplateCoU0uqxxp_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCEvent"
//
#define EventXplatEnabledMonoProfilerGCEvent() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 7)
#define EventXplatEnabledMonoProfilerGCEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 7)

//
// Event write macros for event "MonoProfilerGCEvent"
//
#define FireEtXplatMonoProfilerGCEvent(GCEventType, GCGeneration) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCEvent) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCEvent(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCEvent, GCEventType, GCGeneration) : 0
#define FireEtXplatMonoProfilerGCEvent_AssumeEnabled(GCEventType, GCGeneration) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCEvent(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCEvent, GCEventType, GCGeneration)
#define FireEtXplatMonoProfilerGCEvent_ForContext(pContext, GCEventType, GCGeneration) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCEvent) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCEvent(&(pContext)->Context, &MonoProfilerGCEvent, GCEventType, GCGeneration) : 0
#define FireEtXplatMonoProfilerGCEvent_ForContextAssumeEnabled(pContext, GCEventType, GCGeneration) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCEvent(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCEvent, GCEventType, GCGeneration)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCEvent _mcgen_PASTE2(McTemplateCoU0uq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCAllocation"
//
#define EventXplatEnabledMonoProfilerGCAllocation() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 8)
#define EventXplatEnabledMonoProfilerGCAllocation_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 8)

//
// Event write macros for event "MonoProfilerGCAllocation"
//
#define FireEtXplatMonoProfilerGCAllocation(VTableID, ObjectID, ObjectSize) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCAllocation) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCAllocation(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCAllocation, VTableID, ObjectID, ObjectSize) : 0
#define FireEtXplatMonoProfilerGCAllocation_AssumeEnabled(VTableID, ObjectID, ObjectSize) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCAllocation(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCAllocation, VTableID, ObjectID, ObjectSize)
#define FireEtXplatMonoProfilerGCAllocation_ForContext(pContext, VTableID, ObjectID, ObjectSize) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCAllocation) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCAllocation(&(pContext)->Context, &MonoProfilerGCAllocation, VTableID, ObjectID, ObjectSize) : 0
#define FireEtXplatMonoProfilerGCAllocation_ForContextAssumeEnabled(pContext, VTableID, ObjectID, ObjectSize) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCAllocation(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCAllocation, VTableID, ObjectID, ObjectSize)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCAllocation _mcgen_PASTE2(McTemplateCoU0xpx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCMoves"
//
#define EventXplatEnabledMonoProfilerGCMoves() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 9)
#define EventXplatEnabledMonoProfilerGCMoves_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 9)

//
// Event write macros for event "MonoProfilerGCMoves"
//
#define FireEtXplatMonoProfilerGCMoves(Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCMoves) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCMoves(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCMoves, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerGCMoves_AssumeEnabled(Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCMoves(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCMoves, Count, Values_Len_, Values)
#define FireEtXplatMonoProfilerGCMoves_ForContext(pContext, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCMoves) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCMoves(&(pContext)->Context, &MonoProfilerGCMoves, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerGCMoves_ForContextAssumeEnabled(pContext, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCMoves(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCMoves, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCMoves _mcgen_PASTE2(McTemplateCoU0qNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCResize"
//
#define EventXplatEnabledMonoProfilerGCResize() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 10)
#define EventXplatEnabledMonoProfilerGCResize_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 10)

//
// Event write macros for event "MonoProfilerGCResize"
//
#define FireEtXplatMonoProfilerGCResize(NewSize) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCResize) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCResize(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCResize, NewSize) : 0
#define FireEtXplatMonoProfilerGCResize_AssumeEnabled(NewSize) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCResize(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCResize, NewSize)
#define FireEtXplatMonoProfilerGCResize_ForContext(pContext, NewSize) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCResize) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCResize(&(pContext)->Context, &MonoProfilerGCResize, NewSize) : 0
#define FireEtXplatMonoProfilerGCResize_ForContextAssumeEnabled(pContext, NewSize) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCResize(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCResize, NewSize)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCResize _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCHandleCreated"
//
#define EventXplatEnabledMonoProfilerGCHandleCreated() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 11)
#define EventXplatEnabledMonoProfilerGCHandleCreated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 11)

//
// Event write macros for event "MonoProfilerGCHandleCreated"
//
#define FireEtXplatMonoProfilerGCHandleCreated(HandleID, HandleType, ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCHandleCreated) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleCreated(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHandleCreated, HandleID, HandleType, ObjectID) : 0
#define FireEtXplatMonoProfilerGCHandleCreated_AssumeEnabled(HandleID, HandleType, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleCreated(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHandleCreated, HandleID, HandleType, ObjectID)
#define FireEtXplatMonoProfilerGCHandleCreated_ForContext(pContext, HandleID, HandleType, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCHandleCreated) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleCreated(&(pContext)->Context, &MonoProfilerGCHandleCreated, HandleID, HandleType, ObjectID) : 0
#define FireEtXplatMonoProfilerGCHandleCreated_ForContextAssumeEnabled(pContext, HandleID, HandleType, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleCreated(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCHandleCreated, HandleID, HandleType, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleCreated _mcgen_PASTE2(McTemplateCoU0xup_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCHandleDeleted"
//
#define EventXplatEnabledMonoProfilerGCHandleDeleted() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 11)
#define EventXplatEnabledMonoProfilerGCHandleDeleted_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 11)

//
// Event write macros for event "MonoProfilerGCHandleDeleted"
//
#define FireEtXplatMonoProfilerGCHandleDeleted(HandleID, HandleType) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCHandleDeleted) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleDeleted(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHandleDeleted, HandleID, HandleType) : 0
#define FireEtXplatMonoProfilerGCHandleDeleted_AssumeEnabled(HandleID, HandleType) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleDeleted(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHandleDeleted, HandleID, HandleType)
#define FireEtXplatMonoProfilerGCHandleDeleted_ForContext(pContext, HandleID, HandleType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCHandleDeleted) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleDeleted(&(pContext)->Context, &MonoProfilerGCHandleDeleted, HandleID, HandleType) : 0
#define FireEtXplatMonoProfilerGCHandleDeleted_ForContextAssumeEnabled(pContext, HandleID, HandleType) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleDeleted(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCHandleDeleted, HandleID, HandleType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCHandleDeleted _mcgen_PASTE2(McTemplateCoU0xu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCFinalizing"
//
#define EventXplatEnabledMonoProfilerGCFinalizing() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 12)
#define EventXplatEnabledMonoProfilerGCFinalizing_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 12)

//
// Event write macros for event "MonoProfilerGCFinalizing"
//
#define FireEtXplatMonoProfilerGCFinalizing() \
        MCGEN_EVENT_ENABLED(MonoProfilerGCFinalizing) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizing(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalizing) : 0
#define FireEtXplatMonoProfilerGCFinalizing_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizing(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalizing)
#define FireEtXplatMonoProfilerGCFinalizing_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCFinalizing) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizing(&(pContext)->Context, &MonoProfilerGCFinalizing) : 0
#define FireEtXplatMonoProfilerGCFinalizing_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizing(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCFinalizing)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizing _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCFinalized"
//
#define EventXplatEnabledMonoProfilerGCFinalized() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 12)
#define EventXplatEnabledMonoProfilerGCFinalized_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 12)

//
// Event write macros for event "MonoProfilerGCFinalized"
//
#define FireEtXplatMonoProfilerGCFinalized() \
        MCGEN_EVENT_ENABLED(MonoProfilerGCFinalized) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalized(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalized) : 0
#define FireEtXplatMonoProfilerGCFinalized_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalized(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalized)
#define FireEtXplatMonoProfilerGCFinalized_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCFinalized) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalized(&(pContext)->Context, &MonoProfilerGCFinalized) : 0
#define FireEtXplatMonoProfilerGCFinalized_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalized(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCFinalized)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalized _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCFinalizingObject"
//
#define EventXplatEnabledMonoProfilerGCFinalizingObject() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 12)
#define EventXplatEnabledMonoProfilerGCFinalizingObject_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 12)

//
// Event write macros for event "MonoProfilerGCFinalizingObject"
//
#define FireEtXplatMonoProfilerGCFinalizingObject(ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCFinalizingObject) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizingObject(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalizingObject, ObjectID) : 0
#define FireEtXplatMonoProfilerGCFinalizingObject_AssumeEnabled(ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizingObject(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalizingObject, ObjectID)
#define FireEtXplatMonoProfilerGCFinalizingObject_ForContext(pContext, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCFinalizingObject) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizingObject(&(pContext)->Context, &MonoProfilerGCFinalizingObject, ObjectID) : 0
#define FireEtXplatMonoProfilerGCFinalizingObject_ForContextAssumeEnabled(pContext, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizingObject(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCFinalizingObject, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizingObject _mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCFinalizedObject"
//
#define EventXplatEnabledMonoProfilerGCFinalizedObject() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 12)
#define EventXplatEnabledMonoProfilerGCFinalizedObject_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 12)

//
// Event write macros for event "MonoProfilerGCFinalizedObject"
//
#define FireEtXplatMonoProfilerGCFinalizedObject(ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCFinalizedObject) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizedObject(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalizedObject, ObjectID) : 0
#define FireEtXplatMonoProfilerGCFinalizedObject_AssumeEnabled(ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizedObject(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCFinalizedObject, ObjectID)
#define FireEtXplatMonoProfilerGCFinalizedObject_ForContext(pContext, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCFinalizedObject) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizedObject(&(pContext)->Context, &MonoProfilerGCFinalizedObject, ObjectID) : 0
#define FireEtXplatMonoProfilerGCFinalizedObject_ForContextAssumeEnabled(pContext, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizedObject(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCFinalizedObject, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCFinalizedObject _mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCRootRegister"
//
#define EventXplatEnabledMonoProfilerGCRootRegister() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 13)
#define EventXplatEnabledMonoProfilerGCRootRegister_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 13)

//
// Event write macros for event "MonoProfilerGCRootRegister"
//
#define FireEtXplatMonoProfilerGCRootRegister(RootID, RootSize, RootType, RootKeyID, RootKeyName) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCRootRegister) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCRootRegister(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCRootRegister, RootID, RootSize, RootType, RootKeyID, RootKeyName) : 0
#define FireEtXplatMonoProfilerGCRootRegister_AssumeEnabled(RootID, RootSize, RootType, RootKeyID, RootKeyName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCRootRegister(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCRootRegister, RootID, RootSize, RootType, RootKeyID, RootKeyName)
#define FireEtXplatMonoProfilerGCRootRegister_ForContext(pContext, RootID, RootSize, RootType, RootKeyID, RootKeyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCRootRegister) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCRootRegister(&(pContext)->Context, &MonoProfilerGCRootRegister, RootID, RootSize, RootType, RootKeyID, RootKeyName) : 0
#define FireEtXplatMonoProfilerGCRootRegister_ForContextAssumeEnabled(pContext, RootID, RootSize, RootType, RootKeyID, RootKeyName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCRootRegister(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCRootRegister, RootID, RootSize, RootType, RootKeyID, RootKeyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCRootRegister _mcgen_PASTE2(McTemplateCoU0pxuxz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCRootUnregister"
//
#define EventXplatEnabledMonoProfilerGCRootUnregister() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 13)
#define EventXplatEnabledMonoProfilerGCRootUnregister_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 13)

//
// Event write macros for event "MonoProfilerGCRootUnregister"
//
#define FireEtXplatMonoProfilerGCRootUnregister(RootID) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCRootUnregister) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCRootUnregister(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCRootUnregister, RootID) : 0
#define FireEtXplatMonoProfilerGCRootUnregister_AssumeEnabled(RootID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCRootUnregister(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCRootUnregister, RootID)
#define FireEtXplatMonoProfilerGCRootUnregister_ForContext(pContext, RootID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCRootUnregister) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCRootUnregister(&(pContext)->Context, &MonoProfilerGCRootUnregister, RootID) : 0
#define FireEtXplatMonoProfilerGCRootUnregister_ForContextAssumeEnabled(pContext, RootID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCRootUnregister(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCRootUnregister, RootID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCRootUnregister _mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCRoots"
//
#define EventXplatEnabledMonoProfilerGCRoots() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 13)
#define EventXplatEnabledMonoProfilerGCRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 13)

//
// Event write macros for event "MonoProfilerGCRoots"
//
#define FireEtXplatMonoProfilerGCRoots(Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCRoots) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCRoots(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCRoots, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerGCRoots_AssumeEnabled(Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCRoots(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCRoots, Count, Values_Len_, Values)
#define FireEtXplatMonoProfilerGCRoots_ForContext(pContext, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCRoots) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCRoots(&(pContext)->Context, &MonoProfilerGCRoots, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerGCRoots_ForContextAssumeEnabled(pContext, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCRoots(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCRoots, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCRoots _mcgen_PASTE2(McTemplateCoU0qNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCHeapDumpStart"
//
#define EventXplatEnabledMonoProfilerGCHeapDumpStart() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 14)
#define EventXplatEnabledMonoProfilerGCHeapDumpStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 14)

//
// Event write macros for event "MonoProfilerGCHeapDumpStart"
//
#define FireEtXplatMonoProfilerGCHeapDumpStart(HeapCollectParam) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCHeapDumpStart) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStart(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpStart, HeapCollectParam) : 0
#define FireEtXplatMonoProfilerGCHeapDumpStart_AssumeEnabled(HeapCollectParam) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStart(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpStart, HeapCollectParam)
#define FireEtXplatMonoProfilerGCHeapDumpStart_ForContext(pContext, HeapCollectParam) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCHeapDumpStart) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStart(&(pContext)->Context, &MonoProfilerGCHeapDumpStart, HeapCollectParam) : 0
#define FireEtXplatMonoProfilerGCHeapDumpStart_ForContextAssumeEnabled(pContext, HeapCollectParam) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStart(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCHeapDumpStart, HeapCollectParam)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStart _mcgen_PASTE2(McTemplateCoU0z_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCHeapDumpStop"
//
#define EventXplatEnabledMonoProfilerGCHeapDumpStop() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 14)
#define EventXplatEnabledMonoProfilerGCHeapDumpStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 14)

//
// Event write macros for event "MonoProfilerGCHeapDumpStop"
//
#define FireEtXplatMonoProfilerGCHeapDumpStop() \
        MCGEN_EVENT_ENABLED(MonoProfilerGCHeapDumpStop) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStop(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpStop) : 0
#define FireEtXplatMonoProfilerGCHeapDumpStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStop(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpStop)
#define FireEtXplatMonoProfilerGCHeapDumpStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCHeapDumpStop) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStop(&(pContext)->Context, &MonoProfilerGCHeapDumpStop) : 0
#define FireEtXplatMonoProfilerGCHeapDumpStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStop(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCHeapDumpStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpStop _mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCHeapDumpObjectReference"
//
#define EventXplatEnabledMonoProfilerGCHeapDumpObjectReference() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 14)
#define EventXplatEnabledMonoProfilerGCHeapDumpObjectReference_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 14)

//
// Event write macros for event "MonoProfilerGCHeapDumpObjectReference"
//
#define FireEtXplatMonoProfilerGCHeapDumpObjectReference(ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCHeapDumpObjectReference) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpObjectReference(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpObjectReference, ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerGCHeapDumpObjectReference_AssumeEnabled(ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpObjectReference(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpObjectReference, ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values)
#define FireEtXplatMonoProfilerGCHeapDumpObjectReference_ForContext(pContext, ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCHeapDumpObjectReference) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpObjectReference(&(pContext)->Context, &MonoProfilerGCHeapDumpObjectReference, ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values) : 0
#define FireEtXplatMonoProfilerGCHeapDumpObjectReference_ForContextAssumeEnabled(pContext, ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpObjectReference(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCHeapDumpObjectReference, ObjectID, VTableID, ObjectSize, ObjectGeneration, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpObjectReference _mcgen_PASTE2(McTemplateCoU0pxxuqNR4_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMonitorContention"
//
#define EventXplatEnabledMonoProfilerMonitorContention() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 15)
#define EventXplatEnabledMonoProfilerMonitorContention_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 15)

//
// Event write macros for event "MonoProfilerMonitorContention"
//
#define FireEtXplatMonoProfilerMonitorContention(ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMonitorContention) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMonitorContention(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMonitorContention, ObjectID) : 0
#define FireEtXplatMonoProfilerMonitorContention_AssumeEnabled(ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMonitorContention(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMonitorContention, ObjectID)
#define FireEtXplatMonoProfilerMonitorContention_ForContext(pContext, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMonitorContention) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMonitorContention(&(pContext)->Context, &MonoProfilerMonitorContention, ObjectID) : 0
#define FireEtXplatMonoProfilerMonitorContention_ForContextAssumeEnabled(pContext, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMonitorContention(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMonitorContention, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMonitorContention _mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMonitorFailed"
//
#define EventXplatEnabledMonoProfilerMonitorFailed() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 16)
#define EventXplatEnabledMonoProfilerMonitorFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 16)

//
// Event write macros for event "MonoProfilerMonitorFailed"
//
#define FireEtXplatMonoProfilerMonitorFailed(ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMonitorFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMonitorFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMonitorFailed, ObjectID) : 0
#define FireEtXplatMonoProfilerMonitorFailed_AssumeEnabled(ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMonitorFailed(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMonitorFailed, ObjectID)
#define FireEtXplatMonoProfilerMonitorFailed_ForContext(pContext, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMonitorFailed) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMonitorFailed(&(pContext)->Context, &MonoProfilerMonitorFailed, ObjectID) : 0
#define FireEtXplatMonoProfilerMonitorFailed_ForContextAssumeEnabled(pContext, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMonitorFailed(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMonitorFailed, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMonitorFailed _mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerMonitorAcquired"
//
#define EventXplatEnabledMonoProfilerMonitorAcquired() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 16)
#define EventXplatEnabledMonoProfilerMonitorAcquired_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 16)

//
// Event write macros for event "MonoProfilerMonitorAcquired"
//
#define FireEtXplatMonoProfilerMonitorAcquired(ObjectID) \
        MCGEN_EVENT_ENABLED(MonoProfilerMonitorAcquired) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMonitorAcquired(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMonitorAcquired, ObjectID) : 0
#define FireEtXplatMonoProfilerMonitorAcquired_AssumeEnabled(ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMonitorAcquired(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerMonitorAcquired, ObjectID)
#define FireEtXplatMonoProfilerMonitorAcquired_ForContext(pContext, ObjectID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerMonitorAcquired) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerMonitorAcquired(&(pContext)->Context, &MonoProfilerMonitorAcquired, ObjectID) : 0
#define FireEtXplatMonoProfilerMonitorAcquired_ForContextAssumeEnabled(pContext, ObjectID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerMonitorAcquired(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerMonitorAcquired, ObjectID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerMonitorAcquired _mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerThreadStarted"
//
#define EventXplatEnabledMonoProfilerThreadStarted() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 17)
#define EventXplatEnabledMonoProfilerThreadStarted_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 17)

//
// Event write macros for event "MonoProfilerThreadStarted"
//
#define FireEtXplatMonoProfilerThreadStarted(ThreadID) \
        MCGEN_EVENT_ENABLED(MonoProfilerThreadStarted) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadStarted(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadStarted, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadStarted_AssumeEnabled(ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadStarted(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadStarted, ThreadID)
#define FireEtXplatMonoProfilerThreadStarted_ForContext(pContext, ThreadID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerThreadStarted) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadStarted(&(pContext)->Context, &MonoProfilerThreadStarted, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadStarted_ForContextAssumeEnabled(pContext, ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadStarted(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerThreadStarted, ThreadID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerThreadStarted _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerThreadStopping"
//
#define EventXplatEnabledMonoProfilerThreadStopping() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 18)
#define EventXplatEnabledMonoProfilerThreadStopping_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 18)

//
// Event write macros for event "MonoProfilerThreadStopping"
//
#define FireEtXplatMonoProfilerThreadStopping(ThreadID) \
        MCGEN_EVENT_ENABLED(MonoProfilerThreadStopping) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopping(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadStopping, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadStopping_AssumeEnabled(ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopping(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadStopping, ThreadID)
#define FireEtXplatMonoProfilerThreadStopping_ForContext(pContext, ThreadID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerThreadStopping) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopping(&(pContext)->Context, &MonoProfilerThreadStopping, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadStopping_ForContextAssumeEnabled(pContext, ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopping(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerThreadStopping, ThreadID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopping _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerThreadStopped"
//
#define EventXplatEnabledMonoProfilerThreadStopped() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 17)
#define EventXplatEnabledMonoProfilerThreadStopped_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 17)

//
// Event write macros for event "MonoProfilerThreadStopped"
//
#define FireEtXplatMonoProfilerThreadStopped(ThreadID) \
        MCGEN_EVENT_ENABLED(MonoProfilerThreadStopped) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopped(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadStopped, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadStopped_AssumeEnabled(ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopped(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadStopped, ThreadID)
#define FireEtXplatMonoProfilerThreadStopped_ForContext(pContext, ThreadID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerThreadStopped) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopped(&(pContext)->Context, &MonoProfilerThreadStopped, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadStopped_ForContextAssumeEnabled(pContext, ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopped(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerThreadStopped, ThreadID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerThreadStopped _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerThreadExited"
//
#define EventXplatEnabledMonoProfilerThreadExited() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 17)
#define EventXplatEnabledMonoProfilerThreadExited_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 17)

//
// Event write macros for event "MonoProfilerThreadExited"
//
#define FireEtXplatMonoProfilerThreadExited(ThreadID) \
        MCGEN_EVENT_ENABLED(MonoProfilerThreadExited) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadExited(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadExited, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadExited_AssumeEnabled(ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadExited(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadExited, ThreadID)
#define FireEtXplatMonoProfilerThreadExited_ForContext(pContext, ThreadID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerThreadExited) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadExited(&(pContext)->Context, &MonoProfilerThreadExited, ThreadID) : 0
#define FireEtXplatMonoProfilerThreadExited_ForContextAssumeEnabled(pContext, ThreadID) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadExited(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerThreadExited, ThreadID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerThreadExited _mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerThreadName"
//
#define EventXplatEnabledMonoProfilerThreadName() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 18)
#define EventXplatEnabledMonoProfilerThreadName_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 18)

//
// Event write macros for event "MonoProfilerThreadName"
//
#define FireEtXplatMonoProfilerThreadName(ThreadID, ThreadName) \
        MCGEN_EVENT_ENABLED(MonoProfilerThreadName) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadName(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadName, ThreadID, ThreadName) : 0
#define FireEtXplatMonoProfilerThreadName_AssumeEnabled(ThreadID, ThreadName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadName(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerThreadName, ThreadID, ThreadName)
#define FireEtXplatMonoProfilerThreadName_ForContext(pContext, ThreadID, ThreadName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerThreadName) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerThreadName(&(pContext)->Context, &MonoProfilerThreadName, ThreadID, ThreadName) : 0
#define FireEtXplatMonoProfilerThreadName_ForContextAssumeEnabled(pContext, ThreadID, ThreadName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerThreadName(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerThreadName, ThreadID, ThreadName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerThreadName _mcgen_PASTE2(McTemplateCoU0xz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerJitDoneVerbose"
//
#define EventXplatEnabledMonoProfilerJitDoneVerbose() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 19)
#define EventXplatEnabledMonoProfilerJitDoneVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 19)

//
// Event write macros for event "MonoProfilerJitDoneVerbose"
//
#define FireEtXplatMonoProfilerJitDoneVerbose(MethodID, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MonoProfilerJitDoneVerbose) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitDoneVerbose(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitDoneVerbose, MethodID, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMonoProfilerJitDoneVerbose_AssumeEnabled(MethodID, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitDoneVerbose(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerJitDoneVerbose, MethodID, MethodNamespace, MethodName, MethodSignature)
#define FireEtXplatMonoProfilerJitDoneVerbose_ForContext(pContext, MethodID, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerJitDoneVerbose) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerJitDoneVerbose(&(pContext)->Context, &MonoProfilerJitDoneVerbose, MethodID, MethodNamespace, MethodName, MethodSignature) : 0
#define FireEtXplatMonoProfilerJitDoneVerbose_ForContextAssumeEnabled(pContext, MethodID, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MonoProfilerJitDoneVerbose(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerJitDoneVerbose, MethodID, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerJitDoneVerbose _mcgen_PASTE2(McTemplateCoU0xzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MonoProfilerGCHeapDumpVTableClassReference"
//
#define EventXplatEnabledMonoProfilerGCHeapDumpVTableClassReference() _mcgen_EVENT_BIT_SET(Microsoft_DotNETRuntimeMonoProfilerEnableBits, 20)
#define EventXplatEnabledMonoProfilerGCHeapDumpVTableClassReference_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->EnableBits, 20)

//
// Event write macros for event "MonoProfilerGCHeapDumpVTableClassReference"
//
#define FireEtXplatMonoProfilerGCHeapDumpVTableClassReference(VTableID, ClassID, ModuleID, ClassName) \
        MCGEN_EVENT_ENABLED(MonoProfilerGCHeapDumpVTableClassReference) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpVTableClassReference(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpVTableClassReference, VTableID, ClassID, ModuleID, ClassName) : 0
#define FireEtXplatMonoProfilerGCHeapDumpVTableClassReference_AssumeEnabled(VTableID, ClassID, ModuleID, ClassName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpVTableClassReference(&MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_Context, &MonoProfilerGCHeapDumpVTableClassReference, VTableID, ClassID, ModuleID, ClassName)
#define FireEtXplatMonoProfilerGCHeapDumpVTableClassReference_ForContext(pContext, VTableID, ClassID, ModuleID, ClassName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MonoProfilerGCHeapDumpVTableClassReference) \
        ? _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpVTableClassReference(&(pContext)->Context, &MonoProfilerGCHeapDumpVTableClassReference, VTableID, ClassID, ModuleID, ClassName) : 0
#define FireEtXplatMonoProfilerGCHeapDumpVTableClassReference_ForContextAssumeEnabled(pContext, VTableID, ClassID, ModuleID, ClassName) \
        _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpVTableClassReference(&_mcgen_CheckContextType_Microsoft_DotNETRuntimeMonoProfiler(pContext)->Context, &MonoProfilerGCHeapDumpVTableClassReference, VTableID, ClassID, ModuleID, ClassName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MonoProfilerGCHeapDumpVTableClassReference _mcgen_PASTE2(McTemplateCoU0xxxz_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions
//

//
// Function for template "(default)" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0_def
#define McTemplateCoU0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor
    )
{
#define McTemplateCoU0_ARGCOUNT 0
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0_ARGCOUNT + 1];

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              0,
              NULL);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0_def

//
// Function for template "EventSource" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0dzzz_def
#define McTemplateCoU0dzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0dzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const signed int  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3
    )
{
#define McTemplateCoU0dzzz_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0dzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0dzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0dzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0dzzz_def

//
// Function for template "ThreadPoolWorkerThreadAdjustmentStats" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0ggggggggghh_def
#define McTemplateCoU0ggggggggghh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0ggggggggghh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const double  _Arg0,
    _In_ const double  _Arg1,
    _In_ const double  _Arg2,
    _In_ const double  _Arg3,
    _In_ const double  _Arg4,
    _In_ const double  _Arg5,
    _In_ const double  _Arg6,
    _In_ const double  _Arg7,
    _In_ const double  _Arg8,
    _In_ const unsigned short  _Arg9,
    _In_ const unsigned short  _Arg10
    )
{
#define McTemplateCoU0ggggggggghh_ARGCOUNT 11
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0ggggggggghh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const double)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const double)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const double)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const double)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const double)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const double)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const double)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const double)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const double)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0ggggggggghh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0ggggggggghh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0ggggggggghh_def

//
// Function for template "ThreadPoolWorkerThreadAdjustmentSample" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0gh_def
#define McTemplateCoU0gh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0gh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const double  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateCoU0gh_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0gh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const double)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0gh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0gh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0gh_def

//
// Function for template "ThreadPoolWorkerThreadAdjustmentAdjustment" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0gqqh_def
#define McTemplateCoU0gqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0gqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const double  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0gqqh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0gqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const double)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0gqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0gqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0gqqh_def

//
// Function for template "GCNoUserData" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0h_def
#define McTemplateCoU0h_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0h_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0
    )
{
#define McTemplateCoU0h_ARGCOUNT 1
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0h_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0h_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0h_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0h_def

//
// Function for template "YieldProcessorMeasurement" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hgg_def
#define McTemplateCoU0hgg_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hgg_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const double  _Arg1,
    _In_ const double  _Arg2
    )
{
#define McTemplateCoU0hgg_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hgg_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const double)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const double)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hgg_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hgg_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hgg_def

//
// Function for template "GCLOHCompact" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hhNR1_def
#define McTemplateCoU0hhNR1_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hhNR1_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ ULONG _Arg2_Len_,
    _In_ const void*  _Arg2
    )
{
#define McTemplateCoU0hhNR1_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hhNR1_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],_Arg2, _Arg1 * _Arg2_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hhNR1_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hhNR1_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hhNR1_def

//
// Function for template "ThreadPoolMinMaxThreads" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hhhhh_def
#define McTemplateCoU0hhhhh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hhhhh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0hhhhh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hhhhh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hhhhh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hhhhh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hhhhh_def

//
// Function for template "RuntimeInformation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hhhhhhhhhhquzjz_def
#define McTemplateCoU0hhhhhhhhhhquzjz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hhhhhhhhhhquzjz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned short  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned short  _Arg7,
    _In_ const unsigned short  _Arg8,
    _In_ const unsigned short  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned char  _Arg11,
    _In_opt_ PCWSTR  _Arg12,
    _In_ const GUID*  _Arg13,
    _In_opt_ PCWSTR  _Arg14
    )
{
#define McTemplateCoU0hhhhhhhhhhquzjz_ARGCOUNT 15
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hhhhhhhhhhquzjz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[14],_Arg13, sizeof(GUID)  );

    EventDataDescCreate(&EventData[15],
                        (_Arg14 != NULL) ? _Arg14 : L"NULL",
                        (_Arg14 != NULL) ? (ULONG)((wcslen(_Arg14) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hhhhhhhhhhquzjz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hhhhhhhhhhquzjz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hhhhhhhhhhquzjz_def

//
// Function for template "GCFitBucketInfo" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hhxhNR3_def
#define McTemplateCoU0hhxhNR3_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hhxhNR3_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_ ULONG _Arg4_Len_,
    _In_ const void*  _Arg4
    )
{
#define McTemplateCoU0hhxhNR3_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hhxhNR3_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5],_Arg4, _Arg3 * _Arg4_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hhxhNR3_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hhxhNR3_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hhxhNR3_def

//
// Function for template "GCPerHeapHistory_V3" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hppppppqqqqqqpqNR14_def
#define McTemplateCoU0hppppppqqqqqqpqNR14_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hppppppqqqqqqpqNR14_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_opt_ const void*  _Arg3,
    _In_opt_ const void*  _Arg4,
    _In_opt_ const void*  _Arg5,
    _In_opt_ const void*  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_ const unsigned int  _Arg8,
    _In_ const unsigned int  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ const unsigned int  _Arg12,
    _In_opt_ const void*  _Arg13,
    _In_ const unsigned int  _Arg14,
    _In_ ULONG _Arg15_Len_,
    _In_ const void*  _Arg15
    )
{
#define McTemplateCoU0hppppppqqqqqqpqNR14_ARGCOUNT 16
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hppppppqqqqqqpqNR14_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const void*)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const void*)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const void*)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const void*)  );

    EventDataDescCreate(&EventData[15],&_Arg14, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[16],_Arg15, _Arg14 * _Arg15_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hppppppqqqqqqpqNR14_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hppppppqqqqqqpqNR14_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hppppppqqqqqqpqNR14_def

//
// Function for template "TieredCompilationSettings" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hq_def
#define McTemplateCoU0hq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned int  _Arg1
    )
{
#define McTemplateCoU0hq_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hq_def

//
// Function for template "TieredCompilationBackgroundJitStop" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hqq_def
#define McTemplateCoU0hqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2
    )
{
#define McTemplateCoU0hqq_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hqq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hqq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hqq_def

//
// Function for template "JitInstrumentationData" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hqqxbr2_def
#define McTemplateCoU0hqqxbr2_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hqqxbr2_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_reads_(_Arg2) const unsigned char*  _Arg4
    )
{
#define McTemplateCoU0hqqxbr2_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hqqxbr2_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],_Arg4, (ULONG)sizeof(char)*_Arg2);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hqqxbr2_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hqqxbr2_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hqqxbr2_def

//
// Function for template "JitInstrumentationDataVerbose" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hqqxxqzzzbr2_def
#define McTemplateCoU0hqqxxqzzzbr2_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hqqxxqzzzbr2_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_reads_(_Arg2) const unsigned char*  _Arg9
    )
{
#define McTemplateCoU0hqqxxqzzzbr2_ARGCOUNT 10
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hqqxxqzzzbr2_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],_Arg9, (ULONG)sizeof(char)*_Arg2);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hqqxxqzzzbr2_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hqqxxqzzzbr2_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hqqxxqzzzbr2_def

//
// Function for template "FusionMessage" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0htz_def
#define McTemplateCoU0htz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0htz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const signed int  _Arg1,
    _In_opt_ PCWSTR  _Arg2
    )
{
#define McTemplateCoU0htz_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0htz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0htz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0htz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0htz_def

//
// Function for template "ClrStackWalk" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0huuqP2_def
#define McTemplateCoU0huuqP2_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0huuqP2_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned char  _Arg1,
    _In_ const unsigned char  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_reads_(2) const void* *_Arg4
    )
{
#define McTemplateCoU0huuqP2_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0huuqP2_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5], _Arg4, sizeof(const void*)*2);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0huuqP2_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0huuqP2_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0huuqP2_def

//
// Function for template "ModuleRange" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hxqqu_def
#define McTemplateCoU0hxqqu_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hxqqu_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned char  _Arg4
    )
{
#define McTemplateCoU0hxqqu_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hxqqu_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned char)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hxqqu_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hxqqu_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hxqqu_def

//
// Function for template "ModuleRangePrivate" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hxqquuh_def
#define McTemplateCoU0hxqquuh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hxqquuh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned char  _Arg4,
    _In_ const unsigned char  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateCoU0hxqquuh_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hxqquuh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hxqquuh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hxqquuh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hxqquuh_def

//
// Function for template "NgenBindEvent" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hxqz_def
#define McTemplateCoU0hxqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hxqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_opt_ PCWSTR  _Arg3
    )
{
#define McTemplateCoU0hxqz_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hxqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hxqz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hxqz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hxqz_def

//
// Function for template "MulticoreJitMethodCodeReturnedPrivate" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hxx_def
#define McTemplateCoU0hxx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hxx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2
    )
{
#define McTemplateCoU0hxx_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hxx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hxx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hxx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hxx_def

//
// Function for template "ILStubGenerated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hxxqqzzzzzz_def
#define McTemplateCoU0hxxqqzzzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hxxqqzzzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_opt_ PCWSTR  _Arg10
    )
{
#define McTemplateCoU0hxxqqzzzzzz_ARGCOUNT 11
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hxxqqzzzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hxxqqzzzzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hxxqqzzzzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hxxqqzzzzzz_def

//
// Function for template "ILStubCacheHit" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hxxqzzz_def
#define McTemplateCoU0hxxqzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hxxqzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6
    )
{
#define McTemplateCoU0hxxqzzz_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hxxqzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hxxqzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hxxqzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hxxqzzz_def

//
// Function for template "JittedMethodRichDebugInfo" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hxxxqqbr5_def
#define McTemplateCoU0hxxxqqbr5_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hxxxqqbr5_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_reads_(_Arg5) const unsigned char*  _Arg6
    )
{
#define McTemplateCoU0hxxxqqbr5_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hxxxqqbr5_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],_Arg6, (ULONG)sizeof(char)*_Arg5);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hxxxqqbr5_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hxxxqqbr5_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hxxxqqbr5_def

//
// Function for template "ProfilerMessage" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hz_def
#define McTemplateCoU0hz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1
    )
{
#define McTemplateCoU0hz_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hz_def

//
// Function for template "KnownPathProbed" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hzhd_def
#define McTemplateCoU0hzhd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hzhd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const signed int  _Arg3
    )
{
#define McTemplateCoU0hzhd_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hzhd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hzhd_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hzhd_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hzhd_def

//
// Function for template "ResolutionAttempted" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hzhzhzzz_def
#define McTemplateCoU0hzhzhzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hzhzhzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7
    )
{
#define McTemplateCoU0hzhzhzzz_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hzhzhzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hzhzhzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hzhzhzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hzhzhzzz_def

//
// Function for template "ExecutionCheckpoint" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hzi_def
#define McTemplateCoU0hzi_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hzi_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const signed __int64  _Arg2
    )
{
#define McTemplateCoU0hzi_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hzi_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hzi_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hzi_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hzi_def

//
// Function for template "AssemblyLoadFromResolveHandlerInvoked" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hztzz_def
#define McTemplateCoU0hztzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hztzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const signed int  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4
    )
{
#define McTemplateCoU0hztzz_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hztzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hztzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hztzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hztzz_def

//
// Function for template "MulticoreJitPrivate" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hzzddd_def
#define McTemplateCoU0hzzddd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hzzddd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const signed int  _Arg3,
    _In_ const signed int  _Arg4,
    _In_ const signed int  _Arg5
    )
{
#define McTemplateCoU0hzzddd_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hzzddd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const signed int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hzzddd_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hzzddd_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hzzddd_def

//
// Function for template "AppDomainAssemblyResolveHandlerInvoked" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hzzzz_def
#define McTemplateCoU0hzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4
    )
{
#define McTemplateCoU0hzzzz_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hzzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hzzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hzzzz_def

//
// Function for template "AssemblyLoadStart" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hzzzzz_def
#define McTemplateCoU0hzzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hzzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5
    )
{
#define McTemplateCoU0hzzzzz_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hzzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hzzzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hzzzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hzzzzz_def

//
// Function for template "AssemblyLoadStop" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0hzzzzztzzt_def
#define McTemplateCoU0hzzzzztzzt_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0hzzzzztzzt_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const signed int  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9
    )
{
#define McTemplateCoU0hzzzzztzzt_ARGCOUNT 10
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0hzzzzztzzt_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0hzzzzztzzt_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0hzzzzztzzt_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0hzzzzztzzt_def

//
// Function for template "JitChunkDestroyed" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0p_def
#define McTemplateCoU0p_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0p_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0
    )
{
#define McTemplateCoU0p_ARGCOUNT 1
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0p_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0p_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0p_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0p_def

//
// Function for template "DestroyGCHandle" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0ph_def
#define McTemplateCoU0ph_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0ph_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateCoU0ph_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0ph_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0ph_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0ph_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0ph_def

//
// Function for template "FinalizeObject" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pph_def
#define McTemplateCoU0pph_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pph_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateCoU0pph_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pph_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pph_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pph_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pph_def

//
// Function for template "PrvFinalizeObject" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pphz_def
#define McTemplateCoU0pphz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pphz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_opt_ PCWSTR  _Arg3
    )
{
#define McTemplateCoU0pphz_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pphz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pphz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pphz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pphz_def

//
// Function for template "PinPlugAtGCTime" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0ppph_def
#define McTemplateCoU0ppph_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0ppph_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0ppph_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0ppph_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0ppph_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0ppph_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0ppph_def

//
// Function for template "CCWRefCountChangeAnsi" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pppqxsszh_def
#define McTemplateCoU0pppqxsszh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pppqxsszh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCSTR  _Arg5,
    _In_opt_ PCSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_ const unsigned short  _Arg8
    )
{
#define McTemplateCoU0pppqxsszh_ARGCOUNT 9
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pppqxsszh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : "NULL",
                        (_Arg5 != NULL) ? (ULONG)((strlen(_Arg5) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : "NULL",
                        (_Arg6 != NULL) ? (ULONG)((strlen(_Arg6) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pppqxsszh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pppqxsszh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pppqxsszh_def

//
// Function for template "CCWRefCountChange" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pppqxzzzh_def
#define McTemplateCoU0pppqxzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pppqxzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_ const unsigned short  _Arg8
    )
{
#define McTemplateCoU0pppqxzzzh_ARGCOUNT 9
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pppqxzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pppqxzzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pppqxzzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pppqxzzzh_def

//
// Function for template "SetGCHandle" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0ppqqxh_def
#define McTemplateCoU0ppqqxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0ppqqxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0ppqqxh_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0ppqqxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0ppqqxh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0ppqqxh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0ppqqxh_def

//
// Function for template "GCSampledObjectAllocation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0ppqxh_def
#define McTemplateCoU0ppqxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0ppqxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0ppqxh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0ppqxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0ppqxh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0ppqxh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0ppqxh_def

//
// Function for template "ThreadPoolIOWorkEnqueue" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0ppth_def
#define McTemplateCoU0ppth_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0ppth_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const signed int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0ppth_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0ppth_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0ppth_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0ppth_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0ppth_def

//
// Function for template "PinObjectAtGCTime" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0ppxzh_def
#define McTemplateCoU0ppxzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0ppxzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0ppxzh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0ppxzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0ppxzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0ppxzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0ppxzh_def

//
// Function for template "JitChunkCreated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0px_def
#define McTemplateCoU0px_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0px_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_ const unsigned __int64  _Arg1
    )
{
#define McTemplateCoU0px_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0px_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0px_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0px_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0px_def

//
// Function for template "JitCodeBuffer" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pxu_def
#define McTemplateCoU0pxu_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pxu_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned char  _Arg2
    )
{
#define McTemplateCoU0pxu_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pxu_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned char)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pxu_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pxu_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pxu_def

//
// Function for template "GCRootRegister" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pxuxz_def
#define McTemplateCoU0pxuxz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pxuxz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned char  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ PCWSTR  _Arg4
    )
{
#define McTemplateCoU0pxuxz_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pxuxz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pxuxz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pxuxz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pxuxz_def

//
// Function for template "ContextLoadedUnloaded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pxx_def
#define McTemplateCoU0pxx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pxx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2
    )
{
#define McTemplateCoU0pxx_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pxx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pxx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pxx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pxx_def

//
// Function for template "GCHeapDumpObjectReference" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0pxxuqNR4_def
#define McTemplateCoU0pxxuqNR4_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0pxxuqNR4_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned char  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ ULONG _Arg5_Len_,
    _In_ const void*  _Arg5
    )
{
#define McTemplateCoU0pxxuqNR4_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0pxxuqNR4_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],_Arg5, _Arg4 * _Arg5_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0pxxuqNR4_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0pxxuqNR4_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0pxxuqNR4_def

//
// Function for template "GCFinalizersEnd" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0q_def
#define McTemplateCoU0q_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0q_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0
    )
{
#define McTemplateCoU0q_ARGCOUNT 1
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0q_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0q_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0q_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0q_def

//
// Function for template "GCMoves" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qNR0_def
#define McTemplateCoU0qNR0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qNR0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ ULONG _Arg1_Len_,
    _In_ const void*  _Arg1
    )
{
#define McTemplateCoU0qNR0_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qNR0_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],_Arg1, _Arg0 * _Arg1_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qNR0_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qNR0_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qNR0_def

//
// Function for template "GCEnd" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qh_def
#define McTemplateCoU0qh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateCoU0qh_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qh_def

//
// Function for template "BulkType" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qhNR0_def
#define McTemplateCoU0qhNR0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qhNR0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ ULONG _Arg2_Len_,
    _In_ const void*  _Arg2
    )
{
#define McTemplateCoU0qhNR0_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qhNR0_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],_Arg2, _Arg2_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qhNR0_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qhNR0_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qhNR0_def

//
// Function for template "TypeLoadStop" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qhhxz_def
#define McTemplateCoU0qhhxz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qhhxz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ PCWSTR  _Arg4
    )
{
#define McTemplateCoU0qhhxz_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qhhxz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qhhxz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qhhxz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qhhxz_def

//
// Function for template "GCMarkWithType" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qhqx_def
#define McTemplateCoU0qhqx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qhqx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned __int64  _Arg3
    )
{
#define McTemplateCoU0qhqx_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qhqx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qhqx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qhqx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qhqx_def

//
// Function for template "GCStart" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qq_def
#define McTemplateCoU0qq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1
    )
{
#define McTemplateCoU0qq_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qq_def

//
// Function for template "GCEnd_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqh_def
#define McTemplateCoU0qqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateCoU0qqh_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqh_def

//
// Function for template "GCBulkRootEdge" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqhNR1_def
#define McTemplateCoU0qqhNR1_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ ULONG _Arg3_Len_,
    _In_ const void*  _Arg3
    )
{
#define McTemplateCoU0qqhNR1_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqhNR1_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],_Arg3, _Arg1 * _Arg3_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqhNR1_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqhNR1_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqhNR1_def

//
// Function for template "GCAllocationTick_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqhxpzq_def
#define McTemplateCoU0qqhxpzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqhxpzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ const void*  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6
    )
{
#define McTemplateCoU0qqhxpzq_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqhxpzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqhxpzq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqhxpzq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqhxpzq_def

//
// Function for template "GCAllocationTick_V3" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqhxpzqp_def
#define McTemplateCoU0qqhxpzqp_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqhxpzqp_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ const void*  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ const void*  _Arg7
    )
{
#define McTemplateCoU0qqhxpzqp_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqhxpzqp_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const void*)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqhxpzqp_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqhxpzqp_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqhxpzqp_def

//
// Function for template "GCAllocationTick_V4" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqhxpzqpx_def
#define McTemplateCoU0qqhxpzqpx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqhxpzqpx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ const void*  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ const void*  _Arg7,
    _In_ const unsigned __int64  _Arg8
    )
{
#define McTemplateCoU0qqhxpzqpx_ARGCOUNT 9
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqhxpzqpx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const void*)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqhxpzqpx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqhxpzqpx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqhxpzqpx_def

//
// Function for template "GCJoin" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqq_def
#define McTemplateCoU0qqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2
    )
{
#define McTemplateCoU0qqq_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqq_def

//
// Function for template "GCJoin_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqqh_def
#define McTemplateCoU0qqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0qqqh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqqh_def

//
// Function for template "GCJoin_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqqhq_def
#define McTemplateCoU0qqqhq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqqhq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_ const unsigned int  _Arg4
    )
{
#define McTemplateCoU0qqqhq_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqqhq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqqhq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqqhq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqqhq_def

//
// Function for template "GCStart_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqqqh_def
#define McTemplateCoU0qqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0qqqqh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqqqh_def

//
// Function for template "GCStart_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqqqhx_def
#define McTemplateCoU0qqqqhx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqqqhx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned __int64  _Arg5
    )
{
#define McTemplateCoU0qqqqhx_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqqqhx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqqqhx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqqqhx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqqqhx_def

//
// Function for template "Binding" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqqqzzh_def
#define McTemplateCoU0qqqqzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqqqzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateCoU0qqqqzzh_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqqqzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqqqzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqqqzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqqqzzh_def

//
// Function for template "StrongNameVerification" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqz_def
#define McTemplateCoU0qqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2
    )
{
#define McTemplateCoU0qqz_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqz_def

//
// Function for template "StrongNameVerification_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qqzh_def
#define McTemplateCoU0qqzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qqzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0qqzh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qqzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qqzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qqzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qqzh_def

//
// Function for template "StressLog" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qus_def
#define McTemplateCoU0qus_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qus_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned char  _Arg1,
    _In_opt_ PCSTR  _Arg2
    )
{
#define McTemplateCoU0qus_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qus_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : "NULL",
                        (_Arg2 != NULL) ? (ULONG)((strlen(_Arg2) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qus_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qus_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qus_def

//
// Function for template "StressLog_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qush_def
#define McTemplateCoU0qush_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qush_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned char  _Arg1,
    _In_opt_ PCSTR  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0qush_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qush_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : "NULL",
                        (_Arg2 != NULL) ? (ULONG)((strlen(_Arg2) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qush_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qush_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qush_def

//
// Function for template "GCBulkRootStaticVar" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qxhNR0_def
#define McTemplateCoU0qxhNR0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qxhNR0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ ULONG _Arg3_Len_,
    _In_ const void*  _Arg3
    )
{
#define McTemplateCoU0qxhNR0_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qxhNR0_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],_Arg3, _Arg0 * _Arg3_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qxhNR0_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qxhNR0_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qxhNR0_def

//
// Function for template "TokenTransparencyCalculation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qzqh_def
#define McTemplateCoU0qzqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qzqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0qzqh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qzqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qzqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qzqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qzqh_def

//
// Function for template "TokenTransparencyCalculationResult" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0qzqtth_def
#define McTemplateCoU0qzqtth_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0qzqtth_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const signed int  _Arg3,
    _In_ const signed int  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0qzqtth_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0qzqtth_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0qzqtth_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0qzqtth_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0qzqtth_def

//
// Function for template "GCDecision" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0t_def
#define McTemplateCoU0t_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0t_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const signed int  _Arg0
    )
{
#define McTemplateCoU0t_ARGCOUNT 1
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0t_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const signed int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0t_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0t_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0t_def

//
// Function for template "GCDecision_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0th_def
#define McTemplateCoU0th_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0th_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const signed int  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateCoU0th_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0th_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0th_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0th_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0th_def

//
// Function for template "Contention" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0uh_def
#define McTemplateCoU0uh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0uh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateCoU0uh_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0uh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0uh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0uh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0uh_def

//
// Function for template "ContentionStop_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0uhg_def
#define McTemplateCoU0uhg_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0uhg_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const double  _Arg2
    )
{
#define McTemplateCoU0uhg_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0uhg_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const double)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0uhg_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0uhg_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0uhg_def

//
// Function for template "ContentionStart_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0uhppx_def
#define McTemplateCoU0uhppx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0uhppx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_opt_ const void*  _Arg3,
    _In_ const unsigned __int64  _Arg4
    )
{
#define McTemplateCoU0uhppx_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0uhppx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const void*)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0uhppx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0uhppx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0uhppx_def

//
// Function for template "GCGenerationRange" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0upxxh_def
#define McTemplateCoU0upxxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0upxxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0upxxh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0upxxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0upxxh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0upxxh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0upxxh_def

//
// Function for template "GCEvent" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0uq_def
#define McTemplateCoU0uq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0uq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_ const unsigned int  _Arg1
    )
{
#define McTemplateCoU0uq_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0uq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0uq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0uq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0uq_def

//
// Function for template "ExceptionClause" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0uqxxp_def
#define McTemplateCoU0uqxxp_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0uqxxp_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ const void*  _Arg4
    )
{
#define McTemplateCoU0uqxxp_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0uqxxp_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0uqxxp_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0uqxxp_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0uqxxp_def

//
// Function for template "GCFreeSegment" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0x_def
#define McTemplateCoU0x_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0x_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0
    )
{
#define McTemplateCoU0x_ARGCOUNT 1
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0x_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0x_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0x_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0x_def

//
// Function for template "GCGlobalHeap" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xdqqqq_def
#define McTemplateCoU0xdqqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xdqqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5
    )
{
#define McTemplateCoU0xdqqqq_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xdqqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xdqqqq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xdqqqq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xdqqqq_def

//
// Function for template "GCGlobalHeap_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xdqqqqh_def
#define McTemplateCoU0xdqqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xdqqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateCoU0xdqqqqh_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xdqqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xdqqqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xdqqqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xdqqqqh_def

//
// Function for template "GCGlobalHeap_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xdqqqqhqq_def
#define McTemplateCoU0xdqqqqhqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xdqqqqhqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_ const unsigned int  _Arg8
    )
{
#define McTemplateCoU0xdqqqqhqq_ARGCOUNT 9
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xdqqqqhqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xdqqqqhqq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xdqqqqhqq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xdqqqqhqq_def

//
// Function for template "GCGlobalHeap_V3" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xdqqqqhqqqq_def
#define McTemplateCoU0xdqqqqhqqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xdqqqqhqqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_ const unsigned int  _Arg8,
    _In_ const unsigned int  _Arg9,
    _In_ const unsigned int  _Arg10
    )
{
#define McTemplateCoU0xdqqqqhqqqq_ARGCOUNT 11
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xdqqqqhqqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xdqqqqhqqqq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xdqqqqhqqqq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xdqqqqhqqqq_def

//
// Function for template "GCGlobalHeap_V4" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xdqqqqhqqqqqNR11_def
#define McTemplateCoU0xdqqqqhqqqqqNR11_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xdqqqqhqqqqqNR11_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_ const unsigned int  _Arg8,
    _In_ const unsigned int  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ ULONG _Arg12_Len_,
    _In_ const void*  _Arg12
    )
{
#define McTemplateCoU0xdqqqqhqqqqqNR11_ARGCOUNT 13
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xdqqqqhqqqqqNR11_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],_Arg12, _Arg11 * _Arg12_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xdqqqqhqqqqqNR11_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xdqqqqhqqqqqNR11_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xdqqqqhqqqqqNR11_def

//
// Function for template "GCFreeSegment_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xh_def
#define McTemplateCoU0xh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateCoU0xh_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xh_def

//
// Function for template "CodeSymbols" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xhhqbr3h_def
#define McTemplateCoU0xhhqbr3h_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xhhqbr3h_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_reads_(_Arg3) const unsigned char*  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0xhhqbr3h_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xhhqbr3h_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],_Arg4, (ULONG)sizeof(char)*_Arg3);

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xhhqbr3h_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xhhqbr3h_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xhhqbr3h_def

//
// Function for template "ExceptionThrow" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xp_def
#define McTemplateCoU0xp_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xp_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_opt_ const void*  _Arg1
    )
{
#define McTemplateCoU0xp_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xp_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xp_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xp_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xp_def

//
// Function for template "GCAllocation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xpx_def
#define McTemplateCoU0xpx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xpx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned __int64  _Arg2
    )
{
#define McTemplateCoU0xpx_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xpx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xpx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xpx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xpx_def

//
// Function for template "AppDomainLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xqz_def
#define McTemplateCoU0xqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2
    )
{
#define McTemplateCoU0xqz_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xqz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xqz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xqz_def

//
// Function for template "AppDomainLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xqzqh_def
#define McTemplateCoU0xqzqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xqzqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0xqzqh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xqzqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xqzqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xqzqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xqzqh_def

//
// Function for template "GCHandleDeleted" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xu_def
#define McTemplateCoU0xu_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xu_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned char  _Arg1
    )
{
#define McTemplateCoU0xu_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xu_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned char)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xu_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xu_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xu_def

//
// Function for template "GCHandleCreated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xup_def
#define McTemplateCoU0xup_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xup_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned char  _Arg1,
    _In_opt_ const void*  _Arg2
    )
{
#define McTemplateCoU0xup_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xup_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xup_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xup_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xup_def

//
// Function for template "ClassLoadingFailed" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xx_def
#define McTemplateCoU0xx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1
    )
{
#define McTemplateCoU0xx_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xx_def

//
// Function for template "AppDomainMemAllocated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxh_def
#define McTemplateCoU0xxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateCoU0xxh_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxh_def

//
// Function for template "GCCreateSegment" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxq_def
#define McTemplateCoU0xxq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2
    )
{
#define McTemplateCoU0xxq_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxq_def

//
// Function for template "GCCreateSegment_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqh_def
#define McTemplateCoU0xxqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0xxqh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqh_def

//
// Function for template "JitDone_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqNR3_def
#define McTemplateCoU0xxqqNR3_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqNR3_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ ULONG _Arg4_Len_,
    _In_ const void*  _Arg4
    )
{
#define McTemplateCoU0xxqqNR3_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqNR3_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],_Arg4, _Arg3 * _Arg4_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqNR3_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqNR3_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqNR3_def

//
// Function for template "ThreadCreated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqqh_def
#define McTemplateCoU0xxqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0xxqqqh_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqqh_def

//
// Function for template "MethodDetails" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqxXR3_def
#define McTemplateCoU0xxqqxXR3_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqxXR3_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_reads_(_Arg3) const unsigned __int64 *_Arg5
    )
{
#define McTemplateCoU0xxqqxXR3_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqxXR3_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6], _Arg5, sizeof(const unsigned __int64)*_Arg3);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqxXR3_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqxXR3_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqxXR3_def

//
// Function for template "ModuleLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqzz_def
#define McTemplateCoU0xxqqzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5
    )
{
#define McTemplateCoU0xxqqzz_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqzz_def

//
// Function for template "ModuleLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqzzh_def
#define McTemplateCoU0xxqqzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateCoU0xxqqzzh_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqzzh_def

//
// Function for template "ModuleLoadUnload_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqzzhjqzjqz_def
#define McTemplateCoU0xxqqzzhjqzjqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const GUID*  _Arg7,
    _In_ const unsigned int  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_ const GUID*  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_opt_ PCWSTR  _Arg12
    )
{
#define McTemplateCoU0xxqqzzhjqzjqz_ARGCOUNT 13
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqzzhjqzjqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],_Arg7, sizeof(GUID)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],_Arg10, sizeof(GUID)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqzzhjqzjqz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqzzhjqzjqz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqzzhjqzjqz_def

//
// Function for template "MethodJittingStarted" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqzzz_def
#define McTemplateCoU0xxqqzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6
    )
{
#define McTemplateCoU0xxqqzzz_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqzzz_def

//
// Function for template "MethodJittingStarted_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqqzzzh_def
#define McTemplateCoU0xxqqzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqqzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_ const unsigned short  _Arg7
    )
{
#define McTemplateCoU0xxqqzzzh_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqqzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqqzzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqqzzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqqzzzh_def

//
// Function for template "AssemblyLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxqz_def
#define McTemplateCoU0xxqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_opt_ PCWSTR  _Arg3
    )
{
#define McTemplateCoU0xxqz_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxqz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxqz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxqz_def

//
// Function for template "GCSettings" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxt_def
#define McTemplateCoU0xxt_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxt_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const signed int  _Arg2
    )
{
#define McTemplateCoU0xxt_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxt_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxt_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxt_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxt_def

//
// Function for template "GCSettings_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxth_def
#define McTemplateCoU0xxth_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxth_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const signed int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0xxth_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxth_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxth_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxth_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxth_def

//
// Function for template "MethodILToNativeMap" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxuhQR3QR3h_def
#define McTemplateCoU0xxuhQR3QR3h_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned char  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_reads_(_Arg3) const unsigned int *_Arg4,
    _In_reads_(_Arg3) const unsigned int *_Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateCoU0xxuhQR3QR3h_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxuhQR3QR3h_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5], _Arg4, sizeof(const unsigned int)*_Arg3);

    EventDataDescCreate(&EventData[6], _Arg5, sizeof(const unsigned int)*_Arg3);

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxuhQR3QR3h_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxuhQR3QR3h_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxuhQR3QR3h_def

//
// Function for template "MethodILToNativeMap_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxuhQR3QR3hx_def
#define McTemplateCoU0xxuhQR3QR3hx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxuhQR3QR3hx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned char  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_reads_(_Arg3) const unsigned int *_Arg4,
    _In_reads_(_Arg3) const unsigned int *_Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned __int64  _Arg7
    )
{
#define McTemplateCoU0xxuhQR3QR3hx_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxuhQR3QR3hx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5], _Arg4, sizeof(const unsigned int)*_Arg3);

    EventDataDescCreate(&EventData[6], _Arg5, sizeof(const unsigned int)*_Arg3);

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxuhQR3QR3hx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxuhQR3QR3hx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxuhQR3QR3hx_def

//
// Function for template "VTableLoadingFailedLoaded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxx_def
#define McTemplateCoU0xxx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2
    )
{
#define McTemplateCoU0xxx_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxx_def

//
// Function for template "AppDomainMemSurvived" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxh_def
#define McTemplateCoU0xxxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0xxxh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxh_def

//
// Function for template "BGCOverflow" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqh_def
#define McTemplateCoU0xxxqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0xxxqh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqh_def

//
// Function for template "BGCOverflow_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqhq_def
#define McTemplateCoU0xxxqhq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqhq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned int  _Arg5
    )
{
#define McTemplateCoU0xxxqhq_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqhq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqhq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqhq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqhq_def

//
// Function for template "MethodLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqq_def
#define McTemplateCoU0xxxqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5
    )
{
#define McTemplateCoU0xxxqqq_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqq_def

//
// Function for template "MethodLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqqh_def
#define McTemplateCoU0xxxqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateCoU0xxxqqqh_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqqh_def

//
// Function for template "MethodLoadUnload_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqqhx_def
#define McTemplateCoU0xxxqqqhx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned __int64  _Arg7
    )
{
#define McTemplateCoU0xxxqqqhx_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqqhx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqqhx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqqhx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqqhx_def

//
// Function for template "MethodLoadUnloadVerbose" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqqzzz_def
#define McTemplateCoU0xxxqqqzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8
    )
{
#define McTemplateCoU0xxxqqqzzz_ARGCOUNT 9
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqqzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqqzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqqzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqqzzz_def

//
// Function for template "MethodLoadUnloadVerbose_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqqzzzh_def
#define McTemplateCoU0xxxqqqzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned short  _Arg9
    )
{
#define McTemplateCoU0xxxqqqzzzh_ARGCOUNT 10
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqqzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqqzzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqqzzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqqzzzh_def

//
// Function for template "MethodLoadUnloadVerbose_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqqzzzhx_def
#define McTemplateCoU0xxxqqqzzzhx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned short  _Arg9,
    _In_ const unsigned __int64  _Arg10
    )
{
#define McTemplateCoU0xxxqqqzzzhx_ARGCOUNT 11
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqqzzzhx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqqzzzhx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqqzzzhx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqqzzzhx_def

//
// Function for template "DomainModuleLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqzz_def
#define McTemplateCoU0xxxqqzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6
    )
{
#define McTemplateCoU0xxxqqzz_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqzz_def

//
// Function for template "DomainModuleLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqqzzh_def
#define McTemplateCoU0xxxqqzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_ const unsigned short  _Arg7
    )
{
#define McTemplateCoU0xxxqqzzh_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqqzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqqzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqqzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqqzzh_def

//
// Function for template "AssemblyLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxqzh_def
#define McTemplateCoU0xxxqzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0xxxqzh_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxqzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxqzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxqzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxqzh_def

//
// Function for template "MethodJitMemoryAllocatedForCode" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxxxqh_def
#define McTemplateCoU0xxxxxqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxxxqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateCoU0xxxxxqh_ARGCOUNT 7
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxxxqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxxxqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxxxqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxxxqh_def

//
// Function for template "GCSettingsRundown" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxxxqqh_def
#define McTemplateCoU0xxxxxqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxxxqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_ const unsigned short  _Arg7
    )
{
#define McTemplateCoU0xxxxxqqh_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxxxqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxxxqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxxxqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxxxqqh_def

//
// Function for template "GCHeapStats" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxxxxxxxxqqq_def
#define McTemplateCoU0xxxxxxxxxxqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxxxxxxxxqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_ const unsigned __int64  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ const unsigned int  _Arg12
    )
{
#define McTemplateCoU0xxxxxxxxxxqqq_ARGCOUNT 13
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxxxxxxxxqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const unsigned int)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxxxxxxxxqqq_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxxxxxxxxqqq_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxxxxxxxxqqq_def

//
// Function for template "GCHeapStats_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxxxxxxxxqqqh_def
#define McTemplateCoU0xxxxxxxxxxqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxxxxxxxxqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_ const unsigned __int64  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ const unsigned int  _Arg12,
    _In_ const unsigned short  _Arg13
    )
{
#define McTemplateCoU0xxxxxxxxxxqqqh_ARGCOUNT 14
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxxxxxxxxqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxxxxxxxxqqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxxxxxxxxqqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxxxxxxxxqqqh_def

//
// Function for template "GCHeapStats_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxxxxxxxxqqqhxx_def
#define McTemplateCoU0xxxxxxxxxxqqqhxx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxxxxxxxxqqqhxx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_ const unsigned __int64  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ const unsigned int  _Arg12,
    _In_ const unsigned short  _Arg13,
    _In_ const unsigned __int64  _Arg14,
    _In_ const unsigned __int64  _Arg15
    )
{
#define McTemplateCoU0xxxxxxxxxxqqqhxx_ARGCOUNT 16
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxxxxxxxxqqqhxx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[15],&_Arg14, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[16],&_Arg15, sizeof(const unsigned __int64)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxxxxxxxxqqqhxx_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxxxxxxxxqqqhxx_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxxxxxxxxqqqhxx_def

//
// Function for template "GCHeapDumpVTableClassReference" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxxz_def
#define McTemplateCoU0xxxz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxxz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_opt_ PCWSTR  _Arg3
    )
{
#define McTemplateCoU0xxxz_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxxz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxxz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxxz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxxz_def

//
// Function for template "ClassLoaded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxz_def
#define McTemplateCoU0xxz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_opt_ PCWSTR  _Arg2
    )
{
#define McTemplateCoU0xxz_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxz_def

//
// Function for template "ExceptionHandling" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxzh_def
#define McTemplateCoU0xxzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0xxzh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxzh_def

//
// Function for template "ClassLoaded_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xxzqNR3_def
#define McTemplateCoU0xxzqNR3_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xxzqNR3_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ ULONG _Arg4_Len_,
    _In_ const void*  _Arg4
    )
{
#define McTemplateCoU0xxzqNR3_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xxzqNR3_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],_Arg4, _Arg3 * _Arg4_Len_);

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xxzqNR3_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xxzqNR3_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xxzqNR3_def

//
// Function for template "AppDomainName" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xz_def
#define McTemplateCoU0xz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_opt_ PCWSTR  _Arg1
    )
{
#define McTemplateCoU0xz_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xz_def

//
// Function for template "ModuleLoadedUnloaded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xzz_def
#define McTemplateCoU0xzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2
    )
{
#define McTemplateCoU0xzz_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xzz_def

//
// Function for template "JitDoneVerbose" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xzzz_def
#define McTemplateCoU0xzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3
    )
{
#define McTemplateCoU0xzzz_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xzzz_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xzzz_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xzzz_def

//
// Function for template "R2RGetEntryPoint" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0xzzzxh_def
#define McTemplateCoU0xzzzxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0xzzzxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0xzzzxh_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0xzzzxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0xzzzxh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0xzzzxh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0xzzzxh_def

//
// Function for template "GCHeapDumpStart" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0z_def
#define McTemplateCoU0z_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0z_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0
    )
{
#define McTemplateCoU0z_ARGCOUNT 1
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0z_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0z_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0z_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0z_def

//
// Function for template "DynamicTypeUseStringAndIntPrivate" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zdh_def
#define McTemplateCoU0zdh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zdh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateCoU0zdh_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zdh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zdh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zdh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zdh_def

//
// Function for template "DynamicTypeUsePrivate" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zh_def
#define McTemplateCoU0zh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateCoU0zh_ARGCOUNT 2
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zh_def

//
// Function for template "FailFast" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zpqqh_def
#define McTemplateCoU0zpqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zpqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateCoU0zpqqh_ARGCOUNT 5
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zpqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zpqqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zpqqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zpqqh_def

//
// Function for template "GCDynamicEvent" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zqbr1h_def
#define McTemplateCoU0zqbr1h_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zqbr1h_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_reads_(_Arg1) const unsigned char*  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0zqbr1h_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zqbr1h_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],_Arg2, (ULONG)sizeof(char)*_Arg1);

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zqbr1h_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zqbr1h_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zqbr1h_def

//
// Function for template "ModuleTransparencyCalculation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zqh_def
#define McTemplateCoU0zqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateCoU0zqh_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zqh_def

//
// Function for template "ModuleTransparencyCalculationResult" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zqttttqh_def
#define McTemplateCoU0zqttttqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zqttttqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const signed int  _Arg2,
    _In_ const signed int  _Arg3,
    _In_ const signed int  _Arg4,
    _In_ const signed int  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_ const unsigned short  _Arg7
    )
{
#define McTemplateCoU0zqttttqh_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zqttttqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zqttttqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zqttttqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zqttttqh_def

//
// Function for template "DynamicTypeUseTwoParametersPrivate" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzh_def
#define McTemplateCoU0zzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateCoU0zzh_ARGCOUNT 3
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzh_def

//
// Function for template "Exception" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzpqhh_def
#define McTemplateCoU0zzpqhh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzpqhh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0zzpqhh_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzpqhh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzpqhh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzpqhh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzpqhh_def

//
// Function for template "TypeTransparencyCalculation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzqh_def
#define McTemplateCoU0zzqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0zzqh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzqh_def

//
// Function for template "MethodTransparencyCalculationResult" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzqtth_def
#define McTemplateCoU0zzqtth_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzqtth_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const signed int  _Arg3,
    _In_ const signed int  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateCoU0zzqtth_ARGCOUNT 6
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzqtth_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzqtth_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzqtth_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzqtth_def

//
// Function for template "TypeTransparencyCalculationResult" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzqtttth_def
#define McTemplateCoU0zzqtttth_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzqtttth_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const signed int  _Arg3,
    _In_ const signed int  _Arg4,
    _In_ const signed int  _Arg5,
    _In_ const signed int  _Arg6,
    _In_ const unsigned short  _Arg7
    )
{
#define McTemplateCoU0zzqtttth_ARGCOUNT 8
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzqtttth_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzqtttth_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzqtttth_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzqtttth_def

//
// Function for template "DynamicTypeUsePrivateVariance" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzzh_def
#define McTemplateCoU0zzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateCoU0zzzh_ARGCOUNT 4
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzzh_def

//
// Function for template "MethodJitInliningSucceeded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzzzzzzzzh_def
#define McTemplateCoU0zzzzzzzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzzzzzzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned short  _Arg9
    )
{
#define McTemplateCoU0zzzzzzzzzh_ARGCOUNT 10
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzzzzzzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzzzzzzzzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzzzzzzzzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzzzzzzzzh_def

//
// Function for template "MethodJitTailCallSucceeded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzzzzzzzztqh_def
#define McTemplateCoU0zzzzzzzzztqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzzzzzzzztqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned short  _Arg11
    )
{
#define McTemplateCoU0zzzzzzzzztqh_ARGCOUNT 12
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzzzzzzzztqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzzzzzzzztqh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzzzzzzzztqh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzzzzzzzztqh_def

//
// Function for template "MethodJitInliningFailedAnsi" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzzzzzzzztsh_def
#define McTemplateCoU0zzzzzzzzztsh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzzzzzzzztsh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9,
    _In_opt_ PCSTR  _Arg10,
    _In_ const unsigned short  _Arg11
    )
{
#define McTemplateCoU0zzzzzzzzztsh_ARGCOUNT 12
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzzzzzzzztsh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : "NULL",
                        (_Arg10 != NULL) ? (ULONG)((strlen(_Arg10) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzzzzzzzztsh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzzzzzzzztsh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzzzzzzzztsh_def

//
// Function for template "MethodJitTailCallFailed" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateCoU0zzzzzzzzztzh_def
#define McTemplateCoU0zzzzzzzzztzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateCoU0zzzzzzzzztzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9,
    _In_opt_ PCWSTR  _Arg10,
    _In_ const unsigned short  _Arg11
    )
{
#define McTemplateCoU0zzzzzzzzztzh_ARGCOUNT 12
    ULONG Error = 0;

    EVENT_DATA_DESCRIPTOR EventData[McTemplateCoU0zzzzzzzzztzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned short)  );

    Error = McGenEventWrite(Context, Descriptor, NULL, McTemplateCoU0zzzzzzzzztzh_ARGCOUNT + 1, EventData);

#ifdef MCGEN_CALLOUT
MCGEN_CALLOUT(Context->RegistrationHandle,
              Descriptor,
              McTemplateCoU0zzzzzzzzztzh_ARGCOUNT,
              &EventData[1]);
#endif // MCGEN_CALLOUT

    return Error;
}
#endif // McTemplateCoU0zzzzzzzzztzh_def

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
}
#endif

#define MSG_RuntimePublisher_GCKeywordMessage 0x10000001L
#define MSG_RuntimePublisher_GCHandleKeywordMessage 0x10000002L
#define MSG_RuntimePublisher_AssemblyLoaderKeywordMessage 0x10000003L
#define MSG_RuntimePublisher_LoaderKeywordMessage 0x10000004L
#define MSG_RuntimePublisher_JitKeywordMessage 0x10000005L
#define MSG_RuntimePublisher_NGenKeywordMessage 0x10000006L
#define MSG_RuntimePublisher_StartEnumerationKeywordMessage 0x10000007L
#define MSG_RuntimePublisher_EndEnumerationKeywordMessage 0x10000008L
#define MSG_RuntimePublisher_SecurityKeywordMessage 0x1000000BL
#define MSG_RuntimePublisher_AppDomainResourceManagementKeywordMessage 0x1000000CL
#define MSG_RuntimePublisher_JitTracingKeywordMessage 0x1000000DL
#define MSG_RuntimePublisher_InteropKeywordMessage 0x1000000EL
#define MSG_RuntimePublisher_ContentionKeywordMessage 0x1000000FL
#define MSG_RuntimePublisher_ExceptionKeywordMessage 0x10000010L
#define MSG_RuntimePublisher_ThreadingKeywordMessage 0x10000011L
#define MSG_RuntimePublisher_JittedMethodILToNativeMapKeywordMessage 0x10000012L
#define MSG_RuntimePublisher_OverrideAndSuppressNGenEventsKeywordMessage 0x10000013L
#define MSG_RuntimePublisher_TypeKeywordMessage 0x10000014L
#define MSG_RuntimePublisher_GCHeapDumpKeywordMessage 0x10000015L
#define MSG_RuntimePublisher_GCSampledObjectAllocationHighKeywordMessage 0x10000016L
#define MSG_RuntimePublisher_GCHeapSurvivalAndMovementKeywordMessage 0x10000017L
#define MSG_RuntimePublisher_ManagedHeapCollectKeyword 0x10000018L
#define MSG_RuntimePublisher_GCHeapAndTypeNamesKeyword 0x10000019L
#define MSG_RuntimePublisher_GCSampledObjectAllocationLowKeywordMessage 0x1000001AL
#define MSG_RuntimePublisher_PerfTrackKeywordMessage 0x1000001EL
#define MSG_RuntimePublisher_StackKeywordMessage 0x1000001FL
#define MSG_RuntimePublisher_ThreadTransferKeywordMessage 0x10000020L
#define MSG_RuntimePublisher_DebuggerKeywordMessage 0x10000021L
#define MSG_RuntimePublisher_MonitoringKeywordMessage 0x10000022L
#define MSG_RuntimePublisher_CodeSymbolsKeywordMessage 0x10000023L
#define MSG_RuntimePublisher_EventSourceKeywordMessage 0x10000024L
#define MSG_RuntimePublisher_CompilationKeywordMessage 0x10000025L
#define MSG_RuntimePublisher_CompilationDiagnosticKeywordMessage 0x10000026L
#define MSG_RuntimePublisher_MethodDiagnosticKeywordMessage 0x10000027L
#define MSG_RuntimePublisher_TypeDiagnosticKeywordMessage 0x10000028L
#define MSG_RuntimePublisher_JitInstrumentationDataKeywordMessage 0x10000029L
#define MSG_RuntimePublisher_ProfilerKeywordMessage 0x1000002AL
#define MSG_RundownPublisher_GCKeywordMessage 0x11000001L
#define MSG_RundownPublisher_LoaderKeywordMessage 0x11000004L
#define MSG_RundownPublisher_JitKeywordMessage 0x11000005L
#define MSG_RundownPublisher_NGenKeywordMessage 0x11000006L
#define MSG_RundownPublisher_StartRundownKeywordMessage 0x11000007L
#define MSG_RundownPublisher_EndRundownKeywordMessage 0x11000009L
#define MSG_RuntimePublisher_AppDomainResourceManagementRundownKeywordMessage 0x1100000CL
#define MSG_RundownPublisher_ThreadingKeywordMessage 0x11000011L
#define MSG_RundownPublisher_JittedMethodILToNativeMapRundownKeywordMessage 0x11000012L
#define MSG_RundownPublisher_OverrideAndSuppressNGenEventsRundownKeywordMessage 0x11000013L
#define MSG_RundownPublisher_PerfTrackRundownKeywordMessage 0x1100001EL
#define MSG_RundownPublisher_StackKeywordMessage 0x1100001FL
#define MSG_RundownPublisher_CompilationKeywordMessage 0x11000025L
#define MSG_StressPublisher_StackKeywordMessage 0x1200001FL
#define MSG_PrivatePublisher_GCPrivateKeywordMessage 0x13000001L
#define MSG_PrivatePublisher_BindingKeywordMessage 0x13000002L
#define MSG_PrivatePublisher_NGenForceRestoreKeywordMessage 0x13000003L
#define MSG_PrivatePublisher_PrivateFusionKeywordMessage 0x13000004L
#define MSG_PrivatePublisher_LoaderHeapPrivateKeywordMessage 0x13000005L
#define MSG_PrivatePublisher_DynamicTypeUsageMessage 0x13000006L
#define MSG_PrivatePublisher_SecurityPrivateKeywordMessage 0x1300000BL
#define MSG_PrivatePublisher_InteropPrivateKeywordMessage 0x1300000EL
#define MSG_PrivatePublisher_GCHandlePrivateKeywordMessage 0x1300000FL
#define MSG_PrivatePublisher_MulticoreJitPrivateKeywordMessage 0x13000012L
#define MSG_PrivatePublisher_JittedMethodRichDebugInfoKeyword 0x13000013L
#define MSG_PrivatePublisher_PerfTrackKeywordMessage 0x1300001EL
#define MSG_PrivatePublisher_StackKeywordMessage 0x1300001FL
#define MSG_PrivatePublisher_StartupKeywordMessage 0x13000020L
#define MSG_MonoProfilerPublisher_GCKeywordMessage 0x14000001L
#define MSG_MonoProfilerPublisher_GCHandleKeywordMessage 0x14000002L
#define MSG_MonoProfilerPublisher_LoaderKeywordMessage 0x14000004L
#define MSG_MonoProfilerPublisher_JitKeywordMessage 0x14000005L
#define MSG_MonoProfilerPublisher_ContentionKeywordMessage 0x1400000FL
#define MSG_MonoProfilerPublisher_ExceptionKeywordMessage 0x14000010L
#define MSG_MonoProfilerPublisher_ThreadingKeywordMessage 0x14000011L
#define MSG_MonoProfilerPublisher_GCHeapDumpKeywordMessage 0x14000015L
#define MSG_MonoProfilerPublisher_GCAllocationKeywordMessage 0x14000016L
#define MSG_MonoProfilerPublisher_GCMovesKeywordMessage 0x14000017L
#define MSG_MonoProfilerPublisher_GCHeapCollectKeywordMessage 0x14000018L
#define MSG_MonoProfilerPublisher_GCFinalizationKeywordMessage 0x14000019L
#define MSG_MonoProfilerPublisher_GCResizeKeywordMessage 0x1400001AL
#define MSG_MonoProfilerPublisher_GCRootKeywordMessage 0x1400001BL
#define MSG_MonoProfilerPublisher_GCHeapDumpVTableClassReferenceKeywordMessage 0x1400001CL
#define MSG_MonoProfilerPublisher_MethodTracingKeywordMessage 0x1400001EL
#define MSG_MonoProfilerPublisher_TypeLoadingKeywordMessage 0x14000028L
#define MSG_MonoProfilerPublisher_MonitorKeywordMessage 0x14000029L
#define MSG_RuntimePublisher_GCSuspendEEBeginOpcodeMessage 0x3001000AL
#define MSG_RuntimePublisher_GCAllocationTickOpcodeMessage 0x3001000BL
#define MSG_RuntimePublisher_GCCreateConcurrentThreadOpcodeMessage 0x3001000CL
#define MSG_RuntimePublisher_GCTerminateConcurrentThreadOpcodeMessage 0x3001000DL
#define MSG_RuntimePublisher_GCFinalizersEndOpcodeMessage 0x3001000FL
#define MSG_RuntimePublisher_GCFinalizersBeginOpcodeMessage 0x30010013L
#define MSG_RuntimePublisher_GCBulkRootEdgeOpcodeMessage 0x30010014L
#define MSG_RuntimePublisher_GCBulkRootConditionalWeakTableElementEdgeOpcodeMessage 0x30010015L
#define MSG_RuntimePublisher_GCBulkNodeOpcodeMessage 0x30010016L
#define MSG_RuntimePublisher_GCBulkEdgeOpcodeMessage 0x30010017L
#define MSG_RuntimePublisher_GCSampledObjectAllocationOpcodeMessage 0x30010018L
#define MSG_RuntimePublisher_GCBulkSurvivingObjectRangesOpcodeMessage 0x30010019L
#define MSG_RuntimePublisher_GCBulkMovedObjectRangesOpcodeMessage 0x3001001AL
#define MSG_RuntimePublisher_GCGenerationRangeOpcodeMessage 0x3001001BL
#define MSG_RuntimePublisher_GCMarkStackRootsOpcodeMessage 0x3001001CL
#define MSG_RuntimePublisher_GCMarkFinalizeQueueRootsOpcodeMessage 0x3001001DL
#define MSG_RuntimePublisher_GCMarkHandlesOpcodeMessage 0x3001001EL
#define MSG_RuntimePublisher_GCMarkOlderGenerationRootsOpcodeMessage 0x3001001FL
#define MSG_RuntimePublisher_FinalizeObjectOpcodeMessage 0x30010020L
#define MSG_RuntimePublisher_SetGCHandleOpcodeMessage 0x30010021L
#define MSG_RuntimePublisher_DestroyGCHandleOpcodeMessage 0x30010022L
#define MSG_RuntimePublisher_TriggeredOpcodeMessage 0x30010023L
#define MSG_RuntimePublisher_PinObjectAtGCTimeOpcodeMessage 0x30010024L
#define MSG_RuntimePublisher_GCBulkRootCCWOpcodeMessage 0x30010026L
#define MSG_RuntimePublisher_GCBulkRCWOpcodeMessage 0x30010027L
#define MSG_RuntimePublisher_GCBulkRootStaticVarOpcodeMessage 0x30010028L
#define MSG_RuntimePublisher_GCDynamicEventOpcodeMessage 0x30010029L
#define MSG_RuntimePublisher_GCRestartEEEndOpcodeMessage 0x30010084L
#define MSG_RuntimePublisher_GCHeapStatsOpcodeMessage 0x30010085L
#define MSG_RuntimePublisher_GCCreateSegmentOpcodeMessage 0x30010086L
#define MSG_RuntimePublisher_GCFreeSegmentOpcodeMessage 0x30010087L
#define MSG_RuntimePublisher_GCRestartEEBeginOpcodeMessage 0x30010088L
#define MSG_RuntimePublisher_GCSuspendEEEndOpcodeMessage 0x30010089L
#define MSG_RuntimePublisher_IncreaseMemoryPressureOpcodeMessage 0x300100C8L
#define MSG_RuntimePublisher_DecreaseMemoryPressureOpcodeMessage 0x300100C9L
#define MSG_RuntimePublisher_GCMarkOpcodeMessage 0x300100CAL
#define MSG_RuntimePublisher_GCJoinOpcodeMessage 0x300100CBL
#define MSG_RuntimePublisher_GCPerHeapHistoryOpcodeMessage 0x300100CCL
#define MSG_RuntimePublisher_GCGlobalHeapHistoryOpcodeMessage 0x300100CDL
#define MSG_RuntimePublisher_GenAwareBeginOpcodeMessage 0x300100CEL
#define MSG_RuntimePublisher_GenAwareEndOpcodeMessage 0x300100CFL
#define MSG_RuntimePublisher_GCLOHCompactOpcodeMessage 0x300100D0L
#define MSG_RuntimePublisher_GCFitBucketInfoOpcodeMessage 0x300100D1L
#define MSG_RuntimePublisher_ContentionLockCreatedOpcodeMessage 0x3008000BL
#define MSG_RuntimePublisher_DCStartCompleteOpcodeMessage 0x3009000EL
#define MSG_RuntimePublisher_DCEndCompleteOpcodeMessage 0x3009000FL
#define MSG_RuntimePublisher_MethodLoadOpcodeMessage 0x30090021L
#define MSG_RuntimePublisher_MethodUnloadOpcodeMessage 0x30090022L
#define MSG_RuntimePublisher_MethodDCStartOpcodeMessage 0x30090023L
#define MSG_RuntimePublisher_MethodDCEndOpcodeMessage 0x30090024L
#define MSG_RuntimePublisher_MethodLoadVerboseOpcodeMessage 0x30090025L
#define MSG_RuntimePublisher_MethodUnloadVerboseOpcodeMessage 0x30090026L
#define MSG_RuntimePublisher_MethodDCStartVerboseOpcodeMessage 0x30090027L
#define MSG_RuntimePublisher_MethodDCEndVerboseOpcodeMessage 0x30090028L
#define MSG_RuntimePublisher_MethodJittingStartedOpcodeMessage 0x3009002AL
#define MSG_RuntimePublisher_MethodDetailsOpcodeMessage 0x3009002BL
#define MSG_RuntimePublisher_JitInliningSucceededOpcodeMessage 0x30090053L
#define MSG_RuntimePublisher_JitInliningFailedOpcodeMessage 0x30090054L
#define MSG_RuntimePublisher_JitTailCallSucceededOpcodeMessage 0x30090055L
#define MSG_RuntimePublisher_JitTailCallFailedOpcodeMessage 0x30090056L
#define MSG_RuntimePublisher_MethodILToNativeMapOpcodeMessage 0x30090057L
#define MSG_RuntimePublisher_MemoryAllocatedForJitCodeOpcodeMessage 0x30090067L
#define MSG_RuntimePublisher_ModuleLoadOpcodeMessage 0x300A0021L
#define MSG_RuntimePublisher_ModuleUnloadOpcodeMessage 0x300A0022L
#define MSG_RuntimePublisher_ModuleDCStartOpcodeMessage 0x300A0023L
#define MSG_RuntimePublisher_ModuleDCEndOpcodeMessage 0x300A0024L
#define MSG_RuntimePublisher_AssemblyLoadOpcodeMessage 0x300A0025L
#define MSG_RuntimePublisher_AssemblyUnloadOpcodeMessage 0x300A0026L
#define MSG_RuntimePublisher_AppDomainLoadOpcodeMessage 0x300A0029L
#define MSG_RuntimePublisher_AppDomainUnloadOpcodeMessage 0x300A002AL
#define MSG_RuntimePublisher_DomainModuleLoadOpcodeMessage 0x300A002DL
#define MSG_RuntimePublisher_CLRStackWalkOpcodeMessage 0x300B0052L
#define MSG_RuntimePublisher_AppDomainMemAllocatedOpcodeMessage 0x300E0030L
#define MSG_RuntimePublisher_AppDomainMemSurvivedOpcodeMessage 0x300E0031L
#define MSG_RuntimePublisher_ThreadCreatedOpcodeMessage 0x300E0032L
#define MSG_RuntimePublisher_ThreadTerminatedOpcodeMessage 0x300E0033L
#define MSG_RuntimePublisher_ThreadDomainEnterOpcodeMessage 0x300E0034L
#define MSG_RuntimePublisher_ILStubGeneratedOpcodeMessage 0x300F0058L
#define MSG_RuntimePublisher_ILStubCacheHitOpcodeMessage 0x300F0059L
#define MSG_RuntimePublisher_WaitOpcodeMessage 0x3010005AL
#define MSG_RuntimePublisher_SampleOpcodeMessage 0x30120064L
#define MSG_RuntimePublisher_AdjustmentOpcodeMessage 0x30120065L
#define MSG_RuntimePublisher_StatsOpcodeMessage 0x30120066L
#define MSG_RuntimePublisher_ModuleRangeLoadOpcodeMessage 0x3014000AL
#define MSG_RuntimePublisher_BulkTypeOpcodeMessage 0x3015000AL
#define MSG_RuntimePublisher_EnqueueOpcodeMessage 0x3017000BL
#define MSG_RuntimePublisher_DequeueOpcodeMessage 0x3017000CL
#define MSG_RuntimePublisher_IOEnqueueOpcodeMessage 0x3017000DL
#define MSG_RuntimePublisher_IODequeueOpcodeMessage 0x3017000EL
#define MSG_RuntimePublisher_IOPackOpcodeMessage 0x3017000FL
#define MSG_RuntimePublisher_ThreadCreatingOpcodeMessage 0x3018000BL
#define MSG_RuntimePublisher_ThreadRunningOpcodeMessage 0x3018000CL
#define MSG_RuntimePublisher_TieredCompilationSettingsOpcodeMessage 0x301F000BL
#define MSG_RuntimePublisher_TieredCompilationPauseOpcodeMessage 0x301F000CL
#define MSG_RuntimePublisher_TieredCompilationResumeOpcodeMessage 0x301F000DL
#define MSG_RuntimePublisher_ResolutionAttemptedOpcodeMessage 0x3020000BL
#define MSG_RuntimePublisher_AssemblyLoadContextResolvingHandlerInvokedOpcodeMessage 0x3020000CL
#define MSG_RuntimePublisher_AppDomainAssemblyResolveHandlerInvokedOpcodeMessage 0x3020000DL
#define MSG_RuntimePublisher_AssemblyLoadFromResolveHandlerInvokedOpcodeMessage 0x3020000EL
#define MSG_RuntimePublisher_KnownPathProbedOpcodeMessage 0x3020000FL
#define MSG_RuntimePublisher_InstrumentationDataOpcodeMessage 0x3022000BL
#define MSG_RuntimePublisher_ExecutionCheckpointOpcodeMessage 0x3023000BL
#define MSG_RuntimePublisher_ProfilerOpcodeMessage 0x3024000BL
#define MSG_RundownPublisher_DCStartCompleteOpcodeMessage 0x3101000EL
#define MSG_RundownPublisher_DCEndCompleteOpcodeMessage 0x3101000FL
#define MSG_RundownPublisher_DCStartInitOpcodeMessage 0x31010010L
#define MSG_RundownPublisher_DCEndInitOpcodeMessage 0x31010011L
#define MSG_RundownPublisher_MethodDCStartOpcodeMessage 0x31010023L
#define MSG_RundownPublisher_MethodDCEndOpcodeMessage 0x31010024L
#define MSG_RundownPublisher_MethodDCStartVerboseOpcodeMessage 0x31010027L
#define MSG_RundownPublisher_MethodDCEndVerboseOpcodeMessage 0x31010028L
#define MSG_RundownPublisher_MethodDCStartILToNativeMapOpcodeMessage 0x31010029L
#define MSG_RundownPublisher_MethodDCEndILToNativeMapOpcodeMessage 0x3101002AL
#define MSG_RundownPublisher_ModuleDCStartOpcodeMessage 0x31020023L
#define MSG_RundownPublisher_ModuleDCEndOpcodeMessage 0x31020024L
#define MSG_RundownPublisher_AssemblyDCStartOpcodeMessage 0x31020027L
#define MSG_RundownPublisher_AssemblyDCEndOpcodeMessage 0x31020028L
#define MSG_RundownPublisher_AppDomainDCStartOpcodeMessage 0x3102002BL
#define MSG_RundownPublisher_AppDomainDCEndOpcodeMessage 0x3102002CL
#define MSG_RundownPublisher_DomainModuleDCStartOpcodeMessage 0x3102002EL
#define MSG_RundownPublisher_DomainModuleDCEndOpcodeMessage 0x3102002FL
#define MSG_RundownPublisher_ThreadDCOpcodeMessage 0x31020030L
#define MSG_RundownPublisher_CLRStackWalkOpcodeMessage 0x310B0052L
#define MSG_RundownPublisher_ModuleRangeDCStartOpcodeMessage 0x3114000AL
#define MSG_RundownPublisher_ModuleRangeDCEndOpcodeMessage 0x3114000BL
#define MSG_RundownPublisher_TieredCompilationSettingsDCStartOpcodeMessage 0x311F000BL
#define MSG_RundownPublisher_ExecutionCheckpointDCEndOpcodeMessage 0x3123000BL
#define MSG_RundownPublisher_GCSettingsOpcodeMessage 0x3128000AL
#define MSG_StressPublisher_CLRStackWalkOpcodeMessage 0x320B0052L
#define MSG_PrivatePublisher_GCSettingsOpcodeMessage 0x3301000EL
#define MSG_PrivatePublisher_GCOptimizedOpcodeMessage 0x33010010L
#define MSG_PrivatePublisher_GCPerHeapHistoryOpcodeMessage 0x33010011L
#define MSG_PrivatePublisher_GCGlobalHeapHistoryOpcodeMessage 0x33010012L
#define MSG_PrivatePublisher_GCFullNotifyOpcodeMessage 0x33010013L
#define MSG_PrivatePublisher_GCJoinOpcodeMessage 0x33010014L
#define MSG_PrivatePublisher_GCMarkStackRootsOpcodeMessage 0x33010015L
#define MSG_PrivatePublisher_GCMarkFinalizeQueueRootsOpcodeMessage 0x33010016L
#define MSG_PrivatePublisher_GCMarkHandlesOpcodeMessage 0x33010017L
#define MSG_PrivatePublisher_GCMarkCardsOpcodeMessage 0x33010018L
#define MSG_PrivatePublisher_BGCBeginOpcodeMessage 0x33010019L
#define MSG_PrivatePublisher_BGC1stNonCondEndOpcodeMessage 0x3301001AL
#define MSG_PrivatePublisher_BGC1stConEndOpcodeMessage 0x3301001BL
#define MSG_PrivatePublisher_BGC2ndNonConBeginOpcodeMessage 0x3301001CL
#define MSG_PrivatePublisher_BGC2ndNonConEndOpcodeMessage 0x3301001DL
#define MSG_PrivatePublisher_BGC2ndConBeginOpcodeMessage 0x3301001EL
#define MSG_PrivatePublisher_BGC2ndConEndOpcodeMessage 0x3301001FL
#define MSG_PrivatePublisher_BGCPlanEndOpcodeMessage 0x33010020L
#define MSG_PrivatePublisher_BGCSweepEndOpcodeMessage 0x33010021L
#define MSG_PrivatePublisher_BGCDrainMarkOpcodeMessage 0x33010022L
#define MSG_PrivatePublisher_BGCRevisitOpcodeMessage 0x33010023L
#define MSG_PrivatePublisher_BGCOverflowOpcodeMessage 0x33010024L
#define MSG_PrivatePublisher_BGCAllocWaitBeginOpcodeMessage 0x33010025L
#define MSG_PrivatePublisher_BGCAllocWaitEndOpcodeMessage 0x33010026L
#define MSG_PrivatePublisher_FinalizeObjectOpcodeMessage 0x33010027L
#define MSG_PrivatePublisher_CCWRefCountChangeOpcodeMessage 0x33010028L
#define MSG_PrivatePublisher_SetGCHandleOpcodeMessage 0x3301002AL
#define MSG_PrivatePublisher_DestroyGCHandleOpcodeMessage 0x3301002BL
#define MSG_PrivatePublisher_PinPlugAtGCTimeOpcodeMessage 0x3301002CL
#define MSG_PrivatePublisher_BGC1stSweepEndOpcodeMessage 0x3301002DL
#define MSG_PrivatePublisher_GCDecisionOpcodeMessage 0x33010084L
#define MSG_PrivatePublisher_FailFastOpcodeMessage 0x33020034L
#define MSG_PrivatePublisher_ApplyPolicyStartOpcodeMessage 0x3309000AL
#define MSG_PrivatePublisher_ApplyPolicyEndOpcodeMessage 0x3309000BL
#define MSG_PrivatePublisher_LdLibShFolderOpcodeMessage 0x3309000CL
#define MSG_PrivatePublisher_LdLibShFolderEndOpcodeMessage 0x3309000DL
#define MSG_PrivatePublisher_PrestubWorkerOpcodeMessage 0x3309000EL
#define MSG_PrivatePublisher_PrestubWorkerEndOpcodeMessage 0x3309000FL
#define MSG_PrivatePublisher_GetInstallationStartOpcodeMessage 0x33090010L
#define MSG_PrivatePublisher_GetInstallationEndOpcodeMessage 0x33090011L
#define MSG_PrivatePublisher_OpenHModuleOpcodeMessage 0x33090012L
#define MSG_PrivatePublisher_OpenHModuleEndOpcodeMessage 0x33090013L
#define MSG_PrivatePublisher_ExplicitBindStartOpcodeMessage 0x33090014L
#define MSG_PrivatePublisher_ExplicitBindEndOpcodeMessage 0x33090015L
#define MSG_PrivatePublisher_ParseXmlOpcodeMessage 0x33090016L
#define MSG_PrivatePublisher_ParseXmlEndOpcodeMessage 0x33090017L
#define MSG_PrivatePublisher_InitDefaultDomainOpcodeMessage 0x33090018L
#define MSG_PrivatePublisher_InitDefaultDomainEndOpcodeMessage 0x33090019L
#define MSG_PrivatePublisher_InitSecurityOpcodeMessage 0x3309001AL
#define MSG_PrivatePublisher_InitSecurityEndOpcodeMessage 0x3309001BL
#define MSG_PrivatePublisher_AllowBindingRedirsOpcodeMessage 0x3309001CL
#define MSG_PrivatePublisher_AllowBindingRedirsEndOpcodeMessage 0x3309001DL
#define MSG_PrivatePublisher_EEConfigSyncOpcodeMessage 0x3309001EL
#define MSG_PrivatePublisher_EEConfigSyncEndOpcodeMessage 0x3309001FL
#define MSG_PrivatePublisher_FusionBindingOpcodeMessage 0x33090020L
#define MSG_PrivatePublisher_FusionBindingEndOpcodeMessage 0x33090021L
#define MSG_PrivatePublisher_LoaderCatchCallOpcodeMessage 0x33090022L
#define MSG_PrivatePublisher_LoaderCatchCallEndOpcodeMessage 0x33090023L
#define MSG_PrivatePublisher_FusionInitOpcodeMessage 0x33090024L
#define MSG_PrivatePublisher_FusionInitEndOpcodeMessage 0x33090025L
#define MSG_PrivatePublisher_FusionAppCtxOpcodeMessage 0x33090026L
#define MSG_PrivatePublisher_FusionAppCtxEndOpcodeMessage 0x33090027L
#define MSG_PrivatePublisher_Fusion2EEOpcodeMessage 0x33090028L
#define MSG_PrivatePublisher_Fusion2EEEndOpcodeMessage 0x33090029L
#define MSG_PrivatePublisher_SecurityCatchCallOpcodeMessage 0x3309002AL
#define MSG_PrivatePublisher_SecurityCatchCallEndOpcodeMessage 0x3309002BL
#define MSG_PrivatePublisher_EEStartupStartOpcodeMessage 0x33090080L
#define MSG_PrivatePublisher_EEStartupEndOpcodeMessage 0x33090081L
#define MSG_PrivatePublisher_EEConfigSetupOpcodeMessage 0x33090082L
#define MSG_PrivatePublisher_EEConfigSetupEndOpcodeMessage 0x33090083L
#define MSG_PrivatePublisher_LoadSystemBasesOpcodeMessage 0x33090084L
#define MSG_PrivatePublisher_LoadSystemBasesEndOpcodeMessage 0x33090085L
#define MSG_PrivatePublisher_ExecExeOpcodeMessage 0x33090086L
#define MSG_PrivatePublisher_ExecExeEndOpcodeMessage 0x33090087L
#define MSG_PrivatePublisher_MainOpcodeMessage 0x33090088L
#define MSG_PrivatePublisher_MainEndOpcodeMessage 0x33090089L
#define MSG_PrivatePublisher_BindingPolicyPhaseStartOpcodeMessage 0x330A0033L
#define MSG_PrivatePublisher_BindingPolicyPhaseEndOpcodeMessage 0x330A0034L
#define MSG_PrivatePublisher_BindingNgenPhaseStartOpcodeMessage 0x330A0035L
#define MSG_PrivatePublisher_BindingNgenPhaseEndOpcodeMessage 0x330A0036L
#define MSG_PrivatePublisher_BindingLoopupAndProbingPhaseStartOpcodeMessage 0x330A0037L
#define MSG_PrivatePublisher_BindingLookupAndProbingPhaseEndOpcodeMessage 0x330A0038L
#define MSG_PrivatePublisher_LoaderPhaseStartOpcodeMessage 0x330A0039L
#define MSG_PrivatePublisher_LoaderPhaseEndOpcodeMessage 0x330A003AL
#define MSG_PrivatePublisher_BindingPhaseStartOpcodeMessage 0x330A003BL
#define MSG_PrivatePublisher_BindingPhaseEndOpcodeMessage 0x330A003CL
#define MSG_PrivatePublisher_BindingDownloadPhaseStartOpcodeMessage 0x330A003DL
#define MSG_PrivatePublisher_BindingDownloadPhaseEndOpcodeMessage 0x330A003EL
#define MSG_PrivatePublisher_LoaderAssemblyInitPhaseStartOpcodeMessage 0x330A003FL
#define MSG_PrivatePublisher_LoaderAssemblyInitPhaseEndOpcodeMessage 0x330A0040L
#define MSG_PrivatePublisher_LoaderMappingPhaseStartOpcodeMessage 0x330A0041L
#define MSG_PrivatePublisher_LoaderMappingPhaseEndOpcodeMessage 0x330A0042L
#define MSG_PrivatePublisher_LoaderDeliverEventPhaseStartOpcodeMessage 0x330A0043L
#define MSG_PrivatePublisher_LoaderDeliverEventsPhaseEndOpcodeMessage 0x330A0044L
#define MSG_PrivatePublisher_FusionMessageOpcodeMessage 0x330A0046L
#define MSG_PrivatePublisher_FusionErrorCodeOpcodeMessage 0x330A0047L
#define MSG_PrivatePublisher_CLRStackWalkOpcodeMessage 0x330B0052L
#define MSG_PrivatePublisher_EvidenceGeneratedMessage 0x330C000AL
#define MSG_PrivatePublisher_NgenBindOpcodeMessage 0x330D0045L
#define MSG_PrivatePublisher_ModuleTransparencyComputationStartMessage 0x330E0053L
#define MSG_PrivatePublisher_ModuleTransparencyComputationEndMessage 0x330E0054L
#define MSG_PrivatePublisher_TypeTransparencyComputationStartMessage 0x330E0055L
#define MSG_PrivatePublisher_TypeTransparencyComputationEndMessage 0x330E0056L
#define MSG_PrivatePublisher_MethodTransparencyComputationStartMessage 0x330E0057L
#define MSG_PrivatePublisher_MethodTransparencyComputationEndMessage 0x330E0058L
#define MSG_PrivatePublisher_FieldTransparencyComputationStartMessage 0x330E0059L
#define MSG_PrivatePublisher_FieldTransparencyComputationEndMessage 0x330E005AL
#define MSG_PrivatePublisher_TokenTransparencyComputationStartMessage 0x330E005BL
#define MSG_PrivatePublisher_TokenTransparencyComputationEndMessage 0x330E005CL
#define MSG_PrivatePublisher_LoaderHeapPrivateAllocRequestMessage 0x33100061L
#define MSG_PrivatePublisher_MulticoreJitOpcodeMessage 0x3311000AL
#define MSG_PrivatePublisher_MulticoreJitOpcodeMethodCodeReturnedMessage 0x3311000BL
#define MSG_PrivatePublisher_ModuleRangeLoadOpcodeMessage 0x3314000AL
#define MSG_PrivatePublisher_JittedMethodRichDebugInfoOpcodeMessage 0x3315000AL
#define MSG_PrivatePublisher_IInspectableRuntimeClassNameOpcodeMessage 0x3316000BL
#define MSG_PrivatePublisher_WinRTUnboxOpcodeMessage 0x3316000CL
#define MSG_PrivatePublisher_CreateRCWOpcodeMessage 0x3316000DL
#define MSG_PrivatePublisher_RCWVarianceOpcodeMessage 0x3316000EL
#define MSG_PrivatePublisher_RCWIEnumerableCastingOpcodeMessage 0x3316000FL
#define MSG_PrivatePublisher_CreateCCWOpcodeMessage 0x33160010L
#define MSG_PrivatePublisher_CCWVarianceOpcodeMessage 0x33160011L
#define MSG_PrivatePublisher_ObjectVariantMarshallingToNativeOpcodeMessage 0x33160012L
#define MSG_PrivatePublisher_GetTypeFromGUIDOpcodeMessage 0x33160013L
#define MSG_PrivatePublisher_GetTypeFromProgIDOpcodeMessage 0x33160014L
#define MSG_PrivatePublisher_ConvertToCallbackEtwOpcodeMessage 0x33160015L
#define MSG_PrivatePublisher_BeginCreateManagedReferenceOpcodeMessage 0x33160016L
#define MSG_PrivatePublisher_EndCreateManagedReferenceOpcodeMessage 0x33160017L
#define MSG_PrivatePublisher_ObjectVariantMarshallingToManagedOpcodeMessage 0x33160018L
#define MSG_MonoProfilerPublisher_ContextLoadedOpcodeMessage 0x34010012L
#define MSG_MonoProfilerPublisher_ContextUnloadedOpcodeMessage 0x34010013L
#define MSG_MonoProfilerPublisher_AppDomainLoadingOpcodeMessage 0x34010014L
#define MSG_MonoProfilerPublisher_AppDomainLoadedOpcodeMessage 0x34010015L
#define MSG_MonoProfilerPublisher_AppDomainUnloadingOpcodeMessage 0x34010016L
#define MSG_MonoProfilerPublisher_AppDomainUnloadedOpcodeMessage 0x34010017L
#define MSG_MonoProfilerPublisher_AppDomainNameOpcodeMessage 0x34010018L
#define MSG_MonoProfilerPublisher_JitBeginOpcodeMessage 0x34010019L
#define MSG_MonoProfilerPublisher_JitFailedOpcodeMessage 0x3401001AL
#define MSG_MonoProfilerPublisher_JitDoneOpcodeMessage 0x3401001BL
#define MSG_MonoProfilerPublisher_JitChunkCreatedOpcodeMessage 0x3401001CL
#define MSG_MonoProfilerPublisher_JitChunkDestroyedOpcodeMessage 0x3401001DL
#define MSG_MonoProfilerPublisher_JitCodeBufferOpcodeMessage 0x3401001EL
#define MSG_MonoProfilerPublisher_ClassLoadingOpcodeMessage 0x3401001FL
#define MSG_MonoProfilerPublisher_ClassFailedOpcodeMessage 0x34010020L
#define MSG_MonoProfilerPublisher_ClassLoadedOpcodeMessage 0x34010021L
#define MSG_MonoProfilerPublisher_VTableLoadingOpcodeMessage 0x34010022L
#define MSG_MonoProfilerPublisher_VTableFailedOpcodeMessage 0x34010023L
#define MSG_MonoProfilerPublisher_VTableLoadedOpcodeMessage 0x34010024L
#define MSG_MonoProfilerPublisher_ModuleLoadingOpcodeMessage 0x34010025L
#define MSG_MonoProfilerPublisher_ModuleFailedOpcodeMessage 0x34010026L
#define MSG_MonoProfilerPublisher_ModuleLoadedOpcodeMessage 0x34010027L
#define MSG_MonoProfilerPublisher_ModuleUnloadingOpcodeMessage 0x34010028L
#define MSG_MonoProfilerPublisher_ModuleUnloadedOpcodeMessage 0x34010029L
#define MSG_MonoProfilerPublisher_AssemblyLoadingOpcodeMessage 0x3401002AL
#define MSG_MonoProfilerPublisher_AssemblyLoadedOpcodeMessage 0x3401002BL
#define MSG_MonoProfilerPublisher_AssemblyUnloadingOpcodeMessage 0x3401002CL
#define MSG_MonoProfilerPublisher_AssemblyUnloadedOpcodeMessage 0x3401002DL
#define MSG_MonoProfilerPublisher_MethodEnterOpcodeMessage 0x3401002EL
#define MSG_MonoProfilerPublisher_MethodLeaveOpcodeMessage 0x3401002FL
#define MSG_MonoProfilerPublisher_MethodTailCallOpcodeMessage 0x34010030L
#define MSG_MonoProfilerPublisher_MethodExceptionLeaveOpcodeMessage 0x34010031L
#define MSG_MonoProfilerPublisher_MethodFreeOpcodeMessage 0x34010032L
#define MSG_MonoProfilerPublisher_MethodBeginInvokeOpcodeMessage 0x34010033L
#define MSG_MonoProfilerPublisher_MethodEndInvokeOpcodeMessage 0x34010034L
#define MSG_MonoProfilerPublisher_ExceptionThrowOpcodeMessage 0x34010035L
#define MSG_MonoProfilerPublisher_ExceptionClauseOpcodeMessage 0x34010036L
#define MSG_MonoProfilerPublisher_GCEventOpcodeMessage 0x34010037L
#define MSG_MonoProfilerPublisher_GCAllocationOpcodeMessage 0x34010038L
#define MSG_MonoProfilerPublisher_GCMovesOpcodeMessage 0x34010039L
#define MSG_MonoProfilerPublisher_GCResizeOpcodeMessage 0x3401003AL
#define MSG_MonoProfilerPublisher_GCHandleCreatedOpcodeMessage 0x3401003BL
#define MSG_MonoProfilerPublisher_GCHandleDeletedOpcodeMessage 0x3401003CL
#define MSG_MonoProfilerPublisher_GCFinalizingOpcodeMessage 0x3401003DL
#define MSG_MonoProfilerPublisher_GCFinalizedOpcodeMessage 0x3401003EL
#define MSG_MonoProfilerPublisher_GCFinalizingObjectOpcodeMessage 0x3401003FL
#define MSG_MonoProfilerPublisher_GCFinalizedObjectOpcodeMessage 0x34010040L
#define MSG_MonoProfilerPublisher_GCRootRegisterOpcodeMessage 0x34010041L
#define MSG_MonoProfilerPublisher_GCRootUnregisterOpcodeMessage 0x34010042L
#define MSG_MonoProfilerPublisher_GCRootsOpcodeMessage 0x34010043L
#define MSG_MonoProfilerPublisher_GCHeapDumpStartOpcodeMessage 0x34010044L
#define MSG_MonoProfilerPublisher_GCHeapDumpStopOpcodeMessage 0x34010045L
#define MSG_MonoProfilerPublisher_GCHeapDumpObjectReferenceOpcodeMessage 0x34010046L
#define MSG_MonoProfilerPublisher_MonitorContentionOpcodeMessage 0x34010047L
#define MSG_MonoProfilerPublisher_MonitorFailedOpcodeMessage 0x34010048L
#define MSG_MonoProfilerPublisher_MonitorAquiredOpcodeMessage 0x34010049L
#define MSG_MonoProfilerPublisher_ThreadStartedOpcodeMessage 0x3401004AL
#define MSG_MonoProfilerPublisher_ThreadStoppingOpcodeMessage 0x3401004BL
#define MSG_MonoProfilerPublisher_ThreadStoppedOpcodeMessage 0x3401004CL
#define MSG_MonoProfilerPublisher_ThreadExitedOpcodeMessage 0x3401004DL
#define MSG_MonoProfilerPublisher_ThreadNameOpcodeMessage 0x3401004EL
#define MSG_MonoProfilerPublisher_JitDoneVerboseOpcodeMessage 0x3401004FL
#define MSG_MonoProfilerPublisher_GCHeapDumpVTableClassReferenceOpcodeMessage 0x34010050L
#define MSG_RuntimePublisher_GarbageCollectionTaskMessage 0x70000001L
#define MSG_RuntimePublisher_WorkerThreadCreationTaskMessage 0x70000002L
#define MSG_RuntimePublisher_IOThreadCreationTaskMessage 0x70000003L
#define MSG_RuntimePublisher_WorkerThreadRetirementTaskMessage 0x70000004L
#define MSG_RuntimePublisher_IOThreadRetirementTaskMessage 0x70000005L
#define MSG_RuntimePublisher_ThreadpoolSuspensionTaskMessage 0x70000006L
#define MSG_RuntimePublisher_ExceptionTaskMessage 0x70000007L
#define MSG_RuntimePublisher_ContentionTaskMessage 0x70000008L
#define MSG_RuntimePublisher_MethodTaskMessage 0x70000009L
#define MSG_RuntimePublisher_LoaderTaskMessage 0x7000000AL
#define MSG_RuntimePublisher_StackTaskMessage 0x7000000BL
#define MSG_RuntimePublisher_StrongNameVerificationTaskMessage 0x7000000CL
#define MSG_RuntimePublisher_AuthenticodeVerificationTaskMessage 0x7000000DL
#define MSG_RuntimePublisher_AppDomainResourceManagementTaskMessage 0x7000000EL
#define MSG_RuntimePublisher_ILStubTaskMessage 0x7000000FL
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadTaskMessage 0x70000010L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadRetirementTaskMessage 0x70000011L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentTaskMessage 0x70000012L
#define MSG_RuntimePublisher_EEStartupTaskMessage 0x70000013L
#define MSG_RuntimePublisher_PerfTrackTaskMessage 0x70000014L
#define MSG_RuntimePublisher_TypeTaskMessage 0x70000015L
#define MSG_RuntimePublisher_ThreadPoolWorkingThreadCountTaskMessage 0x70000016L
#define MSG_RuntimePublisher_ThreadPoolTaskMessage 0x70000017L
#define MSG_RuntimePublisher_ThreadTaskMessage 0x70000018L
#define MSG_RuntimePublisher_DebugIPCEventTaskMessage 0x70000019L
#define MSG_RuntimePublisher_DebugExceptionProcessingTaskMessage 0x7000001AL
#define MSG_RuntimePublisher_ExceptionCatchTaskMessage 0x7000001BL
#define MSG_RuntimePublisher_ExceptionFinallyTaskMessage 0x7000001CL
#define MSG_RuntimePublisher_ExceptionFilterTaskMessage 0x7000001DL
#define MSG_RuntimePublisher_CodeSymbolsTaskMessage 0x7000001EL
#define MSG_RuntimePublisher_TieredCompilationTaskMessage 0x7000001FL
#define MSG_RuntimePublisher_AssemblyLoaderTaskMessage 0x70000020L
#define MSG_RuntimePublisher_TypeLoadTaskMessage 0x70000021L
#define MSG_RuntimePublisher_JitInstrumentationDataTaskMessage 0x70000022L
#define MSG_RuntimePublisher_ExecutionCheckpointTaskMessage 0x70000023L
#define MSG_RuntimePublisher_ProfilerTaskMessage 0x70000024L
#define MSG_RuntimePublisher_YieldProcessorMeasurementTaskMessage 0x70000025L
#define MSG_RuntimePublisher_ThreadPoolMinMaxThreadsTaskMessage 0x70000026L
#define MSG_RundownPublisher_MethodTaskMessage 0x71000001L
#define MSG_RundownPublisher_LoaderTaskMessage 0x71000002L
#define MSG_RundownPublisher_StackTaskMessage 0x7100000BL
#define MSG_RundownPublisher_EEStartupTaskMessage 0x71000013L
#define MSG_RundownPublisher_PerfTrackTaskMessage 0x71000014L
#define MSG_RundownPublisher_TieredCompilationTaskMessage 0x7100001FL
#define MSG_RundownPublisher_ExecutionCheckpointTaskMessage 0x71000023L
#define MSG_RundownPublisher_GCTaskMessage   0x71000028L
#define MSG_StressPublisher_StressTaskMessage 0x72000001L
#define MSG_StressPublisher_StackTaskMessage 0x7200000BL
#define MSG_PrivatePublisher_GarbageCollectionTaskMessage 0x73000001L
#define MSG_PrivatePublisher_FailFastTaskMessage 0x73000002L
#define MSG_PrivatePublisher_StartupTaskMessage 0x73000009L
#define MSG_PrivatePublisher_BindingTaskMessage 0x7300000AL
#define MSG_PrivatePublisher_StackTaskMessage 0x7300000BL
#define MSG_PrivatePublisher_EvidenceGeneratedTaskMessage 0x7300000CL
#define MSG_PrivatePublisher_NgenBinderTaskMessage 0x7300000DL
#define MSG_PrivatePublisher_TransparencyComputationMessage 0x7300000EL
#define MSG_PrivatePublisher_LoaderHeapAllocationPrivateTaskMessage 0x73000010L
#define MSG_PrivatePublisher_MulticoreJitTaskMessage 0x73000011L
#define MSG_PrivatePublisher_PerfTrackTaskMessage 0x73000014L
#define MSG_PrivatePublisher_CLRMethodPrivateTaskMessage 0x73000015L
#define MSG_PrivatePublisher_DynamicTypeUsageTaskMessage 0x73000016L
#define MSG_MonoProfilerPublisher_MonoProfilerTaskMessage 0x74000001L
#define MSG_RuntimePublisher_GCStartEventMessage 0xB0000001L
#define MSG_RuntimePublisher_GCEndEventMessage 0xB0000002L
#define MSG_RuntimePublisher_GCRestartEEEndEventMessage 0xB0000003L
#define MSG_RuntimePublisher_GCHeapStatsEventMessage 0xB0000004L
#define MSG_RuntimePublisher_GCCreateSegmentEventMessage 0xB0000005L
#define MSG_RuntimePublisher_GCFreeSegmentEventMessage 0xB0000006L
#define MSG_RuntimePublisher_GCRestartEEBeginEventMessage 0xB0000007L
#define MSG_RuntimePublisher_GCSuspendEEEndEventMessage 0xB0000008L
#define MSG_RuntimePublisher_GCSuspendEEEventMessage 0xB0000009L
#define MSG_RuntimePublisher_GCAllocationTickEventMessage 0xB000000AL
#define MSG_RuntimePublisher_GCCreateConcurrentThreadEventMessage 0xB000000BL
#define MSG_RuntimePublisher_GCTerminateConcurrentThreadEventMessage 0xB000000CL
#define MSG_RuntimePublisher_GCFinalizersEndEventMessage 0xB000000DL
#define MSG_RuntimePublisher_GCFinalizersBeginEventMessage 0xB000000EL
#define MSG_RuntimePublisher_BulkTypeEventMessage 0xB000000FL
#define MSG_RuntimePublisher_GCBulkRootEdgeEventMessage 0xB0000010L
#define MSG_RuntimePublisher_GCBulkRootConditionalWeakTableElementEdgeEventMessage 0xB0000011L
#define MSG_RuntimePublisher_GCBulkNodeEventMessage 0xB0000012L
#define MSG_RuntimePublisher_GCBulkEdgeEventMessage 0xB0000013L
#define MSG_RuntimePublisher_GCSampledObjectAllocationHighEventMessage 0xB0000014L
#define MSG_RuntimePublisher_GCBulkSurvivingObjectRangesEventMessage 0xB0000015L
#define MSG_RuntimePublisher_GCBulkMovedObjectRangesEventMessage 0xB0000016L
#define MSG_RuntimePublisher_GCGenerationRangeEventMessage 0xB0000017L
#define MSG_RuntimePublisher_GCMarkStackRootsEventMessage 0xB0000019L
#define MSG_RuntimePublisher_GCMarkFinalizeQueueRootsEventMessage 0xB000001AL
#define MSG_RuntimePublisher_GCMarkHandlesEventMessage 0xB000001BL
#define MSG_RuntimePublisher_GCMarkOlderGenerationRootsEventMessage 0xB000001CL
#define MSG_RuntimePublisher_FinalizeObjectEventMessage 0xB000001DL
#define MSG_RuntimePublisher_SetGCHandleEventMessage 0xB000001EL
#define MSG_RuntimePublisher_DestroyGCHandleEventMessage 0xB000001FL
#define MSG_RuntimePublisher_GCSampledObjectAllocationLowEventMessage 0xB0000020L
#define MSG_RuntimePublisher_PinObjectAtGCTimeEventMessage 0xB0000021L
#define MSG_RuntimePublisher_GCTriggeredEventMessage 0xB0000023L
#define MSG_RuntimePublisher_GCBulkRootCCWEventMessage 0xB0000024L
#define MSG_RuntimePublisher_GCBulkRCWEventMessage 0xB0000025L
#define MSG_RuntimePublisher_GCBulkRootStaticVarEventMessage 0xB0000026L
#define MSG_RuntimePublisher_WorkerThreadCreateEventMessage 0xB0000028L
#define MSG_RuntimePublisher_WorkerThreadTerminateEventMessage 0xB0000029L
#define MSG_RuntimePublisher_WorkerThreadRetirementRetireThreadEventMessage 0xB000002AL
#define MSG_RuntimePublisher_WorkerThreadRetirementUnretireThreadEventMessage 0xB000002BL
#define MSG_RuntimePublisher_IOThreadCreateEventMessage 0xB000002CL
#define MSG_RuntimePublisher_IOThreadTerminateEventMessage 0xB000002DL
#define MSG_RuntimePublisher_IOThreadRetirementRetireThreadEventMessage 0xB000002EL
#define MSG_RuntimePublisher_IOThreadRetirementUnretireThreadEventMessage 0xB000002FL
#define MSG_RuntimePublisher_ThreadPoolSuspendSuspendThreadEventMessage 0xB0000030L
#define MSG_RuntimePublisher_ThreadPoolSuspendResumeThreadEventMessage 0xB0000031L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadEventMessage 0xB0000032L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentSampleEventMessage 0xB0000036L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentAdjustmentEventMessage 0xB0000037L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentStatsEventMessage 0xB0000038L
#define MSG_RuntimePublisher_YieldProcessorMeasurementEventMessage 0xB000003AL
#define MSG_RuntimePublisher_ThreadPoolMinMaxThreads 0xB000003BL
#define MSG_RuntimePublisher_ThreadPoolWorkingThreadCountEventMessage 0xB000003CL
#define MSG_RuntimePublisher_ThreadPoolEnqueueEventMessage 0xB000003DL
#define MSG_RuntimePublisher_ThreadPoolDequeueEventMessage 0xB000003EL
#define MSG_RuntimePublisher_ThreadPoolIOEnqueueEventMessage 0xB000003FL
#define MSG_RuntimePublisher_ThreadPoolIODequeueEventMessage 0xB0000040L
#define MSG_RuntimePublisher_ThreadPoolIOPackEventMessage 0xB0000041L
#define MSG_RuntimePublisher_ThreadCreatingEventMessage 0xB0000046L
#define MSG_RuntimePublisher_ThreadRunningEventMessage 0xB0000047L
#define MSG_RuntimePublisher_MethodDetailsEventMessage 0xB0000048L
#define MSG_RuntimePublisher_TypeLoadStartEventMessage 0xB0000049L
#define MSG_RuntimePublisher_TypeLoadStopEventMessage 0xB000004AL
#define MSG_RuntimePublisher_ExceptionExceptionThrownEventMessage 0xB0000050L
#define MSG_RuntimePublisher_ContentionStartEventMessage 0xB0000051L
#define MSG_RuntimePublisher_StackEventMessage 0xB0000052L
#define MSG_RuntimePublisher_AppDomainMemAllocatedEventMessage 0xB0000053L
#define MSG_RuntimePublisher_AppDomainMemSurvivedEventMessage 0xB0000054L
#define MSG_RuntimePublisher_ThreadCreatedEventMessage 0xB0000055L
#define MSG_RuntimePublisher_ThreadTerminatedEventMessage 0xB0000056L
#define MSG_RuntimePublisher_ThreadDomainEnterEventMessage 0xB0000057L
#define MSG_RuntimePublisher_ILStubGeneratedEventMessage 0xB0000058L
#define MSG_RuntimePublisher_ILStubCacheHitEventMessage 0xB0000059L
#define MSG_RuntimePublisher_ContentionLockCreatedEventMessage 0xB000005AL
#define MSG_RuntimePublisher_ContentionStopEventMessage 0xB000005BL
#define MSG_RuntimePublisher_DCStartCompleteEventMessage 0xB0000087L
#define MSG_RuntimePublisher_DCEndCompleteEventMessage 0xB0000088L
#define MSG_RuntimePublisher_MethodDCStartEventMessage 0xB0000089L
#define MSG_RuntimePublisher_MethodDCEndEventMessage 0xB000008AL
#define MSG_RuntimePublisher_MethodDCEndVerboseEventMessage 0xB000008CL
#define MSG_RuntimePublisher_MethodLoadEventMessage 0xB000008DL
#define MSG_RuntimePublisher_MethodUnloadEventMessage 0xB000008EL
#define MSG_RuntimePublisher_MethodLoadVerboseEventMessage 0xB000008FL
#define MSG_RuntimePublisher_MethodUnloadVerboseEventMessage 0xB0000090L
#define MSG_RuntimePublisher_MethodJittingStartedEventMessage 0xB0000091L
#define MSG_RuntimePublisher_MethodJitMemoryAllocatedForCodeEventMessage 0xB0000092L
#define MSG_RuntimePublisher_ModuleDCStartEventMessage 0xB0000095L
#define MSG_RuntimePublisher_ModuleDCEndEventMessage 0xB0000096L
#define MSG_RuntimePublisher_DomainModuleLoadEventMessage 0xB0000097L
#define MSG_RuntimePublisher_ModuleLoadEventMessage 0xB0000098L
#define MSG_RuntimePublisher_ModuleUnloadEventMessage 0xB0000099L
#define MSG_RuntimePublisher_AssemblyLoadEventMessage 0xB000009AL
#define MSG_RuntimePublisher_AssemblyUnloadEventMessage 0xB000009BL
#define MSG_RuntimePublisher_AppDomainLoadEventMessage 0xB000009CL
#define MSG_RuntimePublisher_AppDomainUnloadEventMessage 0xB000009DL
#define MSG_RuntimePublisher_ModuleRangeLoadEventMessage 0xB000009EL
#define MSG_RuntimePublisher_R2RGetEntryPointEventMessage 0xB000009FL
#define MSG_RuntimePublisher_R2RGetEntryPointStartEventMessage 0xB00000A0L
#define MSG_RuntimePublisher_StrongNameVerificationStartEventMessage 0xB00000B5L
#define MSG_RuntimePublisher_StrongNameVerificationEndEventMessage 0xB00000B6L
#define MSG_RuntimePublisher_AuthenticodeVerificationStartEventMessage 0xB00000B7L
#define MSG_RuntimePublisher_AuthenticodeVerificationEndEventMessage 0xB00000B8L
#define MSG_RuntimePublisher_MethodJitInliningSucceededEventMessage 0xB00000B9L
#define MSG_RuntimePublisher_MethodJitInliningFailedEventMessage 0xB00000BAL
#define MSG_RuntimePublisher_RuntimeInformationEventMessage 0xB00000BBL
#define MSG_RuntimePublisher_MethodJitTailCallSucceededEventMessage 0xB00000BCL
#define MSG_RuntimePublisher_MethodJitTailCallFailedEventMessage 0xB00000BDL
#define MSG_RuntimePublisher_MethodILToNativeMapEventMessage 0xB00000BEL
#define MSG_RuntimePublisher_IncreaseMemoryPressureEventMessage 0xB00000C8L
#define MSG_RuntimePublisher_DecreaseMemoryPressureEventMessage 0xB00000C9L
#define MSG_RuntimePublisher_GCMarkWithTypeEventMessage 0xB00000CAL
#define MSG_RuntimePublisher_GenAwareBeginEventMessage 0xB00000CEL
#define MSG_RuntimePublisher_GenAwareEndEventMessage 0xB00000CFL
#define MSG_RuntimePublisher_GCLOHCompactEventMessage 0xB00000D0L
#define MSG_RuntimePublisher_GCFitBucketInfoEventMessage 0xB00000D1L
#define MSG_RuntimePublisher_ExceptionExceptionHandlingEventMessage 0xB00000FAL
#define MSG_RuntimePublisher_ExceptionExceptionHandlingNoneEventMessage 0xB00000FBL
#define MSG_RuntimePublisher_CodeSymbolsEventMessage 0xB0000104L
#define MSG_RuntimePublisher_TieredCompilationSettingsEventMessage 0xB0000118L
#define MSG_RuntimePublisher_TieredCompilationPauseEventMessage 0xB0000119L
#define MSG_RuntimePublisher_TieredCompilationResumeEventMessage 0xB000011AL
#define MSG_RuntimePublisher_TieredCompilationBackgroundJitStartEventMessage 0xB000011BL
#define MSG_RuntimePublisher_TieredCompilationBackgroundJitStopEventMessage 0xB000011CL
#define MSG_RuntimePublisher_AssemblyLoadStartEventMessage 0xB0000122L
#define MSG_RuntimePublisher_AssemblyLoadStopEventMessage 0xB0000123L
#define MSG_RuntimePublisher_ResolutionAttemptedEventMessage 0xB0000124L
#define MSG_RuntimePublisher_AssemblyLoadContextResolvingHandlerInvokedEventMessage 0xB0000125L
#define MSG_RuntimePublisher_AppDomainAssemblyResolveHandlerInvokedEventMessage 0xB0000126L
#define MSG_RuntimePublisher_AssemblyLoadFromResolveHandlerInvokedEventMessage 0xB0000127L
#define MSG_RuntimePublisher_KnownPathProbedEventMessage 0xB0000128L
#define MSG_RuntimePublisher_JitInstrumentationDataEventMessage 0xB0000129L
#define MSG_RuntimePublisher_ProfilerEventMessage 0xB000012BL
#define MSG_RuntimePublisher_ExecutionCheckpointEventMessage 0xB000012CL
#define MSG_RuntimePublisher_GCStart_V1EventMessage 0xB0010001L
#define MSG_RuntimePublisher_GCEnd_V1EventMessage 0xB0010002L
#define MSG_RuntimePublisher_GCRestartEEEnd_V1EventMessage 0xB0010003L
#define MSG_RuntimePublisher_GCHeapStats_V1EventMessage 0xB0010004L
#define MSG_RuntimePublisher_GCCreateSegment_V1EventMessage 0xB0010005L
#define MSG_RuntimePublisher_GCFreeSegment_V1EventMessage 0xB0010006L
#define MSG_RuntimePublisher_GCRestartEEBegin_V1EventMessage 0xB0010007L
#define MSG_RuntimePublisher_GCSuspendEEEnd_V1EventMessage 0xB0010008L
#define MSG_RuntimePublisher_GCSuspendEE_V1EventMessage 0xB0010009L
#define MSG_RuntimePublisher_GCAllocationTick_V1EventMessage 0xB001000AL
#define MSG_RuntimePublisher_GCCreateConcurrentThread_V1EventMessage 0xB001000BL
#define MSG_RuntimePublisher_GCTerminateConcurrentThread_V1EventMessage 0xB001000CL
#define MSG_RuntimePublisher_GCFinalizersEnd_V1EventMessage 0xB001000DL
#define MSG_RuntimePublisher_GCFinalizersBegin_V1EventMessage 0xB001000EL
#define MSG_RuntimePublisher_IOThreadCreate_V1EventMessage 0xB001002CL
#define MSG_RuntimePublisher_IOThreadTerminate_V1EventMessage 0xB001002DL
#define MSG_RuntimePublisher_IOThreadRetirementRetireThread_V1EventMessage 0xB001002EL
#define MSG_RuntimePublisher_IOThreadRetirementUnretireThread_V1EventMessage 0xB001002FL
#define MSG_RuntimePublisher_ExceptionExceptionThrown_V1EventMessage 0xB0010050L
#define MSG_RuntimePublisher_ContentionStart_V1EventMessage 0xB0010051L
#define MSG_RuntimePublisher_ContentionStop_V1EventMessage 0xB001005BL
#define MSG_RuntimePublisher_MethodLoad_V1EventMessage 0xB001008DL
#define MSG_RuntimePublisher_MethodUnload_V1EventMessage 0xB001008EL
#define MSG_RuntimePublisher_MethodLoadVerbose_V1EventMessage 0xB001008FL
#define MSG_RuntimePublisher_MethodUnloadVerbose_V1EventMessage 0xB0010090L
#define MSG_RuntimePublisher_MethodJittingStarted_V1EventMessage 0xB0010091L
#define MSG_RuntimePublisher_DomainModuleLoad_V1EventMessage 0xB0010097L
#define MSG_RuntimePublisher_ModuleLoad_V1EventMessage 0xB0010098L
#define MSG_RuntimePublisher_ModuleUnload_V1EventMessage 0xB0010099L
#define MSG_RuntimePublisher_AssemblyLoad_V1EventMessage 0xB001009AL
#define MSG_RuntimePublisher_AssemblyUnload_V1EventMessage 0xB001009BL
#define MSG_RuntimePublisher_AppDomainLoad_V1EventMessage 0xB001009CL
#define MSG_RuntimePublisher_AppDomainUnload_V1EventMessage 0xB001009DL
#define MSG_RuntimePublisher_StrongNameVerificationStart_V1EventMessage 0xB00100B5L
#define MSG_RuntimePublisher_StrongNameVerificationEnd_V1EventMessage 0xB00100B6L
#define MSG_RuntimePublisher_AuthenticodeVerificationStart_V1EventMessage 0xB00100B7L
#define MSG_RuntimePublisher_AuthenticodeVerificationEnd_V1EventMessage 0xB00100B8L
#define MSG_RuntimePublisher_MethodILToNativeMapEventMessage_V1 0xB00100BEL
#define MSG_RuntimePublisher_GCStart_V2EventMessage 0xB0020001L
#define MSG_RuntimePublisher_GCHeapStats_V2EventMessage 0xB0020004L
#define MSG_RuntimePublisher_GCAllocationTick_V2EventMessage 0xB002000AL
#define MSG_RuntimePublisher_ContentionStart_V2EventMessage 0xB0020051L
#define MSG_RuntimePublisher_MethodLoad_V2EventMessage 0xB002008DL
#define MSG_RuntimePublisher_MethodUnload_V2EventMessage 0xB002008EL
#define MSG_RuntimePublisher_MethodLoadVerbose_V2EventMessage 0xB002008FL
#define MSG_RuntimePublisher_MethodUnloadVerbose_V2EventMessage 0xB0020090L
#define MSG_RuntimePublisher_ModuleLoad_V2EventMessage 0xB0020098L
#define MSG_RuntimePublisher_ModuleUnload_V2EventMessage 0xB0020099L
#define MSG_RuntimePublisher_GCJoin_V2EventMessage 0xB00200CBL
#define MSG_RuntimePublisher_GCGlobalHeap_V2EventMessage 0xB00200CDL
#define MSG_RuntimePublisher_GCAllocationTick_V3EventMessage 0xB003000AL
#define MSG_RuntimePublisher_GCPerHeapHistory_V3EventMessage 0xB00300CCL
#define MSG_RuntimePublisher_GCGlobalHeap_V3EventMessage 0xB00300CDL
#define MSG_RuntimePublisher_GCAllocationTick_V4EventMessage 0xB004000AL
#define MSG_RuntimePublisher_GCGlobalHeap_V4EventMessage 0xB00400CDL
#define MSG_RundownPublisher_StackEventMessage 0xB1000000L
#define MSG_RundownPublisher_GCSettingsRundownEventMessage 0xB100000AL
#define MSG_RundownPublisher_MethodDCStartEventMessage 0xB100008DL
#define MSG_RundownPublisher_MethodDCEndEventMessage 0xB100008EL
#define MSG_RundownPublisher_MethodDCStartVerboseEventMessage 0xB100008FL
#define MSG_RundownPublisher_MethodDCEndVerboseEventMessage 0xB1000090L
#define MSG_RundownPublisher_MethodDCStartILToNativeMapEventMessage 0xB1000095L
#define MSG_RundownPublisher_MethodDCEndILToNativeMapEventMessage 0xB1000096L
#define MSG_RundownPublisher_DomainModuleDCStartEventMessage 0xB1000097L
#define MSG_RundownPublisher_DomainModuleDCEndEventMessage 0xB1000098L
#define MSG_RundownPublisher_ModuleDCStartEventMessage 0xB1000099L
#define MSG_RundownPublisher_ModuleDCEndEventMessage 0xB100009AL
#define MSG_RundownPublisher_AssemblyDCStartEventMessage 0xB100009BL
#define MSG_RundownPublisher_AssemblyDCEndEventMessage 0xB100009CL
#define MSG_RundownPublisher_AppDomainDCStartEventMessage 0xB100009DL
#define MSG_RundownPublisher_AppDomainDCEndEventMessage 0xB100009EL
#define MSG_RundownPublisher_ThreadCreatedEventMessage 0xB100009FL
#define MSG_RundownPublisher_ModuleRangeDCStartEventMessage 0xB10000A0L
#define MSG_RundownPublisher_ModuleRangeDCEndEventMessage 0xB10000A1L
#define MSG_RundownPublisher_RuntimeInformationEventMessage 0xB10000BBL
#define MSG_RundownPublisher_TieredCompilationSettingsDCStartEventMessage 0xB1000118L
#define MSG_RundownPublisher_ExecutionCheckpointDCEndEventMessage 0xB100012CL
#define MSG_RundownPublisher_MethodDCStart_V1EventMessage 0xB101008DL
#define MSG_RundownPublisher_MethodDCEnd_V1EventMessage 0xB101008EL
#define MSG_RundownPublisher_MethodDCStartVerbose_V1EventMessage 0xB101008FL
#define MSG_RundownPublisher_MethodDCEndVerbose_V1EventMessage 0xB1010090L
#define MSG_RundownPublisher_DCStartCompleteEventMessage 0xB1010091L
#define MSG_RundownPublisher_DCEndCompleteEventMessage 0xB1010092L
#define MSG_RundownPublisher_DCStartInitEventMessage 0xB1010093L
#define MSG_RundownPublisher_DCEndInitEventMessage 0xB1010094L
#define MSG_RundownPublisher_MethodDCStartILToNativeMapEventMessage_V1 0xB1010095L
#define MSG_RundownPublisher_MethodDCEndILToNativeMapEventMessage_V1 0xB1010096L
#define MSG_RundownPublisher_DomainModuleDCStart_V1EventMessage 0xB1010097L
#define MSG_RundownPublisher_DomainModuleDCEnd_V1EventMessage 0xB1010098L
#define MSG_RundownPublisher_ModuleDCStart_V1EventMessage 0xB1010099L
#define MSG_RundownPublisher_ModuleDCEnd_V1EventMessage 0xB101009AL
#define MSG_RundownPublisher_AssemblyDCStart_V1EventMessage 0xB101009BL
#define MSG_RundownPublisher_AssemblyDCEnd_V1EventMessage 0xB101009CL
#define MSG_RundownPublisher_AppDomainDCStart_V1EventMessage 0xB101009DL
#define MSG_RundownPublisher_AppDomainDCEnd_V1EventMessage 0xB101009EL
#define MSG_RundownPublisher_MethodDCStart_V2EventMessage 0xB102008DL
#define MSG_RundownPublisher_MethodDCEnd_V2EventMessage 0xB102008EL
#define MSG_RundownPublisher_MethodDCStartVerbose_V2EventMessage 0xB102008FL
#define MSG_RundownPublisher_MethodDCEndVerbose_V2EventMessage 0xB1020090L
#define MSG_RundownPublisher_ModuleDCStart_V2EventMessage 0xB1020099L
#define MSG_RundownPublisher_ModuleDCEnd_V2EventMessage 0xB102009AL
#define MSG_StressPublisher_StressLogEventMessage 0xB2000000L
#define MSG_StressPublisher_StackEventMessage 0xB2000001L
#define MSG_StressPublisher_StressLog_V1EventMessage 0xB2010000L
#define MSG_PrivatePublisher_GCDecisionEventMessage 0xB3000001L
#define MSG_PrivatePublisher_GCSettingsEventMessage 0xB3000002L
#define MSG_PrivatePublisher_GCOptimizedEventMessage 0xB3000003L
#define MSG_PrivatePublisher_GCGlobalHeapEventMessage 0xB3000005L
#define MSG_PrivatePublisher_GCJoinEventMessage 0xB3000006L
#define MSG_PrivatePublisher_GCMarkStackRootsEventMessage 0xB3000007L
#define MSG_PrivatePublisher_GCMarkFinalizeQueueRootsEventMessage 0xB3000008L
#define MSG_PrivatePublisher_GCMarkHandlesEventMessage 0xB3000009L
#define MSG_PrivatePublisher_GCMarkCardsEventMessage 0xB300000AL
#define MSG_PrivatePublisher_BGCBeginEventMessage 0xB300000BL
#define MSG_PrivatePublisher_BGC1stNonConEndEventMessage 0xB300000CL
#define MSG_PrivatePublisher_BGC1stConEndEventMessage 0xB300000DL
#define MSG_PrivatePublisher_BGC2ndNonConBeginEventMessage 0xB300000EL
#define MSG_PrivatePublisher_BGC2ndNonConEndEventMessage 0xB300000FL
#define MSG_PrivatePublisher_BGC2ndConBeginEventMessage 0xB3000010L
#define MSG_PrivatePublisher_BGC2ndConEndEventMessage 0xB3000011L
#define MSG_PrivatePublisher_BGCPlanEndEventMessage 0xB3000012L
#define MSG_PrivatePublisher_BGCSweepEndEventMessage 0xB3000013L
#define MSG_PrivatePublisher_BGCDrainMarkEventMessage 0xB3000014L
#define MSG_PrivatePublisher_BGCRevisitEventMessage 0xB3000015L
#define MSG_PrivatePublisher_BGCOverflowEventMessage 0xB3000016L
#define MSG_PrivatePublisher_BGCAllocWaitEventMessage 0xB3000017L
#define MSG_PrivatePublisher_GCFullNotifyEventMessage 0xB3000019L
#define MSG_PrivatePublisher_BGC1stSweepEndEventMessage 0xB300001AL
#define MSG_PrivatePublisher_StartupEventMessage 0xB3000050L
#define MSG_PrivatePublisher_StackEventMessage 0xB3000097L
#define MSG_PrivatePublisher_ModuleRangeLoadEventMessage 0xB300009EL
#define MSG_PrivatePublisher_BindingEventMessage 0xB300009FL
#define MSG_PrivatePublisher_EvidenceGeneratedEventMessage 0xB30000B1L
#define MSG_PrivatePublisher_ModuleTransparencyComputationStartEventMessage 0xB30000B2L
#define MSG_PrivatePublisher_ModuleTransparencyComputationEndEventMessage 0xB30000B3L
#define MSG_PrivatePublisher_TypeTransparencyComputationStartEventMessage 0xB30000B4L
#define MSG_PrivatePublisher_TypeTransparencyComputationEndEventMessage 0xB30000B5L
#define MSG_PrivatePublisher_MethodTransparencyComputationStartEventMessage 0xB30000B6L
#define MSG_PrivatePublisher_MethodTransparencyComputationEndEventMessage 0xB30000B7L
#define MSG_PrivatePublisher_FieldTransparencyComputationStartEventMessage 0xB30000B8L
#define MSG_PrivatePublisher_FieldTransparencyComputationEndEventMessage 0xB30000B9L
#define MSG_PrivatePublisher_TokenTransparencyComputationStartEventMessage 0xB30000BAL
#define MSG_PrivatePublisher_TokenTransparencyComputationEndEventMessage 0xB30000BBL
#define MSG_PrivatePublisher_NgenBinderMessage 0xB30000BCL
#define MSG_PrivatePublisher_JittedMethodRichDebugInfoEventMessage 0xB30000BDL
#define MSG_PrivatePublisher_FailFastEventMessage 0xB30000BFL
#define MSG_PrivatePublisher_FinalizeObjectEventMessage 0xB30000C0L
#define MSG_PrivatePublisher_CCWRefCountChangeEventMessage 0xB30000C1L
#define MSG_PrivatePublisher_SetGCHandleEventMessage 0xB30000C2L
#define MSG_PrivatePublisher_DestroyGCHandleEventMessage 0xB30000C3L
#define MSG_PrivatePublisher_FusionMessageEventMessage 0xB30000C4L
#define MSG_PrivatePublisher_FusionErrorCodeEventMessage 0xB30000C5L
#define MSG_PrivatePublisher_PinPlugAtGCTimeEventMessage 0xB30000C7L
#define MSG_PrivatePublisher_MulticoreJitCommonEventMessage 0xB30000C9L
#define MSG_PrivatePublisher_MulticoreJitMethodCodeReturnedMessage 0xB30000CAL
#define MSG_PrivatePublisher_AllocRequestEventMessage 0xB3000136L
#define MSG_PrivatePublisher_IInspectableRuntimeClassNameMessage 0xB3000190L
#define MSG_PrivatePublisher_WinRTUnboxMessage 0xB3000191L
#define MSG_PrivatePublisher_CreateRcwMessage 0xB3000192L
#define MSG_PrivatePublisher_RcwVarianceMessage 0xB3000193L
#define MSG_PrivatePublisher_RCWIEnumerableCastingMessage 0xB3000194L
#define MSG_PrivatePublisher_CreateCCWMessage 0xB3000195L
#define MSG_PrivatePublisher_CCWVarianceMessage 0xB3000196L
#define MSG_PrivatePublisher_ObjectVariantMarshallingMessage 0xB3000197L
#define MSG_PrivatePublisher_GetTypeFromGUIDMessage 0xB3000198L
#define MSG_PrivatePublisher_GetTypeFromProgIDMessage 0xB3000199L
#define MSG_PrivatePublisher_ConvertToCallbackMessage 0xB300019AL
#define MSG_PrivatePublisher_BeginCreateManagedReferenceMessage 0xB300019BL
#define MSG_PrivatePublisher_EndCreateManagedReferenceMessage 0xB300019CL
#define MSG_PrivatePublisher_GCDecision_V1EventMessage 0xB3010001L
#define MSG_PrivatePublisher_GCSettings_V1EventMessage 0xB3010002L
#define MSG_PrivatePublisher_GCOptimized_V1EventMessage 0xB3010003L
#define MSG_PrivatePublisher_GCPerHeapHistory_V1EventMessage 0xB3010004L
#define MSG_PrivatePublisher_GCGlobalHeap_V1EventMessage 0xB3010005L
#define MSG_PrivatePublisher_GCJoin_V1EventMessage 0xB3010006L
#define MSG_PrivatePublisher_GCMarkStackRoots_V1EventMessage 0xB3010007L
#define MSG_PrivatePublisher_GCMarkFinalizeQueueRoots_V1EventMessage 0xB3010008L
#define MSG_PrivatePublisher_GCMarkHandles_V1EventMessage 0xB3010009L
#define MSG_PrivatePublisher_GCMarkCards_V1EventMessage 0xB301000AL
#define MSG_PrivatePublisher_GCFullNotify_V1EventMessage 0xB3010019L
#define MSG_PrivatePublisher_Startup_V1EventMessage 0xB3010050L
#define MSG_PrivatePublisher_GCPerHeapHistoryEventMessage 0xB3020004L
#define MSG_MonoProfilerPublisher_ContextLoadedUnloadedEventMessage 0xB4000001L
#define MSG_MonoProfilerPublisher_AppDomainLoadUnloadEventMessage 0xB4000003L
#define MSG_MonoProfilerPublisher_AppDomainNameEventMessage 0xB4000007L
#define MSG_MonoProfilerPublisher_JitBeginFailedDoneEventMessage 0xB4000008L
#define MSG_MonoProfilerPublisher_JitChunkCreatedEventMessage 0xB400000BL
#define MSG_MonoProfilerPublisher_JitChunkDestroyedEventMessage 0xB400000CL
#define MSG_MonoProfilerPublisher_JitCodeBufferEventMessage 0xB400000DL
#define MSG_MonoProfilerPublisher_ClassLoadingFailedEventMessage 0xB400000EL
#define MSG_MonoProfilerPublisher_ClassLoadedEventMessage 0xB4000010L
#define MSG_MonoProfilerPublisher_VTableLoadingFailedLoadedEventMessage 0xB4000011L
#define MSG_MonoProfilerPublisher_ModuleLoadingUnloadingFailedEventMessage 0xB4000014L
#define MSG_MonoProfilerPublisher_ModuleLoadedUnloadedEventMessage 0xB4000016L
#define MSG_MonoProfilerPublisher_AssemblyLoadingUnloadingEventMessage 0xB4000019L
#define MSG_MonoProfilerPublisher_AssemblyLoadedUnloadedEventMessage 0xB400001AL
#define MSG_MonoProfilerPublisher_MethodTracingEventMessage 0xB400001DL
#define MSG_MonoProfilerPublisher_ExceptionThrowEventMessage 0xB4000024L
#define MSG_MonoProfilerPublisher_ExceptionClauseEventMessage 0xB4000025L
#define MSG_MonoProfilerPublisher_GCEventEventMessage 0xB4000026L
#define MSG_MonoProfilerPublisher_GCAllocationEventMessage 0xB4000027L
#define MSG_MonoProfilerPublisher_GCMovesEventMessage 0xB4000028L
#define MSG_MonoProfilerPublisher_GCResizeEventMessage 0xB4000029L
#define MSG_MonoProfilerPublisher_GCHandleCreatedEventMessage 0xB400002AL
#define MSG_MonoProfilerPublisher_GCHandleDeletedEventMessage 0xB400002BL
#define MSG_MonoProfilerPublisher_GCFinalizingFinalizedEventMessage 0xB400002CL
#define MSG_MonoProfilerPublisher_GCFinalizingFinalizedObjectEventMessage 0xB400002EL
#define MSG_MonoProfilerPublisher_GCRootRegisterEventMessage 0xB4000030L
#define MSG_MonoProfilerPublisher_GCRootUnregisterEventMessage 0xB4000031L
#define MSG_MonoProfilerPublisher_GCRootsEventMessage 0xB4000032L
#define MSG_MonoProfilerPublisher_GCHeapDumpStartEventMessage 0xB4000033L
#define MSG_MonoProfilerPublisher_GCHeapDumpStopEventMessage 0xB4000034L
#define MSG_MonoProfilerPublisher_GCHeapDumpObjectReferenceEventMessage 0xB4000035L
#define MSG_MonoProfilerPublisher_MonitorContentionFailedAcquiredEventMessage 0xB4000036L
#define MSG_MonoProfilerPublisher_ThreadStartedStoppingStoppedExitedEventMessage 0xB4000039L
#define MSG_MonoProfilerPublisher_ThreadNameEventMessage 0xB400003DL
#define MSG_MonoProfilerPublisher_JitDoneVerboseEventMessage 0xB400003EL
#define MSG_MonoProfilerPublisher_GCHeapDumpVTableClassReferenceEventMessage 0xB400003FL
#define MSG_MonoProfilerPublisher_JitDone_V1EventMessage 0xB401000AL
#define MSG_MonoProfilerPublisher_ClassLoaded_V1EventMessage 0xB4010010L
#define MSG_RuntimePublisher_GCSegment_SmallObjectHeapMapMessage 0xD0000001L
#define MSG_RuntimePublisher_GCSegment_LargeObjectHeapMapMessage 0xD0000002L
#define MSG_RuntimePublisher_GCSegment_ReadOnlyHeapMapMessage 0xD0000003L
#define MSG_RuntimePublisher_GCSegment_PinnedObjectHeapMapMessage 0xD0000004L
#define MSG_RuntimePublisher_GCAllocation_SmallMapMessage 0xD0000005L
#define MSG_RuntimePublisher_GCAllocation_LargeMapMessage 0xD0000006L
#define MSG_RuntimePublisher_GCAllocation_PinnedMapMessage 0xD0000007L
#define MSG_RuntimePublisher_GCBucket_FLItemMapMessage 0xD0000008L
#define MSG_RuntimePublisher_GCBucket_PlugMessage 0xD0000009L
#define MSG_RuntimePublisher_GCType_NonConcurrentGCMapMessage 0xD000000AL
#define MSG_RuntimePublisher_GCType_BackgroundGCMapMessage 0xD000000BL
#define MSG_RuntimePublisher_GCType_ForegroundGCMapMessage 0xD000000CL
#define MSG_RuntimePublisher_GCReason_AllocSmallMapMessage 0xD000000DL
#define MSG_RuntimePublisher_GCReason_InducedMapMessage 0xD000000EL
#define MSG_RuntimePublisher_GCReason_LowMemoryMapMessage 0xD000000FL
#define MSG_RuntimePublisher_GCReason_EmptyMapMessage 0xD0000010L
#define MSG_RuntimePublisher_GCReason_AllocLargeMapMessage 0xD0000011L
#define MSG_RuntimePublisher_GCReason_OutOfSpaceSmallObjectHeapMapMessage 0xD0000012L
#define MSG_RuntimePublisher_GCReason_OutOfSpaceLargeObjectHeapMapMessage 0xD0000013L
#define MSG_RuntimePublisher_GCReason_InducedNoForceMapMessage 0xD0000014L
#define MSG_RuntimePublisher_GCReason_StressMapMessage 0xD0000015L
#define MSG_RuntimePublisher_GCReason_InducedLowMemoryMapMessage 0xD0000016L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendOtherMapMessage 0xD0000017L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForGCMapMessage 0xD0000018L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForAppDomainShutdownMapMessage 0xD0000019L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForCodePitchingMapMessage 0xD000001AL
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForShutdownMapMessage 0xD000001BL
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForDebuggerMapMessage 0xD000001CL
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForGCPrepMapMessage 0xD000001DL
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForDebuggerSweepMapMessage 0xD000001EL
#define MSG_RuntimePublisher_Contention_ManagedMapMessage 0xD000001FL
#define MSG_RuntimePublisher_Contention_NativeMapMessage 0xD0000020L
#define MSG_RuntimePublisher_TailCallType_OptimizedMapMessage 0xD0000021L
#define MSG_RuntimePublisher_TailCallType_RecursiveMapMessage 0xD0000022L
#define MSG_RuntimePublisher_TailCallType_HelperMapMessage 0xD0000023L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_WarmupMapMessage 0xD0000024L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_InitializingMapMessage 0xD0000025L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_RandomMoveMapMessage 0xD0000026L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_ClimbingMoveMapMessage 0xD0000027L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_ChangePointMapMessage 0xD0000028L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_StabilizingMapMessage 0xD0000029L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_StarvationMapMessage 0xD000002AL
#define MSG_RuntimePublisher_ThreadAdjustmentReason_ThreadTimedOutMapMessage 0xD000002BL
#define MSG_RuntimePublisher_GCRootKind_Stack 0xD000002CL
#define MSG_RuntimePublisher_GCRootKind_Finalizer 0xD000002DL
#define MSG_RuntimePublisher_GCRootKind_Handle 0xD000002EL
#define MSG_RuntimePublisher_GCRootKind_Older 0xD000002FL
#define MSG_RuntimePublisher_GCRootKind_SizedRef 0xD0000030L
#define MSG_RuntimePublisher_GCRootKind_Overflow 0xD0000031L
#define MSG_RuntimePublisher_GCRootKind_DependentHandle 0xD0000032L
#define MSG_RuntimePublisher_GCRootKind_NewFQ 0xD0000033L
#define MSG_RuntimePublisher_GCRootKind_Steal 0xD0000034L
#define MSG_RuntimePublisher_GCRootKind_BGC  0xD0000035L
#define MSG_RuntimePublisher_GCHandleKind_WeakShortMessage 0xD0000036L
#define MSG_RuntimePublisher_GCHandleKind_WeakLongMessage 0xD0000037L
#define MSG_RuntimePublisher_GCHandleKind_StrongMessage 0xD0000038L
#define MSG_RuntimePublisher_GCHandleKind_PinnedMessage 0xD0000039L
#define MSG_RuntimePublisher_GCHandleKind_VariableMessage 0xD000003AL
#define MSG_RuntimePublisher_GCHandleKind_RefCountedMessage 0xD000003BL
#define MSG_RuntimePublisher_GCHandleKind_DependentMessage 0xD000003CL
#define MSG_RuntimePublisher_GCHandleKind_AsyncPinnedMessage 0xD000003DL
#define MSG_RuntimePublisher_GCHandleKind_SizedRefMessage 0xD000003EL
#define MSG_RuntimePublisher_KnownPathSource_ApplicationAssembliesMessage 0xD000003FL
#define MSG_RuntimePublisher_KnownPathSource_UnusedMessage 0xD0000040L
#define MSG_RuntimePublisher_KnownPathSource_AppPathsMessage 0xD0000041L
#define MSG_RuntimePublisher_KnownPathSource_PlatformResourceRootsMessage 0xD0000042L
#define MSG_RuntimePublisher_KnownPathSource_SatelliteSubdirectoryMessage 0xD0000043L
#define MSG_RuntimePublisher_ResolutionAttempted_FindInLoadContext 0xD0000044L
#define MSG_RuntimePublisher_ResolutionAttempted_AssemblyLoadContextLoad 0xD0000045L
#define MSG_RuntimePublisher_ResolutionAttempted_ApplicationAssemblies 0xD0000046L
#define MSG_RuntimePublisher_ResolutionAttempted_DefaultAssemblyLoadContextFallback 0xD0000047L
#define MSG_RuntimePublisher_ResolutionAttempted_ResolveSatelliteAssembly 0xD0000048L
#define MSG_RuntimePublisher_ResolutionAttempted_AssemblyLoadContextResolvingEvent 0xD0000049L
#define MSG_RuntimePublisher_ResolutionAttempted_AppDomainAssemblyResolveEvent 0xD000004AL
#define MSG_RuntimePublisher_ResolutionAttempted_Success 0xD000004BL
#define MSG_RuntimePublisher_ResolutionAttempted_AssemblyNotFound 0xD000004CL
#define MSG_RuntimePublisher_ResolutionAttempted_MismatchedAssemblyName 0xD000004DL
#define MSG_RuntimePublisher_ResolutionAttempted_IncompatibleVersion 0xD000004EL
#define MSG_RuntimePublisher_ResolutionAttempted_Failure 0xD000004FL
#define MSG_RuntimePublisher_ResolutionAttempted_Exception 0xD0000050L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ModuleSection 0xD3000001L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_EETableSection 0xD3000002L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_WriteDataSection 0xD3000003L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_WriteableDataSection 0xD3000004L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_DataSection 0xD3000005L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_RVAStaticsSection 0xD3000006L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_EEDataSection 0xD3000007L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_DelayLoadInfoTableEagerSection 0xD3000008L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_DelayLoadInfoTableSection 0xD3000009L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_EEReadonlyData 0xD300000AL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ReadonlyData 0xD300000BL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ClassSection 0xD300000CL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_CrossDomainInfoSection 0xD300000DL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_MethodDescSection 0xD300000EL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_MethodDescWriteableSection 0xD300000FL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ExceptionSection 0xD3000010L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_InstrumentSection 0xD3000011L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_VirtualImportThunkSection 0xD3000012L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ExternalMethodThunkSection 0xD3000013L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_HelperTableSection 0xD3000014L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_MethodPrecodeWriteableSection 0xD3000015L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_MethodPrecodeWriteSection 0xD3000016L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_MethodPrecodeSection 0xD3000017L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_Win32ResourcesSection 0xD3000018L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_HeaderSection 0xD3000019L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_MetadataSection 0xD300001AL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_DelayLoadInfoSection 0xD300001BL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ImportTableSection 0xD300001CL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_CodeSection 0xD300001DL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_CodeHeaderSection 0xD300001EL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_CodeManagerSection 0xD300001FL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_UnwindDataSection 0xD3000020L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_RuntimeFunctionSection 0xD3000021L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_StubsSection 0xD3000022L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_StubDispatchDataSection 0xD3000023L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ExternalMethodDataSection 0xD3000024L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_DelayLoadInfoDelayListSection 0xD3000025L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ReadonlySharedSection 0xD3000026L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ReadonlySection 0xD3000027L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ILSection 0xD3000028L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_GCInfoSection 0xD3000029L
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ILMetadataSection 0xD300002AL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_ResourcesSection 0xD300002BL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_CompressedMapsSection 0xD300002CL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_DebugSection 0xD300002DL
#define MSG_PrivatePublisher_ModuleRangeSectionTypeMap_BaseRelocsSection 0xD300002EL
#define MSG_PrivatePublisher_GCHandleKind_WeakShortMessage 0xD300002FL
#define MSG_PrivatePublisher_GCHandleKind_WeakLongMessage 0xD3000030L
#define MSG_PrivatePublisher_GCHandleKind_StrongMessage 0xD3000031L
#define MSG_PrivatePublisher_GCHandleKind_PinnedMessage 0xD3000032L
#define MSG_PrivatePublisher_GCHandleKind_VariableMessage 0xD3000033L
#define MSG_PrivatePublisher_GCHandleKind_RefCountedMessage 0xD3000034L
#define MSG_PrivatePublisher_GCHandleKind_DependentMessage 0xD3000035L
#define MSG_PrivatePublisher_GCHandleKind_AsyncPinnedMessage 0xD3000036L
#define MSG_PrivatePublisher_GCHandleKind_SizedRefMessage 0xD3000037L
#define MSG_MonoProfilerPublisher_CodeBufferTypeMap_MethodMessage 0xD4000001L
#define MSG_MonoProfilerPublisher_CodeBufferTypeMap_MethodTrampolineMessage 0xD4000002L
#define MSG_MonoProfilerPublisher_CodeBufferTypeMap_UnboxTrampolineMessage 0xD4000003L
#define MSG_MonoProfilerPublisher_CodeBufferTypeMap_IMTTrampolineMessage 0xD4000004L
#define MSG_MonoProfilerPublisher_CodeBufferTypeMap_GenericsTrampolineMessage 0xD4000005L
#define MSG_MonoProfilerPublisher_CodeBufferTypeMap_SpecificTrampolineMessage 0xD4000006L
#define MSG_MonoProfilerPublisher_CodeBufferTypeMap_HelperMessage 0xD4000007L
#define MSG_MonoProfilerPublisher_ExceptionClauseTypeMap_NoneMessage 0xD4000008L
#define MSG_MonoProfilerPublisher_ExceptionClauseTypeMap_FilterMessage 0xD4000009L
#define MSG_MonoProfilerPublisher_ExceptionClauseTypeMap_FinallyMessage 0xD400000AL
#define MSG_MonoProfilerPublisher_ExceptionClauseTypeMap_FaultMessage 0xD400000BL
#define MSG_MonoProfilerPublisher_GCEventTypeMap_StartMessage 0xD400000CL
#define MSG_MonoProfilerPublisher_GCEventTypeMap_EndMessage 0xD400000DL
#define MSG_MonoProfilerPublisher_GCEventTypeMap_PreStopWorldMessage 0xD400000EL
#define MSG_MonoProfilerPublisher_GCEventTypeMap_PostStopWorldMessage 0xD400000FL
#define MSG_MonoProfilerPublisher_GCEventTypeMap_PreStartWorldMessage 0xD4000010L
#define MSG_MonoProfilerPublisher_GCEventTypeMap_PostStartWorldMessage 0xD4000011L
#define MSG_MonoProfilerPublisher_GCEventTypeMap_PreStopWorldLockedMessage 0xD4000012L
#define MSG_MonoProfilerPublisher_GCEventTypeMap_PostStartWorldUnlockedMessage 0xD4000013L
#define MSG_MonoProfilerPublisher_GCHandleTypeMap_WeakMessage 0xD4000014L
#define MSG_MonoProfilerPublisher_GCHandleTypeMap_WeakTrackResurrectionMessage 0xD4000015L
#define MSG_MonoProfilerPublisher_GCHandleTypeMap_NormalMessage 0xD4000016L
#define MSG_MonoProfilerPublisher_GCHandleTypeMap_PinnedMessage 0xD4000017L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_ExternalMessage 0xD4000018L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_StackMessage 0xD4000019L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_FinalizerQueueMessage 0xD400001AL
#define MSG_MonoProfilerPublisher_GCRootTypeMap_StaticMessage 0xD400001BL
#define MSG_MonoProfilerPublisher_GCRootTypeMap_ThreadStaticMessage 0xD400001CL
#define MSG_MonoProfilerPublisher_GCRootTypeMap_ContextStaticMessage 0xD400001DL
#define MSG_MonoProfilerPublisher_GCRootTypeMap_GCHandleMessage 0xD400001EL
#define MSG_MonoProfilerPublisher_GCRootTypeMap_JitMessage 0xD400001FL
#define MSG_MonoProfilerPublisher_GCRootTypeMap_ThreadingMessage 0xD4000020L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_DomainMessage 0xD4000021L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_ReflectionMessage 0xD4000022L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_MarshalMessage 0xD4000023L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_ThreadPoolMessage 0xD4000024L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_DebuggerMessage 0xD4000025L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_HandleMessage 0xD4000026L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_EphemeronMessage 0xD4000027L
#define MSG_MonoProfilerPublisher_GCRootTypeMap_ToggleRefMessage 0xD4000028L
#define MSG_RuntimePublisher_ModuleRangeTypeMap_ColdRangeMessage 0xF0000001L
#define MSG_RuntimePublisher_AppDomain_DefaultMapMessage 0xF0000002L
#define MSG_RuntimePublisher_AppDomain_ExecutableMapMessage 0xF0000003L
#define MSG_RuntimePublisher_AppDomain_SharedMapMessage 0xF0000004L
#define MSG_RuntimePublisher_Assembly_DomainNeutralMapMessage 0xF0000005L
#define MSG_RuntimePublisher_Assembly_DynamicMapMessage 0xF0000006L
#define MSG_RuntimePublisher_Assembly_NativeMapMessage 0xF0000007L
#define MSG_RuntimePublisher_Assembly_CollectibleMapMessage 0xF0000008L
#define MSG_RuntimePublisher_Module_DomainNeutralMapMessage 0xF0000009L
#define MSG_RuntimePublisher_Module_NativeMapMessage 0xF000000AL
#define MSG_RuntimePublisher_Module_DynamicMapMessage 0xF000000BL
#define MSG_RuntimePublisher_Module_ManifestMapMessage 0xF000000CL
#define MSG_RuntimePublisher_Module_IbcOptimizedMapMessage 0xF000000DL
#define MSG_RuntimePublisher_Module_ReadyToRunModuleMapMessage 0xF000000EL
#define MSG_RuntimePublisher_Module_PartialReadyToRunModuleMapMessage 0xF000000FL
#define MSG_RuntimePublisher_Method_DynamicMapMessage 0xF0000010L
#define MSG_RuntimePublisher_Method_GenericMapMessage 0xF0000011L
#define MSG_RuntimePublisher_Method_HasSharedGenericCodeMapMessage 0xF0000012L
#define MSG_RuntimePublisher_Method_JittedMapMessage 0xF0000013L
#define MSG_RuntimePublisher_Method_JitHelperMapMessage 0xF0000014L
#define MSG_RuntimePublisher_Method_ProfilerRejectedPrecompiledCodeMapMessage 0xF0000015L
#define MSG_RuntimePublisher_Method_ReadyToRunRejectedPrecompiledCodeMapMessage 0xF0000016L
#define MSG_RuntimePublisher_StartupMode_ManagedExeMapMessage 0xF0000017L
#define MSG_RuntimePublisher_StartupMode_HostedCLRMapMessage 0xF0000018L
#define MSG_RuntimePublisher_StartupMode_IjwDllMapMessage 0xF0000019L
#define MSG_RuntimePublisher_StartupMode_ComActivatedMapMessage 0xF000001AL
#define MSG_RuntimePublisher_StartupMode_OtherMapMessage 0xF000001BL
#define MSG_RuntimePublisher_RuntimeSku_DesktopCLRMapMessage 0xF000001CL
#define MSG_RuntimePublisher_RuntimeSku_CoreCLRMapMessage 0xF000001DL
#define MSG_RuntimePublisher_RuntimeSku_MonoMapMessage 0xF000001EL
#define MSG_RuntimePublisher_ExceptionThrown_HasInnerExceptionMapMessage 0xF000001FL
#define MSG_RuntimePublisher_ExceptionThrown_NestedMapMessage 0xF0000020L
#define MSG_RuntimePublisher_ExceptionThrown_ReThrownMapMessage 0xF0000021L
#define MSG_RuntimePublisher_ExceptionThrown_CorruptedStateMapMessage 0xF0000022L
#define MSG_RuntimePublisher_ExceptionThrown_CLSCompliantMapMessage 0xF0000023L
#define MSG_RuntimePublisher_ILStubGenerated_ReverseInteropMapMessage 0xF0000024L
#define MSG_RuntimePublisher_ILStubGenerated_COMInteropMapMessage 0xF0000025L
#define MSG_RuntimePublisher_ILStubGenerated_NGenedStubMapMessage 0xF0000026L
#define MSG_RuntimePublisher_ILStubGenerated_DelegateMapMessage 0xF0000027L
#define MSG_RuntimePublisher_ILStubGenerated_VarArgMapMessage 0xF0000028L
#define MSG_RuntimePublisher_ILStubGenerated_UnmanagedCalleeMapMessage 0xF0000029L
#define MSG_RuntimePublisher_ILStubGenerated_StructStubMapMessage 0xF000002AL
#define MSG_RuntimePublisher_Startup_CONCURRENT_GCMapMessage 0xF000002BL
#define MSG_RuntimePublisher_Startup_LOADER_OPTIMIZATION_SINGLE_DOMAINMapMessage 0xF000002CL
#define MSG_RuntimePublisher_Startup_LOADER_OPTIMIZATION_MULTI_DOMAINMapMessage 0xF000002DL
#define MSG_RuntimePublisher_Startup_LOADER_SAFEMODEMapMessage 0xF000002EL
#define MSG_RuntimePublisher_Startup_LOADER_SETPREFERENCEMapMessage 0xF000002FL
#define MSG_RuntimePublisher_Startup_SERVER_GCMapMessage 0xF0000030L
#define MSG_RuntimePublisher_Startup_HOARD_GC_VMMapMessage 0xF0000031L
#define MSG_RuntimePublisher_Startup_SINGLE_VERSION_HOSTING_INTERFACEMapMessage 0xF0000032L
#define MSG_RuntimePublisher_Startup_LEGACY_IMPERSONATIONMapMessage 0xF0000033L
#define MSG_RuntimePublisher_Startup_DISABLE_COMMITTHREADSTACKMapMessage 0xF0000034L
#define MSG_RuntimePublisher_Startup_ALWAYSFLOW_IMPERSONATIONMapMessage 0xF0000035L
#define MSG_RuntimePublisher_Startup_TRIM_GC_COMMITMapMessage 0xF0000036L
#define MSG_RuntimePublisher_Startup_ETWMapMessage 0xF0000037L
#define MSG_RuntimePublisher_Startup_SERVER_BUILDMapMessage 0xF0000038L
#define MSG_RuntimePublisher_Startup_ARMMapMessage 0xF0000039L
#define MSG_RuntimePublisher_TypeFlags_Delegate 0xF000003AL
#define MSG_RuntimePublisher_TypeFlags_Finalizable 0xF000003BL
#define MSG_RuntimePublisher_TypeFlags_ExternallyImplementedCOMObject 0xF000003CL
#define MSG_RuntimePublisher_TypeFlags_Array 0xF000003DL
#define MSG_RuntimePublisher_TypeFlags_ArrayRankBit0 0xF000003EL
#define MSG_RuntimePublisher_TypeFlags_ArrayRankBit1 0xF000003FL
#define MSG_RuntimePublisher_TypeFlags_ArrayRankBit2 0xF0000040L
#define MSG_RuntimePublisher_TypeFlags_ArrayRankBit3 0xF0000041L
#define MSG_RuntimePublisher_TypeFlags_ArrayRankBit4 0xF0000042L
#define MSG_RuntimePublisher_TypeFlags_ArrayRankBit5 0xF0000043L
#define MSG_RuntimePublisher_GCRootFlags_Pinning 0xF0000044L
#define MSG_RuntimePublisher_GCRootFlags_WeakRef 0xF0000045L
#define MSG_RuntimePublisher_GCRootFlags_Interior 0xF0000046L
#define MSG_RuntimePublisher_GCRootFlags_RefCounted 0xF0000047L
#define MSG_RuntimePublisher_GCRootStaticVarFlags_ThreadLocal 0xF0000048L
#define MSG_RuntimePublisher_GCRootCCWFlags_Strong 0xF0000049L
#define MSG_RuntimePublisher_GCRootCCWFlags_Pegged 0xF000004AL
#define MSG_RuntimePublisher_ThreadFlags_GCSpecial 0xF000004BL
#define MSG_RuntimePublisher_ThreadFlags_Finalizer 0xF000004CL
#define MSG_RuntimePublisher_ThreadFlags_ThreadPoolWorker 0xF000004DL
#define MSG_RuntimePublisher_TieredCompilationSettingsFlags_NoneMapMessage 0xF000004EL
#define MSG_RuntimePublisher_TieredCompilationSettingsFlags_QuickJitMapMessage 0xF000004FL
#define MSG_RuntimePublisher_TieredCompilationSettingsFlags_QuickJitForLoopsMapMessage 0xF0000050L
#define MSG_RuntimePublisher_TieredCompilationSettingsFlags_TieredPGOMapMessage 0xF0000051L
#define MSG_RuntimePublisher_TieredCompilationSettingsFlags_ReadyToRunMapMessage 0xF0000052L
#define MSG_RundownPublisher_ModuleRangeTypeMap_ColdRangeMessage 0xF1000001L
#define MSG_RundownPublisher_AppDomain_DefaultMapMessage 0xF1000002L
#define MSG_RundownPublisher_AppDomain_ExecutableMapMessage 0xF1000003L
#define MSG_RundownPublisher_AppDomain_SharedMapMessage 0xF1000004L
#define MSG_RundownPublisher_Assembly_DomainNeutralMapMessage 0xF1000005L
#define MSG_RundownPublisher_Assembly_DynamicMapMessage 0xF1000006L
#define MSG_RundownPublisher_Assembly_NativeMapMessage 0xF1000007L
#define MSG_RundownPublisher_Assembly_CollectibleMapMessage 0xF1000008L
#define MSG_RundownPublisher_Module_DomainNeutralMapMessage 0xF1000009L
#define MSG_RundownPublisher_Module_NativeMapMessage 0xF100000AL
#define MSG_RundownPublisher_Module_DynamicMapMessage 0xF100000BL
#define MSG_RundownPublisher_Module_ManifestMapMessage 0xF100000CL
#define MSG_RundownPublisher_Module_IbcOptimizedMapMessage 0xF100000DL
#define MSG_RundownPublisher_Module_ReadyToRunModuleMapMessage 0xF100000EL
#define MSG_RundownPublisher_Module_PartialReadyToRunModuleMapMessage 0xF100000FL
#define MSG_RundownPublisher_Method_DynamicMapMessage 0xF1000010L
#define MSG_RundownPublisher_Method_GenericMapMessage 0xF1000011L
#define MSG_RundownPublisher_Method_HasSharedGenericCodeMapMessage 0xF1000012L
#define MSG_RundownPublisher_Method_JittedMapMessage 0xF1000013L
#define MSG_RundownPublisher_StartupMode_ManagedExeMapMessage 0xF1000014L
#define MSG_RundownPublisher_StartupMode_HostedCLRMapMessage 0xF1000015L
#define MSG_RundownPublisher_StartupMode_IjwDllMapMessage 0xF1000016L
#define MSG_RundownPublisher_StartupMode_ComActivatedMapMessage 0xF1000017L
#define MSG_RundownPublisher_StartupMode_OtherMapMessage 0xF1000018L
#define MSG_RundownPublisher_RuntimeSku_DesktopCLRMapMessage 0xF1000019L
#define MSG_RundownPublisher_RuntimeSku_CoreCLRMapMessage 0xF100001AL
#define MSG_RundownPublisher_RuntimeSku_MonoMapMessage 0xF100001BL
#define MSG_RundownPublisher_Startup_CONCURRENT_GCMapMessage 0xF100001CL
#define MSG_RundownPublisher_Startup_LOADER_OPTIMIZATION_SINGLE_DOMAINMapMessage 0xF100001DL
#define MSG_RundownPublisher_Startup_LOADER_OPTIMIZATION_MULTI_DOMAINMapMessage 0xF100001EL
#define MSG_RundownPublisher_Startup_LOADER_SAFEMODEMapMessage 0xF100001FL
#define MSG_RundownPublisher_Startup_LOADER_SETPREFERENCEMapMessage 0xF1000020L
#define MSG_RundownPublisher_Startup_SERVER_GCMapMessage 0xF1000021L
#define MSG_RundownPublisher_Startup_HOARD_GC_VMMapMessage 0xF1000022L
#define MSG_RundownPublisher_Startup_SINGLE_VERSION_HOSTING_INTERFACEMapMessage 0xF1000023L
#define MSG_RundownPublisher_Startup_LEGACY_IMPERSONATIONMapMessage 0xF1000024L
#define MSG_RundownPublisher_Startup_DISABLE_COMMITTHREADSTACKMapMessage 0xF1000025L
#define MSG_RundownPublisher_Startup_ALWAYSFLOW_IMPERSONATIONMapMessage 0xF1000026L
#define MSG_RundownPublisher_Startup_TRIM_GC_COMMITMapMessage 0xF1000027L
#define MSG_RundownPublisher_Startup_ETWMapMessage 0xF1000028L
#define MSG_RundownPublisher_Startup_SERVER_BUILDMapMessage 0xF1000029L
#define MSG_RundownPublisher_Startup_ARMMapMessage 0xF100002AL
#define MSG_RundownPublisher_ThreadFlags_GCSpecial 0xF100002BL
#define MSG_RundownPublisher_ThreadFlags_Finalizer 0xF100002CL
#define MSG_RundownPublisher_ThreadFlags_ThreadPoolWorker 0xF100002DL
#define MSG_RundownPublisher_TieredCompilationSettingsFlags_NoneMapMessage 0xF100002EL
#define MSG_RundownPublisher_TieredCompilationSettingsFlags_QuickJitMapMessage 0xF100002FL
#define MSG_RundownPublisher_TieredCompilationSettingsFlags_QuickJitForLoopsMapMessage 0xF1000030L
#define MSG_RundownPublisher_TieredCompilationSettingsFlags_TieredPGOMapMessage 0xF1000031L
#define MSG_RundownPublisher_TieredCompilationSettingsFlags_ReadyToRunMapMessage 0xF1000032L
#define MSG_PrivatePublisher_ModuleRangeIBCTypeMap_IBCUnprofiledSectionMessage 0xF3000001L
#define MSG_PrivatePublisher_ModuleRangeIBCTypeMap_IBCProfiledSectionMessage 0xF3000002L
#define MSG_PrivatePublisher_ModuleRangeTypeMap_HotRangeMessage 0xF3000003L
#define MSG_PrivatePublisher_ModuleRangeTypeMap_WarmRangeMessage 0xF3000004L
#define MSG_PrivatePublisher_ModuleRangeTypeMap_ColdRangeMessage 0xF3000005L
#define MSG_PrivatePublisher_ModuleRangeTypeMap_HotColdRangeMessage 0xF3000006L
