// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
//
// File: eventtrace.cpp
// Abstract: This module implements Event Tracing support
//
// ============================================================================

#include "common.h"

#include "gcenv.h"
#include "gcheaputilities.h"

#include "daccess.h"

#include "thread.h"
#include "threadstore.h"
#include "threadstore.inl"

volatile LONGLONG ETW::GCLog::s_l64LastClientSequenceNumber = 0;

// This implements the public runtime provider's GCHeapCollectKeyword.  It
// performs a full, gen-2, blocking GC.
void ETW::GCLog::ForceGC(LONGLONG l64ClientSequenceNumber)
{
    CONTRACTL
    {
        NOTHROW;
        GC_TRIGGERS;
        MODE_ANY;
    }
    CONTRACTL_END;

    if (!GCHeapUtilities::IsGCHeapInitialized())
        return;

    // No InterlockedExchange64 on Redhawk, even though there is one for
    // InterlockedCompareExchange64. Technically, there's a race here by using
    // InterlockedCompareExchange64, but it's not worth addressing. The race would be
    // between two ETW controllers trying to trigger GCs simultaneously, in which case
    // one will win and get its sequence number to appear in the GCStart event, while the
    // other will lose. Rare, uninteresting, and low-impact.
    PalInterlockedCompareExchange64(&s_l64LastClientSequenceNumber, l64ClientSequenceNumber, s_l64LastClientSequenceNumber);

    ForceGCForDiagnostics();
}

//---------------------------------------------------------------------------------------
//
// Helper to fire the GCStart event.  Figures out which version of GCStart to fire, and
// includes the client sequence number, if available.
//
// Arguments:
//      pGcInfo - ETW_GC_INFO containing details from GC about this collection
//

// static
void ETW::GCLog::FireGcStart(ETW_GC_INFO* pGcInfo)
{
    LIMITED_METHOD_CONTRACT;

    if (RUNTIME_PROVIDER_CATEGORY_ENABLED(TRACE_LEVEL_INFORMATION, CLR_GC_KEYWORD))
    {
        // If the controller specified a client sequence number for us to log with this
        // GCStart, then retrieve it
        LONGLONG l64ClientSequenceNumberToLog = 0;
        if ((s_l64LastClientSequenceNumber != 0) &&
            (pGcInfo->GCStart.Depth == GCHeapUtilities::GetGCHeap()->GetMaxGeneration()) &&
            (pGcInfo->GCStart.Reason == ETW_GC_INFO::GC_INDUCED))
        {
            // No InterlockedExchange64 on Redhawk (presumably b/c there is no compiler
            // intrinsic for this on x86, even though there is one for InterlockedCompareExchange64)
            l64ClientSequenceNumberToLog = PalInterlockedCompareExchange64(&s_l64LastClientSequenceNumber, 0, s_l64LastClientSequenceNumber);
        }

        FireEtwGCStart_V2(pGcInfo->GCStart.Count, pGcInfo->GCStart.Depth, pGcInfo->GCStart.Reason, pGcInfo->GCStart.Type, GetClrInstanceId(), l64ClientSequenceNumberToLog);
    }
}

//---------------------------------------------------------------------------------------
//
// Contains code common to profapi and ETW scenarios where the profiler wants to force
// the CLR to perform a GC.  The important work here is to create a managed thread for
// the current thread BEFORE the GC begins.  On both ETW and profapi threads, there may
// not yet be a managed thread object.  But some scenarios require a managed thread
// object be present (notably if we need to call into Jupiter during the GC).
//
// Return Value:
//      HRESULT indicating success or failure
//
// Assumptions:
//      Caller should ensure that the EE has fully started up and that the GC heap is
//      initialized enough to actually perform a GC
//

// static
HRESULT ETW::GCLog::ForceGCForDiagnostics()
{
    CONTRACTL
    {
        NOTHROW;
        GC_TRIGGERS;
        MODE_ANY;
    }
    CONTRACTL_END;

    HRESULT hr = E_FAIL;

    _ASSERTE(GCHeapUtilities::IsGCHeapInitialized());

    ThreadStore::AttachCurrentThread();
    Thread* pThread = ThreadStore::GetCurrentThread();

    // While doing the GC, much code assumes & asserts the thread doing the GC is in
    // cooperative mode.
    pThread->DisablePreemptiveMode();

    hr = GCHeapUtilities::GetGCHeap()->GarbageCollect(
        -1,     // all generations should be collected
        FALSE,  // low_memory_p
        collection_blocking);

    // In case this thread (generated by the ETW OS APIs) hangs around a while,
    // better stick it back into preemptive mode, so it doesn't block any other GCs
    pThread->EnablePreemptiveMode();

    return hr;
}

COOP_PINVOKE_HELPER(void, RhpEtwExceptionThrown, (LPCWSTR exceptionTypeName, LPCWSTR exceptionMessage, void* faultingIP, HRESULT hresult))
{
    FireEtXplatExceptionThrown_V1(exceptionTypeName,
        exceptionMessage,
        faultingIP,
        hresult,
        0,
        GetClrInstanceId());
}
