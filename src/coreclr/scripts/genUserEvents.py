from __future__ import print_function
from genEventing import *
import os
import xml.dom.minidom as DOM
from utilities import open_for_update, parseExclusionList, parseInclusionList

stdprolog_cpp = """// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

/******************************************************************

DO NOT MODIFY. AUTOGENERATED FILE.
This file is generated using the logic from <root>/src/scripts/genUserEvent.py

******************************************************************/

"""

stdprolog_cmake = """#
#
#******************************************************************

#DO NOT MODIFY. AUTOGENERATED FILE.
#This file is generated using the logic from <root>/src/scripts/genUserEvent.py

#******************************************************************

"""

userevent_dirname = "userevents"

def generateMethodSignatureEnabled(eventName, runtimeFlavor, providerName, eventLevel, eventKeywords):
    return "%s UserEventEnabled%s(void)" % (getEventPipeDataTypeMapping(runtimeFlavor)["BOOL"], eventName,)#mayhbe add in genEventing.py

def generateMethodSignatureWrite(eventName, template, extern, runtimeFlavor):
    sig_pieces = []

    if extern: sig_pieces.append('extern "C" ')
    sig_pieces.append("%s UserEventWriteEvent" % (getEventPipeDataTypeMapping(runtimeFlavor)["ULONG"]))
    sig_pieces.append(eventName)
    sig_pieces.append("(")

    if template:
        sig_pieces.append("\n")
        fnSig = template.signature
        for paramName in fnSig.paramlist:
            fnparam = fnSig.getParam(paramName)
            wintypeName = fnparam.winType
            typewName = getPalDataTypeMapping(runtimeFlavor)[wintypeName]
            winCount = fnparam.count
            countw = getPalDataTypeMapping(runtimeFlavor)[winCount]

            if paramName in template.structs:
                sig_pieces.append(
                    "%sint %s_ElementSize,\n" %
                    (lindent, paramName))

            sig_pieces.append(lindent)
            sig_pieces.append(typewName)
            if countw != " ":
                sig_pieces.append(countw)

            sig_pieces.append(" ")
            sig_pieces.append(fnparam.name)
            sig_pieces.append(",\n")

    sig_pieces.append(lindent)
    sig_pieces.append("%s ActivityId,\n" % (getEventPipeDataTypeMapping(runtimeFlavor)["LPCGUID"]))
    sig_pieces.append(lindent)
    sig_pieces.append("%s RelatedActivityId" % (getEventPipeDataTypeMapping(runtimeFlavor)["LPCGUID"]))
    sig_pieces.append(")")
    return ''.join(sig_pieces)
def formatGuid(providerGuid):
    providerGuid = providerGuid[1:-1]
    guidParts = providerGuid.split('-')
    lastPart = guidParts[-1]
    guidParts = guidParts[:-1]
    nextLastPart = guidParts[-1]
    guidParts = guidParts[:-1]
    nextLastPartSplit = [nextLastPart[i:i+2] for i in range(0, len(nextLastPart), 2)]
    lastPartSplit = [lastPart[i:i+2] for i in range(0, len(lastPart), 2)]
    guidParts.extend(nextLastPartSplit)
    guidParts.extend(lastPartSplit)
    guidParts[0] = "0x" + guidParts[0]
    return ", 0x".join(guidParts)

def generateClrUserEventWriteEventsImpl(providerNode, providerPrettyName, providerName, eventNodes, allTemplates, extern, target_cpp, runtimeFlavor, inclusionList, exclusionList):
    WriteEventImpl = []
    # User Event Provider Declaration
    providerGuid = formatGuid(providerNode.getAttribute('guid'))
    WriteEventImpl.append("TRACELOGGING_DEFINE_PROVIDER(%s, \"%s\", (%s));\n\n" % (providerPrettyName, providerName, providerGuid))
    for eventNode in eventNodes:
        eventName = eventNode.getAttribute('symbol')
        templateName = eventNode.getAttribute('template')
        eventLevel = eventNode.getAttribute('level')
        eventKeywords = eventNode.getAttribute('keywords')
        eventKeywordsMask = generateEventKeywords(eventKeywords)


        if not includeEvent(inclusionList, providerName, eventName):
            continue

        eventIsEnabledFunc = ""
        if runtimeFlavor.coreclr:
            eventIsEnabledFunc = "TraceLoggingProviderEnabled"
        elif (runtimeFlavor.mono or runtimeFlavor.nativeaot):
            eventIsEnabledFunc = "ep_event_is_enabled"

        # generate UserEventEnabled function
        eventEnabledImpl = generateMethodSignatureEnabled(eventName, runtimeFlavor, providerName, eventLevel, eventKeywords) + """
{
    return %s(UserEvent%s, %s, %s);
}

""" % (eventIsEnabledFunc, eventName, getUserEventLogLevelMapping(runtimeFlavor)[eventLevel], eventKeywordsMask)
        WriteEventImpl.append(eventEnabledImpl)

            # generate UserEventWriteEvent function
        fnptype = []

        if templateName:
            template = allTemplates[templateName]
        else:
            template = None

        fnptype.append(generateMethodSignatureWrite(eventName, template, extern, runtimeFlavor))
        fnptype.append("\n{\n")
        checking = """    if (!UserEventEnabled%s())
        return ERROR_SUCCESS;
""" % (eventName)

        fnptype.append(checking)

        WriteEventImpl.extend(fnptype)

        if template:
            body = generateWriteEventBody(template, providerPrettyName, eventName, runtimeFlavor, eventLevel, eventKeywordsMask)
            WriteEventImpl.append(body)
            WriteEventImpl.append("}\n\n")
        else: #not too sure about this
            if runtimeFlavor.coreclr:
                WriteEventImpl.append(
                    "    TraceLoggingWriteActivity(%s, \"%s\"" %(providerPrettyName, eventName) +
                    ", ActivityId, RelatedActivityId);\n")
            # elif (runtimeFlavor.mono or runtimeFlavor.nativeaot):
            #     WriteEventImpl.append(
            #         "    ep_write_event (EventPipeEvent" +
            #         eventName +
            #         ", (uint8_t *) NULL, 0, (const uint8_t *)ActivityId, (const uint8_t *)RelatedActivityId);\n")
            WriteEventImpl.append("\n    return ERROR_SUCCESS;\n}\n\n")
    return ''.join(WriteEventImpl)

def generateWriteEventBody(template, providerPrettyName, eventName, runtimeFlavor, eventLevel, eventKeywordsMask):
    #each of the if/else in this function is a different type of template, or a template containing specific args
    fnSig = template.signature
    pack_list = []
    #need the providerNode to get the first arg for TraceLoggingWrite
    pack_list.append("    TraceLoggingWriteActivity(%s, \"%s\", ActivityId, RelatedActivityId, TraceLoggingLevel(%s), TraceLoggingKeyword(%s)" % (providerPrettyName, eventName, getUserEventLogLevelMapping(runtimeFlavor)[eventLevel], eventKeywordsMask))

    for paramName in fnSig.paramlist:
        parameter = fnSig.getParam(paramName)
        if paramName in template.structs:
            size = "(int)%s_ElementSize * (int)%s" % (
                paramName, parameter.prop)
            pack_list.append("    TraceLoggingBinary(%s, %s)" % (parameter, size))
        elif paramName in template.arrays:
            size = "sizeof(%s) * (int)%s" % (
                getArrayDataTypeMapping(runtimeFlavor)[parameter.winType],
                parameter.prop)
        elif parameter.winType == "win:GUID":
            pack_list.append("    %s((uint8_t *)%s)" % (getUserEventDataTypeMapping(runtimeFlavor)[parameter.winType], parameter.name))
        else:
            pack_list.append("    %s(%s)" % (getUserEventDataTypeMapping(runtimeFlavor)[parameter.winType], parameter.name))
    code = ",\n".join(pack_list)  + "\n    );\n    return ERROR_SUCCESS;\n" #+ "\n\n"
    return code



keywordMap = {}

def generateEventKeywords(eventKeywords):
    mask = 0
    # split keywords if there are multiple
    allKeywords = eventKeywords.split()

    for singleKeyword in allKeywords:
        mask = mask | keywordMap[singleKeyword]

    return mask

def getCoreCLRUserEventHelperFileImplPrefix():
    return """
//#include "common.h"
#include <stdlib.h>
#include <string.h>

#ifndef TARGET_UNIX
#include <windef.h>
#include <crtdbg.h>
#else
#include "pal.h"
#endif //TARGET_UNIX

bool ResizeBuffer(BYTE *&buffer, size_t& size, size_t currLen, size_t newSize, bool &fixedBuffer)
{
    newSize = (size_t)(newSize * 1.5);
    _ASSERTE(newSize > size); // check for overflow

    if (newSize < 32)
        newSize = 32;

    BYTE *newBuffer = new (nothrow) BYTE[newSize];

    if (newBuffer == NULL)
        return false;

    memcpy(newBuffer, buffer, currLen);

    if (!fixedBuffer)
        delete[] buffer;

    buffer = newBuffer;
    size = newSize;
    fixedBuffer = false;

    return true;
}

bool WriteToBuffer(const BYTE *src, size_t len, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer)
{
    if (!src) return true;
    if (offset + len > size)
    {
        if (!ResizeBuffer(buffer, size, offset, size + len, fixedBuffer))
            return false;
    }

    memcpy(buffer + offset, src, len);
    offset += len;
    return true;
}

bool WriteToBuffer(PCWSTR str, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer)
{
    if (!str) return true;
    size_t byteCount = (u16_strlen(str) + 1) * sizeof(*str);

    if (offset + byteCount > size)
    {
        if (!ResizeBuffer(buffer, size, offset, size + byteCount, fixedBuffer))
            return false;
    }

    memcpy(buffer + offset, str, byteCount);
    offset += byteCount;
    return true;
}

bool WriteToBuffer(const char *str, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer)
{
    if (!str) return true;
    size_t len = strlen(str) + 1;
    if (offset + len > size)
    {
        if (!ResizeBuffer(buffer, size, offset, size + len, fixedBuffer))
            return false;
    }

    memcpy(buffer + offset, str, len);
    offset += len;
    return true;
}

"""

def getCoreCLRUserEventHelperFileImplSuffix():
    return ""

def getMonoUserEventHelperFileImplPrefix():
    return """#include <config.h>
#ifdef ENABLE_PERFTRACING
#include <userevent/ep-rt-config.h>
#include <userevent/ep-types.h>
#include <userevent/ep-rt.h>
#include <userevent/ep.h>
#include <userevent/ep-event.h>

bool
resize_buffer (
    uint8_t **buffer,
    size_t *size,
    size_t current_size,
    size_t new_size,
    bool *fixed_buffer);

bool
write_buffer (
    const uint8_t *value,
    size_t value_size,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer);

bool
write_buffer_string_utf8_to_utf16_t (
    const ep_char8_t *value,
    size_t value_len,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer);

bool
write_buffer_string_utf8_t (
    const ep_char8_t *value,
    size_t value_len,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer);

bool
resize_buffer (
    uint8_t **buffer,
    size_t *size,
    size_t current_size,
    size_t new_size,
    bool *fixed_buffer)
{
    EP_ASSERT (buffer != NULL);
    EP_ASSERT (size != NULL);
    EP_ASSERT (fixed_buffer != NULL);

    new_size = (size_t)(new_size * 1.5);
    if (new_size < *size) {
        EP_ASSERT (!"Overflow");
        return false;
    }

    if (new_size < 32)
        new_size = 32;

    uint8_t *new_buffer;
    new_buffer = ep_rt_byte_array_alloc (new_size);
    ep_raise_error_if_nok (new_buffer != NULL);

    memcpy (new_buffer, *buffer, current_size);

    if (!*fixed_buffer)
        ep_rt_byte_array_free (*buffer);

    *buffer = new_buffer;
    *size = new_size;
    *fixed_buffer = false;

    return true;

    ep_on_error:
    return false;
}

bool
write_buffer (
    const uint8_t *value,
    size_t value_size,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    EP_ASSERT (buffer != NULL);
    EP_ASSERT (offset != NULL);
    EP_ASSERT (size != NULL);
    EP_ASSERT (fixed_buffer != NULL);

    if ((value_size + *offset) > *size)
        ep_raise_error_if_nok (resize_buffer (buffer, size, *offset, *size + value_size, fixed_buffer));

    memcpy (*buffer + *offset, value, value_size);
    *offset += value_size;

    return true;

ep_on_error:
    return false;
}

bool
write_buffer_string_utf8_to_utf16_t (
    const ep_char8_t *value,
    size_t value_len,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    if (!value || value_len == 0) {
        value_len = sizeof (ep_char16_t);
        if ((value_len + *offset) > *size)
            ep_raise_error_if_nok (resize_buffer (buffer, size, *offset, *size + value_len, fixed_buffer));
        (*buffer) [*offset] = 0;
        (*offset)++;
        (*buffer) [*offset] = 0;
        (*offset)++;
        return true;
    }

    GFixedBufferCustomAllocatorData custom_alloc_data;
    custom_alloc_data.buffer = *buffer + *offset;
    custom_alloc_data.buffer_size = *size - *offset;
    custom_alloc_data.req_buffer_size = 0;

    if (!g_utf8_to_utf16le_custom_alloc (value, (glong)value_len, NULL, NULL, g_fixed_buffer_custom_allocator, &custom_alloc_data, NULL)) {
        ep_raise_error_if_nok (resize_buffer (buffer, size, *offset, *size + custom_alloc_data.req_buffer_size, fixed_buffer));
        custom_alloc_data.buffer = *buffer + *offset;
        custom_alloc_data.buffer_size = *size - *offset;
        custom_alloc_data.req_buffer_size = 0;
        ep_raise_error_if_nok (g_utf8_to_utf16le_custom_alloc (value, (glong)value_len, NULL, NULL, g_fixed_buffer_custom_allocator, &custom_alloc_data, NULL) != NULL);
    }

    *offset += custom_alloc_data.req_buffer_size;
    return true;

ep_on_error:
    return false;
}

bool
write_buffer_string_utf8_t (
    const ep_char8_t *value,
    size_t value_len,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    if (!value)
        value_len = 0;

    if ((value_len + 1 + *offset) > *size)
        ep_raise_error_if_nok (resize_buffer (buffer, size, *offset, *size + value_len + 1, fixed_buffer));

    if (value_len != 0) {
        memcpy (*buffer + *offset, value, value_len);
        *offset += value_len;
    }

    (*buffer) [*offset] = 0;
    (*offset)++;

    return true;

ep_on_error:
    return false;
}

"""

def getMonoUserEventHelperFileImplSuffix():
    return "#endif\n"

def getAotUserEventHelperFileImplPrefix():
    return """
//#include <common.h>
#include <gcenv.h>

#include <eventtrace_context.h>
#include <gcheaputilities.h>

#include <userevent/ep.h>
#include <userevent/ep-provider.h>
#include <userevent/ep-config.h>
#include <userevent/ep-event.h>
#include <userevent/ep-event-instance.h>
#include <userevent/ep-session.h>
#include <userevent/ep-session-provider.h>
#include <userevent/ep-metadata-generator.h>
#include <userevent/ep-event-payload.h>
#include <userevent/ep-buffer-manager.h>

%s

bool ResizeBuffer(BYTE *&buffer, size_t& size, size_t currLen, size_t newSize, bool &fixedBuffer)
{
    newSize = (size_t)(newSize * 1.5);
    _ASSERTE(newSize > size); // check for overflow

    if (newSize < 32)
        newSize = 32;

    BYTE *newBuffer = new (nothrow) BYTE[newSize];

    if (newBuffer == NULL)
        return false;

    memcpy(newBuffer, buffer, currLen);

    if (!fixedBuffer)
        delete[] buffer;

    buffer = newBuffer;
    size = newSize;
    fixedBuffer = false;

    return true;
}

bool WriteToBuffer(const BYTE *src, size_t len, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer)
{
    if (!src) return true;
    if (offset + len > size)
    {
        if (!ResizeBuffer(buffer, size, offset, size + len, fixedBuffer))
            return false;
    }

    memcpy(buffer + offset, src, len);
    offset += len;
    return true;
}

bool WriteToBuffer(const WCHAR*  str, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer)
{
    if (!str) return true;
    size_t byteCount = (ep_rt_utf16_string_len(reinterpret_cast<const ep_char16_t*>(str)) + 1) * sizeof(*str);

    if (offset + byteCount > size)
    {
        if (!ResizeBuffer(buffer, size, offset, size + byteCount, fixedBuffer))
            return false;
    }

    memcpy(buffer + offset, str, byteCount);
    offset += byteCount;
    return true;
}

bool WriteToBuffer(const char *str, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer)
{
    if (!str) return true;
    size_t len = strlen(str) + 1;
    if (offset + len > size)
    {
        if (!ResizeBuffer(buffer, size, offset, size + len, fixedBuffer))
            return false;
    }

    memcpy(buffer + offset, str, len);
    offset += len;
    return true;
}

UserEventProvider * create_provider(const WCHAR* providerName, UserEventCallback callback, void* pCallbackContext = nullptr)
{
    ep_char8_t *providerNameUTF8 = ep_rt_utf16_to_utf8_string(reinterpret_cast<const ep_char16_t *>(providerName));
    UserEventProvider * provider = ep_create_provider (providerNameUTF8, callback, pCallbackContext);
    ep_rt_utf8_string_free (providerNameUTF8);
    return provider;
}

""" % (getCoreCLRMonoNativeAotTypeAdaptionDefines())

def getAotUserEventHelperFileImplSuffix():
    return ""

def generateUserEventHelperFile(etwmanifest, userevent_directory, target_cpp, runtimeFlavor, extern, dryRun):
    usereventhelpersPath = os.path.join(userevent_directory, "usereventhelpers" + (".cpp" if target_cpp else ".c"))
    if dryRun:
        print(usereventhelpersPath)
    else:
        with open_for_update(usereventhelpersPath) as helper:
            helper.write(stdprolog_cpp)
            if runtimeFlavor.coreclr:
                helper.write(getCoreCLRUserEventHelperFileImplPrefix())
            elif runtimeFlavor.mono:
                helper.write(getMonoUserEventHelperFileImplPrefix())
            elif runtimeFlavor.nativeaot:
                helper.write(getAotUserEventHelperFileImplPrefix())

            tree = DOM.parse(etwmanifest)

            for providerNode in tree.getElementsByTagName('provider'):
                providerName = providerNode.getAttribute('name')
                if includeProvider(providerName, runtimeFlavor):
                    providerPrettyName = providerName.replace("Windows-", '')
                    providerPrettyName = providerPrettyName.replace("Microsoft-", '')
                    providerPrettyName = providerPrettyName.replace('-', '_')
                    if extern: helper.write(
                        'extern "C" '
                    )
                    helper.write(
                        "void Init" +
                        providerPrettyName +
                        "(void);\n\n")

            if extern: helper.write(
                'extern "C" '
            )
            helper.write("void InitProvidersAndEvents(void);\n\n")
            helper.write("void InitProvidersAndEvents(void)\n{\n")
            for providerNode in tree.getElementsByTagName('provider'):
                providerName = providerNode.getAttribute('name')
                if includeProvider(providerName, runtimeFlavor):
                    providerPrettyName = providerName.replace("Windows-", '')
                    providerPrettyName = providerPrettyName.replace("Microsoft-", '')
                    providerPrettyName = providerPrettyName.replace('-', '_')
                    helper.write("    Init" + providerPrettyName + "();\n")
            helper.write("}\n")

            if (runtimeFlavor.coreclr or runtimeFlavor.nativeaot):
                helper.write(getCoreCLRUserEventHelperFileImplSuffix())
            elif runtimeFlavor.mono:
                helper.write(getMonoUserEventHelperFileImplSuffix())

        helper.close()
def getCoreCLRUserEventImplFilePrefix():
    return """#include "common.h" //FIXME<>
#include <stdint.h>
#include <eventheader/TraceLoggingProvider.h>
"""

def getCoreCLRUserEventImplFileSuffix():
    return ""

def getMonoUserEventImplFilePrefix():
    return """#include <userevent/ep-rt-config.h>
#ifdef ENABLE_PERFTRACING
#include <userevent/ep.h>
#include <userevent/ep-event.h>
#include "clrusereventwriteevents.h"
%s
/*
 * Forward declares of functions.
 */

bool
resize_buffer (
    uint8_t **buffer,
    size_t *size,
    size_t current_size,
    size_t new_size,
    bool *fixed_buffer);

bool
write_buffer (
    const uint8_t *value,
    size_t value_size,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer);

bool
write_buffer_string_utf8_t (
    const ep_char8_t *value,
    size_t value_len,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer);

bool
write_buffer_string_utf8_to_utf16_t (
    const ep_char8_t *value,
    size_t value_len,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer);

static
inline
bool
write_buffer_guid_t (
    const uint8_t *value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    return write_buffer (value, EP_GUID_SIZE, buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_uint8_t (
    uint8_t value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    return write_buffer ((const uint8_t *)&value, sizeof (uint8_t), buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_uint16_t (
    uint16_t value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    value = ep_rt_val_uint16_t (value);
    return write_buffer ((const uint8_t *)&value, sizeof (uint16_t), buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_uint32_t (
    uint32_t value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    value = ep_rt_val_uint32_t (value);
    return write_buffer ((const uint8_t *)&value, sizeof (uint32_t), buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_int32_t (
    int32_t value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    value = ep_rt_val_int32_t (value);
    return write_buffer ((const uint8_t *)&value, sizeof (int32_t), buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_uint64_t (
    uint64_t value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    value = ep_rt_val_uint64_t (value);
    return write_buffer ((const uint8_t *)&value, sizeof (uint64_t), buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_int64_t (
    int64_t value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    value = ep_rt_val_int64_t (value);
    return write_buffer ((const uint8_t *)&value, sizeof (int64_t), buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_double_t (
    double value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
#if BIGENDIAN
    uint64_t value_as_uint64_t;
    memcpy (&value_as_uint64_t, &value, sizeof (uint64_t));
    value_as_uint64_t = ep_rt_val_uint64_t (value_as_uint64_t);
    memcpy (&value, &value_as_uint64_t, sizeof (uint64_t));
#endif
    return write_buffer ((const uint8_t *)&value, sizeof (double), buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_bool_t (
    bool value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    return write_buffer_int32_t (value, buffer, offset, size, fixed_buffer);
}

static
inline
bool
write_buffer_uintptr_t (
    uintptr_t value,
    uint8_t **buffer,
    size_t *offset,
    size_t *size,
    bool *fixed_buffer)
{
    value = ep_rt_val_uintptr_t (value);
    return write_buffer ((const uint8_t *)&value, sizeof (uintptr_t), buffer, offset, size, fixed_buffer);
}

static
inline
UserEventEvent *
provider_add_event (
    UserEventProvider *provider,
    uint32_t event_id,
    uint64_t keywords,
    uint32_t event_version,
    UserEventEventLevel level,
    bool need_stack)
{
    return ep_provider_add_event (provider, event_id, keywords, event_version, level, need_stack, NULL, 0);
}

static
inline
UserEventProvider *
create_provider (
    const wchar_t *provider_name,
    UserEventCallback callback_func)
{
    ep_char8_t *provider_name_utf8 = NULL;

#if WCHAR_MAX == 0xFFFF
    provider_name_utf8 = g_utf16_to_utf8 ((const gunichar2 *)provider_name, -1, NULL, NULL, NULL);
#else
    gunichar2 *provider_name_utf16 = g_ucs4_to_utf16 ((const gunichar *)provider_name, -1, NULL, NULL, NULL);
    provider_name_utf8 = g_utf16_to_utf8 (provider_name_utf16, -1, NULL, NULL, NULL);
    g_free (provider_name_utf16);
#endif

    ep_return_null_if_nok (provider_name_utf8 != NULL);

    UserEventProvider *provider = ep_create_provider (provider_name_utf8, callback_func, NULL);

    g_free (provider_name_utf8);
    return provider;
}
""" % (getCoreCLRMonoNativeAotTypeAdaptionDefines())

def getMonoUserEventImplFileSuffix():
    return "#endif\n"

def getAotUserEventImplFilePrefix():
    return """
//#include <common.h>
#include <gcenv.h>

#include <eventtrace_context.h>
#include <gcheaputilities.h>

#include <userevent/ep.h>
#include <userevent/ep-provider.h>
#include <userevent/ep-config.h>
#include <userevent/ep-event.h>
#include <userevent/ep-event-instance.h>
#include <userevent/ep-session.h>
#include <userevent/ep-session-provider.h>
#include <userevent/ep-metadata-generator.h>
#include <userevent/ep-event-payload.h>
#include <userevent/ep-buffer-manager.h>

%s

bool ResizeBuffer(BYTE *&buffer, size_t& size, size_t currLen, size_t newSize, bool &fixedBuffer);
bool WriteToBuffer(const WCHAR* str, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer);
bool WriteToBuffer(const BYTE *src, size_t len, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer);

UserEventProvider * create_provider(const WCHAR*, UserEventCallback, void* pCallbackContext = nullptr);

template <typename T>
bool WriteToBuffer(const T &value, BYTE *&buffer, size_t& offset, size_t& size, bool &fixedBuffer)
{
    if (sizeof(T) + offset > size)
    {
        if (!ResizeBuffer(buffer, size, offset, size + sizeof(T), fixedBuffer))
            return false;
    }

    memcpy(buffer + offset, (char *)&value, sizeof(T));
    offset += sizeof(T);
    return true;
}

""" % (getCoreCLRMonoNativeAotTypeAdaptionDefines())

def getAotUserEventImplFileSuffix():
    return """
bool DotNETRuntimeProvider_IsEnabled(unsigned char level, unsigned long long keyword)
{
    if (!ep_enabled())
        return false;

    USEREVENT_TRACE_CONTEXT& context = MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_DOTNET_Context.UserEventProvider;
    if (!context.IsEnabled)
        return false;

    if (level > context.Level)
        return false;

    return (keyword == (ULONGLONG)0) || (keyword & context.EnabledKeywordsBitmask) != 0;
}
"""

def generateUserEventImplFiles(
        etwmanifest, userevent_directory, extern, target_cpp, runtimeFlavor, inclusionList, exclusionList, dryRun):
    tree = DOM.parse(etwmanifest)

    # Find the src directory starting with the assumption that
    # A) It is named 'src'
    # B) This script lives in it
    src_dirname = os.path.dirname(__file__)
    while os.path.basename(src_dirname) != "src":
        src_dirname = os.path.dirname(src_dirname)

        if os.path.basename(src_dirname) == "":
            raise IOError("Could not find the Core CLR 'src' directory")

    for providerNode in tree.getElementsByTagName('provider'):
        providerName = providerNode.getAttribute('name')
        if not includeProvider(providerName, runtimeFlavor):
            continue

        providerPrettyName = providerName.replace("Windows-", '')
        providerPrettyName = providerPrettyName.replace("Microsoft-", '')

        providerName_File = providerPrettyName.replace('-', '')
        if target_cpp:
            providerName_File = providerName_File + ".cpp"
        else:
            providerName_File = providerName_File + ".c"

        providerName_File = providerName_File.lower()

        usereventfile = os.path.join(userevent_directory, providerName_File)

        providerPrettyName = providerPrettyName.replace('-', '_')

        if dryRun:
            print(usereventfile)
        else:
            with open_for_update(usereventfile) as usereventImpl:
                usereventImpl.write(stdprolog_cpp)
                header = ""
                if runtimeFlavor.coreclr:
                    header = getCoreCLRUserEventImplFilePrefix()
                elif runtimeFlavor.mono:
                    header = getMonoUserEventImplFilePrefix()
                elif runtimeFlavor.nativeaot:
                    header = getAotUserEventImplFilePrefix()

                usereventImpl.write(header + "\n")
                #usereventImpl.write(
                #    "const %s* %sName = W(\"%s\");\n" % (
                 #       getEventPipeDataTypeMapping(runtimeFlavor)["WCHAR"], #FIX
                 #       providerPrettyName,
                 #       providerName
                #    )
                #)

                #usereventImpl.write(
                #    "UserEventProvider *UserEventProvider" + providerPrettyName +
                 #   (" = nullptr;\n" if target_cpp else " = NULL;\n")
                #)
                templateNodes = providerNode.getElementsByTagName('template')
                allTemplates = parseTemplateNodes(templateNodes)
                eventNodes = providerNode.getElementsByTagName('event')
                usereventImpl.write(
                    generateClrUserEventWriteEventsImpl(
                        providerNode,
                        providerPrettyName,
                        providerName,
                        eventNodes,
                        allTemplates,
                        extern,
                        target_cpp,
                        runtimeFlavor,
                        inclusionList,
                        exclusionList) + "\n")

                if runtimeFlavor.coreclr:
                    usereventImpl.write(getCoreCLRUserEventImplFileSuffix())
                elif runtimeFlavor.mono:
                    usereventImpl.write(getMonoUserEventImplFileSuffix())
                elif runtimeFlavor.nativeaot and providerName=="Microsoft-Windows-DotNETRuntime":
                    usereventImpl.write(getAotUserEventImplFileSuffix())

def generateUserEventFiles(
        etwmanifest, intermediate, extern, target_cpp, runtimeFlavor, inclusionList, exclusionList, dryRun):
    userevent_directory = os.path.join(intermediate, userevent_dirname)
    tree = DOM.parse(etwmanifest)

    if not os.path.exists(userevent_directory):
        os.makedirs(userevent_directory)

    # generate helper file
    generateUserEventHelperFile(etwmanifest, userevent_directory, target_cpp, runtimeFlavor, extern, dryRun)

    # generate all keywords
    for keywordNode in tree.getElementsByTagName('keyword'):
        keywordName = keywordNode.getAttribute('name')
        keywordMask = keywordNode.getAttribute('mask')
        keywordMap[keywordName] = int(keywordMask, 0)

    # generate file for each provider
    generateUserEventImplFiles(
        etwmanifest,
        userevent_directory,
        extern,
        target_cpp,
        runtimeFlavor,
        inclusionList,
        exclusionList,
        dryRun
    )

import argparse
import sys

def main(argv):

    # parse the command line
    parser = argparse.ArgumentParser(
        description="Generates the Code required to instrument userevent logging mechanism")

    required = parser.add_argument_group('required arguments')
    required.add_argument('--man', type=str, required=True,
                          help='full path to manifest containing the description of events')
    required.add_argument('--exc',  type=str, required=True,
                                    help='full path to exclusion list')
    required.add_argument('--inc',  type=str,default="",
                                    help='full path to inclusion list')
    required.add_argument('--intermediate', type=str, required=True,
                          help='full path to eventprovider  intermediate directory')
    required.add_argument('--runtimeflavor', type=str,default="CoreCLR",
                          help='runtime flavor')
    required.add_argument('--nonextern', action='store_true',
                          help='if specified, will generate files to be compiled into the CLR rather than extern' )
    required.add_argument('--dry-run', action='store_true',
                                    help='if specified, will output the names of the generated files instead of generating the files' )
    args, unknown = parser.parse_known_args(argv)
    if unknown:
        print('Unknown argument(s): ', ', '.join(unknown))
        return 1

    sClrEtwAllMan = args.man
    exclusion_filename = args.exc
    inclusion_filename = args.inc
    intermediate = args.intermediate
    runtimeFlavor = RuntimeFlavor(args.runtimeflavor)
    extern = not args.nonextern
    dryRun = args.dry_run

    target_cpp = True
    if runtimeFlavor.mono:
        extern = False
        target_cpp = False

    inclusion_list = parseInclusionList(inclusion_filename)
    exclusion_list = parseExclusionList(exclusion_filename)

    generateUserEventFiles(sClrEtwAllMan, intermediate, extern, target_cpp, runtimeFlavor, inclusion_list, exclusion_list, dryRun)

if __name__ == '__main__':
    return_code = main(sys.argv[1:])
    sys.exit(return_code)
