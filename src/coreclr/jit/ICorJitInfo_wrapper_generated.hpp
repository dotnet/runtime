// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// DO NOT EDIT THIS FILE! IT IS AUTOGENERATED
// To regenerate run the gen script in src/coreclr/tools/Common/JitInterface/ThunkGenerator
// and follow the instructions in docs/project/updating-jitinterface.md

#define API_ENTER(name) wrapComp->CLR_API_Enter(API_##name);
#define API_LEAVE(name) wrapComp->CLR_API_Leave(API_##name);

/**********************************************************************************/
// clang-format off
/**********************************************************************************/

bool WrapICorJitInfo::isIntrinsic(
          CORINFO_METHOD_HANDLE ftn)
{
    API_ENTER(isIntrinsic);
    bool temp = wrapHnd->isIntrinsic(ftn);
    API_LEAVE(isIntrinsic);
    return temp;
}

bool WrapICorJitInfo::notifyMethodInfoUsage(
          CORINFO_METHOD_HANDLE ftn)
{
    API_ENTER(notifyMethodInfoUsage);
    bool temp = wrapHnd->notifyMethodInfoUsage(ftn);
    API_LEAVE(notifyMethodInfoUsage);
    return temp;
}

uint32_t WrapICorJitInfo::getMethodAttribs(
          CORINFO_METHOD_HANDLE ftn)
{
    API_ENTER(getMethodAttribs);
    uint32_t temp = wrapHnd->getMethodAttribs(ftn);
    API_LEAVE(getMethodAttribs);
    return temp;
}

void WrapICorJitInfo::setMethodAttribs(
          CORINFO_METHOD_HANDLE ftn,
          CorInfoMethodRuntimeFlags attribs)
{
    API_ENTER(setMethodAttribs);
    wrapHnd->setMethodAttribs(ftn, attribs);
    API_LEAVE(setMethodAttribs);
}

void WrapICorJitInfo::getMethodSig(
          CORINFO_METHOD_HANDLE ftn,
          CORINFO_SIG_INFO* sig,
          CORINFO_CLASS_HANDLE memberParent)
{
    API_ENTER(getMethodSig);
    wrapHnd->getMethodSig(ftn, sig, memberParent);
    API_LEAVE(getMethodSig);
}

bool WrapICorJitInfo::getMethodInfo(
          CORINFO_METHOD_HANDLE ftn,
          CORINFO_METHOD_INFO* info,
          CORINFO_CONTEXT_HANDLE context)
{
    API_ENTER(getMethodInfo);
    bool temp = wrapHnd->getMethodInfo(ftn, info, context);
    API_LEAVE(getMethodInfo);
    return temp;
}

bool WrapICorJitInfo::haveSameMethodDefinition(
          CORINFO_METHOD_HANDLE meth1Hnd,
          CORINFO_METHOD_HANDLE meth2Hnd)
{
    API_ENTER(haveSameMethodDefinition);
    bool temp = wrapHnd->haveSameMethodDefinition(meth1Hnd, meth2Hnd);
    API_LEAVE(haveSameMethodDefinition);
    return temp;
}

CorInfoInline WrapICorJitInfo::canInline(
          CORINFO_METHOD_HANDLE callerHnd,
          CORINFO_METHOD_HANDLE calleeHnd)
{
    API_ENTER(canInline);
    CorInfoInline temp = wrapHnd->canInline(callerHnd, calleeHnd);
    API_LEAVE(canInline);
    return temp;
}

void WrapICorJitInfo::beginInlining(
          CORINFO_METHOD_HANDLE inlinerHnd,
          CORINFO_METHOD_HANDLE inlineeHnd)
{
    API_ENTER(beginInlining);
    wrapHnd->beginInlining(inlinerHnd, inlineeHnd);
    API_LEAVE(beginInlining);
}

void WrapICorJitInfo::reportInliningDecision(
          CORINFO_METHOD_HANDLE inlinerHnd,
          CORINFO_METHOD_HANDLE inlineeHnd,
          CorInfoInline inlineResult,
          const char* reason)
{
    API_ENTER(reportInliningDecision);
    wrapHnd->reportInliningDecision(inlinerHnd, inlineeHnd, inlineResult, reason);
    API_LEAVE(reportInliningDecision);
}

bool WrapICorJitInfo::canTailCall(
          CORINFO_METHOD_HANDLE callerHnd,
          CORINFO_METHOD_HANDLE declaredCalleeHnd,
          CORINFO_METHOD_HANDLE exactCalleeHnd,
          bool fIsTailPrefix)
{
    API_ENTER(canTailCall);
    bool temp = wrapHnd->canTailCall(callerHnd, declaredCalleeHnd, exactCalleeHnd, fIsTailPrefix);
    API_LEAVE(canTailCall);
    return temp;
}

void WrapICorJitInfo::reportTailCallDecision(
          CORINFO_METHOD_HANDLE callerHnd,
          CORINFO_METHOD_HANDLE calleeHnd,
          bool fIsTailPrefix,
          CorInfoTailCall tailCallResult,
          const char* reason)
{
    API_ENTER(reportTailCallDecision);
    wrapHnd->reportTailCallDecision(callerHnd, calleeHnd, fIsTailPrefix, tailCallResult, reason);
    API_LEAVE(reportTailCallDecision);
}

void WrapICorJitInfo::getEHinfo(
          CORINFO_METHOD_HANDLE ftn,
          unsigned EHnumber,
          CORINFO_EH_CLAUSE* clause)
{
    API_ENTER(getEHinfo);
    wrapHnd->getEHinfo(ftn, EHnumber, clause);
    API_LEAVE(getEHinfo);
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getMethodClass(
          CORINFO_METHOD_HANDLE method)
{
    API_ENTER(getMethodClass);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getMethodClass(method);
    API_LEAVE(getMethodClass);
    return temp;
}

void WrapICorJitInfo::getMethodVTableOffset(
          CORINFO_METHOD_HANDLE method,
          unsigned* offsetOfIndirection,
          unsigned* offsetAfterIndirection,
          bool* isRelative)
{
    API_ENTER(getMethodVTableOffset);
    wrapHnd->getMethodVTableOffset(method, offsetOfIndirection, offsetAfterIndirection, isRelative);
    API_LEAVE(getMethodVTableOffset);
}

bool WrapICorJitInfo::resolveVirtualMethod(
          CORINFO_DEVIRTUALIZATION_INFO* info)
{
    API_ENTER(resolveVirtualMethod);
    bool temp = wrapHnd->resolveVirtualMethod(info);
    API_LEAVE(resolveVirtualMethod);
    return temp;
}

CORINFO_METHOD_HANDLE WrapICorJitInfo::getUnboxedEntry(
          CORINFO_METHOD_HANDLE ftn,
          bool* requiresInstMethodTableArg)
{
    API_ENTER(getUnboxedEntry);
    CORINFO_METHOD_HANDLE temp = wrapHnd->getUnboxedEntry(ftn, requiresInstMethodTableArg);
    API_LEAVE(getUnboxedEntry);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getDefaultComparerClass(
          CORINFO_CLASS_HANDLE elemType)
{
    API_ENTER(getDefaultComparerClass);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getDefaultComparerClass(elemType);
    API_LEAVE(getDefaultComparerClass);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getDefaultEqualityComparerClass(
          CORINFO_CLASS_HANDLE elemType)
{
    API_ENTER(getDefaultEqualityComparerClass);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getDefaultEqualityComparerClass(elemType);
    API_LEAVE(getDefaultEqualityComparerClass);
    return temp;
}

void WrapICorJitInfo::expandRawHandleIntrinsic(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_GENERICHANDLE_RESULT* pResult)
{
    API_ENTER(expandRawHandleIntrinsic);
    wrapHnd->expandRawHandleIntrinsic(pResolvedToken, pResult);
    API_LEAVE(expandRawHandleIntrinsic);
}

bool WrapICorJitInfo::isIntrinsicType(
          CORINFO_CLASS_HANDLE classHnd)
{
    API_ENTER(isIntrinsicType);
    bool temp = wrapHnd->isIntrinsicType(classHnd);
    API_LEAVE(isIntrinsicType);
    return temp;
}

CorInfoCallConvExtension WrapICorJitInfo::getUnmanagedCallConv(
          CORINFO_METHOD_HANDLE method,
          CORINFO_SIG_INFO* callSiteSig,
          bool* pSuppressGCTransition)
{
    API_ENTER(getUnmanagedCallConv);
    CorInfoCallConvExtension temp = wrapHnd->getUnmanagedCallConv(method, callSiteSig, pSuppressGCTransition);
    API_LEAVE(getUnmanagedCallConv);
    return temp;
}

bool WrapICorJitInfo::pInvokeMarshalingRequired(
          CORINFO_METHOD_HANDLE method,
          CORINFO_SIG_INFO* callSiteSig)
{
    API_ENTER(pInvokeMarshalingRequired);
    bool temp = wrapHnd->pInvokeMarshalingRequired(method, callSiteSig);
    API_LEAVE(pInvokeMarshalingRequired);
    return temp;
}

bool WrapICorJitInfo::satisfiesMethodConstraints(
          CORINFO_CLASS_HANDLE parent,
          CORINFO_METHOD_HANDLE method)
{
    API_ENTER(satisfiesMethodConstraints);
    bool temp = wrapHnd->satisfiesMethodConstraints(parent, method);
    API_LEAVE(satisfiesMethodConstraints);
    return temp;
}

void WrapICorJitInfo::methodMustBeLoadedBeforeCodeIsRun(
          CORINFO_METHOD_HANDLE method)
{
    API_ENTER(methodMustBeLoadedBeforeCodeIsRun);
    wrapHnd->methodMustBeLoadedBeforeCodeIsRun(method);
    API_LEAVE(methodMustBeLoadedBeforeCodeIsRun);
}

CORINFO_METHOD_HANDLE WrapICorJitInfo::mapMethodDeclToMethodImpl(
          CORINFO_METHOD_HANDLE method)
{
    API_ENTER(mapMethodDeclToMethodImpl);
    CORINFO_METHOD_HANDLE temp = wrapHnd->mapMethodDeclToMethodImpl(method);
    API_LEAVE(mapMethodDeclToMethodImpl);
    return temp;
}

void WrapICorJitInfo::getGSCookie(
          GSCookie* pCookieVal,
          GSCookie** ppCookieVal)
{
    API_ENTER(getGSCookie);
    wrapHnd->getGSCookie(pCookieVal, ppCookieVal);
    API_LEAVE(getGSCookie);
}

void WrapICorJitInfo::setPatchpointInfo(
          PatchpointInfo* patchpointInfo)
{
    API_ENTER(setPatchpointInfo);
    wrapHnd->setPatchpointInfo(patchpointInfo);
    API_LEAVE(setPatchpointInfo);
}

PatchpointInfo* WrapICorJitInfo::getOSRInfo(
          unsigned* ilOffset)
{
    API_ENTER(getOSRInfo);
    PatchpointInfo* temp = wrapHnd->getOSRInfo(ilOffset);
    API_LEAVE(getOSRInfo);
    return temp;
}

void WrapICorJitInfo::resolveToken(
          CORINFO_RESOLVED_TOKEN* pResolvedToken)
{
    API_ENTER(resolveToken);
    wrapHnd->resolveToken(pResolvedToken);
    API_LEAVE(resolveToken);
}

void WrapICorJitInfo::findSig(
          CORINFO_MODULE_HANDLE module,
          unsigned sigTOK,
          CORINFO_CONTEXT_HANDLE context,
          CORINFO_SIG_INFO* sig)
{
    API_ENTER(findSig);
    wrapHnd->findSig(module, sigTOK, context, sig);
    API_LEAVE(findSig);
}

void WrapICorJitInfo::findCallSiteSig(
          CORINFO_MODULE_HANDLE module,
          unsigned methTOK,
          CORINFO_CONTEXT_HANDLE context,
          CORINFO_SIG_INFO* sig)
{
    API_ENTER(findCallSiteSig);
    wrapHnd->findCallSiteSig(module, methTOK, context, sig);
    API_LEAVE(findCallSiteSig);
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getTokenTypeAsHandle(
          CORINFO_RESOLVED_TOKEN* pResolvedToken)
{
    API_ENTER(getTokenTypeAsHandle);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getTokenTypeAsHandle(pResolvedToken);
    API_LEAVE(getTokenTypeAsHandle);
    return temp;
}

int WrapICorJitInfo::getStringLiteral(
          CORINFO_MODULE_HANDLE module,
          unsigned metaTOK,
          char16_t* buffer,
          int bufferSize,
          int startIndex)
{
    API_ENTER(getStringLiteral);
    int temp = wrapHnd->getStringLiteral(module, metaTOK, buffer, bufferSize, startIndex);
    API_LEAVE(getStringLiteral);
    return temp;
}

size_t WrapICorJitInfo::printObjectDescription(
          CORINFO_OBJECT_HANDLE handle,
          char* buffer,
          size_t bufferSize,
          size_t* pRequiredBufferSize)
{
    API_ENTER(printObjectDescription);
    size_t temp = wrapHnd->printObjectDescription(handle, buffer, bufferSize, pRequiredBufferSize);
    API_LEAVE(printObjectDescription);
    return temp;
}

CorInfoType WrapICorJitInfo::asCorInfoType(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(asCorInfoType);
    CorInfoType temp = wrapHnd->asCorInfoType(cls);
    API_LEAVE(asCorInfoType);
    return temp;
}

const char* WrapICorJitInfo::getClassNameFromMetadata(
          CORINFO_CLASS_HANDLE cls,
          const char** namespaceName)
{
    API_ENTER(getClassNameFromMetadata);
    const char* temp = wrapHnd->getClassNameFromMetadata(cls, namespaceName);
    API_LEAVE(getClassNameFromMetadata);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getTypeInstantiationArgument(
          CORINFO_CLASS_HANDLE cls,
          unsigned index)
{
    API_ENTER(getTypeInstantiationArgument);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getTypeInstantiationArgument(cls, index);
    API_LEAVE(getTypeInstantiationArgument);
    return temp;
}

size_t WrapICorJitInfo::printClassName(
          CORINFO_CLASS_HANDLE cls,
          char* buffer,
          size_t bufferSize,
          size_t* pRequiredBufferSize)
{
    API_ENTER(printClassName);
    size_t temp = wrapHnd->printClassName(cls, buffer, bufferSize, pRequiredBufferSize);
    API_LEAVE(printClassName);
    return temp;
}

bool WrapICorJitInfo::isValueClass(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(isValueClass);
    bool temp = wrapHnd->isValueClass(cls);
    API_LEAVE(isValueClass);
    return temp;
}

uint32_t WrapICorJitInfo::getClassAttribs(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getClassAttribs);
    uint32_t temp = wrapHnd->getClassAttribs(cls);
    API_LEAVE(getClassAttribs);
    return temp;
}

CORINFO_MODULE_HANDLE WrapICorJitInfo::getClassModule(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getClassModule);
    CORINFO_MODULE_HANDLE temp = wrapHnd->getClassModule(cls);
    API_LEAVE(getClassModule);
    return temp;
}

CORINFO_ASSEMBLY_HANDLE WrapICorJitInfo::getModuleAssembly(
          CORINFO_MODULE_HANDLE mod)
{
    API_ENTER(getModuleAssembly);
    CORINFO_ASSEMBLY_HANDLE temp = wrapHnd->getModuleAssembly(mod);
    API_LEAVE(getModuleAssembly);
    return temp;
}

const char* WrapICorJitInfo::getAssemblyName(
          CORINFO_ASSEMBLY_HANDLE assem)
{
    API_ENTER(getAssemblyName);
    const char* temp = wrapHnd->getAssemblyName(assem);
    API_LEAVE(getAssemblyName);
    return temp;
}

void* WrapICorJitInfo::LongLifetimeMalloc(
          size_t sz)
{
    API_ENTER(LongLifetimeMalloc);
    void* temp = wrapHnd->LongLifetimeMalloc(sz);
    API_LEAVE(LongLifetimeMalloc);
    return temp;
}

void WrapICorJitInfo::LongLifetimeFree(
          void* obj)
{
    API_ENTER(LongLifetimeFree);
    wrapHnd->LongLifetimeFree(obj);
    API_LEAVE(LongLifetimeFree);
}

bool WrapICorJitInfo::getIsClassInitedFlagAddress(
          CORINFO_CLASS_HANDLE cls,
          CORINFO_CONST_LOOKUP* addr,
          int* offset)
{
    API_ENTER(getIsClassInitedFlagAddress);
    bool temp = wrapHnd->getIsClassInitedFlagAddress(cls, addr, offset);
    API_LEAVE(getIsClassInitedFlagAddress);
    return temp;
}

size_t WrapICorJitInfo::getClassThreadStaticDynamicInfo(
          CORINFO_CLASS_HANDLE clr)
{
    API_ENTER(getClassThreadStaticDynamicInfo);
    size_t temp = wrapHnd->getClassThreadStaticDynamicInfo(clr);
    API_LEAVE(getClassThreadStaticDynamicInfo);
    return temp;
}

size_t WrapICorJitInfo::getClassStaticDynamicInfo(
          CORINFO_CLASS_HANDLE clr)
{
    API_ENTER(getClassStaticDynamicInfo);
    size_t temp = wrapHnd->getClassStaticDynamicInfo(clr);
    API_LEAVE(getClassStaticDynamicInfo);
    return temp;
}

bool WrapICorJitInfo::getStaticBaseAddress(
          CORINFO_CLASS_HANDLE cls,
          bool isGc,
          CORINFO_CONST_LOOKUP* addr)
{
    API_ENTER(getStaticBaseAddress);
    bool temp = wrapHnd->getStaticBaseAddress(cls, isGc, addr);
    API_LEAVE(getStaticBaseAddress);
    return temp;
}

unsigned WrapICorJitInfo::getClassSize(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getClassSize);
    unsigned temp = wrapHnd->getClassSize(cls);
    API_LEAVE(getClassSize);
    return temp;
}

unsigned WrapICorJitInfo::getHeapClassSize(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getHeapClassSize);
    unsigned temp = wrapHnd->getHeapClassSize(cls);
    API_LEAVE(getHeapClassSize);
    return temp;
}

bool WrapICorJitInfo::canAllocateOnStack(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(canAllocateOnStack);
    bool temp = wrapHnd->canAllocateOnStack(cls);
    API_LEAVE(canAllocateOnStack);
    return temp;
}

unsigned WrapICorJitInfo::getClassAlignmentRequirement(
          CORINFO_CLASS_HANDLE cls,
          bool fDoubleAlignHint)
{
    API_ENTER(getClassAlignmentRequirement);
    unsigned temp = wrapHnd->getClassAlignmentRequirement(cls, fDoubleAlignHint);
    API_LEAVE(getClassAlignmentRequirement);
    return temp;
}

unsigned WrapICorJitInfo::getClassGClayout(
          CORINFO_CLASS_HANDLE cls,
          uint8_t* gcPtrs)
{
    API_ENTER(getClassGClayout);
    unsigned temp = wrapHnd->getClassGClayout(cls, gcPtrs);
    API_LEAVE(getClassGClayout);
    return temp;
}

unsigned WrapICorJitInfo::getClassNumInstanceFields(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getClassNumInstanceFields);
    unsigned temp = wrapHnd->getClassNumInstanceFields(cls);
    API_LEAVE(getClassNumInstanceFields);
    return temp;
}

CORINFO_FIELD_HANDLE WrapICorJitInfo::getFieldInClass(
          CORINFO_CLASS_HANDLE clsHnd,
          int32_t num)
{
    API_ENTER(getFieldInClass);
    CORINFO_FIELD_HANDLE temp = wrapHnd->getFieldInClass(clsHnd, num);
    API_LEAVE(getFieldInClass);
    return temp;
}

GetTypeLayoutResult WrapICorJitInfo::getTypeLayout(
          CORINFO_CLASS_HANDLE typeHnd,
          CORINFO_TYPE_LAYOUT_NODE* treeNodes,
          size_t* numTreeNodes)
{
    API_ENTER(getTypeLayout);
    GetTypeLayoutResult temp = wrapHnd->getTypeLayout(typeHnd, treeNodes, numTreeNodes);
    API_LEAVE(getTypeLayout);
    return temp;
}

bool WrapICorJitInfo::checkMethodModifier(
          CORINFO_METHOD_HANDLE hMethod,
          const char* modifier,
          bool fOptional)
{
    API_ENTER(checkMethodModifier);
    bool temp = wrapHnd->checkMethodModifier(hMethod, modifier, fOptional);
    API_LEAVE(checkMethodModifier);
    return temp;
}

CorInfoHelpFunc WrapICorJitInfo::getNewHelper(
          CORINFO_CLASS_HANDLE classHandle,
          bool* pHasSideEffects)
{
    API_ENTER(getNewHelper);
    CorInfoHelpFunc temp = wrapHnd->getNewHelper(classHandle, pHasSideEffects);
    API_LEAVE(getNewHelper);
    return temp;
}

CorInfoHelpFunc WrapICorJitInfo::getNewArrHelper(
          CORINFO_CLASS_HANDLE arrayCls)
{
    API_ENTER(getNewArrHelper);
    CorInfoHelpFunc temp = wrapHnd->getNewArrHelper(arrayCls);
    API_LEAVE(getNewArrHelper);
    return temp;
}

CorInfoHelpFunc WrapICorJitInfo::getCastingHelper(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          bool fThrowing)
{
    API_ENTER(getCastingHelper);
    CorInfoHelpFunc temp = wrapHnd->getCastingHelper(pResolvedToken, fThrowing);
    API_LEAVE(getCastingHelper);
    return temp;
}

CorInfoHelpFunc WrapICorJitInfo::getSharedCCtorHelper(
          CORINFO_CLASS_HANDLE clsHnd)
{
    API_ENTER(getSharedCCtorHelper);
    CorInfoHelpFunc temp = wrapHnd->getSharedCCtorHelper(clsHnd);
    API_LEAVE(getSharedCCtorHelper);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getTypeForBox(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getTypeForBox);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getTypeForBox(cls);
    API_LEAVE(getTypeForBox);
    return temp;
}

CorInfoHelpFunc WrapICorJitInfo::getBoxHelper(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getBoxHelper);
    CorInfoHelpFunc temp = wrapHnd->getBoxHelper(cls);
    API_LEAVE(getBoxHelper);
    return temp;
}

CorInfoHelpFunc WrapICorJitInfo::getUnBoxHelper(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getUnBoxHelper);
    CorInfoHelpFunc temp = wrapHnd->getUnBoxHelper(cls);
    API_LEAVE(getUnBoxHelper);
    return temp;
}

CORINFO_OBJECT_HANDLE WrapICorJitInfo::getRuntimeTypePointer(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getRuntimeTypePointer);
    CORINFO_OBJECT_HANDLE temp = wrapHnd->getRuntimeTypePointer(cls);
    API_LEAVE(getRuntimeTypePointer);
    return temp;
}

bool WrapICorJitInfo::isObjectImmutable(
          CORINFO_OBJECT_HANDLE objPtr)
{
    API_ENTER(isObjectImmutable);
    bool temp = wrapHnd->isObjectImmutable(objPtr);
    API_LEAVE(isObjectImmutable);
    return temp;
}

bool WrapICorJitInfo::getStringChar(
          CORINFO_OBJECT_HANDLE strObj,
          int index,
          uint16_t* value)
{
    API_ENTER(getStringChar);
    bool temp = wrapHnd->getStringChar(strObj, index, value);
    API_LEAVE(getStringChar);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getObjectType(
          CORINFO_OBJECT_HANDLE objPtr)
{
    API_ENTER(getObjectType);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getObjectType(objPtr);
    API_LEAVE(getObjectType);
    return temp;
}

bool WrapICorJitInfo::getReadyToRunHelper(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_LOOKUP_KIND* pGenericLookupKind,
          CorInfoHelpFunc id,
          CORINFO_CONST_LOOKUP* pLookup)
{
    API_ENTER(getReadyToRunHelper);
    bool temp = wrapHnd->getReadyToRunHelper(pResolvedToken, pGenericLookupKind, id, pLookup);
    API_LEAVE(getReadyToRunHelper);
    return temp;
}

void WrapICorJitInfo::getReadyToRunDelegateCtorHelper(
          CORINFO_RESOLVED_TOKEN* pTargetMethod,
          mdToken targetConstraint,
          CORINFO_CLASS_HANDLE delegateType,
          CORINFO_LOOKUP* pLookup)
{
    API_ENTER(getReadyToRunDelegateCtorHelper);
    wrapHnd->getReadyToRunDelegateCtorHelper(pTargetMethod, targetConstraint, delegateType, pLookup);
    API_LEAVE(getReadyToRunDelegateCtorHelper);
}

CorInfoInitClassResult WrapICorJitInfo::initClass(
          CORINFO_FIELD_HANDLE field,
          CORINFO_METHOD_HANDLE method,
          CORINFO_CONTEXT_HANDLE context)
{
    API_ENTER(initClass);
    CorInfoInitClassResult temp = wrapHnd->initClass(field, method, context);
    API_LEAVE(initClass);
    return temp;
}

void WrapICorJitInfo::classMustBeLoadedBeforeCodeIsRun(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(classMustBeLoadedBeforeCodeIsRun);
    wrapHnd->classMustBeLoadedBeforeCodeIsRun(cls);
    API_LEAVE(classMustBeLoadedBeforeCodeIsRun);
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getBuiltinClass(
          CorInfoClassId classId)
{
    API_ENTER(getBuiltinClass);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getBuiltinClass(classId);
    API_LEAVE(getBuiltinClass);
    return temp;
}

CorInfoType WrapICorJitInfo::getTypeForPrimitiveValueClass(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getTypeForPrimitiveValueClass);
    CorInfoType temp = wrapHnd->getTypeForPrimitiveValueClass(cls);
    API_LEAVE(getTypeForPrimitiveValueClass);
    return temp;
}

CorInfoType WrapICorJitInfo::getTypeForPrimitiveNumericClass(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getTypeForPrimitiveNumericClass);
    CorInfoType temp = wrapHnd->getTypeForPrimitiveNumericClass(cls);
    API_LEAVE(getTypeForPrimitiveNumericClass);
    return temp;
}

bool WrapICorJitInfo::canCast(
          CORINFO_CLASS_HANDLE child,
          CORINFO_CLASS_HANDLE parent)
{
    API_ENTER(canCast);
    bool temp = wrapHnd->canCast(child, parent);
    API_LEAVE(canCast);
    return temp;
}

TypeCompareState WrapICorJitInfo::compareTypesForCast(
          CORINFO_CLASS_HANDLE fromClass,
          CORINFO_CLASS_HANDLE toClass)
{
    API_ENTER(compareTypesForCast);
    TypeCompareState temp = wrapHnd->compareTypesForCast(fromClass, toClass);
    API_LEAVE(compareTypesForCast);
    return temp;
}

TypeCompareState WrapICorJitInfo::compareTypesForEquality(
          CORINFO_CLASS_HANDLE cls1,
          CORINFO_CLASS_HANDLE cls2)
{
    API_ENTER(compareTypesForEquality);
    TypeCompareState temp = wrapHnd->compareTypesForEquality(cls1, cls2);
    API_LEAVE(compareTypesForEquality);
    return temp;
}

bool WrapICorJitInfo::isMoreSpecificType(
          CORINFO_CLASS_HANDLE cls1,
          CORINFO_CLASS_HANDLE cls2)
{
    API_ENTER(isMoreSpecificType);
    bool temp = wrapHnd->isMoreSpecificType(cls1, cls2);
    API_LEAVE(isMoreSpecificType);
    return temp;
}

bool WrapICorJitInfo::isExactType(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(isExactType);
    bool temp = wrapHnd->isExactType(cls);
    API_LEAVE(isExactType);
    return temp;
}

TypeCompareState WrapICorJitInfo::isEnum(
          CORINFO_CLASS_HANDLE cls,
          CORINFO_CLASS_HANDLE* underlyingType)
{
    API_ENTER(isEnum);
    TypeCompareState temp = wrapHnd->isEnum(cls, underlyingType);
    API_LEAVE(isEnum);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getParentType(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getParentType);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getParentType(cls);
    API_LEAVE(getParentType);
    return temp;
}

CorInfoType WrapICorJitInfo::getChildType(
          CORINFO_CLASS_HANDLE clsHnd,
          CORINFO_CLASS_HANDLE* clsRet)
{
    API_ENTER(getChildType);
    CorInfoType temp = wrapHnd->getChildType(clsHnd, clsRet);
    API_LEAVE(getChildType);
    return temp;
}

bool WrapICorJitInfo::isSDArray(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(isSDArray);
    bool temp = wrapHnd->isSDArray(cls);
    API_LEAVE(isSDArray);
    return temp;
}

unsigned WrapICorJitInfo::getArrayRank(
          CORINFO_CLASS_HANDLE cls)
{
    API_ENTER(getArrayRank);
    unsigned temp = wrapHnd->getArrayRank(cls);
    API_LEAVE(getArrayRank);
    return temp;
}

CorInfoArrayIntrinsic WrapICorJitInfo::getArrayIntrinsicID(
          CORINFO_METHOD_HANDLE ftn)
{
    API_ENTER(getArrayIntrinsicID);
    CorInfoArrayIntrinsic temp = wrapHnd->getArrayIntrinsicID(ftn);
    API_LEAVE(getArrayIntrinsicID);
    return temp;
}

void* WrapICorJitInfo::getArrayInitializationData(
          CORINFO_FIELD_HANDLE field,
          uint32_t size)
{
    API_ENTER(getArrayInitializationData);
    void* temp = wrapHnd->getArrayInitializationData(field, size);
    API_LEAVE(getArrayInitializationData);
    return temp;
}

CorInfoIsAccessAllowedResult WrapICorJitInfo::canAccessClass(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_METHOD_HANDLE callerHandle,
          CORINFO_HELPER_DESC* pAccessHelper)
{
    API_ENTER(canAccessClass);
    CorInfoIsAccessAllowedResult temp = wrapHnd->canAccessClass(pResolvedToken, callerHandle, pAccessHelper);
    API_LEAVE(canAccessClass);
    return temp;
}

size_t WrapICorJitInfo::printFieldName(
          CORINFO_FIELD_HANDLE field,
          char* buffer,
          size_t bufferSize,
          size_t* pRequiredBufferSize)
{
    API_ENTER(printFieldName);
    size_t temp = wrapHnd->printFieldName(field, buffer, bufferSize, pRequiredBufferSize);
    API_LEAVE(printFieldName);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getFieldClass(
          CORINFO_FIELD_HANDLE field)
{
    API_ENTER(getFieldClass);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getFieldClass(field);
    API_LEAVE(getFieldClass);
    return temp;
}

CorInfoType WrapICorJitInfo::getFieldType(
          CORINFO_FIELD_HANDLE field,
          CORINFO_CLASS_HANDLE* structType,
          CORINFO_CLASS_HANDLE memberParent)
{
    API_ENTER(getFieldType);
    CorInfoType temp = wrapHnd->getFieldType(field, structType, memberParent);
    API_LEAVE(getFieldType);
    return temp;
}

unsigned WrapICorJitInfo::getFieldOffset(
          CORINFO_FIELD_HANDLE field)
{
    API_ENTER(getFieldOffset);
    unsigned temp = wrapHnd->getFieldOffset(field);
    API_LEAVE(getFieldOffset);
    return temp;
}

void WrapICorJitInfo::getFieldInfo(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_METHOD_HANDLE callerHandle,
          CORINFO_ACCESS_FLAGS flags,
          CORINFO_FIELD_INFO* pResult)
{
    API_ENTER(getFieldInfo);
    wrapHnd->getFieldInfo(pResolvedToken, callerHandle, flags, pResult);
    API_LEAVE(getFieldInfo);
}

uint32_t WrapICorJitInfo::getThreadLocalFieldInfo(
          CORINFO_FIELD_HANDLE field,
          bool isGCtype)
{
    API_ENTER(getThreadLocalFieldInfo);
    uint32_t temp = wrapHnd->getThreadLocalFieldInfo(field, isGCtype);
    API_LEAVE(getThreadLocalFieldInfo);
    return temp;
}

void WrapICorJitInfo::getThreadLocalStaticBlocksInfo(
          CORINFO_THREAD_STATIC_BLOCKS_INFO* pInfo)
{
    API_ENTER(getThreadLocalStaticBlocksInfo);
    wrapHnd->getThreadLocalStaticBlocksInfo(pInfo);
    API_LEAVE(getThreadLocalStaticBlocksInfo);
}

void WrapICorJitInfo::getThreadLocalStaticInfo_NativeAOT(
          CORINFO_THREAD_STATIC_INFO_NATIVEAOT* pInfo)
{
    API_ENTER(getThreadLocalStaticInfo_NativeAOT);
    wrapHnd->getThreadLocalStaticInfo_NativeAOT(pInfo);
    API_LEAVE(getThreadLocalStaticInfo_NativeAOT);
}

bool WrapICorJitInfo::isFieldStatic(
          CORINFO_FIELD_HANDLE fldHnd)
{
    API_ENTER(isFieldStatic);
    bool temp = wrapHnd->isFieldStatic(fldHnd);
    API_LEAVE(isFieldStatic);
    return temp;
}

int WrapICorJitInfo::getArrayOrStringLength(
          CORINFO_OBJECT_HANDLE objHnd)
{
    API_ENTER(getArrayOrStringLength);
    int temp = wrapHnd->getArrayOrStringLength(objHnd);
    API_LEAVE(getArrayOrStringLength);
    return temp;
}

void WrapICorJitInfo::getBoundaries(
          CORINFO_METHOD_HANDLE ftn,
          unsigned int* cILOffsets,
          uint32_t** pILOffsets,
          ICorDebugInfo::BoundaryTypes* implicitBoundaries)
{
    API_ENTER(getBoundaries);
    wrapHnd->getBoundaries(ftn, cILOffsets, pILOffsets, implicitBoundaries);
    API_LEAVE(getBoundaries);
}

void WrapICorJitInfo::setBoundaries(
          CORINFO_METHOD_HANDLE ftn,
          uint32_t cMap,
          ICorDebugInfo::OffsetMapping* pMap)
{
    API_ENTER(setBoundaries);
    wrapHnd->setBoundaries(ftn, cMap, pMap);
    API_LEAVE(setBoundaries);
}

void WrapICorJitInfo::getVars(
          CORINFO_METHOD_HANDLE ftn,
          uint32_t* cVars,
          ICorDebugInfo::ILVarInfo** vars,
          bool* extendOthers)
{
    API_ENTER(getVars);
    wrapHnd->getVars(ftn, cVars, vars, extendOthers);
    API_LEAVE(getVars);
}

void WrapICorJitInfo::setVars(
          CORINFO_METHOD_HANDLE ftn,
          uint32_t cVars,
          ICorDebugInfo::NativeVarInfo* vars)
{
    API_ENTER(setVars);
    wrapHnd->setVars(ftn, cVars, vars);
    API_LEAVE(setVars);
}

void WrapICorJitInfo::reportRichMappings(
          ICorDebugInfo::InlineTreeNode* inlineTreeNodes,
          uint32_t numInlineTreeNodes,
          ICorDebugInfo::RichOffsetMapping* mappings,
          uint32_t numMappings)
{
    API_ENTER(reportRichMappings);
    wrapHnd->reportRichMappings(inlineTreeNodes, numInlineTreeNodes, mappings, numMappings);
    API_LEAVE(reportRichMappings);
}

void WrapICorJitInfo::reportMetadata(
          const char* key,
          const void* value,
          size_t length)
{
    API_ENTER(reportMetadata);
    wrapHnd->reportMetadata(key, value, length);
    API_LEAVE(reportMetadata);
}

void* WrapICorJitInfo::allocateArray(
          size_t cBytes)
{
    API_ENTER(allocateArray);
    void* temp = wrapHnd->allocateArray(cBytes);
    API_LEAVE(allocateArray);
    return temp;
}

void WrapICorJitInfo::freeArray(
          void* array)
{
    API_ENTER(freeArray);
    wrapHnd->freeArray(array);
    API_LEAVE(freeArray);
}

CORINFO_ARG_LIST_HANDLE WrapICorJitInfo::getArgNext(
          CORINFO_ARG_LIST_HANDLE args)
{
    API_ENTER(getArgNext);
    CORINFO_ARG_LIST_HANDLE temp = wrapHnd->getArgNext(args);
    API_LEAVE(getArgNext);
    return temp;
}

CorInfoTypeWithMod WrapICorJitInfo::getArgType(
          CORINFO_SIG_INFO* sig,
          CORINFO_ARG_LIST_HANDLE args,
          CORINFO_CLASS_HANDLE* vcTypeRet)
{
    API_ENTER(getArgType);
    CorInfoTypeWithMod temp = wrapHnd->getArgType(sig, args, vcTypeRet);
    API_LEAVE(getArgType);
    return temp;
}

int WrapICorJitInfo::getExactClasses(
          CORINFO_CLASS_HANDLE baseType,
          int maxExactClasses,
          CORINFO_CLASS_HANDLE* exactClsRet)
{
    API_ENTER(getExactClasses);
    int temp = wrapHnd->getExactClasses(baseType, maxExactClasses, exactClsRet);
    API_LEAVE(getExactClasses);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getArgClass(
          CORINFO_SIG_INFO* sig,
          CORINFO_ARG_LIST_HANDLE args)
{
    API_ENTER(getArgClass);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getArgClass(sig, args);
    API_LEAVE(getArgClass);
    return temp;
}

CorInfoHFAElemType WrapICorJitInfo::getHFAType(
          CORINFO_CLASS_HANDLE hClass)
{
    API_ENTER(getHFAType);
    CorInfoHFAElemType temp = wrapHnd->getHFAType(hClass);
    API_LEAVE(getHFAType);
    return temp;
}

bool WrapICorJitInfo::runWithErrorTrap(
          ICorJitInfo::errorTrapFunction function,
          void* parameter)
{
    API_ENTER(runWithErrorTrap);
    bool temp = wrapHnd->runWithErrorTrap(function, parameter);
    API_LEAVE(runWithErrorTrap);
    return temp;
}

bool WrapICorJitInfo::runWithSPMIErrorTrap(
          ICorJitInfo::errorTrapFunction function,
          void* parameter)
{
    API_ENTER(runWithSPMIErrorTrap);
    bool temp = wrapHnd->runWithSPMIErrorTrap(function, parameter);
    API_LEAVE(runWithSPMIErrorTrap);
    return temp;
}

void WrapICorJitInfo::getEEInfo(
          CORINFO_EE_INFO* pEEInfoOut)
{
    API_ENTER(getEEInfo);
    wrapHnd->getEEInfo(pEEInfoOut);
    API_LEAVE(getEEInfo);
}

const char16_t* WrapICorJitInfo::getJitTimeLogFilename()
{
    API_ENTER(getJitTimeLogFilename);
    const char16_t* temp = wrapHnd->getJitTimeLogFilename();
    API_LEAVE(getJitTimeLogFilename);
    return temp;
}

mdMethodDef WrapICorJitInfo::getMethodDefFromMethod(
          CORINFO_METHOD_HANDLE hMethod)
{
    API_ENTER(getMethodDefFromMethod);
    mdMethodDef temp = wrapHnd->getMethodDefFromMethod(hMethod);
    API_LEAVE(getMethodDefFromMethod);
    return temp;
}

size_t WrapICorJitInfo::printMethodName(
          CORINFO_METHOD_HANDLE ftn,
          char* buffer,
          size_t bufferSize,
          size_t* pRequiredBufferSize)
{
    API_ENTER(printMethodName);
    size_t temp = wrapHnd->printMethodName(ftn, buffer, bufferSize, pRequiredBufferSize);
    API_LEAVE(printMethodName);
    return temp;
}

const char* WrapICorJitInfo::getMethodNameFromMetadata(
          CORINFO_METHOD_HANDLE ftn,
          const char** className,
          const char** namespaceName,
          const char** enclosingClassName)
{
    API_ENTER(getMethodNameFromMetadata);
    const char* temp = wrapHnd->getMethodNameFromMetadata(ftn, className, namespaceName, enclosingClassName);
    API_LEAVE(getMethodNameFromMetadata);
    return temp;
}

unsigned WrapICorJitInfo::getMethodHash(
          CORINFO_METHOD_HANDLE ftn)
{
    API_ENTER(getMethodHash);
    unsigned temp = wrapHnd->getMethodHash(ftn);
    API_LEAVE(getMethodHash);
    return temp;
}

bool WrapICorJitInfo::getSystemVAmd64PassStructInRegisterDescriptor(
          CORINFO_CLASS_HANDLE structHnd,
          SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR* structPassInRegDescPtr)
{
    API_ENTER(getSystemVAmd64PassStructInRegisterDescriptor);
    bool temp = wrapHnd->getSystemVAmd64PassStructInRegisterDescriptor(structHnd, structPassInRegDescPtr);
    API_LEAVE(getSystemVAmd64PassStructInRegisterDescriptor);
    return temp;
}

uint32_t WrapICorJitInfo::getLoongArch64PassStructInRegisterFlags(
          CORINFO_CLASS_HANDLE structHnd)
{
    API_ENTER(getLoongArch64PassStructInRegisterFlags);
    uint32_t temp = wrapHnd->getLoongArch64PassStructInRegisterFlags(structHnd);
    API_LEAVE(getLoongArch64PassStructInRegisterFlags);
    return temp;
}

uint32_t WrapICorJitInfo::getRISCV64PassStructInRegisterFlags(
          CORINFO_CLASS_HANDLE structHnd)
{
    API_ENTER(getRISCV64PassStructInRegisterFlags);
    uint32_t temp = wrapHnd->getRISCV64PassStructInRegisterFlags(structHnd);
    API_LEAVE(getRISCV64PassStructInRegisterFlags);
    return temp;
}

uint32_t WrapICorJitInfo::getThreadTLSIndex(
          void** ppIndirection)
{
    API_ENTER(getThreadTLSIndex);
    uint32_t temp = wrapHnd->getThreadTLSIndex(ppIndirection);
    API_LEAVE(getThreadTLSIndex);
    return temp;
}

int32_t* WrapICorJitInfo::getAddrOfCaptureThreadGlobal(
          void** ppIndirection)
{
    API_ENTER(getAddrOfCaptureThreadGlobal);
    int32_t* temp = wrapHnd->getAddrOfCaptureThreadGlobal(ppIndirection);
    API_LEAVE(getAddrOfCaptureThreadGlobal);
    return temp;
}

void* WrapICorJitInfo::getHelperFtn(
          CorInfoHelpFunc ftnNum,
          void** ppIndirection)
{
    API_ENTER(getHelperFtn);
    void* temp = wrapHnd->getHelperFtn(ftnNum, ppIndirection);
    API_LEAVE(getHelperFtn);
    return temp;
}

void WrapICorJitInfo::getFunctionEntryPoint(
          CORINFO_METHOD_HANDLE ftn,
          CORINFO_CONST_LOOKUP* pResult,
          CORINFO_ACCESS_FLAGS accessFlags)
{
    API_ENTER(getFunctionEntryPoint);
    wrapHnd->getFunctionEntryPoint(ftn, pResult, accessFlags);
    API_LEAVE(getFunctionEntryPoint);
}

void WrapICorJitInfo::getFunctionFixedEntryPoint(
          CORINFO_METHOD_HANDLE ftn,
          bool isUnsafeFunctionPointer,
          CORINFO_CONST_LOOKUP* pResult)
{
    API_ENTER(getFunctionFixedEntryPoint);
    wrapHnd->getFunctionFixedEntryPoint(ftn, isUnsafeFunctionPointer, pResult);
    API_LEAVE(getFunctionFixedEntryPoint);
}

void* WrapICorJitInfo::getMethodSync(
          CORINFO_METHOD_HANDLE ftn,
          void** ppIndirection)
{
    API_ENTER(getMethodSync);
    void* temp = wrapHnd->getMethodSync(ftn, ppIndirection);
    API_LEAVE(getMethodSync);
    return temp;
}

CorInfoHelpFunc WrapICorJitInfo::getLazyStringLiteralHelper(
          CORINFO_MODULE_HANDLE handle)
{
    API_ENTER(getLazyStringLiteralHelper);
    CorInfoHelpFunc temp = wrapHnd->getLazyStringLiteralHelper(handle);
    API_LEAVE(getLazyStringLiteralHelper);
    return temp;
}

CORINFO_MODULE_HANDLE WrapICorJitInfo::embedModuleHandle(
          CORINFO_MODULE_HANDLE handle,
          void** ppIndirection)
{
    API_ENTER(embedModuleHandle);
    CORINFO_MODULE_HANDLE temp = wrapHnd->embedModuleHandle(handle, ppIndirection);
    API_LEAVE(embedModuleHandle);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::embedClassHandle(
          CORINFO_CLASS_HANDLE handle,
          void** ppIndirection)
{
    API_ENTER(embedClassHandle);
    CORINFO_CLASS_HANDLE temp = wrapHnd->embedClassHandle(handle, ppIndirection);
    API_LEAVE(embedClassHandle);
    return temp;
}

CORINFO_METHOD_HANDLE WrapICorJitInfo::embedMethodHandle(
          CORINFO_METHOD_HANDLE handle,
          void** ppIndirection)
{
    API_ENTER(embedMethodHandle);
    CORINFO_METHOD_HANDLE temp = wrapHnd->embedMethodHandle(handle, ppIndirection);
    API_LEAVE(embedMethodHandle);
    return temp;
}

CORINFO_FIELD_HANDLE WrapICorJitInfo::embedFieldHandle(
          CORINFO_FIELD_HANDLE handle,
          void** ppIndirection)
{
    API_ENTER(embedFieldHandle);
    CORINFO_FIELD_HANDLE temp = wrapHnd->embedFieldHandle(handle, ppIndirection);
    API_LEAVE(embedFieldHandle);
    return temp;
}

void WrapICorJitInfo::embedGenericHandle(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          bool fEmbedParent,
          CORINFO_GENERICHANDLE_RESULT* pResult)
{
    API_ENTER(embedGenericHandle);
    wrapHnd->embedGenericHandle(pResolvedToken, fEmbedParent, pResult);
    API_LEAVE(embedGenericHandle);
}

void WrapICorJitInfo::getLocationOfThisType(
          CORINFO_METHOD_HANDLE context,
          CORINFO_LOOKUP_KIND* pLookupKind)
{
    API_ENTER(getLocationOfThisType);
    wrapHnd->getLocationOfThisType(context, pLookupKind);
    API_LEAVE(getLocationOfThisType);
}

void WrapICorJitInfo::getAddressOfPInvokeTarget(
          CORINFO_METHOD_HANDLE method,
          CORINFO_CONST_LOOKUP* pLookup)
{
    API_ENTER(getAddressOfPInvokeTarget);
    wrapHnd->getAddressOfPInvokeTarget(method, pLookup);
    API_LEAVE(getAddressOfPInvokeTarget);
}

void* WrapICorJitInfo::GetCookieForPInvokeCalliSig(
          CORINFO_SIG_INFO* szMetaSig,
          void** ppIndirection)
{
    API_ENTER(GetCookieForPInvokeCalliSig);
    void* temp = wrapHnd->GetCookieForPInvokeCalliSig(szMetaSig, ppIndirection);
    API_LEAVE(GetCookieForPInvokeCalliSig);
    return temp;
}

bool WrapICorJitInfo::canGetCookieForPInvokeCalliSig(
          CORINFO_SIG_INFO* szMetaSig)
{
    API_ENTER(canGetCookieForPInvokeCalliSig);
    bool temp = wrapHnd->canGetCookieForPInvokeCalliSig(szMetaSig);
    API_LEAVE(canGetCookieForPInvokeCalliSig);
    return temp;
}

CORINFO_JUST_MY_CODE_HANDLE WrapICorJitInfo::getJustMyCodeHandle(
          CORINFO_METHOD_HANDLE method,
          CORINFO_JUST_MY_CODE_HANDLE** ppIndirection)
{
    API_ENTER(getJustMyCodeHandle);
    CORINFO_JUST_MY_CODE_HANDLE temp = wrapHnd->getJustMyCodeHandle(method, ppIndirection);
    API_LEAVE(getJustMyCodeHandle);
    return temp;
}

void WrapICorJitInfo::GetProfilingHandle(
          bool* pbHookFunction,
          void** pProfilerHandle,
          bool* pbIndirectedHandles)
{
    API_ENTER(GetProfilingHandle);
    wrapHnd->GetProfilingHandle(pbHookFunction, pProfilerHandle, pbIndirectedHandles);
    API_LEAVE(GetProfilingHandle);
}

void WrapICorJitInfo::getCallInfo(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken,
          CORINFO_METHOD_HANDLE callerHandle,
          CORINFO_CALLINFO_FLAGS flags,
          CORINFO_CALL_INFO* pResult)
{
    API_ENTER(getCallInfo);
    wrapHnd->getCallInfo(pResolvedToken, pConstrainedResolvedToken, callerHandle, flags, pResult);
    API_LEAVE(getCallInfo);
}

bool WrapICorJitInfo::getStaticFieldContent(
          CORINFO_FIELD_HANDLE field,
          uint8_t* buffer,
          int bufferSize,
          int valueOffset,
          bool ignoreMovableObjects)
{
    API_ENTER(getStaticFieldContent);
    bool temp = wrapHnd->getStaticFieldContent(field, buffer, bufferSize, valueOffset, ignoreMovableObjects);
    API_LEAVE(getStaticFieldContent);
    return temp;
}

bool WrapICorJitInfo::getObjectContent(
          CORINFO_OBJECT_HANDLE obj,
          uint8_t* buffer,
          int bufferSize,
          int valueOffset)
{
    API_ENTER(getObjectContent);
    bool temp = wrapHnd->getObjectContent(obj, buffer, bufferSize, valueOffset);
    API_LEAVE(getObjectContent);
    return temp;
}

CORINFO_CLASS_HANDLE WrapICorJitInfo::getStaticFieldCurrentClass(
          CORINFO_FIELD_HANDLE field,
          bool* pIsSpeculative)
{
    API_ENTER(getStaticFieldCurrentClass);
    CORINFO_CLASS_HANDLE temp = wrapHnd->getStaticFieldCurrentClass(field, pIsSpeculative);
    API_LEAVE(getStaticFieldCurrentClass);
    return temp;
}

CORINFO_VARARGS_HANDLE WrapICorJitInfo::getVarArgsHandle(
          CORINFO_SIG_INFO* pSig,
          void** ppIndirection)
{
    API_ENTER(getVarArgsHandle);
    CORINFO_VARARGS_HANDLE temp = wrapHnd->getVarArgsHandle(pSig, ppIndirection);
    API_LEAVE(getVarArgsHandle);
    return temp;
}

bool WrapICorJitInfo::canGetVarArgsHandle(
          CORINFO_SIG_INFO* pSig)
{
    API_ENTER(canGetVarArgsHandle);
    bool temp = wrapHnd->canGetVarArgsHandle(pSig);
    API_LEAVE(canGetVarArgsHandle);
    return temp;
}

InfoAccessType WrapICorJitInfo::constructStringLiteral(
          CORINFO_MODULE_HANDLE module,
          mdToken metaTok,
          void** ppValue)
{
    API_ENTER(constructStringLiteral);
    InfoAccessType temp = wrapHnd->constructStringLiteral(module, metaTok, ppValue);
    API_LEAVE(constructStringLiteral);
    return temp;
}

InfoAccessType WrapICorJitInfo::emptyStringLiteral(
          void** ppValue)
{
    API_ENTER(emptyStringLiteral);
    InfoAccessType temp = wrapHnd->emptyStringLiteral(ppValue);
    API_LEAVE(emptyStringLiteral);
    return temp;
}

uint32_t WrapICorJitInfo::getFieldThreadLocalStoreID(
          CORINFO_FIELD_HANDLE field,
          void** ppIndirection)
{
    API_ENTER(getFieldThreadLocalStoreID);
    uint32_t temp = wrapHnd->getFieldThreadLocalStoreID(field, ppIndirection);
    API_LEAVE(getFieldThreadLocalStoreID);
    return temp;
}

CORINFO_METHOD_HANDLE WrapICorJitInfo::GetDelegateCtor(
          CORINFO_METHOD_HANDLE methHnd,
          CORINFO_CLASS_HANDLE clsHnd,
          CORINFO_METHOD_HANDLE targetMethodHnd,
          DelegateCtorArgs* pCtorData)
{
    API_ENTER(GetDelegateCtor);
    CORINFO_METHOD_HANDLE temp = wrapHnd->GetDelegateCtor(methHnd, clsHnd, targetMethodHnd, pCtorData);
    API_LEAVE(GetDelegateCtor);
    return temp;
}

void WrapICorJitInfo::MethodCompileComplete(
          CORINFO_METHOD_HANDLE methHnd)
{
    API_ENTER(MethodCompileComplete);
    wrapHnd->MethodCompileComplete(methHnd);
    API_LEAVE(MethodCompileComplete);
}

bool WrapICorJitInfo::getTailCallHelpers(
          CORINFO_RESOLVED_TOKEN* callToken,
          CORINFO_SIG_INFO* sig,
          CORINFO_GET_TAILCALL_HELPERS_FLAGS flags,
          CORINFO_TAILCALL_HELPERS* pResult)
{
    API_ENTER(getTailCallHelpers);
    bool temp = wrapHnd->getTailCallHelpers(callToken, sig, flags, pResult);
    API_LEAVE(getTailCallHelpers);
    return temp;
}

bool WrapICorJitInfo::convertPInvokeCalliToCall(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          bool mustConvert)
{
    API_ENTER(convertPInvokeCalliToCall);
    bool temp = wrapHnd->convertPInvokeCalliToCall(pResolvedToken, mustConvert);
    API_LEAVE(convertPInvokeCalliToCall);
    return temp;
}

bool WrapICorJitInfo::notifyInstructionSetUsage(
          CORINFO_InstructionSet instructionSet,
          bool supportEnabled)
{
    API_ENTER(notifyInstructionSetUsage);
    bool temp = wrapHnd->notifyInstructionSetUsage(instructionSet, supportEnabled);
    API_LEAVE(notifyInstructionSetUsage);
    return temp;
}

void WrapICorJitInfo::updateEntryPointForTailCall(
          CORINFO_CONST_LOOKUP* entryPoint)
{
    API_ENTER(updateEntryPointForTailCall);
    wrapHnd->updateEntryPointForTailCall(entryPoint);
    API_LEAVE(updateEntryPointForTailCall);
}

void WrapICorJitInfo::allocMem(
          AllocMemArgs* pArgs)
{
    API_ENTER(allocMem);
    wrapHnd->allocMem(pArgs);
    API_LEAVE(allocMem);
}

void WrapICorJitInfo::reserveUnwindInfo(
          bool isFunclet,
          bool isColdCode,
          uint32_t unwindSize)
{
    API_ENTER(reserveUnwindInfo);
    wrapHnd->reserveUnwindInfo(isFunclet, isColdCode, unwindSize);
    API_LEAVE(reserveUnwindInfo);
}

void WrapICorJitInfo::allocUnwindInfo(
          uint8_t* pHotCode,
          uint8_t* pColdCode,
          uint32_t startOffset,
          uint32_t endOffset,
          uint32_t unwindSize,
          uint8_t* pUnwindBlock,
          CorJitFuncKind funcKind)
{
    API_ENTER(allocUnwindInfo);
    wrapHnd->allocUnwindInfo(pHotCode, pColdCode, startOffset, endOffset, unwindSize, pUnwindBlock, funcKind);
    API_LEAVE(allocUnwindInfo);
}

void* WrapICorJitInfo::allocGCInfo(
          size_t size)
{
    API_ENTER(allocGCInfo);
    void* temp = wrapHnd->allocGCInfo(size);
    API_LEAVE(allocGCInfo);
    return temp;
}

void WrapICorJitInfo::setEHcount(
          unsigned cEH)
{
    API_ENTER(setEHcount);
    wrapHnd->setEHcount(cEH);
    API_LEAVE(setEHcount);
}

void WrapICorJitInfo::setEHinfo(
          unsigned EHnumber,
          const CORINFO_EH_CLAUSE* clause)
{
    API_ENTER(setEHinfo);
    wrapHnd->setEHinfo(EHnumber, clause);
    API_LEAVE(setEHinfo);
}

bool WrapICorJitInfo::logMsg(
          unsigned level,
          const char* fmt,
          va_list args)
{
    API_ENTER(logMsg);
    bool temp = wrapHnd->logMsg(level, fmt, args);
    API_LEAVE(logMsg);
    return temp;
}

int WrapICorJitInfo::doAssert(
          const char* szFile,
          int iLine,
          const char* szExpr)
{
    API_ENTER(doAssert);
    int temp = wrapHnd->doAssert(szFile, iLine, szExpr);
    API_LEAVE(doAssert);
    return temp;
}

void WrapICorJitInfo::reportFatalError(
          CorJitResult result)
{
    API_ENTER(reportFatalError);
    wrapHnd->reportFatalError(result);
    API_LEAVE(reportFatalError);
}

JITINTERFACE_HRESULT WrapICorJitInfo::getPgoInstrumentationResults(
          CORINFO_METHOD_HANDLE ftnHnd,
          ICorJitInfo::PgoInstrumentationSchema** pSchema,
          uint32_t* pCountSchemaItems,
          uint8_t** pInstrumentationData,
          ICorJitInfo::PgoSource* pgoSource)
{
    API_ENTER(getPgoInstrumentationResults);
    JITINTERFACE_HRESULT temp = wrapHnd->getPgoInstrumentationResults(ftnHnd, pSchema, pCountSchemaItems, pInstrumentationData, pgoSource);
    API_LEAVE(getPgoInstrumentationResults);
    return temp;
}

JITINTERFACE_HRESULT WrapICorJitInfo::allocPgoInstrumentationBySchema(
          CORINFO_METHOD_HANDLE ftnHnd,
          ICorJitInfo::PgoInstrumentationSchema* pSchema,
          uint32_t countSchemaItems,
          uint8_t** pInstrumentationData)
{
    API_ENTER(allocPgoInstrumentationBySchema);
    JITINTERFACE_HRESULT temp = wrapHnd->allocPgoInstrumentationBySchema(ftnHnd, pSchema, countSchemaItems, pInstrumentationData);
    API_LEAVE(allocPgoInstrumentationBySchema);
    return temp;
}

void WrapICorJitInfo::recordCallSite(
          uint32_t instrOffset,
          CORINFO_SIG_INFO* callSig,
          CORINFO_METHOD_HANDLE methodHandle)
{
    API_ENTER(recordCallSite);
    wrapHnd->recordCallSite(instrOffset, callSig, methodHandle);
    API_LEAVE(recordCallSite);
}

void WrapICorJitInfo::recordRelocation(
          void* location,
          void* locationRW,
          void* target,
          uint16_t fRelocType,
          int32_t addlDelta)
{
    API_ENTER(recordRelocation);
    wrapHnd->recordRelocation(location, locationRW, target, fRelocType, addlDelta);
    API_LEAVE(recordRelocation);
}

uint16_t WrapICorJitInfo::getRelocTypeHint(
          void* target)
{
    API_ENTER(getRelocTypeHint);
    uint16_t temp = wrapHnd->getRelocTypeHint(target);
    API_LEAVE(getRelocTypeHint);
    return temp;
}

uint32_t WrapICorJitInfo::getExpectedTargetArchitecture()
{
    API_ENTER(getExpectedTargetArchitecture);
    uint32_t temp = wrapHnd->getExpectedTargetArchitecture();
    API_LEAVE(getExpectedTargetArchitecture);
    return temp;
}

uint32_t WrapICorJitInfo::getJitFlags(
          CORJIT_FLAGS* flags,
          uint32_t sizeInBytes)
{
    API_ENTER(getJitFlags);
    uint32_t temp = wrapHnd->getJitFlags(flags, sizeInBytes);
    API_LEAVE(getJitFlags);
    return temp;
}

/**********************************************************************************/
// clang-format on
/**********************************************************************************/
