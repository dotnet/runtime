// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// DO NOT EDIT THIS FILE! IT IS AUTOGENERATED
// To regenerate run the gen script in src/coreclr/tools/Common/JitInterface/ThunkGenerator
// and follow the instructions in docs/project/updating-jitinterface.md


#include "corinfoexception.h"
#include "../../../inc/corjit.h"

struct JitInterfaceCallbacks
{
    uint32_t (* getMethodAttribs)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn);
    void (* setMethodAttribs)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, CorInfoMethodRuntimeFlags attribs);
    void (* getMethodSig)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, CORINFO_SIG_INFO* sig, CORINFO_CLASS_HANDLE memberParent);
    bool (* getMethodInfo)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, CORINFO_METHOD_INFO* info);
    CorInfoInline (* canInline)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE callerHnd, CORINFO_METHOD_HANDLE calleeHnd, uint32_t* pRestrictions);
    void (* reportInliningDecision)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE inlinerHnd, CORINFO_METHOD_HANDLE inlineeHnd, CorInfoInline inlineResult, const char* reason);
    bool (* canTailCall)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE callerHnd, CORINFO_METHOD_HANDLE declaredCalleeHnd, CORINFO_METHOD_HANDLE exactCalleeHnd, bool fIsTailPrefix);
    void (* reportTailCallDecision)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE callerHnd, CORINFO_METHOD_HANDLE calleeHnd, bool fIsTailPrefix, CorInfoTailCall tailCallResult, const char* reason);
    void (* getEHinfo)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, unsigned EHnumber, CORINFO_EH_CLAUSE* clause);
    CORINFO_CLASS_HANDLE (* getMethodClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method);
    CORINFO_MODULE_HANDLE (* getMethodModule)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method);
    void (* getMethodVTableOffset)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method, unsigned* offsetOfIndirection, unsigned* offsetAfterIndirection, bool* isRelative);
    bool (* resolveVirtualMethod)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_DEVIRTUALIZATION_INFO* info);
    CORINFO_METHOD_HANDLE (* getUnboxedEntry)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, bool* requiresInstMethodTableArg);
    CORINFO_CLASS_HANDLE (* getDefaultComparerClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE elemType);
    CORINFO_CLASS_HANDLE (* getDefaultEqualityComparerClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE elemType);
    void (* expandRawHandleIntrinsic)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, CORINFO_GENERICHANDLE_RESULT* pResult);
    CorInfoIntrinsics (* getIntrinsicID)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method, bool* pMustExpand);
    bool (* isIntrinsicType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE classHnd);
    CorInfoCallConvExtension (* getUnmanagedCallConv)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method, CORINFO_SIG_INFO* callSiteSig, bool* pSuppressGCTransition);
    bool (* pInvokeMarshalingRequired)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method, CORINFO_SIG_INFO* callSiteSig);
    bool (* satisfiesMethodConstraints)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE parent, CORINFO_METHOD_HANDLE method);
    bool (* isCompatibleDelegate)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE objCls, CORINFO_CLASS_HANDLE methodParentCls, CORINFO_METHOD_HANDLE method, CORINFO_CLASS_HANDLE delegateCls, bool* pfIsOpenDelegate);
    void (* methodMustBeLoadedBeforeCodeIsRun)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method);
    CORINFO_METHOD_HANDLE (* mapMethodDeclToMethodImpl)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method);
    void (* getGSCookie)(void * thisHandle, CorInfoExceptionClass** ppException, GSCookie* pCookieVal, GSCookie** ppCookieVal);
    void (* setPatchpointInfo)(void * thisHandle, CorInfoExceptionClass** ppException, PatchpointInfo* patchpointInfo);
    PatchpointInfo* (* getOSRInfo)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned* ilOffset);
    void (* resolveToken)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken);
    bool (* tryResolveToken)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken);
    void (* findSig)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE module, unsigned sigTOK, CORINFO_CONTEXT_HANDLE context, CORINFO_SIG_INFO* sig);
    void (* findCallSiteSig)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE module, unsigned methTOK, CORINFO_CONTEXT_HANDLE context, CORINFO_SIG_INFO* sig);
    CORINFO_CLASS_HANDLE (* getTokenTypeAsHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken);
    bool (* isValidToken)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE module, unsigned metaTOK);
    bool (* isValidStringRef)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE module, unsigned metaTOK);
    const char16_t* (* getStringLiteral)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE module, unsigned metaTOK, int* length);
    CorInfoType (* asCorInfoType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    const char* (* getClassName)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    const char* (* getClassNameFromMetadata)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls, const char** namespaceName);
    CORINFO_CLASS_HANDLE (* getTypeInstantiationArgument)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls, unsigned index);
    int (* appendClassName)(void * thisHandle, CorInfoExceptionClass** ppException, char16_t** ppBuf, int* pnBufLen, CORINFO_CLASS_HANDLE cls, bool fNamespace, bool fFullInst, bool fAssembly);
    bool (* isValueClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CorInfoInlineTypeCheck (* canInlineTypeCheck)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls, CorInfoInlineTypeCheckSource source);
    uint32_t (* getClassAttribs)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    bool (* isStructRequiringStackAllocRetBuf)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CORINFO_MODULE_HANDLE (* getClassModule)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CORINFO_ASSEMBLY_HANDLE (* getModuleAssembly)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE mod);
    const char* (* getAssemblyName)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_ASSEMBLY_HANDLE assem);
    void* (* LongLifetimeMalloc)(void * thisHandle, CorInfoExceptionClass** ppException, size_t sz);
    void (* LongLifetimeFree)(void * thisHandle, CorInfoExceptionClass** ppException, void* obj);
    size_t (* getClassModuleIdForStatics)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls, CORINFO_MODULE_HANDLE* pModule, void** ppIndirection);
    unsigned (* getClassSize)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    unsigned (* getHeapClassSize)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    bool (* canAllocateOnStack)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    unsigned (* getClassAlignmentRequirement)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls, bool fDoubleAlignHint);
    unsigned (* getClassGClayout)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls, uint8_t* gcPtrs);
    unsigned (* getClassNumInstanceFields)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CORINFO_FIELD_HANDLE (* getFieldInClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE clsHnd, int32_t num);
    bool (* checkMethodModifier)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE hMethod, const char* modifier, bool fOptional);
    CorInfoHelpFunc (* getNewHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, CORINFO_METHOD_HANDLE callerHandle, bool* pHasSideEffects);
    CorInfoHelpFunc (* getNewArrHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE arrayCls);
    CorInfoHelpFunc (* getCastingHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, bool fThrowing);
    CorInfoHelpFunc (* getSharedCCtorHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE clsHnd);
    CORINFO_CLASS_HANDLE (* getTypeForBox)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CorInfoHelpFunc (* getBoxHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CorInfoHelpFunc (* getUnBoxHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    bool (* getReadyToRunHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, CORINFO_LOOKUP_KIND* pGenericLookupKind, CorInfoHelpFunc id, CORINFO_CONST_LOOKUP* pLookup);
    void (* getReadyToRunDelegateCtorHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pTargetMethod, CORINFO_CLASS_HANDLE delegateType, CORINFO_LOOKUP* pLookup);
    const char* (* getHelperName)(void * thisHandle, CorInfoExceptionClass** ppException, CorInfoHelpFunc helpFunc);
    CorInfoInitClassResult (* initClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field, CORINFO_METHOD_HANDLE method, CORINFO_CONTEXT_HANDLE context);
    void (* classMustBeLoadedBeforeCodeIsRun)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CORINFO_CLASS_HANDLE (* getBuiltinClass)(void * thisHandle, CorInfoExceptionClass** ppException, CorInfoClassId classId);
    CorInfoType (* getTypeForPrimitiveValueClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CorInfoType (* getTypeForPrimitiveNumericClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    bool (* canCast)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE child, CORINFO_CLASS_HANDLE parent);
    bool (* areTypesEquivalent)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls1, CORINFO_CLASS_HANDLE cls2);
    TypeCompareState (* compareTypesForCast)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE fromClass, CORINFO_CLASS_HANDLE toClass);
    TypeCompareState (* compareTypesForEquality)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls1, CORINFO_CLASS_HANDLE cls2);
    CORINFO_CLASS_HANDLE (* mergeClasses)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls1, CORINFO_CLASS_HANDLE cls2);
    bool (* isMoreSpecificType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls1, CORINFO_CLASS_HANDLE cls2);
    CORINFO_CLASS_HANDLE (* getParentType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    CorInfoType (* getChildType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE clsHnd, CORINFO_CLASS_HANDLE* clsRet);
    bool (* satisfiesClassConstraints)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    bool (* isSDArray)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    unsigned (* getArrayRank)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    void* (* getArrayInitializationData)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field, uint32_t size);
    CorInfoIsAccessAllowedResult (* canAccessClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, CORINFO_METHOD_HANDLE callerHandle, CORINFO_HELPER_DESC* pAccessHelper);
    const char* (* getFieldName)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE ftn, const char** moduleName);
    CORINFO_CLASS_HANDLE (* getFieldClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field);
    CorInfoType (* getFieldType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field, CORINFO_CLASS_HANDLE* structType, CORINFO_CLASS_HANDLE memberParent);
    unsigned (* getFieldOffset)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field);
    void (* getFieldInfo)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, CORINFO_METHOD_HANDLE callerHandle, CORINFO_ACCESS_FLAGS flags, CORINFO_FIELD_INFO* pResult);
    bool (* isFieldStatic)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE fldHnd);
    void (* getBoundaries)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, unsigned int* cILOffsets, uint32_t** pILOffsets, ICorDebugInfo::BoundaryTypes* implictBoundaries);
    void (* setBoundaries)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, uint32_t cMap, ICorDebugInfo::OffsetMapping* pMap);
    void (* getVars)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, uint32_t* cVars, ICorDebugInfo::ILVarInfo** vars, bool* extendOthers);
    void (* setVars)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, uint32_t cVars, ICorDebugInfo::NativeVarInfo* vars);
    void* (* allocateArray)(void * thisHandle, CorInfoExceptionClass** ppException, size_t cBytes);
    void (* freeArray)(void * thisHandle, CorInfoExceptionClass** ppException, void* array);
    CORINFO_ARG_LIST_HANDLE (* getArgNext)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_ARG_LIST_HANDLE args);
    CorInfoTypeWithMod (* getArgType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_SIG_INFO* sig, CORINFO_ARG_LIST_HANDLE args, CORINFO_CLASS_HANDLE* vcTypeRet);
    CORINFO_CLASS_HANDLE (* getArgClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_SIG_INFO* sig, CORINFO_ARG_LIST_HANDLE args);
    CorInfoHFAElemType (* getHFAType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE hClass);
    JITINTERFACE_HRESULT (* GetErrorHRESULT)(void * thisHandle, CorInfoExceptionClass** ppException, struct _EXCEPTION_POINTERS* pExceptionPointers);
    uint32_t (* GetErrorMessage)(void * thisHandle, CorInfoExceptionClass** ppException, char16_t* buffer, uint32_t bufferLength);
    int (* FilterException)(void * thisHandle, CorInfoExceptionClass** ppException, struct _EXCEPTION_POINTERS* pExceptionPointers);
    void (* HandleException)(void * thisHandle, CorInfoExceptionClass** ppException, struct _EXCEPTION_POINTERS* pExceptionPointers);
    void (* ThrowExceptionForJitResult)(void * thisHandle, CorInfoExceptionClass** ppException, JITINTERFACE_HRESULT result);
    void (* ThrowExceptionForHelper)(void * thisHandle, CorInfoExceptionClass** ppException, const CORINFO_HELPER_DESC* throwHelper);
    bool (* runWithErrorTrap)(void * thisHandle, CorInfoExceptionClass** ppException, ICorJitInfo::errorTrapFunction function, void* parameter);
    void (* getEEInfo)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_EE_INFO* pEEInfoOut);
    const char16_t* (* getJitTimeLogFilename)(void * thisHandle, CorInfoExceptionClass** ppException);
    mdMethodDef (* getMethodDefFromMethod)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE hMethod);
    const char* (* getMethodName)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, const char** moduleName);
    const char* (* getMethodNameFromMetadata)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, const char** className, const char** namespaceName, const char** enclosingClassName);
    unsigned (* getMethodHash)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn);
    size_t (* findNameOfToken)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE moduleHandle, unsigned int token, char* szFQName, size_t FQNameCapacity);
    bool (* getSystemVAmd64PassStructInRegisterDescriptor)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE structHnd, SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR* structPassInRegDescPtr);
    uint32_t (* getThreadTLSIndex)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppIndirection);
    const void* (* getInlinedCallFrameVptr)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppIndirection);
    int32_t* (* getAddrOfCaptureThreadGlobal)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppIndirection);
    void* (* getHelperFtn)(void * thisHandle, CorInfoExceptionClass** ppException, CorInfoHelpFunc ftnNum, void** ppIndirection);
    void (* getFunctionEntryPoint)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, CORINFO_CONST_LOOKUP* pResult, CORINFO_ACCESS_FLAGS accessFlags);
    void (* getFunctionFixedEntryPoint)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, CORINFO_CONST_LOOKUP* pResult);
    void* (* getMethodSync)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftn, void** ppIndirection);
    CorInfoHelpFunc (* getLazyStringLiteralHelper)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE handle);
    CORINFO_MODULE_HANDLE (* embedModuleHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE handle, void** ppIndirection);
    CORINFO_CLASS_HANDLE (* embedClassHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE handle, void** ppIndirection);
    CORINFO_METHOD_HANDLE (* embedMethodHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE handle, void** ppIndirection);
    CORINFO_FIELD_HANDLE (* embedFieldHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE handle, void** ppIndirection);
    void (* embedGenericHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, bool fEmbedParent, CORINFO_GENERICHANDLE_RESULT* pResult);
    void (* getLocationOfThisType)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE context, CORINFO_LOOKUP_KIND* pLookupKind);
    void (* getAddressOfPInvokeTarget)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method, CORINFO_CONST_LOOKUP* pLookup);
    void* (* GetCookieForPInvokeCalliSig)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_SIG_INFO* szMetaSig, void** ppIndirection);
    bool (* canGetCookieForPInvokeCalliSig)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_SIG_INFO* szMetaSig);
    CORINFO_JUST_MY_CODE_HANDLE (* getJustMyCodeHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE method, CORINFO_JUST_MY_CODE_HANDLE** ppIndirection);
    void (* GetProfilingHandle)(void * thisHandle, CorInfoExceptionClass** ppException, bool* pbHookFunction, void** pProfilerHandle, bool* pbIndirectedHandles);
    void (* getCallInfo)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_HANDLE callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO* pResult);
    bool (* canAccessFamily)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE hCaller, CORINFO_CLASS_HANDLE hInstanceType);
    bool (* isRIDClassDomainID)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls);
    unsigned (* getClassDomainID)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_CLASS_HANDLE cls, void** ppIndirection);
    void* (* getFieldAddress)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field, void** ppIndirection);
    CORINFO_CLASS_HANDLE (* getStaticFieldCurrentClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field, bool* pIsSpeculative);
    CORINFO_VARARGS_HANDLE (* getVarArgsHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_SIG_INFO* pSig, void** ppIndirection);
    bool (* canGetVarArgsHandle)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_SIG_INFO* pSig);
    InfoAccessType (* constructStringLiteral)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE module, unsigned int metaTok, void** ppValue);
    InfoAccessType (* emptyStringLiteral)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppValue);
    uint32_t (* getFieldThreadLocalStoreID)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_FIELD_HANDLE field, void** ppIndirection);
    void (* setOverride)(void * thisHandle, CorInfoExceptionClass** ppException, ICorDynamicInfo* pOverride, CORINFO_METHOD_HANDLE currentMethod);
    void (* addActiveDependency)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_MODULE_HANDLE moduleFrom, CORINFO_MODULE_HANDLE moduleTo);
    CORINFO_METHOD_HANDLE (* GetDelegateCtor)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE methHnd, CORINFO_CLASS_HANDLE clsHnd, CORINFO_METHOD_HANDLE targetMethodHnd, DelegateCtorArgs* pCtorData);
    void (* MethodCompileComplete)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE methHnd);
    bool (* getTailCallHelpers)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* callToken, CORINFO_SIG_INFO* sig, CORINFO_GET_TAILCALL_HELPERS_FLAGS flags, CORINFO_TAILCALL_HELPERS* pResult);
    bool (* convertPInvokeCalliToCall)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, bool mustConvert);
    bool (* notifyInstructionSetUsage)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_InstructionSet instructionSet, bool supportEnabled);
    void (* allocMem)(void * thisHandle, CorInfoExceptionClass** ppException, uint32_t hotCodeSize, uint32_t coldCodeSize, uint32_t roDataSize, uint32_t xcptnsCount, CorJitAllocMemFlag flag, void** hotCodeBlock, void** coldCodeBlock, void** roDataBlock);
    void (* reserveUnwindInfo)(void * thisHandle, CorInfoExceptionClass** ppException, bool isFunclet, bool isColdCode, uint32_t unwindSize);
    void (* allocUnwindInfo)(void * thisHandle, CorInfoExceptionClass** ppException, uint8_t* pHotCode, uint8_t* pColdCode, uint32_t startOffset, uint32_t endOffset, uint32_t unwindSize, uint8_t* pUnwindBlock, CorJitFuncKind funcKind);
    void* (* allocGCInfo)(void * thisHandle, CorInfoExceptionClass** ppException, size_t size);
    void (* setEHcount)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned cEH);
    void (* setEHinfo)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned EHnumber, const CORINFO_EH_CLAUSE* clause);
    bool (* logMsg)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned level, const char* fmt, va_list args);
    int (* doAssert)(void * thisHandle, CorInfoExceptionClass** ppException, const char* szFile, int iLine, const char* szExpr);
    void (* reportFatalError)(void * thisHandle, CorInfoExceptionClass** ppException, CorJitResult result);
    JITINTERFACE_HRESULT (* getPgoInstrumentationResults)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftnHnd, ICorJitInfo::PgoInstrumentationSchema** pSchema, uint32_t* pCountSchemaItems, uint8_t** pInstrumentationData);
    JITINTERFACE_HRESULT (* allocPgoInstrumentationBySchema)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftnHnd, ICorJitInfo::PgoInstrumentationSchema* pSchema, uint32_t countSchemaItems, uint8_t** pInstrumentationData);
    CORINFO_CLASS_HANDLE (* getLikelyClass)(void * thisHandle, CorInfoExceptionClass** ppException, CORINFO_METHOD_HANDLE ftnHnd, CORINFO_CLASS_HANDLE baseHnd, uint32_t ilOffset, uint32_t* pLikelihood, uint32_t* pNumberOfClasses);
    void (* recordCallSite)(void * thisHandle, CorInfoExceptionClass** ppException, uint32_t instrOffset, CORINFO_SIG_INFO* callSig, CORINFO_METHOD_HANDLE methodHandle);
    void (* recordRelocation)(void * thisHandle, CorInfoExceptionClass** ppException, void* location, void* target, uint16_t fRelocType, uint16_t slotNum, int32_t addlDelta);
    uint16_t (* getRelocTypeHint)(void * thisHandle, CorInfoExceptionClass** ppException, void* target);
    uint32_t (* getExpectedTargetArchitecture)(void * thisHandle, CorInfoExceptionClass** ppException);
    uint32_t (* getJitFlags)(void * thisHandle, CorInfoExceptionClass** ppException, CORJIT_FLAGS* flags, uint32_t sizeInBytes);

};

class JitInterfaceWrapper : public ICorJitInfo
{
    void * _thisHandle;
    JitInterfaceCallbacks * _callbacks;

public:
    JitInterfaceWrapper(void * thisHandle, void ** callbacks)
        : _thisHandle(thisHandle), _callbacks((JitInterfaceCallbacks *)callbacks)
    {
    }


    virtual uint32_t getMethodAttribs(
          CORINFO_METHOD_HANDLE ftn)
{
    CorInfoExceptionClass* pException = nullptr;
    uint32_t temp = _callbacks->getMethodAttribs(_thisHandle, &pException, ftn);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void setMethodAttribs(
          CORINFO_METHOD_HANDLE ftn,
          CorInfoMethodRuntimeFlags attribs)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setMethodAttribs(_thisHandle, &pException, ftn, attribs);
    if (pException != nullptr) throw pException;
}

    virtual void getMethodSig(
          CORINFO_METHOD_HANDLE ftn,
          CORINFO_SIG_INFO* sig,
          CORINFO_CLASS_HANDLE memberParent)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getMethodSig(_thisHandle, &pException, ftn, sig, memberParent);
    if (pException != nullptr) throw pException;
}

    virtual bool getMethodInfo(
          CORINFO_METHOD_HANDLE ftn,
          CORINFO_METHOD_INFO* info)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getMethodInfo(_thisHandle, &pException, ftn, info);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoInline canInline(
          CORINFO_METHOD_HANDLE callerHnd,
          CORINFO_METHOD_HANDLE calleeHnd,
          uint32_t* pRestrictions)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoInline temp = _callbacks->canInline(_thisHandle, &pException, callerHnd, calleeHnd, pRestrictions);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void reportInliningDecision(
          CORINFO_METHOD_HANDLE inlinerHnd,
          CORINFO_METHOD_HANDLE inlineeHnd,
          CorInfoInline inlineResult,
          const char* reason)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reportInliningDecision(_thisHandle, &pException, inlinerHnd, inlineeHnd, inlineResult, reason);
    if (pException != nullptr) throw pException;
}

    virtual bool canTailCall(
          CORINFO_METHOD_HANDLE callerHnd,
          CORINFO_METHOD_HANDLE declaredCalleeHnd,
          CORINFO_METHOD_HANDLE exactCalleeHnd,
          bool fIsTailPrefix)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canTailCall(_thisHandle, &pException, callerHnd, declaredCalleeHnd, exactCalleeHnd, fIsTailPrefix);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void reportTailCallDecision(
          CORINFO_METHOD_HANDLE callerHnd,
          CORINFO_METHOD_HANDLE calleeHnd,
          bool fIsTailPrefix,
          CorInfoTailCall tailCallResult,
          const char* reason)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reportTailCallDecision(_thisHandle, &pException, callerHnd, calleeHnd, fIsTailPrefix, tailCallResult, reason);
    if (pException != nullptr) throw pException;
}

    virtual void getEHinfo(
          CORINFO_METHOD_HANDLE ftn,
          unsigned EHnumber,
          CORINFO_EH_CLAUSE* clause)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getEHinfo(_thisHandle, &pException, ftn, EHnumber, clause);
    if (pException != nullptr) throw pException;
}

    virtual CORINFO_CLASS_HANDLE getMethodClass(
          CORINFO_METHOD_HANDLE method)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getMethodClass(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_MODULE_HANDLE getMethodModule(
          CORINFO_METHOD_HANDLE method)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_MODULE_HANDLE temp = _callbacks->getMethodModule(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getMethodVTableOffset(
          CORINFO_METHOD_HANDLE method,
          unsigned* offsetOfIndirection,
          unsigned* offsetAfterIndirection,
          bool* isRelative)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getMethodVTableOffset(_thisHandle, &pException, method, offsetOfIndirection, offsetAfterIndirection, isRelative);
    if (pException != nullptr) throw pException;
}

    virtual bool resolveVirtualMethod(
          CORINFO_DEVIRTUALIZATION_INFO* info)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->resolveVirtualMethod(_thisHandle, &pException, info);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_METHOD_HANDLE getUnboxedEntry(
          CORINFO_METHOD_HANDLE ftn,
          bool* requiresInstMethodTableArg)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_METHOD_HANDLE temp = _callbacks->getUnboxedEntry(_thisHandle, &pException, ftn, requiresInstMethodTableArg);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getDefaultComparerClass(
          CORINFO_CLASS_HANDLE elemType)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getDefaultComparerClass(_thisHandle, &pException, elemType);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getDefaultEqualityComparerClass(
          CORINFO_CLASS_HANDLE elemType)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getDefaultEqualityComparerClass(_thisHandle, &pException, elemType);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void expandRawHandleIntrinsic(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_GENERICHANDLE_RESULT* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->expandRawHandleIntrinsic(_thisHandle, &pException, pResolvedToken, pResult);
    if (pException != nullptr) throw pException;
}

    virtual CorInfoIntrinsics getIntrinsicID(
          CORINFO_METHOD_HANDLE method,
          bool* pMustExpand)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoIntrinsics temp = _callbacks->getIntrinsicID(_thisHandle, &pException, method, pMustExpand);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isIntrinsicType(
          CORINFO_CLASS_HANDLE classHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isIntrinsicType(_thisHandle, &pException, classHnd);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoCallConvExtension getUnmanagedCallConv(
          CORINFO_METHOD_HANDLE method,
          CORINFO_SIG_INFO* callSiteSig,
          bool* pSuppressGCTransition)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoCallConvExtension temp = _callbacks->getUnmanagedCallConv(_thisHandle, &pException, method, callSiteSig, pSuppressGCTransition);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool pInvokeMarshalingRequired(
          CORINFO_METHOD_HANDLE method,
          CORINFO_SIG_INFO* callSiteSig)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->pInvokeMarshalingRequired(_thisHandle, &pException, method, callSiteSig);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool satisfiesMethodConstraints(
          CORINFO_CLASS_HANDLE parent,
          CORINFO_METHOD_HANDLE method)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->satisfiesMethodConstraints(_thisHandle, &pException, parent, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isCompatibleDelegate(
          CORINFO_CLASS_HANDLE objCls,
          CORINFO_CLASS_HANDLE methodParentCls,
          CORINFO_METHOD_HANDLE method,
          CORINFO_CLASS_HANDLE delegateCls,
          bool* pfIsOpenDelegate)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isCompatibleDelegate(_thisHandle, &pException, objCls, methodParentCls, method, delegateCls, pfIsOpenDelegate);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void methodMustBeLoadedBeforeCodeIsRun(
          CORINFO_METHOD_HANDLE method)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->methodMustBeLoadedBeforeCodeIsRun(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
}

    virtual CORINFO_METHOD_HANDLE mapMethodDeclToMethodImpl(
          CORINFO_METHOD_HANDLE method)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_METHOD_HANDLE temp = _callbacks->mapMethodDeclToMethodImpl(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getGSCookie(
          GSCookie* pCookieVal,
          GSCookie** ppCookieVal)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getGSCookie(_thisHandle, &pException, pCookieVal, ppCookieVal);
    if (pException != nullptr) throw pException;
}

    virtual void setPatchpointInfo(
          PatchpointInfo* patchpointInfo)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setPatchpointInfo(_thisHandle, &pException, patchpointInfo);
    if (pException != nullptr) throw pException;
}

    virtual PatchpointInfo* getOSRInfo(
          unsigned* ilOffset)
{
    CorInfoExceptionClass* pException = nullptr;
    PatchpointInfo* temp = _callbacks->getOSRInfo(_thisHandle, &pException, ilOffset);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void resolveToken(
          CORINFO_RESOLVED_TOKEN* pResolvedToken)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->resolveToken(_thisHandle, &pException, pResolvedToken);
    if (pException != nullptr) throw pException;
}

    virtual bool tryResolveToken(
          CORINFO_RESOLVED_TOKEN* pResolvedToken)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->tryResolveToken(_thisHandle, &pException, pResolvedToken);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void findSig(
          CORINFO_MODULE_HANDLE module,
          unsigned sigTOK,
          CORINFO_CONTEXT_HANDLE context,
          CORINFO_SIG_INFO* sig)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->findSig(_thisHandle, &pException, module, sigTOK, context, sig);
    if (pException != nullptr) throw pException;
}

    virtual void findCallSiteSig(
          CORINFO_MODULE_HANDLE module,
          unsigned methTOK,
          CORINFO_CONTEXT_HANDLE context,
          CORINFO_SIG_INFO* sig)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->findCallSiteSig(_thisHandle, &pException, module, methTOK, context, sig);
    if (pException != nullptr) throw pException;
}

    virtual CORINFO_CLASS_HANDLE getTokenTypeAsHandle(
          CORINFO_RESOLVED_TOKEN* pResolvedToken)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getTokenTypeAsHandle(_thisHandle, &pException, pResolvedToken);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isValidToken(
          CORINFO_MODULE_HANDLE module,
          unsigned metaTOK)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isValidToken(_thisHandle, &pException, module, metaTOK);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isValidStringRef(
          CORINFO_MODULE_HANDLE module,
          unsigned metaTOK)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isValidStringRef(_thisHandle, &pException, module, metaTOK);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char16_t* getStringLiteral(
          CORINFO_MODULE_HANDLE module,
          unsigned metaTOK,
          int* length)
{
    CorInfoExceptionClass* pException = nullptr;
    const char16_t* temp = _callbacks->getStringLiteral(_thisHandle, &pException, module, metaTOK, length);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoType asCorInfoType(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoType temp = _callbacks->asCorInfoType(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getClassName(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getClassName(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getClassNameFromMetadata(
          CORINFO_CLASS_HANDLE cls,
          const char** namespaceName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getClassNameFromMetadata(_thisHandle, &pException, cls, namespaceName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getTypeInstantiationArgument(
          CORINFO_CLASS_HANDLE cls,
          unsigned index)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getTypeInstantiationArgument(_thisHandle, &pException, cls, index);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int appendClassName(
          char16_t** ppBuf,
          int* pnBufLen,
          CORINFO_CLASS_HANDLE cls,
          bool fNamespace,
          bool fFullInst,
          bool fAssembly)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->appendClassName(_thisHandle, &pException, ppBuf, pnBufLen, cls, fNamespace, fFullInst, fAssembly);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isValueClass(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isValueClass(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoInlineTypeCheck canInlineTypeCheck(
          CORINFO_CLASS_HANDLE cls,
          CorInfoInlineTypeCheckSource source)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoInlineTypeCheck temp = _callbacks->canInlineTypeCheck(_thisHandle, &pException, cls, source);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual uint32_t getClassAttribs(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    uint32_t temp = _callbacks->getClassAttribs(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isStructRequiringStackAllocRetBuf(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isStructRequiringStackAllocRetBuf(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_MODULE_HANDLE getClassModule(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_MODULE_HANDLE temp = _callbacks->getClassModule(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_ASSEMBLY_HANDLE getModuleAssembly(
          CORINFO_MODULE_HANDLE mod)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_ASSEMBLY_HANDLE temp = _callbacks->getModuleAssembly(_thisHandle, &pException, mod);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getAssemblyName(
          CORINFO_ASSEMBLY_HANDLE assem)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getAssemblyName(_thisHandle, &pException, assem);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* LongLifetimeMalloc(
          size_t sz)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->LongLifetimeMalloc(_thisHandle, &pException, sz);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void LongLifetimeFree(
          void* obj)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->LongLifetimeFree(_thisHandle, &pException, obj);
    if (pException != nullptr) throw pException;
}

    virtual size_t getClassModuleIdForStatics(
          CORINFO_CLASS_HANDLE cls,
          CORINFO_MODULE_HANDLE* pModule,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    size_t temp = _callbacks->getClassModuleIdForStatics(_thisHandle, &pException, cls, pModule, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassSize(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassSize(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getHeapClassSize(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getHeapClassSize(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canAllocateOnStack(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canAllocateOnStack(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassAlignmentRequirement(
          CORINFO_CLASS_HANDLE cls,
          bool fDoubleAlignHint)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassAlignmentRequirement(_thisHandle, &pException, cls, fDoubleAlignHint);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassGClayout(
          CORINFO_CLASS_HANDLE cls,
          uint8_t* gcPtrs)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassGClayout(_thisHandle, &pException, cls, gcPtrs);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassNumInstanceFields(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassNumInstanceFields(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_FIELD_HANDLE getFieldInClass(
          CORINFO_CLASS_HANDLE clsHnd,
          int32_t num)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_FIELD_HANDLE temp = _callbacks->getFieldInClass(_thisHandle, &pException, clsHnd, num);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool checkMethodModifier(
          CORINFO_METHOD_HANDLE hMethod,
          const char* modifier,
          bool fOptional)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->checkMethodModifier(_thisHandle, &pException, hMethod, modifier, fOptional);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHelpFunc getNewHelper(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_METHOD_HANDLE callerHandle,
          bool* pHasSideEffects)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHelpFunc temp = _callbacks->getNewHelper(_thisHandle, &pException, pResolvedToken, callerHandle, pHasSideEffects);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHelpFunc getNewArrHelper(
          CORINFO_CLASS_HANDLE arrayCls)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHelpFunc temp = _callbacks->getNewArrHelper(_thisHandle, &pException, arrayCls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHelpFunc getCastingHelper(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          bool fThrowing)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHelpFunc temp = _callbacks->getCastingHelper(_thisHandle, &pException, pResolvedToken, fThrowing);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHelpFunc getSharedCCtorHelper(
          CORINFO_CLASS_HANDLE clsHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHelpFunc temp = _callbacks->getSharedCCtorHelper(_thisHandle, &pException, clsHnd);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getTypeForBox(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getTypeForBox(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHelpFunc getBoxHelper(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHelpFunc temp = _callbacks->getBoxHelper(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHelpFunc getUnBoxHelper(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHelpFunc temp = _callbacks->getUnBoxHelper(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool getReadyToRunHelper(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_LOOKUP_KIND* pGenericLookupKind,
          CorInfoHelpFunc id,
          CORINFO_CONST_LOOKUP* pLookup)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getReadyToRunHelper(_thisHandle, &pException, pResolvedToken, pGenericLookupKind, id, pLookup);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getReadyToRunDelegateCtorHelper(
          CORINFO_RESOLVED_TOKEN* pTargetMethod,
          CORINFO_CLASS_HANDLE delegateType,
          CORINFO_LOOKUP* pLookup)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getReadyToRunDelegateCtorHelper(_thisHandle, &pException, pTargetMethod, delegateType, pLookup);
    if (pException != nullptr) throw pException;
}

    virtual const char* getHelperName(
          CorInfoHelpFunc helpFunc)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getHelperName(_thisHandle, &pException, helpFunc);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoInitClassResult initClass(
          CORINFO_FIELD_HANDLE field,
          CORINFO_METHOD_HANDLE method,
          CORINFO_CONTEXT_HANDLE context)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoInitClassResult temp = _callbacks->initClass(_thisHandle, &pException, field, method, context);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void classMustBeLoadedBeforeCodeIsRun(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->classMustBeLoadedBeforeCodeIsRun(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
}

    virtual CORINFO_CLASS_HANDLE getBuiltinClass(
          CorInfoClassId classId)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getBuiltinClass(_thisHandle, &pException, classId);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoType getTypeForPrimitiveValueClass(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoType temp = _callbacks->getTypeForPrimitiveValueClass(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoType getTypeForPrimitiveNumericClass(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoType temp = _callbacks->getTypeForPrimitiveNumericClass(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canCast(
          CORINFO_CLASS_HANDLE child,
          CORINFO_CLASS_HANDLE parent)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canCast(_thisHandle, &pException, child, parent);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool areTypesEquivalent(
          CORINFO_CLASS_HANDLE cls1,
          CORINFO_CLASS_HANDLE cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->areTypesEquivalent(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual TypeCompareState compareTypesForCast(
          CORINFO_CLASS_HANDLE fromClass,
          CORINFO_CLASS_HANDLE toClass)
{
    CorInfoExceptionClass* pException = nullptr;
    TypeCompareState temp = _callbacks->compareTypesForCast(_thisHandle, &pException, fromClass, toClass);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual TypeCompareState compareTypesForEquality(
          CORINFO_CLASS_HANDLE cls1,
          CORINFO_CLASS_HANDLE cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    TypeCompareState temp = _callbacks->compareTypesForEquality(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE mergeClasses(
          CORINFO_CLASS_HANDLE cls1,
          CORINFO_CLASS_HANDLE cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->mergeClasses(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isMoreSpecificType(
          CORINFO_CLASS_HANDLE cls1,
          CORINFO_CLASS_HANDLE cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isMoreSpecificType(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getParentType(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getParentType(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoType getChildType(
          CORINFO_CLASS_HANDLE clsHnd,
          CORINFO_CLASS_HANDLE* clsRet)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoType temp = _callbacks->getChildType(_thisHandle, &pException, clsHnd, clsRet);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool satisfiesClassConstraints(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->satisfiesClassConstraints(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isSDArray(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isSDArray(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getArrayRank(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getArrayRank(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getArrayInitializationData(
          CORINFO_FIELD_HANDLE field,
          uint32_t size)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getArrayInitializationData(_thisHandle, &pException, field, size);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoIsAccessAllowedResult canAccessClass(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_METHOD_HANDLE callerHandle,
          CORINFO_HELPER_DESC* pAccessHelper)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoIsAccessAllowedResult temp = _callbacks->canAccessClass(_thisHandle, &pException, pResolvedToken, callerHandle, pAccessHelper);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getFieldName(
          CORINFO_FIELD_HANDLE ftn,
          const char** moduleName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getFieldName(_thisHandle, &pException, ftn, moduleName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getFieldClass(
          CORINFO_FIELD_HANDLE field)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getFieldClass(_thisHandle, &pException, field);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoType getFieldType(
          CORINFO_FIELD_HANDLE field,
          CORINFO_CLASS_HANDLE* structType,
          CORINFO_CLASS_HANDLE memberParent)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoType temp = _callbacks->getFieldType(_thisHandle, &pException, field, structType, memberParent);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getFieldOffset(
          CORINFO_FIELD_HANDLE field)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getFieldOffset(_thisHandle, &pException, field);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getFieldInfo(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_METHOD_HANDLE callerHandle,
          CORINFO_ACCESS_FLAGS flags,
          CORINFO_FIELD_INFO* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getFieldInfo(_thisHandle, &pException, pResolvedToken, callerHandle, flags, pResult);
    if (pException != nullptr) throw pException;
}

    virtual bool isFieldStatic(
          CORINFO_FIELD_HANDLE fldHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isFieldStatic(_thisHandle, &pException, fldHnd);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getBoundaries(
          CORINFO_METHOD_HANDLE ftn,
          unsigned int* cILOffsets,
          uint32_t** pILOffsets,
          ICorDebugInfo::BoundaryTypes* implictBoundaries)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getBoundaries(_thisHandle, &pException, ftn, cILOffsets, pILOffsets, implictBoundaries);
    if (pException != nullptr) throw pException;
}

    virtual void setBoundaries(
          CORINFO_METHOD_HANDLE ftn,
          uint32_t cMap,
          ICorDebugInfo::OffsetMapping* pMap)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setBoundaries(_thisHandle, &pException, ftn, cMap, pMap);
    if (pException != nullptr) throw pException;
}

    virtual void getVars(
          CORINFO_METHOD_HANDLE ftn,
          uint32_t* cVars,
          ICorDebugInfo::ILVarInfo** vars,
          bool* extendOthers)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getVars(_thisHandle, &pException, ftn, cVars, vars, extendOthers);
    if (pException != nullptr) throw pException;
}

    virtual void setVars(
          CORINFO_METHOD_HANDLE ftn,
          uint32_t cVars,
          ICorDebugInfo::NativeVarInfo* vars)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setVars(_thisHandle, &pException, ftn, cVars, vars);
    if (pException != nullptr) throw pException;
}

    virtual void* allocateArray(
          size_t cBytes)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->allocateArray(_thisHandle, &pException, cBytes);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void freeArray(
          void* array)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->freeArray(_thisHandle, &pException, array);
    if (pException != nullptr) throw pException;
}

    virtual CORINFO_ARG_LIST_HANDLE getArgNext(
          CORINFO_ARG_LIST_HANDLE args)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_ARG_LIST_HANDLE temp = _callbacks->getArgNext(_thisHandle, &pException, args);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoTypeWithMod getArgType(
          CORINFO_SIG_INFO* sig,
          CORINFO_ARG_LIST_HANDLE args,
          CORINFO_CLASS_HANDLE* vcTypeRet)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoTypeWithMod temp = _callbacks->getArgType(_thisHandle, &pException, sig, args, vcTypeRet);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getArgClass(
          CORINFO_SIG_INFO* sig,
          CORINFO_ARG_LIST_HANDLE args)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getArgClass(_thisHandle, &pException, sig, args);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHFAElemType getHFAType(
          CORINFO_CLASS_HANDLE hClass)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHFAElemType temp = _callbacks->getHFAType(_thisHandle, &pException, hClass);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual JITINTERFACE_HRESULT GetErrorHRESULT(
          struct _EXCEPTION_POINTERS* pExceptionPointers)
{
    CorInfoExceptionClass* pException = nullptr;
    JITINTERFACE_HRESULT temp = _callbacks->GetErrorHRESULT(_thisHandle, &pException, pExceptionPointers);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual uint32_t GetErrorMessage(
          char16_t* buffer,
          uint32_t bufferLength)
{
    CorInfoExceptionClass* pException = nullptr;
    uint32_t temp = _callbacks->GetErrorMessage(_thisHandle, &pException, buffer, bufferLength);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int FilterException(
          struct _EXCEPTION_POINTERS* pExceptionPointers);

    virtual void HandleException(
          struct _EXCEPTION_POINTERS* pExceptionPointers);

    virtual void ThrowExceptionForJitResult(
          JITINTERFACE_HRESULT result)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->ThrowExceptionForJitResult(_thisHandle, &pException, result);
    if (pException != nullptr) throw pException;
}

    virtual void ThrowExceptionForHelper(
          const CORINFO_HELPER_DESC* throwHelper)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->ThrowExceptionForHelper(_thisHandle, &pException, throwHelper);
    if (pException != nullptr) throw pException;
}

    virtual bool runWithErrorTrap(
          ICorJitInfo::errorTrapFunction function,
          void* parameter);

    virtual void getEEInfo(
          CORINFO_EE_INFO* pEEInfoOut)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getEEInfo(_thisHandle, &pException, pEEInfoOut);
    if (pException != nullptr) throw pException;
}

    virtual const char16_t* getJitTimeLogFilename()
{
    CorInfoExceptionClass* pException = nullptr;
    const char16_t* temp = _callbacks->getJitTimeLogFilename(_thisHandle, &pException);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual mdMethodDef getMethodDefFromMethod(
          CORINFO_METHOD_HANDLE hMethod)
{
    CorInfoExceptionClass* pException = nullptr;
    mdMethodDef temp = _callbacks->getMethodDefFromMethod(_thisHandle, &pException, hMethod);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getMethodName(
          CORINFO_METHOD_HANDLE ftn,
          const char** moduleName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getMethodName(_thisHandle, &pException, ftn, moduleName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getMethodNameFromMetadata(
          CORINFO_METHOD_HANDLE ftn,
          const char** className,
          const char** namespaceName,
          const char** enclosingClassName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getMethodNameFromMetadata(_thisHandle, &pException, ftn, className, namespaceName, enclosingClassName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getMethodHash(
          CORINFO_METHOD_HANDLE ftn)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getMethodHash(_thisHandle, &pException, ftn);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual size_t findNameOfToken(
          CORINFO_MODULE_HANDLE moduleHandle,
          unsigned int token,
          char* szFQName,
          size_t FQNameCapacity)
{
    CorInfoExceptionClass* pException = nullptr;
    size_t temp = _callbacks->findNameOfToken(_thisHandle, &pException, moduleHandle, token, szFQName, FQNameCapacity);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool getSystemVAmd64PassStructInRegisterDescriptor(
          CORINFO_CLASS_HANDLE structHnd,
          SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR* structPassInRegDescPtr)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getSystemVAmd64PassStructInRegisterDescriptor(_thisHandle, &pException, structHnd, structPassInRegDescPtr);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual uint32_t getThreadTLSIndex(
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    uint32_t temp = _callbacks->getThreadTLSIndex(_thisHandle, &pException, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const void* getInlinedCallFrameVptr(
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    const void* temp = _callbacks->getInlinedCallFrameVptr(_thisHandle, &pException, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int32_t* getAddrOfCaptureThreadGlobal(
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    int32_t* temp = _callbacks->getAddrOfCaptureThreadGlobal(_thisHandle, &pException, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getHelperFtn(
          CorInfoHelpFunc ftnNum,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getHelperFtn(_thisHandle, &pException, ftnNum, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getFunctionEntryPoint(
          CORINFO_METHOD_HANDLE ftn,
          CORINFO_CONST_LOOKUP* pResult,
          CORINFO_ACCESS_FLAGS accessFlags)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getFunctionEntryPoint(_thisHandle, &pException, ftn, pResult, accessFlags);
    if (pException != nullptr) throw pException;
}

    virtual void getFunctionFixedEntryPoint(
          CORINFO_METHOD_HANDLE ftn,
          CORINFO_CONST_LOOKUP* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getFunctionFixedEntryPoint(_thisHandle, &pException, ftn, pResult);
    if (pException != nullptr) throw pException;
}

    virtual void* getMethodSync(
          CORINFO_METHOD_HANDLE ftn,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getMethodSync(_thisHandle, &pException, ftn, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CorInfoHelpFunc getLazyStringLiteralHelper(
          CORINFO_MODULE_HANDLE handle)
{
    CorInfoExceptionClass* pException = nullptr;
    CorInfoHelpFunc temp = _callbacks->getLazyStringLiteralHelper(_thisHandle, &pException, handle);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_MODULE_HANDLE embedModuleHandle(
          CORINFO_MODULE_HANDLE handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_MODULE_HANDLE temp = _callbacks->embedModuleHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE embedClassHandle(
          CORINFO_CLASS_HANDLE handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->embedClassHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_METHOD_HANDLE embedMethodHandle(
          CORINFO_METHOD_HANDLE handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_METHOD_HANDLE temp = _callbacks->embedMethodHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_FIELD_HANDLE embedFieldHandle(
          CORINFO_FIELD_HANDLE handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_FIELD_HANDLE temp = _callbacks->embedFieldHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void embedGenericHandle(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          bool fEmbedParent,
          CORINFO_GENERICHANDLE_RESULT* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->embedGenericHandle(_thisHandle, &pException, pResolvedToken, fEmbedParent, pResult);
    if (pException != nullptr) throw pException;
}

    virtual void getLocationOfThisType(
          CORINFO_METHOD_HANDLE context,
          CORINFO_LOOKUP_KIND* pLookupKind)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getLocationOfThisType(_thisHandle, &pException, context, pLookupKind);
    if (pException != nullptr) throw pException;
}

    virtual void getAddressOfPInvokeTarget(
          CORINFO_METHOD_HANDLE method,
          CORINFO_CONST_LOOKUP* pLookup)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getAddressOfPInvokeTarget(_thisHandle, &pException, method, pLookup);
    if (pException != nullptr) throw pException;
}

    virtual void* GetCookieForPInvokeCalliSig(
          CORINFO_SIG_INFO* szMetaSig,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->GetCookieForPInvokeCalliSig(_thisHandle, &pException, szMetaSig, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canGetCookieForPInvokeCalliSig(
          CORINFO_SIG_INFO* szMetaSig)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canGetCookieForPInvokeCalliSig(_thisHandle, &pException, szMetaSig);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_JUST_MY_CODE_HANDLE getJustMyCodeHandle(
          CORINFO_METHOD_HANDLE method,
          CORINFO_JUST_MY_CODE_HANDLE** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_JUST_MY_CODE_HANDLE temp = _callbacks->getJustMyCodeHandle(_thisHandle, &pException, method, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void GetProfilingHandle(
          bool* pbHookFunction,
          void** pProfilerHandle,
          bool* pbIndirectedHandles)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->GetProfilingHandle(_thisHandle, &pException, pbHookFunction, pProfilerHandle, pbIndirectedHandles);
    if (pException != nullptr) throw pException;
}

    virtual void getCallInfo(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken,
          CORINFO_METHOD_HANDLE callerHandle,
          CORINFO_CALLINFO_FLAGS flags,
          CORINFO_CALL_INFO* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getCallInfo(_thisHandle, &pException, pResolvedToken, pConstrainedResolvedToken, callerHandle, flags, pResult);
    if (pException != nullptr) throw pException;
}

    virtual bool canAccessFamily(
          CORINFO_METHOD_HANDLE hCaller,
          CORINFO_CLASS_HANDLE hInstanceType)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canAccessFamily(_thisHandle, &pException, hCaller, hInstanceType);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isRIDClassDomainID(
          CORINFO_CLASS_HANDLE cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isRIDClassDomainID(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassDomainID(
          CORINFO_CLASS_HANDLE cls,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassDomainID(_thisHandle, &pException, cls, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getFieldAddress(
          CORINFO_FIELD_HANDLE field,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getFieldAddress(_thisHandle, &pException, field, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getStaticFieldCurrentClass(
          CORINFO_FIELD_HANDLE field,
          bool* pIsSpeculative)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getStaticFieldCurrentClass(_thisHandle, &pException, field, pIsSpeculative);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_VARARGS_HANDLE getVarArgsHandle(
          CORINFO_SIG_INFO* pSig,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_VARARGS_HANDLE temp = _callbacks->getVarArgsHandle(_thisHandle, &pException, pSig, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canGetVarArgsHandle(
          CORINFO_SIG_INFO* pSig)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canGetVarArgsHandle(_thisHandle, &pException, pSig);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual InfoAccessType constructStringLiteral(
          CORINFO_MODULE_HANDLE module,
          unsigned int metaTok,
          void** ppValue)
{
    CorInfoExceptionClass* pException = nullptr;
    InfoAccessType temp = _callbacks->constructStringLiteral(_thisHandle, &pException, module, metaTok, ppValue);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual InfoAccessType emptyStringLiteral(
          void** ppValue)
{
    CorInfoExceptionClass* pException = nullptr;
    InfoAccessType temp = _callbacks->emptyStringLiteral(_thisHandle, &pException, ppValue);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual uint32_t getFieldThreadLocalStoreID(
          CORINFO_FIELD_HANDLE field,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    uint32_t temp = _callbacks->getFieldThreadLocalStoreID(_thisHandle, &pException, field, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void setOverride(
          ICorDynamicInfo* pOverride,
          CORINFO_METHOD_HANDLE currentMethod)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setOverride(_thisHandle, &pException, pOverride, currentMethod);
    if (pException != nullptr) throw pException;
}

    virtual void addActiveDependency(
          CORINFO_MODULE_HANDLE moduleFrom,
          CORINFO_MODULE_HANDLE moduleTo)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->addActiveDependency(_thisHandle, &pException, moduleFrom, moduleTo);
    if (pException != nullptr) throw pException;
}

    virtual CORINFO_METHOD_HANDLE GetDelegateCtor(
          CORINFO_METHOD_HANDLE methHnd,
          CORINFO_CLASS_HANDLE clsHnd,
          CORINFO_METHOD_HANDLE targetMethodHnd,
          DelegateCtorArgs* pCtorData)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_METHOD_HANDLE temp = _callbacks->GetDelegateCtor(_thisHandle, &pException, methHnd, clsHnd, targetMethodHnd, pCtorData);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void MethodCompileComplete(
          CORINFO_METHOD_HANDLE methHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->MethodCompileComplete(_thisHandle, &pException, methHnd);
    if (pException != nullptr) throw pException;
}

    virtual bool getTailCallHelpers(
          CORINFO_RESOLVED_TOKEN* callToken,
          CORINFO_SIG_INFO* sig,
          CORINFO_GET_TAILCALL_HELPERS_FLAGS flags,
          CORINFO_TAILCALL_HELPERS* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getTailCallHelpers(_thisHandle, &pException, callToken, sig, flags, pResult);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool convertPInvokeCalliToCall(
          CORINFO_RESOLVED_TOKEN* pResolvedToken,
          bool mustConvert)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->convertPInvokeCalliToCall(_thisHandle, &pException, pResolvedToken, mustConvert);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool notifyInstructionSetUsage(
          CORINFO_InstructionSet instructionSet,
          bool supportEnabled)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->notifyInstructionSetUsage(_thisHandle, &pException, instructionSet, supportEnabled);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void allocMem(
          uint32_t hotCodeSize,
          uint32_t coldCodeSize,
          uint32_t roDataSize,
          uint32_t xcptnsCount,
          CorJitAllocMemFlag flag,
          void** hotCodeBlock,
          void** coldCodeBlock,
          void** roDataBlock)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->allocMem(_thisHandle, &pException, hotCodeSize, coldCodeSize, roDataSize, xcptnsCount, flag, hotCodeBlock, coldCodeBlock, roDataBlock);
    if (pException != nullptr) throw pException;
}

    virtual void reserveUnwindInfo(
          bool isFunclet,
          bool isColdCode,
          uint32_t unwindSize)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reserveUnwindInfo(_thisHandle, &pException, isFunclet, isColdCode, unwindSize);
    if (pException != nullptr) throw pException;
}

    virtual void allocUnwindInfo(
          uint8_t* pHotCode,
          uint8_t* pColdCode,
          uint32_t startOffset,
          uint32_t endOffset,
          uint32_t unwindSize,
          uint8_t* pUnwindBlock,
          CorJitFuncKind funcKind)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->allocUnwindInfo(_thisHandle, &pException, pHotCode, pColdCode, startOffset, endOffset, unwindSize, pUnwindBlock, funcKind);
    if (pException != nullptr) throw pException;
}

    virtual void* allocGCInfo(
          size_t size)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->allocGCInfo(_thisHandle, &pException, size);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void setEHcount(
          unsigned cEH)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setEHcount(_thisHandle, &pException, cEH);
    if (pException != nullptr) throw pException;
}

    virtual void setEHinfo(
          unsigned EHnumber,
          const CORINFO_EH_CLAUSE* clause)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setEHinfo(_thisHandle, &pException, EHnumber, clause);
    if (pException != nullptr) throw pException;
}

    virtual bool logMsg(
          unsigned level,
          const char* fmt,
          va_list args)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->logMsg(_thisHandle, &pException, level, fmt, args);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int doAssert(
          const char* szFile,
          int iLine,
          const char* szExpr)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->doAssert(_thisHandle, &pException, szFile, iLine, szExpr);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void reportFatalError(
          CorJitResult result)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reportFatalError(_thisHandle, &pException, result);
    if (pException != nullptr) throw pException;
}

    virtual JITINTERFACE_HRESULT getPgoInstrumentationResults(
          CORINFO_METHOD_HANDLE ftnHnd,
          ICorJitInfo::PgoInstrumentationSchema** pSchema,
          uint32_t* pCountSchemaItems,
          uint8_t** pInstrumentationData)
{
    CorInfoExceptionClass* pException = nullptr;
    JITINTERFACE_HRESULT temp = _callbacks->getPgoInstrumentationResults(_thisHandle, &pException, ftnHnd, pSchema, pCountSchemaItems, pInstrumentationData);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual JITINTERFACE_HRESULT allocPgoInstrumentationBySchema(
          CORINFO_METHOD_HANDLE ftnHnd,
          ICorJitInfo::PgoInstrumentationSchema* pSchema,
          uint32_t countSchemaItems,
          uint8_t** pInstrumentationData)
{
    CorInfoExceptionClass* pException = nullptr;
    JITINTERFACE_HRESULT temp = _callbacks->allocPgoInstrumentationBySchema(_thisHandle, &pException, ftnHnd, pSchema, countSchemaItems, pInstrumentationData);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual CORINFO_CLASS_HANDLE getLikelyClass(
          CORINFO_METHOD_HANDLE ftnHnd,
          CORINFO_CLASS_HANDLE baseHnd,
          uint32_t ilOffset,
          uint32_t* pLikelihood,
          uint32_t* pNumberOfClasses)
{
    CorInfoExceptionClass* pException = nullptr;
    CORINFO_CLASS_HANDLE temp = _callbacks->getLikelyClass(_thisHandle, &pException, ftnHnd, baseHnd, ilOffset, pLikelihood, pNumberOfClasses);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void recordCallSite(
          uint32_t instrOffset,
          CORINFO_SIG_INFO* callSig,
          CORINFO_METHOD_HANDLE methodHandle)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->recordCallSite(_thisHandle, &pException, instrOffset, callSig, methodHandle);
    if (pException != nullptr) throw pException;
}

    virtual void recordRelocation(
          void* location,
          void* target,
          uint16_t fRelocType,
          uint16_t slotNum,
          int32_t addlDelta)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->recordRelocation(_thisHandle, &pException, location, target, fRelocType, slotNum, addlDelta);
    if (pException != nullptr) throw pException;
}

    virtual uint16_t getRelocTypeHint(
          void* target)
{
    CorInfoExceptionClass* pException = nullptr;
    uint16_t temp = _callbacks->getRelocTypeHint(_thisHandle, &pException, target);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual uint32_t getExpectedTargetArchitecture()
{
    CorInfoExceptionClass* pException = nullptr;
    uint32_t temp = _callbacks->getExpectedTargetArchitecture(_thisHandle, &pException);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual uint32_t getJitFlags(
          CORJIT_FLAGS* flags,
          uint32_t sizeInBytes)
{
    CorInfoExceptionClass* pException = nullptr;
    uint32_t temp = _callbacks->getJitFlags(_thisHandle, &pException, flags, sizeInBytes);
    if (pException != nullptr) throw pException;
    return temp;
}
};
