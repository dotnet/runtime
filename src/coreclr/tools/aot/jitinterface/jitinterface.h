// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// DO NOT EDIT THIS FILE! IT IS AUTOGENERATED
// To regenerate run the gen script in src/coreclr/tools/Common/JitInterface/ThunkGenerator
// and follow the instructions in docs/project/updating-jitinterface.md


#include "corinfoexception.h"

struct JitInterfaceCallbacks
{
    unsigned int (* getMethodAttribs)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn);
    void (* setMethodAttribs)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, int attribs);
    void (* getMethodSig)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, void* sig, void* memberParent);
    bool (* getMethodInfo)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, void* info);
    int (* canInline)(void * thisHandle, CorInfoExceptionClass** ppException, void* callerHnd, void* calleeHnd, unsigned int* pRestrictions);
    void (* reportInliningDecision)(void * thisHandle, CorInfoExceptionClass** ppException, void* inlinerHnd, void* inlineeHnd, int inlineResult, const char* reason);
    bool (* canTailCall)(void * thisHandle, CorInfoExceptionClass** ppException, void* callerHnd, void* declaredCalleeHnd, void* exactCalleeHnd, bool fIsTailPrefix);
    void (* reportTailCallDecision)(void * thisHandle, CorInfoExceptionClass** ppException, void* callerHnd, void* calleeHnd, bool fIsTailPrefix, int tailCallResult, const char* reason);
    void (* getEHinfo)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, unsigned EHnumber, void* clause);
    void* (* getMethodClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* method);
    void* (* getMethodModule)(void * thisHandle, CorInfoExceptionClass** ppException, void* method);
    void (* getMethodVTableOffset)(void * thisHandle, CorInfoExceptionClass** ppException, void* method, unsigned* offsetOfIndirection, unsigned* offsetAfterIndirection, bool* isRelative);
    bool (* resolveVirtualMethod)(void * thisHandle, CorInfoExceptionClass** ppException, void* info);
    void* (* getUnboxedEntry)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, bool* requiresInstMethodTableArg);
    void* (* getDefaultEqualityComparerClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* elemType);
    void (* expandRawHandleIntrinsic)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, void* pResult);
    int (* getIntrinsicID)(void * thisHandle, CorInfoExceptionClass** ppException, void* method, bool* pMustExpand);
    bool (* isIntrinsicType)(void * thisHandle, CorInfoExceptionClass** ppException, void* classHnd);
    int (* getUnmanagedCallConv)(void * thisHandle, CorInfoExceptionClass** ppException, void* method, void* callSiteSig, bool* pSuppressGCTransition);
    bool (* pInvokeMarshalingRequired)(void * thisHandle, CorInfoExceptionClass** ppException, void* method, void* callSiteSig);
    bool (* satisfiesMethodConstraints)(void * thisHandle, CorInfoExceptionClass** ppException, void* parent, void* method);
    bool (* isCompatibleDelegate)(void * thisHandle, CorInfoExceptionClass** ppException, void* objCls, void* methodParentCls, void* method, void* delegateCls, bool* pfIsOpenDelegate);
    void (* methodMustBeLoadedBeforeCodeIsRun)(void * thisHandle, CorInfoExceptionClass** ppException, void* method);
    void* (* mapMethodDeclToMethodImpl)(void * thisHandle, CorInfoExceptionClass** ppException, void* method);
    void (* getGSCookie)(void * thisHandle, CorInfoExceptionClass** ppException, void* pCookieVal, void** ppCookieVal);
    void (* setPatchpointInfo)(void * thisHandle, CorInfoExceptionClass** ppException, void* patchpointInfo);
    void* (* getOSRInfo)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned* ilOffset);
    void (* resolveToken)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken);
    bool (* tryResolveToken)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken);
    void (* findSig)(void * thisHandle, CorInfoExceptionClass** ppException, void* module, unsigned sigTOK, void* context, void* sig);
    void (* findCallSiteSig)(void * thisHandle, CorInfoExceptionClass** ppException, void* module, unsigned methTOK, void* context, void* sig);
    void* (* getTokenTypeAsHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken);
    bool (* isValidToken)(void * thisHandle, CorInfoExceptionClass** ppException, void* module, unsigned metaTOK);
    bool (* isValidStringRef)(void * thisHandle, CorInfoExceptionClass** ppException, void* module, unsigned metaTOK);
    const wchar_t* (* getStringLiteral)(void * thisHandle, CorInfoExceptionClass** ppException, void* module, unsigned metaTOK, int* length);
    int (* asCorInfoType)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    const char* (* getClassName)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    const char* (* getClassNameFromMetadata)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls, const char** namespaceName);
    void* (* getTypeInstantiationArgument)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls, unsigned index);
    int (* appendClassName)(void * thisHandle, CorInfoExceptionClass** ppException, wchar_t** ppBuf, int* pnBufLen, void* cls, bool fNamespace, bool fFullInst, bool fAssembly);
    bool (* isValueClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    int (* canInlineTypeCheck)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls, int source);
    unsigned int (* getClassAttribs)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    bool (* isStructRequiringStackAllocRetBuf)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    void* (* getClassModule)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    void* (* getModuleAssembly)(void * thisHandle, CorInfoExceptionClass** ppException, void* mod);
    const char* (* getAssemblyName)(void * thisHandle, CorInfoExceptionClass** ppException, void* assem);
    void* (* LongLifetimeMalloc)(void * thisHandle, CorInfoExceptionClass** ppException, size_t sz);
    void (* LongLifetimeFree)(void * thisHandle, CorInfoExceptionClass** ppException, void* obj);
    size_t (* getClassModuleIdForStatics)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls, void* pModule, void** ppIndirection);
    unsigned (* getClassSize)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    unsigned (* getHeapClassSize)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    bool (* canAllocateOnStack)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    unsigned (* getClassAlignmentRequirement)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls, bool fDoubleAlignHint);
    unsigned (* getClassGClayout)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls, unsigned char* gcPtrs);
    unsigned (* getClassNumInstanceFields)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    void* (* getFieldInClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* clsHnd, int num);
    bool (* checkMethodModifier)(void * thisHandle, CorInfoExceptionClass** ppException, void* hMethod, const char* modifier, bool fOptional);
    int (* getNewHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, void* callerHandle, bool* pHasSideEffects);
    int (* getNewArrHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* arrayCls);
    int (* getCastingHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, bool fThrowing);
    int (* getSharedCCtorHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* clsHnd);
    void* (* getTypeForBox)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    int (* getBoxHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    int (* getUnBoxHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    bool (* getReadyToRunHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, void* pGenericLookupKind, int id, void* pLookup);
    void (* getReadyToRunDelegateCtorHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* pTargetMethod, void* delegateType, void* pLookup);
    const char* (* getHelperName)(void * thisHandle, CorInfoExceptionClass** ppException, int helpFunc);
    int (* initClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* field, void* method, void* context);
    void (* classMustBeLoadedBeforeCodeIsRun)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    void* (* getBuiltinClass)(void * thisHandle, CorInfoExceptionClass** ppException, int classId);
    int (* getTypeForPrimitiveValueClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    int (* getTypeForPrimitiveNumericClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    bool (* canCast)(void * thisHandle, CorInfoExceptionClass** ppException, void* child, void* parent);
    bool (* areTypesEquivalent)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls1, void* cls2);
    int (* compareTypesForCast)(void * thisHandle, CorInfoExceptionClass** ppException, void* fromClass, void* toClass);
    int (* compareTypesForEquality)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls1, void* cls2);
    void* (* mergeClasses)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls1, void* cls2);
    bool (* isMoreSpecificType)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls1, void* cls2);
    void* (* getParentType)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    int (* getChildType)(void * thisHandle, CorInfoExceptionClass** ppException, void* clsHnd, void* clsRet);
    bool (* satisfiesClassConstraints)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    bool (* isSDArray)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    unsigned (* getArrayRank)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    void* (* getArrayInitializationData)(void * thisHandle, CorInfoExceptionClass** ppException, void* field, unsigned int size);
    int (* canAccessClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, void* callerHandle, void* pAccessHelper);
    const char* (* getFieldName)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, const char** moduleName);
    void* (* getFieldClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* field);
    int (* getFieldType)(void * thisHandle, CorInfoExceptionClass** ppException, void* field, void* structType, void* memberParent);
    unsigned (* getFieldOffset)(void * thisHandle, CorInfoExceptionClass** ppException, void* field);
    void (* getFieldInfo)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, void* callerHandle, int flags, void* pResult);
    bool (* isFieldStatic)(void * thisHandle, CorInfoExceptionClass** ppException, void* fldHnd);
    void (* getBoundaries)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, unsigned int* cILOffsets, unsigned int** pILOffsets, void* implictBoundaries);
    void (* setBoundaries)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, unsigned int cMap, void* pMap);
    void (* getVars)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, unsigned int* cVars, void* vars, bool* extendOthers);
    void (* setVars)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, unsigned int cVars, void* vars);
    void* (* allocateArray)(void * thisHandle, CorInfoExceptionClass** ppException, size_t cBytes);
    void (* freeArray)(void * thisHandle, CorInfoExceptionClass** ppException, void* array);
    void* (* getArgNext)(void * thisHandle, CorInfoExceptionClass** ppException, void* args);
    int (* getArgType)(void * thisHandle, CorInfoExceptionClass** ppException, void* sig, void* args, void* vcTypeRet);
    void* (* getArgClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* sig, void* args);
    int (* getHFAType)(void * thisHandle, CorInfoExceptionClass** ppException, void* hClass);
    int (* GetErrorHRESULT)(void * thisHandle, CorInfoExceptionClass** ppException, void* pExceptionPointers);
    unsigned int (* GetErrorMessage)(void * thisHandle, CorInfoExceptionClass** ppException, wchar_t* buffer, unsigned int bufferLength);
    int (* FilterException)(void * thisHandle, CorInfoExceptionClass** ppException, void* pExceptionPointers);
    void (* HandleException)(void * thisHandle, CorInfoExceptionClass** ppException, void* pExceptionPointers);
    void (* ThrowExceptionForJitResult)(void * thisHandle, CorInfoExceptionClass** ppException, int result);
    void (* ThrowExceptionForHelper)(void * thisHandle, CorInfoExceptionClass** ppException, const void* throwHelper);
    bool (* runWithErrorTrap)(void * thisHandle, CorInfoExceptionClass** ppException, void* function, void* parameter);
    void (* getEEInfo)(void * thisHandle, CorInfoExceptionClass** ppException, void* pEEInfoOut);
    const wchar_t* (* getJitTimeLogFilename)(void * thisHandle, CorInfoExceptionClass** ppException);
    unsigned int (* getMethodDefFromMethod)(void * thisHandle, CorInfoExceptionClass** ppException, void* hMethod);
    const char* (* getMethodName)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, const char** moduleName);
    const char* (* getMethodNameFromMetadata)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, const char** className, const char** namespaceName, const char** enclosingClassName);
    unsigned (* getMethodHash)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn);
    size_t (* findNameOfToken)(void * thisHandle, CorInfoExceptionClass** ppException, void* moduleHandle, unsigned int token, char* szFQName, size_t FQNameCapacity);
    bool (* getSystemVAmd64PassStructInRegisterDescriptor)(void * thisHandle, CorInfoExceptionClass** ppException, void* structHnd, void* structPassInRegDescPtr);
    unsigned int (* getThreadTLSIndex)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppIndirection);
    const void* (* getInlinedCallFrameVptr)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppIndirection);
    long* (* getAddrOfCaptureThreadGlobal)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppIndirection);
    void* (* getHelperFtn)(void * thisHandle, CorInfoExceptionClass** ppException, int ftnNum, void** ppIndirection);
    void (* getFunctionEntryPoint)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, void* pResult, int accessFlags);
    void (* getFunctionFixedEntryPoint)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, void* pResult);
    void* (* getMethodSync)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftn, void** ppIndirection);
    int (* getLazyStringLiteralHelper)(void * thisHandle, CorInfoExceptionClass** ppException, void* handle);
    void* (* embedModuleHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* handle, void** ppIndirection);
    void* (* embedClassHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* handle, void** ppIndirection);
    void* (* embedMethodHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* handle, void** ppIndirection);
    void* (* embedFieldHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* handle, void** ppIndirection);
    void (* embedGenericHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, bool fEmbedParent, void* pResult);
    void (* getLocationOfThisType)(void * thisHandle, CorInfoExceptionClass** ppException, void* context, void* pLookupKind);
    void (* getAddressOfPInvokeTarget)(void * thisHandle, CorInfoExceptionClass** ppException, void* method, void* pLookup);
    void* (* GetCookieForPInvokeCalliSig)(void * thisHandle, CorInfoExceptionClass** ppException, void* szMetaSig, void** ppIndirection);
    bool (* canGetCookieForPInvokeCalliSig)(void * thisHandle, CorInfoExceptionClass** ppException, void* szMetaSig);
    void* (* getJustMyCodeHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* method, void** ppIndirection);
    void (* GetProfilingHandle)(void * thisHandle, CorInfoExceptionClass** ppException, bool* pbHookFunction, void** pProfilerHandle, bool* pbIndirectedHandles);
    void (* getCallInfo)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, void* pConstrainedResolvedToken, void* callerHandle, int flags, void* pResult);
    bool (* canAccessFamily)(void * thisHandle, CorInfoExceptionClass** ppException, void* hCaller, void* hInstanceType);
    bool (* isRIDClassDomainID)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls);
    unsigned (* getClassDomainID)(void * thisHandle, CorInfoExceptionClass** ppException, void* cls, void** ppIndirection);
    void* (* getFieldAddress)(void * thisHandle, CorInfoExceptionClass** ppException, void* field, void** ppIndirection);
    void* (* getStaticFieldCurrentClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* field, bool* pIsSpeculative);
    void* (* getVarArgsHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* pSig, void** ppIndirection);
    bool (* canGetVarArgsHandle)(void * thisHandle, CorInfoExceptionClass** ppException, void* pSig);
    int (* constructStringLiteral)(void * thisHandle, CorInfoExceptionClass** ppException, void* module, unsigned int metaTok, void** ppValue);
    int (* emptyStringLiteral)(void * thisHandle, CorInfoExceptionClass** ppException, void** ppValue);
    unsigned int (* getFieldThreadLocalStoreID)(void * thisHandle, CorInfoExceptionClass** ppException, void* field, void** ppIndirection);
    void (* setOverride)(void * thisHandle, CorInfoExceptionClass** ppException, void* pOverride, void* currentMethod);
    void (* addActiveDependency)(void * thisHandle, CorInfoExceptionClass** ppException, void* moduleFrom, void* moduleTo);
    void* (* GetDelegateCtor)(void * thisHandle, CorInfoExceptionClass** ppException, void* methHnd, void* clsHnd, void* targetMethodHnd, void* pCtorData);
    void (* MethodCompileComplete)(void * thisHandle, CorInfoExceptionClass** ppException, void* methHnd);
    bool (* getTailCallHelpers)(void * thisHandle, CorInfoExceptionClass** ppException, void* callToken, void* sig, int flags, void* pResult);
    bool (* convertPInvokeCalliToCall)(void * thisHandle, CorInfoExceptionClass** ppException, void* pResolvedToken, bool mustConvert);
    bool (* notifyInstructionSetUsage)(void * thisHandle, CorInfoExceptionClass** ppException, int instructionSet, bool supportEnabled);
    void (* allocMem)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned int hotCodeSize, unsigned int coldCodeSize, unsigned int roDataSize, unsigned int xcptnsCount, int flag, void** hotCodeBlock, void** coldCodeBlock, void** roDataBlock);
    void (* reserveUnwindInfo)(void * thisHandle, CorInfoExceptionClass** ppException, bool isFunclet, bool isColdCode, unsigned int unwindSize);
    void (* allocUnwindInfo)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned char* pHotCode, unsigned char* pColdCode, unsigned int startOffset, unsigned int endOffset, unsigned int unwindSize, unsigned char* pUnwindBlock, int funcKind);
    void* (* allocGCInfo)(void * thisHandle, CorInfoExceptionClass** ppException, size_t size);
    void (* setEHcount)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned cEH);
    void (* setEHinfo)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned EHnumber, void* clause);
    bool (* logMsg)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned level, const char* fmt, va_list args);
    int (* doAssert)(void * thisHandle, CorInfoExceptionClass** ppException, const char* szFile, int iLine, const char* szExpr);
    void (* reportFatalError)(void * thisHandle, CorInfoExceptionClass** ppException, int result);
    int (* allocMethodBlockCounts)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned int count, void** pBlockCounts);
    int (* getMethodBlockCounts)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftnHnd, unsigned int* pCount, void** pBlockCounts, unsigned int* pNumRuns);
    void* (* getLikelyClass)(void * thisHandle, CorInfoExceptionClass** ppException, void* ftnHnd, void* baseHnd, unsigned int ilOffset, unsigned int* pLikelihood, unsigned int* pNumberOfClasses);
    void (* recordCallSite)(void * thisHandle, CorInfoExceptionClass** ppException, unsigned int instrOffset, void* callSig, void* methodHandle);
    void (* recordRelocation)(void * thisHandle, CorInfoExceptionClass** ppException, void* location, void* target, unsigned short fRelocType, unsigned short slotNum, int addlDelta);
    unsigned short (* getRelocTypeHint)(void * thisHandle, CorInfoExceptionClass** ppException, void* target);
    unsigned int (* getExpectedTargetArchitecture)(void * thisHandle, CorInfoExceptionClass** ppException);
    unsigned int (* getJitFlags)(void * thisHandle, CorInfoExceptionClass** ppException, void* flags, unsigned int sizeInBytes);

};

class JitInterfaceWrapper
{
    void * _thisHandle;
    JitInterfaceCallbacks * _callbacks;

public:
    JitInterfaceWrapper(void * thisHandle, void ** callbacks)
        : _thisHandle(thisHandle), _callbacks((JitInterfaceCallbacks *)callbacks)
    {
    }


    virtual unsigned int getMethodAttribs(
          void* ftn)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->getMethodAttribs(_thisHandle, &pException, ftn);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void setMethodAttribs(
          void* ftn,
          int attribs)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setMethodAttribs(_thisHandle, &pException, ftn, attribs);
    if (pException != nullptr) throw pException;
}

    virtual void getMethodSig(
          void* ftn,
          void* sig,
          void* memberParent)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getMethodSig(_thisHandle, &pException, ftn, sig, memberParent);
    if (pException != nullptr) throw pException;
}

    virtual bool getMethodInfo(
          void* ftn,
          void* info)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getMethodInfo(_thisHandle, &pException, ftn, info);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int canInline(
          void* callerHnd,
          void* calleeHnd,
          unsigned int* pRestrictions)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->canInline(_thisHandle, &pException, callerHnd, calleeHnd, pRestrictions);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void reportInliningDecision(
          void* inlinerHnd,
          void* inlineeHnd,
          int inlineResult,
          const char* reason)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reportInliningDecision(_thisHandle, &pException, inlinerHnd, inlineeHnd, inlineResult, reason);
    if (pException != nullptr) throw pException;
}

    virtual bool canTailCall(
          void* callerHnd,
          void* declaredCalleeHnd,
          void* exactCalleeHnd,
          bool fIsTailPrefix)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canTailCall(_thisHandle, &pException, callerHnd, declaredCalleeHnd, exactCalleeHnd, fIsTailPrefix);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void reportTailCallDecision(
          void* callerHnd,
          void* calleeHnd,
          bool fIsTailPrefix,
          int tailCallResult,
          const char* reason)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reportTailCallDecision(_thisHandle, &pException, callerHnd, calleeHnd, fIsTailPrefix, tailCallResult, reason);
    if (pException != nullptr) throw pException;
}

    virtual void getEHinfo(
          void* ftn,
          unsigned EHnumber,
          void* clause)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getEHinfo(_thisHandle, &pException, ftn, EHnumber, clause);
    if (pException != nullptr) throw pException;
}

    virtual void* getMethodClass(
          void* method)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getMethodClass(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getMethodModule(
          void* method)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getMethodModule(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getMethodVTableOffset(
          void* method,
          unsigned* offsetOfIndirection,
          unsigned* offsetAfterIndirection,
          bool* isRelative)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getMethodVTableOffset(_thisHandle, &pException, method, offsetOfIndirection, offsetAfterIndirection, isRelative);
    if (pException != nullptr) throw pException;
}

    virtual bool resolveVirtualMethod(
          void* info)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->resolveVirtualMethod(_thisHandle, &pException, info);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getUnboxedEntry(
          void* ftn,
          bool* requiresInstMethodTableArg)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getUnboxedEntry(_thisHandle, &pException, ftn, requiresInstMethodTableArg);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getDefaultEqualityComparerClass(
          void* elemType)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getDefaultEqualityComparerClass(_thisHandle, &pException, elemType);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void expandRawHandleIntrinsic(
          void* pResolvedToken,
          void* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->expandRawHandleIntrinsic(_thisHandle, &pException, pResolvedToken, pResult);
    if (pException != nullptr) throw pException;
}

    virtual int getIntrinsicID(
          void* method,
          bool* pMustExpand)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getIntrinsicID(_thisHandle, &pException, method, pMustExpand);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isIntrinsicType(
          void* classHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isIntrinsicType(_thisHandle, &pException, classHnd);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getUnmanagedCallConv(
          void* method,
          void* callSiteSig,
          bool* pSuppressGCTransition)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getUnmanagedCallConv(_thisHandle, &pException, method, callSiteSig, pSuppressGCTransition);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool pInvokeMarshalingRequired(
          void* method,
          void* callSiteSig)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->pInvokeMarshalingRequired(_thisHandle, &pException, method, callSiteSig);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool satisfiesMethodConstraints(
          void* parent,
          void* method)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->satisfiesMethodConstraints(_thisHandle, &pException, parent, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isCompatibleDelegate(
          void* objCls,
          void* methodParentCls,
          void* method,
          void* delegateCls,
          bool* pfIsOpenDelegate)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isCompatibleDelegate(_thisHandle, &pException, objCls, methodParentCls, method, delegateCls, pfIsOpenDelegate);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void methodMustBeLoadedBeforeCodeIsRun(
          void* method)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->methodMustBeLoadedBeforeCodeIsRun(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
}

    virtual void* mapMethodDeclToMethodImpl(
          void* method)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->mapMethodDeclToMethodImpl(_thisHandle, &pException, method);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getGSCookie(
          void* pCookieVal,
          void** ppCookieVal)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getGSCookie(_thisHandle, &pException, pCookieVal, ppCookieVal);
    if (pException != nullptr) throw pException;
}

    virtual void setPatchpointInfo(
          void* patchpointInfo)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setPatchpointInfo(_thisHandle, &pException, patchpointInfo);
    if (pException != nullptr) throw pException;
}

    virtual void* getOSRInfo(
          unsigned* ilOffset)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getOSRInfo(_thisHandle, &pException, ilOffset);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void resolveToken(
          void* pResolvedToken)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->resolveToken(_thisHandle, &pException, pResolvedToken);
    if (pException != nullptr) throw pException;
}

    virtual bool tryResolveToken(
          void* pResolvedToken)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->tryResolveToken(_thisHandle, &pException, pResolvedToken);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void findSig(
          void* module,
          unsigned sigTOK,
          void* context,
          void* sig)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->findSig(_thisHandle, &pException, module, sigTOK, context, sig);
    if (pException != nullptr) throw pException;
}

    virtual void findCallSiteSig(
          void* module,
          unsigned methTOK,
          void* context,
          void* sig)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->findCallSiteSig(_thisHandle, &pException, module, methTOK, context, sig);
    if (pException != nullptr) throw pException;
}

    virtual void* getTokenTypeAsHandle(
          void* pResolvedToken)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getTokenTypeAsHandle(_thisHandle, &pException, pResolvedToken);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isValidToken(
          void* module,
          unsigned metaTOK)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isValidToken(_thisHandle, &pException, module, metaTOK);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isValidStringRef(
          void* module,
          unsigned metaTOK)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isValidStringRef(_thisHandle, &pException, module, metaTOK);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const wchar_t* getStringLiteral(
          void* module,
          unsigned metaTOK,
          int* length)
{
    CorInfoExceptionClass* pException = nullptr;
    const wchar_t* temp = _callbacks->getStringLiteral(_thisHandle, &pException, module, metaTOK, length);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int asCorInfoType(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->asCorInfoType(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getClassName(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getClassName(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getClassNameFromMetadata(
          void* cls,
          const char** namespaceName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getClassNameFromMetadata(_thisHandle, &pException, cls, namespaceName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getTypeInstantiationArgument(
          void* cls,
          unsigned index)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getTypeInstantiationArgument(_thisHandle, &pException, cls, index);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int appendClassName(
          wchar_t** ppBuf,
          int* pnBufLen,
          void* cls,
          bool fNamespace,
          bool fFullInst,
          bool fAssembly)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->appendClassName(_thisHandle, &pException, ppBuf, pnBufLen, cls, fNamespace, fFullInst, fAssembly);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isValueClass(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isValueClass(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int canInlineTypeCheck(
          void* cls,
          int source)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->canInlineTypeCheck(_thisHandle, &pException, cls, source);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned int getClassAttribs(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->getClassAttribs(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isStructRequiringStackAllocRetBuf(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isStructRequiringStackAllocRetBuf(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getClassModule(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getClassModule(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getModuleAssembly(
          void* mod)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getModuleAssembly(_thisHandle, &pException, mod);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getAssemblyName(
          void* assem)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getAssemblyName(_thisHandle, &pException, assem);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* LongLifetimeMalloc(
          size_t sz)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->LongLifetimeMalloc(_thisHandle, &pException, sz);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void LongLifetimeFree(
          void* obj)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->LongLifetimeFree(_thisHandle, &pException, obj);
    if (pException != nullptr) throw pException;
}

    virtual size_t getClassModuleIdForStatics(
          void* cls,
          void* pModule,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    size_t temp = _callbacks->getClassModuleIdForStatics(_thisHandle, &pException, cls, pModule, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassSize(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassSize(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getHeapClassSize(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getHeapClassSize(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canAllocateOnStack(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canAllocateOnStack(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassAlignmentRequirement(
          void* cls,
          bool fDoubleAlignHint)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassAlignmentRequirement(_thisHandle, &pException, cls, fDoubleAlignHint);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassGClayout(
          void* cls,
          unsigned char* gcPtrs)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassGClayout(_thisHandle, &pException, cls, gcPtrs);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassNumInstanceFields(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassNumInstanceFields(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getFieldInClass(
          void* clsHnd,
          int num)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getFieldInClass(_thisHandle, &pException, clsHnd, num);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool checkMethodModifier(
          void* hMethod,
          const char* modifier,
          bool fOptional)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->checkMethodModifier(_thisHandle, &pException, hMethod, modifier, fOptional);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getNewHelper(
          void* pResolvedToken,
          void* callerHandle,
          bool* pHasSideEffects)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getNewHelper(_thisHandle, &pException, pResolvedToken, callerHandle, pHasSideEffects);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getNewArrHelper(
          void* arrayCls)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getNewArrHelper(_thisHandle, &pException, arrayCls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getCastingHelper(
          void* pResolvedToken,
          bool fThrowing)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getCastingHelper(_thisHandle, &pException, pResolvedToken, fThrowing);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getSharedCCtorHelper(
          void* clsHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getSharedCCtorHelper(_thisHandle, &pException, clsHnd);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getTypeForBox(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getTypeForBox(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getBoxHelper(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getBoxHelper(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getUnBoxHelper(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getUnBoxHelper(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool getReadyToRunHelper(
          void* pResolvedToken,
          void* pGenericLookupKind,
          int id,
          void* pLookup)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getReadyToRunHelper(_thisHandle, &pException, pResolvedToken, pGenericLookupKind, id, pLookup);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getReadyToRunDelegateCtorHelper(
          void* pTargetMethod,
          void* delegateType,
          void* pLookup)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getReadyToRunDelegateCtorHelper(_thisHandle, &pException, pTargetMethod, delegateType, pLookup);
    if (pException != nullptr) throw pException;
}

    virtual const char* getHelperName(
          int helpFunc)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getHelperName(_thisHandle, &pException, helpFunc);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int initClass(
          void* field,
          void* method,
          void* context)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->initClass(_thisHandle, &pException, field, method, context);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void classMustBeLoadedBeforeCodeIsRun(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->classMustBeLoadedBeforeCodeIsRun(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
}

    virtual void* getBuiltinClass(
          int classId)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getBuiltinClass(_thisHandle, &pException, classId);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getTypeForPrimitiveValueClass(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getTypeForPrimitiveValueClass(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getTypeForPrimitiveNumericClass(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getTypeForPrimitiveNumericClass(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canCast(
          void* child,
          void* parent)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canCast(_thisHandle, &pException, child, parent);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool areTypesEquivalent(
          void* cls1,
          void* cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->areTypesEquivalent(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int compareTypesForCast(
          void* fromClass,
          void* toClass)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->compareTypesForCast(_thisHandle, &pException, fromClass, toClass);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int compareTypesForEquality(
          void* cls1,
          void* cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->compareTypesForEquality(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* mergeClasses(
          void* cls1,
          void* cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->mergeClasses(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isMoreSpecificType(
          void* cls1,
          void* cls2)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isMoreSpecificType(_thisHandle, &pException, cls1, cls2);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getParentType(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getParentType(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getChildType(
          void* clsHnd,
          void* clsRet)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getChildType(_thisHandle, &pException, clsHnd, clsRet);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool satisfiesClassConstraints(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->satisfiesClassConstraints(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isSDArray(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isSDArray(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getArrayRank(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getArrayRank(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getArrayInitializationData(
          void* field,
          unsigned int size)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getArrayInitializationData(_thisHandle, &pException, field, size);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int canAccessClass(
          void* pResolvedToken,
          void* callerHandle,
          void* pAccessHelper)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->canAccessClass(_thisHandle, &pException, pResolvedToken, callerHandle, pAccessHelper);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getFieldName(
          void* ftn,
          const char** moduleName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getFieldName(_thisHandle, &pException, ftn, moduleName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getFieldClass(
          void* field)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getFieldClass(_thisHandle, &pException, field);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getFieldType(
          void* field,
          void* structType,
          void* memberParent)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getFieldType(_thisHandle, &pException, field, structType, memberParent);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getFieldOffset(
          void* field)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getFieldOffset(_thisHandle, &pException, field);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getFieldInfo(
          void* pResolvedToken,
          void* callerHandle,
          int flags,
          void* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getFieldInfo(_thisHandle, &pException, pResolvedToken, callerHandle, flags, pResult);
    if (pException != nullptr) throw pException;
}

    virtual bool isFieldStatic(
          void* fldHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isFieldStatic(_thisHandle, &pException, fldHnd);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getBoundaries(
          void* ftn,
          unsigned int* cILOffsets,
          unsigned int** pILOffsets,
          void* implictBoundaries)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getBoundaries(_thisHandle, &pException, ftn, cILOffsets, pILOffsets, implictBoundaries);
    if (pException != nullptr) throw pException;
}

    virtual void setBoundaries(
          void* ftn,
          unsigned int cMap,
          void* pMap)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setBoundaries(_thisHandle, &pException, ftn, cMap, pMap);
    if (pException != nullptr) throw pException;
}

    virtual void getVars(
          void* ftn,
          unsigned int* cVars,
          void* vars,
          bool* extendOthers)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getVars(_thisHandle, &pException, ftn, cVars, vars, extendOthers);
    if (pException != nullptr) throw pException;
}

    virtual void setVars(
          void* ftn,
          unsigned int cVars,
          void* vars)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setVars(_thisHandle, &pException, ftn, cVars, vars);
    if (pException != nullptr) throw pException;
}

    virtual void* allocateArray(
          size_t cBytes)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->allocateArray(_thisHandle, &pException, cBytes);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void freeArray(
          void* array)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->freeArray(_thisHandle, &pException, array);
    if (pException != nullptr) throw pException;
}

    virtual void* getArgNext(
          void* args)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getArgNext(_thisHandle, &pException, args);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getArgType(
          void* sig,
          void* args,
          void* vcTypeRet)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getArgType(_thisHandle, &pException, sig, args, vcTypeRet);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getArgClass(
          void* sig,
          void* args)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getArgClass(_thisHandle, &pException, sig, args);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getHFAType(
          void* hClass)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getHFAType(_thisHandle, &pException, hClass);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int GetErrorHRESULT(
          void* pExceptionPointers)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->GetErrorHRESULT(_thisHandle, &pException, pExceptionPointers);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned int GetErrorMessage(
          wchar_t* buffer,
          unsigned int bufferLength)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->GetErrorMessage(_thisHandle, &pException, buffer, bufferLength);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int FilterException(
          void* pExceptionPointers);

    virtual void HandleException(
          void* pExceptionPointers);

    virtual void ThrowExceptionForJitResult(
          int result)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->ThrowExceptionForJitResult(_thisHandle, &pException, result);
    if (pException != nullptr) throw pException;
}

    virtual void ThrowExceptionForHelper(
          const void* throwHelper)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->ThrowExceptionForHelper(_thisHandle, &pException, throwHelper);
    if (pException != nullptr) throw pException;
}

    virtual bool runWithErrorTrap(
          void* function,
          void* parameter);

    virtual void getEEInfo(
          void* pEEInfoOut)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getEEInfo(_thisHandle, &pException, pEEInfoOut);
    if (pException != nullptr) throw pException;
}

    virtual const wchar_t* getJitTimeLogFilename()
{
    CorInfoExceptionClass* pException = nullptr;
    const wchar_t* temp = _callbacks->getJitTimeLogFilename(_thisHandle, &pException);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned int getMethodDefFromMethod(
          void* hMethod)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->getMethodDefFromMethod(_thisHandle, &pException, hMethod);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getMethodName(
          void* ftn,
          const char** moduleName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getMethodName(_thisHandle, &pException, ftn, moduleName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const char* getMethodNameFromMetadata(
          void* ftn,
          const char** className,
          const char** namespaceName,
          const char** enclosingClassName)
{
    CorInfoExceptionClass* pException = nullptr;
    const char* temp = _callbacks->getMethodNameFromMetadata(_thisHandle, &pException, ftn, className, namespaceName, enclosingClassName);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getMethodHash(
          void* ftn)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getMethodHash(_thisHandle, &pException, ftn);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual size_t findNameOfToken(
          void* moduleHandle,
          unsigned int token,
          char* szFQName,
          size_t FQNameCapacity)
{
    CorInfoExceptionClass* pException = nullptr;
    size_t temp = _callbacks->findNameOfToken(_thisHandle, &pException, moduleHandle, token, szFQName, FQNameCapacity);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool getSystemVAmd64PassStructInRegisterDescriptor(
          void* structHnd,
          void* structPassInRegDescPtr)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getSystemVAmd64PassStructInRegisterDescriptor(_thisHandle, &pException, structHnd, structPassInRegDescPtr);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned int getThreadTLSIndex(
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->getThreadTLSIndex(_thisHandle, &pException, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual const void* getInlinedCallFrameVptr(
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    const void* temp = _callbacks->getInlinedCallFrameVptr(_thisHandle, &pException, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual long* getAddrOfCaptureThreadGlobal(
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    long* temp = _callbacks->getAddrOfCaptureThreadGlobal(_thisHandle, &pException, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getHelperFtn(
          int ftnNum,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getHelperFtn(_thisHandle, &pException, ftnNum, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void getFunctionEntryPoint(
          void* ftn,
          void* pResult,
          int accessFlags)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getFunctionEntryPoint(_thisHandle, &pException, ftn, pResult, accessFlags);
    if (pException != nullptr) throw pException;
}

    virtual void getFunctionFixedEntryPoint(
          void* ftn,
          void* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getFunctionFixedEntryPoint(_thisHandle, &pException, ftn, pResult);
    if (pException != nullptr) throw pException;
}

    virtual void* getMethodSync(
          void* ftn,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getMethodSync(_thisHandle, &pException, ftn, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getLazyStringLiteralHelper(
          void* handle)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getLazyStringLiteralHelper(_thisHandle, &pException, handle);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* embedModuleHandle(
          void* handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->embedModuleHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* embedClassHandle(
          void* handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->embedClassHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* embedMethodHandle(
          void* handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->embedMethodHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* embedFieldHandle(
          void* handle,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->embedFieldHandle(_thisHandle, &pException, handle, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void embedGenericHandle(
          void* pResolvedToken,
          bool fEmbedParent,
          void* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->embedGenericHandle(_thisHandle, &pException, pResolvedToken, fEmbedParent, pResult);
    if (pException != nullptr) throw pException;
}

    virtual void getLocationOfThisType(
          void* context,
          void* pLookupKind)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getLocationOfThisType(_thisHandle, &pException, context, pLookupKind);
    if (pException != nullptr) throw pException;
}

    virtual void getAddressOfPInvokeTarget(
          void* method,
          void* pLookup)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getAddressOfPInvokeTarget(_thisHandle, &pException, method, pLookup);
    if (pException != nullptr) throw pException;
}

    virtual void* GetCookieForPInvokeCalliSig(
          void* szMetaSig,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->GetCookieForPInvokeCalliSig(_thisHandle, &pException, szMetaSig, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canGetCookieForPInvokeCalliSig(
          void* szMetaSig)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canGetCookieForPInvokeCalliSig(_thisHandle, &pException, szMetaSig);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getJustMyCodeHandle(
          void* method,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getJustMyCodeHandle(_thisHandle, &pException, method, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void GetProfilingHandle(
          bool* pbHookFunction,
          void** pProfilerHandle,
          bool* pbIndirectedHandles)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->GetProfilingHandle(_thisHandle, &pException, pbHookFunction, pProfilerHandle, pbIndirectedHandles);
    if (pException != nullptr) throw pException;
}

    virtual void getCallInfo(
          void* pResolvedToken,
          void* pConstrainedResolvedToken,
          void* callerHandle,
          int flags,
          void* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->getCallInfo(_thisHandle, &pException, pResolvedToken, pConstrainedResolvedToken, callerHandle, flags, pResult);
    if (pException != nullptr) throw pException;
}

    virtual bool canAccessFamily(
          void* hCaller,
          void* hInstanceType)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canAccessFamily(_thisHandle, &pException, hCaller, hInstanceType);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool isRIDClassDomainID(
          void* cls)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->isRIDClassDomainID(_thisHandle, &pException, cls);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned getClassDomainID(
          void* cls,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned temp = _callbacks->getClassDomainID(_thisHandle, &pException, cls, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getFieldAddress(
          void* field,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getFieldAddress(_thisHandle, &pException, field, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getStaticFieldCurrentClass(
          void* field,
          bool* pIsSpeculative)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getStaticFieldCurrentClass(_thisHandle, &pException, field, pIsSpeculative);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getVarArgsHandle(
          void* pSig,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getVarArgsHandle(_thisHandle, &pException, pSig, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool canGetVarArgsHandle(
          void* pSig)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->canGetVarArgsHandle(_thisHandle, &pException, pSig);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int constructStringLiteral(
          void* module,
          unsigned int metaTok,
          void** ppValue)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->constructStringLiteral(_thisHandle, &pException, module, metaTok, ppValue);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int emptyStringLiteral(
          void** ppValue)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->emptyStringLiteral(_thisHandle, &pException, ppValue);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned int getFieldThreadLocalStoreID(
          void* field,
          void** ppIndirection)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->getFieldThreadLocalStoreID(_thisHandle, &pException, field, ppIndirection);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void setOverride(
          void* pOverride,
          void* currentMethod)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setOverride(_thisHandle, &pException, pOverride, currentMethod);
    if (pException != nullptr) throw pException;
}

    virtual void addActiveDependency(
          void* moduleFrom,
          void* moduleTo)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->addActiveDependency(_thisHandle, &pException, moduleFrom, moduleTo);
    if (pException != nullptr) throw pException;
}

    virtual void* GetDelegateCtor(
          void* methHnd,
          void* clsHnd,
          void* targetMethodHnd,
          void* pCtorData)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->GetDelegateCtor(_thisHandle, &pException, methHnd, clsHnd, targetMethodHnd, pCtorData);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void MethodCompileComplete(
          void* methHnd)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->MethodCompileComplete(_thisHandle, &pException, methHnd);
    if (pException != nullptr) throw pException;
}

    virtual bool getTailCallHelpers(
          void* callToken,
          void* sig,
          int flags,
          void* pResult)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->getTailCallHelpers(_thisHandle, &pException, callToken, sig, flags, pResult);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool convertPInvokeCalliToCall(
          void* pResolvedToken,
          bool mustConvert)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->convertPInvokeCalliToCall(_thisHandle, &pException, pResolvedToken, mustConvert);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual bool notifyInstructionSetUsage(
          int instructionSet,
          bool supportEnabled)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->notifyInstructionSetUsage(_thisHandle, &pException, instructionSet, supportEnabled);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void allocMem(
          unsigned int hotCodeSize,
          unsigned int coldCodeSize,
          unsigned int roDataSize,
          unsigned int xcptnsCount,
          int flag,
          void** hotCodeBlock,
          void** coldCodeBlock,
          void** roDataBlock)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->allocMem(_thisHandle, &pException, hotCodeSize, coldCodeSize, roDataSize, xcptnsCount, flag, hotCodeBlock, coldCodeBlock, roDataBlock);
    if (pException != nullptr) throw pException;
}

    virtual void reserveUnwindInfo(
          bool isFunclet,
          bool isColdCode,
          unsigned int unwindSize)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reserveUnwindInfo(_thisHandle, &pException, isFunclet, isColdCode, unwindSize);
    if (pException != nullptr) throw pException;
}

    virtual void allocUnwindInfo(
          unsigned char* pHotCode,
          unsigned char* pColdCode,
          unsigned int startOffset,
          unsigned int endOffset,
          unsigned int unwindSize,
          unsigned char* pUnwindBlock,
          int funcKind)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->allocUnwindInfo(_thisHandle, &pException, pHotCode, pColdCode, startOffset, endOffset, unwindSize, pUnwindBlock, funcKind);
    if (pException != nullptr) throw pException;
}

    virtual void* allocGCInfo(
          size_t size)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->allocGCInfo(_thisHandle, &pException, size);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void setEHcount(
          unsigned cEH)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setEHcount(_thisHandle, &pException, cEH);
    if (pException != nullptr) throw pException;
}

    virtual void setEHinfo(
          unsigned EHnumber,
          void* clause)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->setEHinfo(_thisHandle, &pException, EHnumber, clause);
    if (pException != nullptr) throw pException;
}

    virtual bool logMsg(
          unsigned level,
          const char* fmt,
          va_list args)
{
    CorInfoExceptionClass* pException = nullptr;
    bool temp = _callbacks->logMsg(_thisHandle, &pException, level, fmt, args);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int doAssert(
          const char* szFile,
          int iLine,
          const char* szExpr)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->doAssert(_thisHandle, &pException, szFile, iLine, szExpr);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void reportFatalError(
          int result)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->reportFatalError(_thisHandle, &pException, result);
    if (pException != nullptr) throw pException;
}

    virtual int allocMethodBlockCounts(
          unsigned int count,
          void** pBlockCounts)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->allocMethodBlockCounts(_thisHandle, &pException, count, pBlockCounts);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual int getMethodBlockCounts(
          void* ftnHnd,
          unsigned int* pCount,
          void** pBlockCounts,
          unsigned int* pNumRuns)
{
    CorInfoExceptionClass* pException = nullptr;
    int temp = _callbacks->getMethodBlockCounts(_thisHandle, &pException, ftnHnd, pCount, pBlockCounts, pNumRuns);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void* getLikelyClass(
          void* ftnHnd,
          void* baseHnd,
          unsigned int ilOffset,
          unsigned int* pLikelihood,
          unsigned int* pNumberOfClasses)
{
    CorInfoExceptionClass* pException = nullptr;
    void* temp = _callbacks->getLikelyClass(_thisHandle, &pException, ftnHnd, baseHnd, ilOffset, pLikelihood, pNumberOfClasses);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual void recordCallSite(
          unsigned int instrOffset,
          void* callSig,
          void* methodHandle)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->recordCallSite(_thisHandle, &pException, instrOffset, callSig, methodHandle);
    if (pException != nullptr) throw pException;
}

    virtual void recordRelocation(
          void* location,
          void* target,
          unsigned short fRelocType,
          unsigned short slotNum,
          int addlDelta)
{
    CorInfoExceptionClass* pException = nullptr;
    _callbacks->recordRelocation(_thisHandle, &pException, location, target, fRelocType, slotNum, addlDelta);
    if (pException != nullptr) throw pException;
}

    virtual unsigned short getRelocTypeHint(
          void* target)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned short temp = _callbacks->getRelocTypeHint(_thisHandle, &pException, target);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned int getExpectedTargetArchitecture()
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->getExpectedTargetArchitecture(_thisHandle, &pException);
    if (pException != nullptr) throw pException;
    return temp;
}

    virtual unsigned int getJitFlags(
          void* flags,
          unsigned int sizeInBytes)
{
    CorInfoExceptionClass* pException = nullptr;
    unsigned int temp = _callbacks->getJitFlags(_thisHandle, &pException, flags, sizeInBytes);
    if (pException != nullptr) throw pException;
    return temp;
}
};
