##
## Copyright (c) Microsoft. All rights reserved.
## Licensed under the MIT license. See LICENSE file in the project root for full license information.
##
#
#USAGE: 
#Add Events: modify <root>src/vm/ClrEtwAll.man
#Generate Code : perl <root>/src/inc/genXplatLttng.pl
#

use strict;
use warnings;
use XML::DOM;
use FindBin;
use Scalar::Util qw(looks_like_number);


our $lindent;
our %palDataTypeMapping;

require "$FindBin::Bin/genXplatEtw.pl";

my $stdprolog=<<Copy_Right;
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//

/******************************************************************

DO NOT MODIFY. AUTOGENERATED FILE.
This file is generated using the logic from <root>/src/inc/genXplatLttng.pl

******************************************************************/

Copy_Right

my %lttngDataTypeMapping =(
#constructed types
    "win:null"          =>" ",
    "win:Int64"         =>"const __int64",
    "win:ULong"         =>"const ULONG",
    "win:count"         =>"*",
    "win:Struct"        =>"const int",
#actual spec
    "win:GUID"          =>"const int",
    "win:AnsiString"    =>"const char*",
    "win:UnicodeString" =>"const char*",
    "win:Double"        =>"const double",
    "win:Int32"         =>"const signed int",
    "win:Boolean"       =>"const BOOL",
    "win:UInt64"        =>"const unsigned __int64",
    "win:UInt32"        =>"const unsigned int",
    "win:UInt16"        =>"const unsigned short",
    "win:UInt8"         =>"const unsigned char",
    "win:Pointer"       =>"const size_t",
    "win:Binary"        =>"const BYTE"
);

my %ctfDataTypeMapping =(
#constructed types
    "win:Int64"         =>"ctf_integer",
    "win:ULong"         =>"ctf_integer",
    "win:count"         =>"ctf_sequence",
    "win:Struct"        =>"ctf_sequence",
#actual spec
    "win:GUID"          =>"ctf_sequence",
    "win:AnsiString"    =>"ctf_string",
    "win:UnicodeString" =>"ctf_string",
    "win:Double"        =>"ctf_float",
    "win:Int32"         =>"ctf_integer",
    "win:Boolean"       =>"ctf_integer",
    "win:UInt64"        =>"ctf_integer",
    "win:UInt32"        =>"ctf_integer",
    "win:UInt16"        =>"ctf_integer",
    "win:UInt8"         =>"ctf_integer",  #actually a character
    "win:Pointer"       =>"ctf_integer",
    "win:Binary"        =>"ctf_sequence"
);

#we loop over the template property so that the code generated is same every time the script runs
#generate the code in

#            generate $lttngevent*header.h
#            each template corresponds to a TRACEPOINT_EVENT_CLASS, its structure would be like
#define ThreadCreated_TRACEPOINT_ARGS \
#    TP_ARGS(\
#        const unsigned __int64, ManagedThreadID,\
#        cosnt unsigned __int64, AppDomainID,\
#        const unsigned int, Flags,\
#        const unsigned int, ManagedThreadIndex,\
#        const unsigned int, OSThreadID,\
#        const unsigned short, ClrInstanceID\
#    )
#TRACEPOINT_EVENT_CLASS(
#    Microsoft_DotNETRuntime,
#    ThreadCreated ,
#    ThreadCreated_TRACEPOINT_ARGS,
#    TP_FIELDS(
#        ctf_integer(unsigned __int64, ManagedThreadID,ManagedThreadID)
#        ctf_integer(unsigned __int64, AppDomainID,AppDomainID)
#        ctf_integer(unsigned int, Flags,Flags)
#        ctf_integer(unsigned int, ManagedThreadIndex,ManagedThreadIndex)
#        ctf_integer(unsigned int, OSThreadID,OSThreadID)
#        ctf_integer(unsigned short, ClrInstanceID,ClrInstanceID)
#    )
#)
#define ThreadCreatedT_TRACEPOINT_INSTANCE(name) \
#TRACEPOINT_EVENT_INSTANCE(\
#    Microsoft_DotNETRuntime,\
#    ThreadCreated ,\
#    name ,\
#    ThreadCreated_TRACEPOINT_ARGS\
#)
sub GenerateLttngHeader
{
    my ($providerName,$rTemplateNodes,$allTemplatemap,$allLTTngTemplateTypes,$allTemplateVarProps,$alleventname) = @_;
    my @rTemplateNodes        = @$rTemplateNodes ;
    my @alleventname          = @$alleventname ;
    my %allTemplatemap        = %$allTemplatemap;
    my %allLTTngTemplateTypes = %$allLTTngTemplateTypes;
    my %allTemplateVarProps   = %$allTemplateVarProps;
    my $lTTngHdr;

    foreach my $rTemplateNode (@rTemplateNodes)
    {
        my $XMLtemplateName = $rTemplateNode->getAttribute('tid');
        foreach my $templateName (@{$allTemplatemap{$XMLtemplateName}})
        {
            my $fnSignature =  $allLTTngTemplateTypes{$templateName};
            my $tp_args;
#TP_ARGS
            $tp_args=<<TP_ARGS_PROLOG;

#define $templateName\_TRACEPOINT_ARGS \\
TP_ARGS(\\
TP_ARGS_PROLOG
            foreach  my $params (@$fnSignature)
            {

                my $wintypeName = $params->{"type"} || die "no type ";
                my $varname     = $params->{"var"} || die "no name ";
                my $winCount    = $params->{"count"} || die "no count ";
                my $countw      = $lttngDataTypeMapping{$winCount} || die "no mapping for $winCount";

                #TP_ARGS
                my $typewName = $lttngDataTypeMapping{$wintypeName} || die "no mapping for $wintypeName";
                $tp_args      = $tp_args."        $typewName"."$countw";
                $tp_args      =~s/ +$//;
                $tp_args      = $tp_args." ,$varname,\\\n";

            }
            $tp_args  =~s/,\\\n+$//;
            $tp_args  = $tp_args."\\\n)\n";
            $lTTngHdr = $lTTngHdr.$tp_args;
# end of TP_ARGS

#TP Fields and Event Class

#start TP_EVENT_CLASS
            my $tp_fields = <<TP_EVENT_CLASS_CONT;
TRACEPOINT_EVENT_CLASS(
    $providerName,
    $templateName,
    $templateName\_TRACEPOINT_ARGS,
     TP_FIELDS(
TP_EVENT_CLASS_CONT

            foreach  my $params (@$fnSignature)
            {
                my $wintypeName = $params->{"type"};
                my $varname     = $params->{"var"};
                my $winCount    = $params->{"count"};
                my $countw      = $lttngDataTypeMapping{$winCount} || die "no mapping for $winCount";
                my $typewName   = $lttngDataTypeMapping{$wintypeName} || die "no mapping for $wintypeName";
                $typewName      =~s/^const //;

                #TP_FIELDS
                my $ctf_type;
                my $tp_fields_body;
                my $varProps = $allTemplateVarProps{$templateName};

                if (exists $varProps->{$varname})
                {
                    #this is an explicit struct treat as a sequence
                    $ctf_type       = "ctf_sequence";
                    my $sizeofseq   = "$varProps->{$varname}";
                    $tp_fields_body = "$typewName, $varname, $varname,size_t,$sizeofseq";
                }
                else
                {
                    $ctf_type = $ctfDataTypeMapping{$wintypeName} || die "no mapping for $wintypeName";

                    if ($ctf_type eq "ctf_string")
                    {
                        $tp_fields_body = "$varname,$varname";
                    }
                    elsif ($ctf_type eq "ctf_integer" || $ctf_type eq "ctf_float")
                    {
                        $tp_fields_body = "$typewName,$varname,$varname";
                    }
                    elsif ($ctf_type eq "ctf_sequence") 
                    {
                        die "ctf_sequence needs to have its memory expilicitly laid out";
                    }
                    else 
                    {
                        die "no such ctf intrinsic called $ctf_type"; 
                    }

                }

                $tp_fields = $tp_fields."        $ctf_type($tp_fields_body)\n";
            }
            $tp_fields = $tp_fields."    )\n)\n";
            $lTTngHdr  = $lTTngHdr.$tp_fields;


# end of TP_EVENT_CLASS
            #
# Macro for defining event instance
            $lTTngHdr = $lTTngHdr."#define $templateName";
            $lTTngHdr = $lTTngHdr.<<TP_EVENT_CLASS_EPILOG;
T_TRACEPOINT_INSTANCE(name) \\
TRACEPOINT_EVENT_INSTANCE(\\
    $providerName,\\
    $templateName ,\\
    name ,\\
    $templateName\_TRACEPOINT_ARGS \\
)
TP_EVENT_CLASS_EPILOG

#end Macro for defining event instance
        }
    }
#add an empty template node to just specify the event name in the event stream
    $lTTngHdr = $lTTngHdr.<<TP_EVENT_CLASS_EMPTY;
TRACEPOINT_EVENT_CLASS(
    $providerName,
    emptyTemplate ,
    TP_ARGS(),
    TP_FIELDS()
)
#define T_TRACEPOINT_INSTANCE(name) \\
TRACEPOINT_EVENT_INSTANCE(\\
    $providerName,\\
    emptyTemplate,\\
    name ,\\
    TP_ARGS()\\
)
TP_EVENT_CLASS_EMPTY
#end of empty template
    # create the event instance in headers
    foreach my $reventNode (@alleventname)
    {
        my $eventName    = $reventNode->getAttribute('symbol');
        my $templateName = $reventNode->getAttribute('template');

        if ($eventName eq '') { die " $reventNode event does not have a symbol"}
        if ($templateName eq '')
        {
            $lTTngHdr = $lTTngHdr."T_TRACEPOINT_INSTANCE($eventName)\n";
            next;
        }

        foreach my $subtemplates (@{$allTemplatemap{$templateName}})
        {
            my $subevent = $subtemplates;
            $subevent    =~s/$templateName//;
            $lTTngHdr    = $lTTngHdr."$subtemplates"."T_TRACEPOINT_INSTANCE($eventName$subevent)\n";
        }

    }

    $lTTngHdr = $lTTngHdr.<<EOT_Epilog;
#endif /* LTTNG_CORECLR_H$providerName */
#include <lttng/tracepoint-event.h>
EOT_Epilog

    return  $lTTngHdr;
}

sub GenerateLttngTpProvider
{
    my ($providerName,$rTemplateNodes,$allTemplatemap,$allLTTngTemplateTypes,$allTemplateVarProps,$alleventname) = @_;
    my @rTemplateNodes        = @$rTemplateNodes ;
    my @alleventname          = @$alleventname ;
    my %allTemplatemap        = %$allTemplatemap;
    my %allLTTngTemplateTypes = %$allLTTngTemplateTypes;
    my %allTemplateVarProps   = %$allTemplateVarProps;
    my $lTTngImpl;

    foreach my $reventNode (@alleventname)
    {
        my @vars_to_be_freed; #vars representing the allocation we make
        my $eventName    = $reventNode->getAttribute('symbol');
        my $templateName = $reventNode->getAttribute('template');

        #generate EventXplatEnabled
        $lTTngImpl  = $lTTngImpl."extern \"C\" BOOL  EventXplatEnabled$eventName(){ return TRUE;}\n";
        #generate FireEtw functions
        my $fnptype     = "extern \"C\" ULONG  FireEtXplat$eventName(\n";
        my $linefnptype = "";

        if ( $templateName ne "")
        {
            foreach my $subtemplates (@{$allTemplatemap{$templateName}})
            {
                my $fnSignature = $allLTTngTemplateTypes{$subtemplates} ;


                foreach  my $params (@$fnSignature)
                {
                    my $wintypeName = $params->{"type"};
                    my $typewName   = $palDataTypeMapping{$wintypeName} || die "no mapping for $wintypeName";
                    my $winCount    = $params->{"count"};
                    my $countw      = $palDataTypeMapping{$winCount} || die "no mapping for $winCount";
                    $linefnptype    = $linefnptype.$lindent.$typewName.$countw;
                    $linefnptype    =~s/ +$//;
                    $linefnptype    = $linefnptype." ";
                    $linefnptype    = $linefnptype.$params->{"var"};
                    $linefnptype    = $linefnptype.",\n";
                }

            }
            $linefnptype =~ s/,+$//;
        }
        $fnptype   = $fnptype.$linefnptype.")\n";
        $fnptype   = $fnptype."{\n  ULONG Error = ERROR_WRITE_FAULT;\n";
        $lTTngImpl = $lTTngImpl.$fnptype;
#start of fn body
        $lTTngImpl = $lTTngImpl.<<FN_PROLOG;
    if (!EventXplatEnabled$eventName()){ return ERROR_SUCCESS;};
FN_PROLOG
        my $linefnbody = "";
        if ($templateName ne '')
        {
#emit code to init variables convert unicode to ansi string
            foreach my $subtemplates (@{$allTemplatemap{$templateName}})
            {
                my $fnSignature = $allLTTngTemplateTypes{$subtemplates};
                foreach  my $params (@$fnSignature)
                {
                    my $wintypeName = $params->{"type"};
                    if($wintypeName eq "win:UnicodeString")
                    {

                        my $paramname = $params->{"var"};
                        $lTTngImpl    = $lTTngImpl.<<UTFCODE_INIT;
    INT $paramname\_path_size = -1;
    INT $paramname\_full_name_path_size = WideCharToMultiByte( CP_ACP, 0, $paramname, -1, NULL, 0, NULL, NULL );
    CHAR* $paramname\_full_name=NULL;
UTFCODE_INIT
                    }
                }
            }

            $lTTngImpl = $lTTngImpl."\n";

            foreach my $subtemplates (@{$allTemplatemap{$templateName}})
            {
                my $fnSignature = $allLTTngTemplateTypes{$subtemplates};
                my  $subevent   = "";

                if ($linefnbody ne "")
                {
                    $linefnbody =~ s/,+$//;
                    $linefnbody = $linefnbody."        );\n";
                }

#start emitting Tracepoint                     
                $subevent   = $subtemplates;
                $subevent   =~s/$templateName//;
                $linefnbody = <<FN_body_cont;
                    $linefnbody
     tracepoint(
        $providerName,
        $eventName$subevent,
FN_body_cont
                foreach  my $params (@$fnSignature)
                {
                    $linefnbody     = $linefnbody."        ";
                    my $wintypeName = $params->{"type"};
                    my $winCount    = $params->{"count"};
                    my $paramname   = $params->{"var"};
                    my $ctf_type    = $ctfDataTypeMapping{$winCount} || $ctfDataTypeMapping{$wintypeName} || die "no such ctf mapping for  $eventName: $wintypeName $paramname "; ;
                    if ($ctf_type eq "ctf_string")
                    {
                        if($wintypeName eq "win:UnicodeString")
                        {
#emit code to convert unicode to ansi string
                            $lTTngImpl = $lTTngImpl.<<UTFCODE;
    $paramname\_full_name = (CHAR*)malloc($paramname\_full_name_path_size*sizeof(CHAR));
    _ASSERTE($paramname\_full_name != NULL);
    if($paramname\_full_name == NULL){goto LExit;}

    $paramname\_path_size = WideCharToMultiByte( CP_ACP, 0, $paramname, -1, $paramname\_full_name, $paramname\_full_name_path_size, NULL, NULL );
    _ASSERTE($paramname\_path_size == $paramname\_full_name_path_size );
    if( $paramname\_path_size == 0 ){ Error = ERROR_INVALID_PARAMETER; goto LExit;}
UTFCODE
                            push @vars_to_be_freed, "$paramname\_full_name";

                            $linefnbody = $linefnbody."$paramname\_full_name";
                            $linefnbody = $linefnbody.",\n";
                            next;
                        }
                    }
                    elsif (($ctf_type eq "ctf_sequence") or ($wintypeName eq "win:Pointer"))
                    {

                        $linefnbody = $linefnbody."($lttngDataTypeMapping{$wintypeName}$lttngDataTypeMapping{$winCount}";
                        $linefnbody =~ s/ +$//;
                        $linefnbody = $linefnbody.") ";
                    }
                    $linefnbody = $linefnbody.$paramname;
                    $linefnbody = $linefnbody.",\n";
                }
            }
            $linefnbody =~ s/,+$//;
            $linefnbody = $linefnbody."        );\n";
        }
        else
        {
            $linefnbody = <<FN_body_cont;
                    $linefnbody
     tracepoint(
        $providerName,
        $eventName
     );
FN_body_cont

        }

        $lTTngImpl = $lTTngImpl.<<FnBodyComp;
            $linefnbody
        Error = ERROR_SUCCESS;
FnBodyComp
#end of fn
        if (@vars_to_be_freed)
        {
            $lTTngImpl = $lTTngImpl."LExit:\n";
        }

        while( my $var = pop @vars_to_be_freed)
        {
            $lTTngImpl = $lTTngImpl. "        if ($var != NULL) {free($var);}\n";
        }
        $lTTngImpl = $lTTngImpl. "\nreturn Error;\n}\n";
    }

    return $lTTngImpl;
}
sub GenerateLttngFiles
{
    my $sClrEtwAllMan = "$FindBin::Bin/../vm/ClrEtwAll.man";
    my $rParser       = new XML::DOM::Parser;
    my $rClrEtwAllMan = $rParser->parsefile($sClrEtwAllMan);

    GeneratePlformIndFiles($sClrEtwAllMan);

    foreach my $rProviderNode ($rClrEtwAllMan->getElementsByTagName('provider'))
    {

        my $providerName      = $rProviderNode->getAttribute('name');
        $providerName         =~s/Windows-//i;
        $providerName         =~s/Microsoft-//i;
        my $providerName_File = $providerName;
        $providerName_File    =~s/-//g;
        $providerName_File    = "\L$providerName\E";
        $providerName         =~s/-/_/g;

        my $lttngevntheadershortname = "lttng/tp$providerName_File.h";
        my $lttngevntheader          = "$FindBin::Bin/../pal/src/eventprovider/$lttngevntheadershortname";
        my $lttngevntprov            = "$FindBin::Bin/../pal/src/eventprovider/lttng/eventprov$providerName_File.cpp";
        my $lttngevntprovTp          = "$FindBin::Bin/../pal/src/eventprovider/lttng/traceptprov$providerName_File.cpp";

        open(lTTngImpl,   ">$lttngevntprov") || die "Cannot open $lttngevntprov\n";
        open(lTTngTpImpl, ">$lttngevntprovTp") || die "Cannot open $lttngevntprovTp\n";
        open(lTTngHdr,    ">$lttngevntheader") || die "Cannot open $lttngevntheader\n";


        print lTTngHdr    $stdprolog;
        print lTTngImpl   $stdprolog;
        print lTTngTpImpl $stdprolog;

        print lTTngTpImpl <<LTTNg_TPIMp;

#define TRACEPOINT_CREATE_PROBES
#include "./$lttngevntheadershortname"
LTTNg_TPIMp

        print lTTngHdr <<LTTNgHDR_Prolog;

#include "palrt.h"
#include "pal.h"

#undef TRACEPOINT_PROVIDER
#define TRACEPOINT_PROVIDER $providerName

#undef TRACEPOINT_INCLUDE
#define TRACEPOINT_INCLUDE "./$lttngevntheadershortname"

#if !defined(LTTNG_CORECLR_H$providerName) || defined(TRACEPOINT_HEADER_MULTI_READ)
#define LTTNG_CORECLR_H$providerName

#include <lttng/tracepoint.h>

LTTNgHDR_Prolog

        print lTTngImpl <<EventProvider_Prolog;

#define TRACEPOINT_DEFINE
#define TRACEPOINT_PROBE_DYNAMIC_LINKAGE
#include "$lttngevntheadershortname"
EventProvider_Prolog

        my @rTemplateNodes = $rProviderNode->getElementsByTagName('template');
        my @alleventname   = $rProviderNode->getElementsByTagName('event');
#Parse the XML file to construct datatypes used in code generation below

        my ($allTemplatemap,$allLTTngTemplateTypes,$allTemplateVarProps) = ParseTemplates(@rTemplateNodes);
        
        my %allTemplatemap        = %$allTemplatemap;
        my %allLTTngTemplateTypes = %$allLTTngTemplateTypes;
        my %allTemplateVarProps   = %$allTemplateVarProps;

#generate the header
        print  lTTngHdr GenerateLttngHeader($providerName,\@rTemplateNodes,\%allTemplatemap,\%allLTTngTemplateTypes,\%allTemplateVarProps,\@alleventname);

#create the implementation of eventing functions : lttngeventprov*.cpp
        print lTTngImpl GenerateLttngTpProvider($providerName,\@rTemplateNodes,\%allTemplatemap,\%allLTTngTemplateTypes,\%allTemplateVarProps,\@alleventname);

        close(lTTngImpl);
        close(lTTngTpImpl);
        close(lTTngHdr);

    }

}

GenerateLttngFiles();
