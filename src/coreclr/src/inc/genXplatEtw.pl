##
## Copyright (c) Microsoft. All rights reserved.
## Licensed under the MIT license. See LICENSE file in the project root for full license information.
##
#
#USAGE: 
#Add Events: modify <root>src/vm/ClrEtwAll.man
#Look at the Code in  <root>/src/inc/genXplatLttng.pl for using subroutines in this file
#

use strict;
use warnings;
use XML::DOM;
use FindBin;
use Scalar::Util qw(looks_like_number);
use Term::ANSIColor;
our $stdprolog=<<Copy_Right;
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//

/******************************************************************

DO NOT MODIFY. AUTOGENERATED FILE.
This file is generated using the logic from <root>/src/inc/genXplatEtw.pl

******************************************************************/

Copy_Right


our $lindent = "                  ";
our %palDataTypeMapping =(
#constructed types
    "win:null"          =>" ",
    "win:Int64"         =>"const __int64",
    "win:ULong"         =>"const ULONG",
    "win:count"         =>"*",
    "win:Struct"        =>"const void",
#actual spec
    "win:GUID"          =>"const GUID",
    "win:AnsiString"    =>"LPCSTR",
    "win:UnicodeString" =>"PCWSTR",
    "win:Double"        =>"const double",
    "win:Int32"         =>"const signed int",
    "win:Boolean"       =>"const BOOL",
    "win:UInt64"        =>"const unsigned __int64",
    "win:UInt32"        =>"const unsigned int",
    "win:UInt16"        =>"const unsigned short",
    "win:UInt8"         =>"const unsigned char",
    "win:Pointer"       =>"const void*",
    "win:Binary"        =>"const BYTE"
);

#the abstract templates are created out of the templates in the manifest,
#they generally correspond one to one, but if the number of arguments in the
#manifest template > 10 it is broken down to a different abstract template with
#the same name followed by suffix _<num>

    #return values
#   my %allTemplatemap;           #maps manifest templates to the list of abstract templates
#   my %allAbstractTemplateTypes; #has all the required info on abstract template
#       Fields:
#             "type"=> AbstractTypeName as given in the Manifest,
#             "var" => The Name of the Variable as given in the Manifest,
#             "count" =>indicates if the variable is a pointer to a memory location
#
#   my %allTemplateVarProps;      # maps  size occupied in memory for every pointer by the variable name per abstract template
#
my @ignoredXmlTemplateAttribes = ("map","outType");
my @usedXmlTemplateAttribes = ("name","inType","count", "length");
sub ParseTemplates
{
    my @rTemplateNodes = @_;

    #return values
    my %allTemplatemap;
    my %allAbstractTemplateTypes;
    my %allTemplateVarProps;

    foreach my $rTemplateNode (@rTemplateNodes)
    {
        my $templateName = $rTemplateNode->getAttribute('tid');
        #step 1: Get the list of arguments
        my @fnSignature;
        my %fnSignatureshadow;
        my %varProps;
        my %varDependencies;
        my $count = 0;

#validate that no new attribute is added to XML file that we do not know about
my %ignoredXmlTemplateAttribes = map {$_ => 1} @ignoredXmlTemplateAttribes;
my %usedXmlTemplateAttribes    = map {$_ => 1} @usedXmlTemplateAttribes;

        foreach my $rdataNode ($rTemplateNode->getElementsByTagName('data',0))
        {
            my $nodemap = $rdataNode->getAttributes;

            for my $val ($nodemap->getValues)
            {
                my $attrib_name = $val->getName();
                if (!exists($ignoredXmlTemplateAttribes{$attrib_name}) && !exists($usedXmlTemplateAttribes{$attrib_name}))
                {
                    die "unknown attribute $attrib_name in template:$templateName";
                }
            }
        }
#end of validation

        foreach my $rdataNode ($rTemplateNode->getElementsByTagName('data',0))
        {
            my $dataName    = $rdataNode->getAttribute('name');
            my $wintypeName = $rdataNode->getAttribute('inType');

            #count and length are the same

            my $wincount  = $rdataNode->getAttribute('count');
            my $winlength = $rdataNode->getAttribute('length');

            if ((looks_like_number($winlength) && $winlength != 1) || $winlength ne "") {
                $wincount =$winlength;
            }
            #connstruct function signature
            $fnSignatureshadow{$dataName} = {"type"=> $wintypeName,"var" => $dataName, "count" =>"win:null"};
            $fnSignature[$count++]        = $dataName;
            my  @varDpnds                 = ($dataName);

            if  (looks_like_number($wincount) && $wincount == 1){}
            elsif( $wincount ne ""  )
            {
                $fnSignatureshadow{$dataName}{"count"} ="win:count";
                my $countVarName = $wincount;
                if ( exists $fnSignatureshadow{$countVarName})
                {

                    $varProps{$dataName} = "$countVarName";
                    @varDpnds = ($countVarName,@varDpnds); # make sure $dataName is the last in the list
                }
                elsif (looks_like_number($wincount))
                {
                    $varProps{$dataName} = "$wincount";

                }
                else {
                    die "don't know ehat the count: $count represents \n";
                }

            }
            #special case for GUIDS, consider them as structs
            if ($wintypeName eq "win:GUID")
            {
                $fnSignatureshadow{$dataName}{"count"} = "win:count";
                $varProps{$dataName}                   = "sizeof(GUID)/sizeof(int)";
            }
            $varDependencies{$dataName} = \@varDpnds;
        }

        foreach my $structToBeMarshalled  ($rTemplateNode->getElementsByTagName('struct',0))
        {

            #add to the function signature
            my $struct_len     =  "Arg$count"."_Struct_Len_";
            my $struct_pointer = "Arg$count"."_Struct_Pointer_";

            $fnSignatureshadow{$struct_len}     = {"type"=> "win:ULong","var" => $struct_len, "count" =>"win:null"};
            $fnSignatureshadow{$struct_pointer} = {"type"=> "win:Struct","var" => $struct_pointer, "count" =>"win:count"};

            $fnSignature[$count++] = $struct_len;
            $fnSignature[$count++] = $struct_pointer;
            #used in code generation
            my $structName                    = $structToBeMarshalled->getAttribute('name');
            my $countVarName                  = $structToBeMarshalled->getAttribute('count') || die "Struct $structName in template $templateName does not have attribute count";
            $varProps{$struct_pointer}        = "$countVarName*$struct_len/sizeof(int)";
            $varDependencies{$struct_len}     = [$struct_len];
            $varDependencies{$struct_pointer} = [$countVarName, $struct_len, $struct_pointer];
        }


        #at this point we have the complete argument list, now break them into chunks of ten
        #As Abstract supports a maximum of 10 arguments
        $count                   = 0;
        my $abstracttemplateName = $templateName;
        my $subevent_cnt         = 1;
        my $last_inserted;
        my %abstractFnFrameShadow;
        my @abstractFnFrame;

        foreach  my $dataName  (@fnSignature)
        {
            FRAMEARGS:
            my $framecount = @abstractFnFrame;
            if ($count%10 == 0 and $framecount > 0)
            {
                #check if all the dependecies are present
                my $depExists   = 1;
                my $dependecies = $varDependencies{$dataName};
                foreach my $dependency (@$dependecies)
                {
                    if (not exists $abstractFnFrameShadow{$dependency})
                    {
                        $depExists = 0;
                        last;
                    }
                }
                #remove elements if the dependency list is not complete
                if( $depExists == 0 )
                {

                    print color('bold red'), "***Warning: Test this feature out depends removed in $abstracttemplateName with @$dependecies\n ***";
                    my $i=0;
                    my $firstdependecy = @$dependecies[0] || die "no varDependencies for $dataName";

                    foreach  my $params (@abstractFnFrame)
                    {
                        my $varname = $params->{"var"} || die "no name ";
                        if ($varname  eq $firstdependecy ){  last; }
                        $i++;
                    }

                    my $dependecieslen = @$dependecies;
                    splice @abstractFnFrame, $i,$dependecieslen ;
                }

                @{$allAbstractTemplateTypes{$abstracttemplateName}} = @abstractFnFrame;
                push (@{$allTemplatemap{$templateName}}, $abstracttemplateName);
                $allTemplateVarProps{$abstracttemplateName} = \%varProps;
                #clear abstractFnFrameShadow
                undef %abstractFnFrameShadow;
                undef @abstractFnFrame ;
                $abstracttemplateName = "$templateName\_$subevent_cnt";
                $subevent_cnt++;
                $count = 0;

                next; # so that next frame can begin
            }

            my $dependecies = $varDependencies{$dataName} || die "no varDependencies for $dataName";
            foreach my $dependency (@$dependecies)
            {

                if (not exists $abstractFnFrameShadow{$dependency})
                {
                    $abstractFnFrameShadow{$dependency} = 1;
                    $abstractFnFrame[$count++]          = $fnSignatureshadow{$dependency};

                    #   if ($dataName ne   $dependency){
                    goto FRAMEARGS;
                    #}
                }
            }
        }
        my $templatelen = @fnSignature;
        if($templatelen == 0 || $count > 0)
        {
            push (@{$allTemplatemap{$templateName}}, $abstracttemplateName);
            $allAbstractTemplateTypes{$abstracttemplateName} =\@abstractFnFrame;
            $allTemplateVarProps{$abstracttemplateName}      =\%varProps;
        }
    }

    return (\%allTemplatemap,\%allAbstractTemplateTypes,\%allTemplateVarProps)
}

#generates the dummy header file which is used by the VM as entry point to the logging Functions
sub GenerateclrEtwDummy
{
    my ($rTemplateNodes,$allTemplatemap,$allAbstractTemplateTypes,$allTemplateVarProps,$alleventname) = @_;
    my @rTemplateNodes        = @$rTemplateNodes ;
    my @alleventname          = @$alleventname ;
    my %allTemplatemap        = %$allTemplatemap;
    my %allAbstractTemplateTypes = %$allAbstractTemplateTypes;
    my %allTemplateVarProps   = %$allTemplateVarProps;
    my $clretmEvents;

    foreach my $reventNode (@alleventname)
    {
        my $eventName    = $reventNode->getAttribute('symbol');
        my $templateName = $reventNode->getAttribute('template');

        #generate FireEtw functions
        my $fnptype = "\#define FireEtw$eventName(";
        my $line    = "";
        if ($templateName ne '')
        {
            foreach my $subtemplates (@{$allTemplatemap{$templateName}})
            {
                my $fnSignature = $allAbstractTemplateTypes{$subtemplates};

                foreach  my $params (@$fnSignature)
                {
                    $line = $line.$params->{"var"}.", ";
                }
            }
            $line =~s/, +$//;
        }
        $fnptype      = $fnptype.$line.") 0\n";
        $clretmEvents = $clretmEvents.$fnptype;
    }
    return $clretmEvents;
}
#generates the header file which is used by the VM as entry point to the logging Functions
sub GenerateclrXplatEvents
{
    my ($rTemplateNodes,$allTemplatemap,$allAbstractTemplateTypes,$allTemplateVarProps,$alleventname) = @_;
    my @rTemplateNodes        = @$rTemplateNodes ;
    my @alleventname          = @$alleventname ;
    my %allTemplatemap        = %$allTemplatemap;
    my %allAbstractTemplateTypes = %$allAbstractTemplateTypes;
    my %allTemplateVarProps   = %$allTemplateVarProps;
    my $clrallEvents;
    foreach my $reventNode (@alleventname)
    {
        my $eventName    = $reventNode->getAttribute('symbol');
        my $templateName = $reventNode->getAttribute('template');

        #generate EventEnabled
        $clrallEvents = $clrallEvents."extern \"C\" BOOL EventXplatEnabled$eventName();\n";
        #generate FireEtw functions
        my $fnptype = "extern \"C\" ULONG   FireEtXplat$eventName(\n";
        my $line    = "";
        if ($templateName ne '')
        {
            foreach my $subtemplates (@{$allTemplatemap{$templateName}})
            {
                my $fnSignature = $allAbstractTemplateTypes{$subtemplates};

                foreach  my $params (@$fnSignature)
                {
                    my $wintypeName = $params->{"type"};
                    my $typewName   = $palDataTypeMapping{$wintypeName} || die "no mapping for $wintypeName";
                    my $winCount    = $params->{"count"};
                    my $countw      = $palDataTypeMapping{$winCount} || die "no mapping for $winCount";
                    $line           = $line.$lindent.$typewName.$countw." ";
                    $line           = $line.$params->{"var"};
                    $line           = $line.",\n";
                }
            }
            $line =~ s/,+$//;
        }
        $fnptype      = $fnptype.$line.");\n";
        $clrallEvents = $clrallEvents.$fnptype;
    }
    return $clrallEvents;
}
sub GenerateclrallEvents
{
    my ($rTemplateNodes,$allTemplatemap,$allAbstractTemplateTypes,$allTemplateVarProps,$alleventname) = @_;
    my @rTemplateNodes           = @$rTemplateNodes ;
    my @alleventname             = @$alleventname ;
    my %allTemplatemap           = %$allTemplatemap;
    my %allAbstractTemplateTypes = %$allAbstractTemplateTypes;
    my %allTemplateVarProps      = %$allTemplateVarProps;
    my $clrallEvents;
    foreach my $reventNode (@alleventname)
    {
        my $eventName    = $reventNode->getAttribute('symbol');
        my $templateName = $reventNode->getAttribute('template');

        #generate EventEnabled
        $clrallEvents = $clrallEvents."inline BOOL EventEnabled$eventName() {return XplatEventLogger::IsEventLoggingEnabled() && EventXplatEnabled$eventName();}\n\n";
        #generate FireEtw functions
        my $fnptype     = "inline ULONG FireEtw$eventName(\n";
        my $fnbody      = $lindent."if (!EventEnabled$eventName()) {return ERROR_SUCCESS;}\n";
        my $line        = "";

        if ($templateName ne '')
        {
            foreach my $subtemplates (@{$allTemplatemap{$templateName}})
            {
                my $fnSignature = $allAbstractTemplateTypes{$subtemplates};

                foreach  my $params (@$fnSignature)
                {
                    my $wintypeName = $params->{"type"};
                    my $typewName   = $palDataTypeMapping{$wintypeName} || die "no mapping for $wintypeName";
                    my $winCount    = $params->{"count"};
                    my $countw      = $palDataTypeMapping{$winCount} || die "no mapping for $winCount";
                    $fnptype           = $fnptype.$lindent.$typewName.$countw." ";
                    $fnptype           = $fnptype.$params->{"var"};
                    $fnptype           = $fnptype.",\n";
                }
                #fnsignature
                foreach  my $params (@$fnSignature)
                {
                    $line        = $line.$params->{"var"};
                    $line        = $line.",";
                }

            }
            $line    =~ s/,+$//;
            $fnptype =~ s/,+$//;
        }

        $fnptype      = $fnptype.")\n{\n";
        $fnbody       = $fnbody.$lindent."return FireEtXplat$eventName(".$line.");\n";
        $fnbody       = $fnbody."}\n\n";
        
        $clrallEvents = $clrallEvents.$fnptype.$fnbody;
    }
    return $clrallEvents;
}

# Generates PAL tests that are used for sanity checking of the Logging Functions
sub GenerateclralltestEvents
{
    my ($rTemplateNodes,$allTemplatemap,$allAbstractTemplateTypes,$allTemplateVarProps,$alleventname) = @_;
    my @rTemplateNodes           = @$rTemplateNodes ;
    my @alleventname             = @$alleventname ;
    my %allTemplatemap           = %$allTemplatemap;
    my %allAbstractTemplateTypes = %$allAbstractTemplateTypes;
    my %allTemplateVarProps      = %$allTemplateVarProps;
    my $clrallTestEvents;
    foreach my $reventNode (@alleventname)
    {
        my $eventName    = $reventNode->getAttribute('symbol');
        my $templateName = $reventNode->getAttribute('template');

        #generate EventEnabled
        $clrallTestEvents = $clrallTestEvents." EventXplatEnabled$eventName();\n";
        #generate FireEtw functions
        my $fnptype = "Error |= FireEtXplat$eventName(\n";
        my $line="";
        if ($templateName ne '')
        {
            foreach my $subtemplates (@{$allTemplatemap{$templateName}})
            {
                my $fnSignature = $allAbstractTemplateTypes{$subtemplates};

                foreach  my $params (@$fnSignature)
                {
                    my $wintypeName = $params->{"type"};
                    my $winCount    = $params->{"count"};
                    my $countw      = $palDataTypeMapping{$winCount} || die "no mapping for $winCount";
                    my $varName     = $params->{"var"};
                    my $argline;
                    if ( uc($varName) eq "COUNT")
                    {
                        $argline="2";
                    }
                    else
                    {
                        if( $wintypeName eq "win:GUID"){  $argline = "&myGuid";}
                        elsif( $wintypeName eq "win:Binary"){  $argline = "win_Binary";}
                        elsif( $wintypeName eq "win:Pointer" && $winCount eq "win:count"){  $argline = "(const void**)&var11";}
                        elsif( $wintypeName eq "win:Pointer"){  $argline        = "(const void*)var11";}
                        elsif( $wintypeName eq "win:AnsiString" ){  $argline    = "\" Testing AniString \"";}
                        elsif( $wintypeName eq "win:UnicodeString" ){  $argline = "W(\" Testing UnicodeString \")";}
                        else{
                            if( $winCount eq "win:count"){  $line = $line."&";}
                            $argline = $wintypeName;
                            $argline =~ s/:/_/;
                        }

                    }
                    $line = $line.$argline;
                    $line = $line.",\n";
                }
            }
            $line =~ s/,+$//;
        }
        $fnptype          = $fnptype.$line.");\n";
        $clrallTestEvents = $clrallTestEvents.$fnptype;
    }
    return $clrallTestEvents;
}

sub WriteTestProlog
{
    #Test prolog
    my $clrallTestEvents = <<TestCPP_Prolog;
/*=====================================================================
**
** Source:   clralltestevents.cpp
**
** Purpose:  Ensure Correctness of Eventing code
**
**
**===================================================================*/
#include <palsuite.h>
#include <clrxplatevents.h>

typedef struct _Struct1 {
        ULONG   Data1;
        unsigned short Data2;
        unsigned short Data3;
        unsigned char  Data4[8];
} Struct1;

Struct1 var21[2] = { { 245, 13, 14, "deadbea" }, { 542, 0, 14, "deadflu" } };

Struct1* var11 = var21;
Struct1* win_Struct = var21;

GUID myGuid ={ 245, 13, 14, "deadbea" };
double win_Double =34.04;
ULONG win_ULong = 34;
BOOL win_Boolean = FALSE;
unsigned __int64 win_UInt64 = 114;
unsigned int win_UInt32 = 4;
unsigned short win_UInt16 = 12;
unsigned char win_UInt8 = 9;
int win_Int32 = 12;
BYTE* win_Binary =(BYTE*)var21 ; 
int __cdecl main(int argc, char **argv)
{

    /* Initialize the PAL.
    */

    if(0 != PAL_Initialize(argc, argv))
    {
        return FAIL;
    }

    ULONG Error = ERROR_SUCCESS;
#if defined(FEATURE_EVENT_TRACE)
    Trace("\\n Starting functional  eventing APIs tests  \\n");

TestCPP_Prolog
}

sub WriteTestEpilog
{
    my $clrallTestEvents=<<TestCPP_Epilog;
 /* Shutdown the PAL.
     */

    if (Error != ERROR_SUCCESS)
    {
        Fail("One or more eventing Apis failed\\n ");
        return FAIL;
    }
        Trace("\\n All eventing APIs were fired succesfully \\n");
#endif //defined(FEATURE_EVENT_TRACE)
        PAL_Terminate();
        return PASS;
}

TestCPP_Epilog
    return $clrallTestEvents;
}
# This function generates files which are independent of the logging system
# and provides the entry point to the Event Logging system
sub GeneratePlformIndFiles
{

    
    my $sClrEtwAllMan    = $_[0]; #the manifest 
    my $rParser          = new XML::DOM::Parser;
    my $rClrEtwAllMan    = $rParser->parsefile($sClrEtwAllMan);
    my $clrxplatevents     = "$FindBin::Bin/../pal/prebuilt/inc/clrxplatevents.h";
    my $clrallevents     = "$FindBin::Bin/../pal/prebuilt/inc/clrallevents.h";
    my $clretwdummy      = "$FindBin::Bin/../pal/prebuilt/inc/etmdummy.h";
    my $clralltestevents = "$FindBin::Bin/../pal/tests/palsuite/eventprovider/clralltestevents.cpp";

    open(clrallEvents,     ">$clrallevents") || die "Cannot open $clrallevents\n";
    open(clrXplatEvents,   ">$clrxplatevents") || die "Cannot open $clrxplatevents\n";
    open(clrEtwDummy,      ">$clretwdummy") || die "Cannot open $clretwdummy\n";
    open(clrallTestEvents, ">$clralltestevents") || die "Cannot open $clrallevents\n";
    
    print clrallEvents     $stdprolog;
    print clrXplatEvents   $stdprolog;
    print clrEtwDummy      $stdprolog;
    print clrallTestEvents $stdprolog;
    print clrallTestEvents WriteTestProlog();
    print clrallEvents  "#include \"clrxplatevents.h\"\n";
 
    foreach my $rProviderNode ($rClrEtwAllMan->getElementsByTagName('provider'))
    {
        my @rTemplateNodes = $rProviderNode->getElementsByTagName('template');
        my @alleventname   = $rProviderNode->getElementsByTagName('event');
#Parse the XML file to construct datatypes used in code generation below

        my ($allTemplatemap,$allAbstractTemplateTypes,$allTemplateVarProps) = ParseTemplates(@rTemplateNodes);
        
        my %allTemplatemap           = %$allTemplatemap;
        my %allAbstractTemplateTypes = %$allAbstractTemplateTypes;
        my %allTemplateVarProps      = %$allTemplateVarProps;

#vm header: 
        print clrallEvents GenerateclrallEvents(\@rTemplateNodes,\%allTemplatemap,\%allAbstractTemplateTypes,\%allTemplateVarProps,\@alleventname);

#pal: create clrallevents.h
        print clrXplatEvents GenerateclrXplatEvents(\@rTemplateNodes,\%allTemplatemap,\%allAbstractTemplateTypes,\%allTemplateVarProps,\@alleventname);

#pal: create etmdummy.h
        print clrEtwDummy GenerateclrEtwDummy(\@rTemplateNodes,\%allTemplatemap,\%allAbstractTemplateTypes,\%allTemplateVarProps,\@alleventname);

#paltest: create clralltestevents.cpp
        print clrallTestEvents GenerateclralltestEvents(\@rTemplateNodes,\%allTemplatemap,\%allAbstractTemplateTypes,\%allTemplateVarProps,\@alleventname);
    }

    print clrallTestEvents WriteTestEpilog();

    close(clrallEvents);
    close(clrXplatEvents);
    close(clrallTestEvents);
    $rClrEtwAllMan->dispose;
}

