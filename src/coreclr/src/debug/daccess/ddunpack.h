//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information. 
//

// Unpacker
// 
// Lives on EE side of the fence
//
// Note that this file is generated by ndp\clr\src\Debug\tools\BuildDDMarshal\.  
// Changes should be made to output\DDUnpack_template.h in that directory.
// 


#ifndef _DDUNPACK_H_
#define _DDUNPACK_H_

#if defined(FEATURE_DBGIPC_TRANSPORT_VM)

#include "ddmarshalutil.h"
#include "ddshared.h"

extern "C" IDacDbiInterface::IAllocator * g_pAllocator;

class DDAllocatorHolder 
{
public:
    DDAllocatorHolder(IDacDbiInterface::IAllocator * pAllocator)
    {
        // not reentrant
        _ASSERTE(g_pAllocator == NULL);
        g_pAllocator = pAllocator;
    }

    ~DDAllocatorHolder()
    {
        g_pAllocator = NULL;
    }
};

#define DD_UNPACK_ENTER_MAY_THROW \
    DDAllocatorHolder __ddunpackHolder(this->m_pAllocator);

// Header for unpacking 
// 
class DDUnpack
    {
    protected:
        IDacDbiInterface * m_pReal;
        IDacDbiInterface::IAllocator * m_pAllocator;
    public:
        DDUnpack(IDacDbiInterface * pReal, IDacDbiInterface::IAllocator * pAllocator)
        {
            m_pReal = pReal;
            m_pAllocator = pAllocator;
        }

        // Main entry point
        // This will then delegate to the proper unpacking stubs.
        void HandleDDMessage(ReadBuffer * pSend, WriteBuffer * pResult);


        //
        // Stubs 
        // 

//---------------------------------------------------------------------
// Unpacking stubs
    // HRESULT CheckDbiVersion(const DbiVersion * pVersion)
    void Unpack_CheckDbiVersion(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT FlushCache()
    void Unpack_FlushCache(ReadBuffer * pSend, WriteBuffer * pResult);

    // void DacSetTargetConsistencyChecks(bool fEnableAsserts)
    void Unpack_DacSetTargetConsistencyChecks(ReadBuffer * pSend, WriteBuffer * pResult);

    // void Destroy()
    void Unpack_Destroy(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsLeftSideInitialized()
    void Unpack_IsLeftSideInitialized(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_AppDomain GetAppDomainFromId(ULONG appdomainId)
    void Unpack_GetAppDomainFromId(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG GetAppDomainId(VMPTR_AppDomain vmAppDomain)
    void Unpack_GetAppDomainId(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetAppDomainObject(VMPTR_AppDomain vmAppDomain)
    void Unpack_GetAppDomainObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsDefaultDomain(VMPTR_AppDomain vmAppDomain)
    void Unpack_IsDefaultDomain(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetAssemblyFromDomainAssembly(VMPTR_DomainAssembly vmDomainAssembly, VMPTR_Assembly * vmAssembly)
    void Unpack_GetAssemblyFromDomainAssembly(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsAssemblyFullyTrusted(VMPTR_DomainAssembly vmDomainAssembly)
    void Unpack_IsAssemblyFullyTrusted(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetAppDomainFullName(VMPTR_AppDomain vmAppDomain, IStringHolder * pStrName)
    void Unpack_GetAppDomainFullName(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetModuleSimpleName(VMPTR_Module vmModule, IStringHolder * pStrFilename)
    void Unpack_GetModuleSimpleName(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL GetAssemblyPath(VMPTR_Assembly vmAssembly, IStringHolder * pStrFilename)
    void Unpack_GetAssemblyPath(ReadBuffer * pSend, WriteBuffer * pResult);

    // void ResolveTypeReference(const TypeRefData * pTypeRefInfo, TypeRefData * pTargetRefInfo)
    void Unpack_ResolveTypeReference(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL GetModulePath(VMPTR_Module vmModule, IStringHolder * pStrFilename)
    void Unpack_GetModulePath(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL GetModuleNGenPath(VMPTR_Module vmModule, IStringHolder * pStrFilename)
    void Unpack_GetModuleNGenPath(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetMetadata(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer)
    void Unpack_GetMetadata(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetSymbolsBuffer(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer, IDacDbiInterface::SymbolFormat * pSymbolFormat)
    void Unpack_GetSymbolsBuffer(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetModuleData(VMPTR_Module vmModule, ModuleInfo * pData)
    void Unpack_GetModuleData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetDomainFileData(VMPTR_DomainFile vmDomainFile, DomainFileInfo * pData)
    void Unpack_GetDomainFileData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetModuleForDomainFile(VMPTR_DomainFile vmDomainFile, VMPTR_Module * pModule)
    void Unpack_GetModuleForDomainFile(ReadBuffer * pSend, WriteBuffer * pResult);

    // IDacDbiInterface::AddressType GetAddressType(CORDB_ADDRESS address)
    void Unpack_GetAddressType(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsTransitionStub(CORDB_ADDRESS address)
    void Unpack_IsTransitionStub(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL * pfAllowJITOpts, BOOL * pfEnableEnC)
    void Unpack_GetCompilerFlags(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT SetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL fAllowJitOpts, BOOL fEnableEnC)
    void Unpack_SetCompilerFlags(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateAppDomains(IDacDbiInterface::FP_APPDOMAIN_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateAppDomains(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateAssembliesInAppDomain(VMPTR_AppDomain vmAppDomain, IDacDbiInterface::FP_ASSEMBLY_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateAssembliesInAppDomain(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateModulesInAssembly(VMPTR_DomainAssembly vmAssembly, IDacDbiInterface::FP_MODULE_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateModulesInAssembly(ReadBuffer * pSend, WriteBuffer * pResult);

    // void RequestSyncAtEvent()
    void Unpack_RequestSyncAtEvent(ReadBuffer * pSend, WriteBuffer * pResult);

    // void MarkDebuggerAttachPending()
    void Unpack_MarkDebuggerAttachPending(ReadBuffer * pSend, WriteBuffer * pResult);

    // void MarkDebuggerAttached(BOOL fAttached)
    void Unpack_MarkDebuggerAttached(ReadBuffer * pSend, WriteBuffer * pResult);

    // void Hijack(VMPTR_Thread vmThread, ULONG32 dwThreadId, const EXCEPTION_RECORD * pRecord, T_CONTEXT * pOriginalContext, ULONG32 cbSizeContext, EHijackReason::EHijackReason reason, void * pUserData, CORDB_ADDRESS * pRemoteContextAddr)
    void Unpack_Hijack(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateConnections(IDacDbiInterface::FP_CONNECTION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateConnections(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateThreads(IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateThreads(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool IsThreadMarkedDead(VMPTR_Thread vmThread)
    void Unpack_IsThreadMarkedDead(ReadBuffer * pSend, WriteBuffer * pResult);

    // HANDLE GetThreadHandle(VMPTR_Thread vmThread)
    void Unpack_GetThreadHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetThreadObject(VMPTR_Thread vmThread)
    void Unpack_GetThreadObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // void SetDebugState(VMPTR_Thread vmThread, CorDebugThreadState debugState)
    void Unpack_SetDebugState(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL HasUnhandledException(VMPTR_Thread vmThread)
    void Unpack_HasUnhandledException(ReadBuffer * pSend, WriteBuffer * pResult);

    // CorDebugUserState GetUserState(VMPTR_Thread vmThread)
    void Unpack_GetUserState(ReadBuffer * pSend, WriteBuffer * pResult);

    // CONNID GetConnectionID(VMPTR_Thread vmThread)
    void Unpack_GetConnectionID(ReadBuffer * pSend, WriteBuffer * pResult);

    // TASKID GetTaskID(VMPTR_Thread vmThread)
    void Unpack_GetTaskID(ReadBuffer * pSend, WriteBuffer * pResult);

    // DWORD TryGetVolatileOSThreadID(VMPTR_Thread vmThread)
    void Unpack_TryGetVolatileOSThreadID(ReadBuffer * pSend, WriteBuffer * pResult);

    // DWORD GetUniqueThreadID(VMPTR_Thread vmThread)
    void Unpack_GetUniqueThreadID(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetCurrentException(VMPTR_Thread vmThread)
    void Unpack_GetCurrentException(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetCurrentCustomDebuggerNotification(VMPTR_Thread vmThread)
    void Unpack_GetCurrentCustomDebuggerNotification(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_AppDomain GetCurrentAppDomain(VMPTR_Thread vmThread)
    void Unpack_GetCurrentAppDomain(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_DomainAssembly ResolveAssembly(VMPTR_DomainFile vmScope, mdToken tkAssemblyRef)
    void Unpack_ResolveAssembly(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetNativeCodeSequencePointsAndVarInfo(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS startAddress, BOOL fCodeAvailabe, NativeVarData * pNativeVarData, SequencePoints * pSequencePoints)
    void Unpack_GetNativeCodeSequencePointsAndVarInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_CONTEXT GetManagedStoppedContext(VMPTR_Thread vmThread)
    void Unpack_GetManagedStoppedContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // void CreateStackWalk(VMPTR_Thread vmThread, DT_CONTEXT * pInternalContextBuffer, StackWalkHandle * ppSFIHandle)
    void Unpack_CreateStackWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // void DeleteStackWalk(StackWalkHandle ppSFIHandle)
    void Unpack_DeleteStackWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetStackWalkCurrentContext(StackWalkHandle pSFIHandle, DT_CONTEXT * pContext)
    void Unpack_GetStackWalkCurrentContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // void SetStackWalkCurrentContext(VMPTR_Thread vmThread, StackWalkHandle pSFIHandle, CorDebugSetContextFlag flag, DT_CONTEXT * pContext)
    void Unpack_SetStackWalkCurrentContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL UnwindStackWalkFrame(StackWalkHandle pSFIHandle)
    void Unpack_UnwindStackWalkFrame(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT CheckContext(VMPTR_Thread vmThread, const DT_CONTEXT * pContext)
    void Unpack_CheckContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // IDacDbiInterface::FrameType GetStackWalkCurrentFrameInfo(StackWalkHandle pSFIHandle, DebuggerIPCE_STRData * pFrameData)
    void Unpack_GetStackWalkCurrentFrameInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG32 GetCountOfInternalFrames(VMPTR_Thread vmThread)
    void Unpack_GetCountOfInternalFrames(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateInternalFrames(VMPTR_Thread vmThread, IDacDbiInterface::FP_INTERNAL_FRAME_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateInternalFrames(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsMatchingParentFrame(FramePointer fpToCheck, FramePointer fpParent)
    void Unpack_IsMatchingParentFrame(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG32 GetStackParameterSize(CORDB_ADDRESS controlPC)
    void Unpack_GetStackParameterSize(ReadBuffer * pSend, WriteBuffer * pResult);

    // FramePointer GetFramePointer(StackWalkHandle pSFIHandle)
    void Unpack_GetFramePointer(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsLeafFrame(VMPTR_Thread vmThread, const DT_CONTEXT * pContext)
    void Unpack_IsLeafFrame(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetContext(VMPTR_Thread vmThread, DT_CONTEXT * pContextBuffer)
    void Unpack_GetContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // void ConvertContextToDebuggerRegDisplay(const DT_CONTEXT * pInContext, DebuggerREGDISPLAY * pOutDRD, BOOL fActive)
    void Unpack_ConvertContextToDebuggerRegDisplay(ReadBuffer * pSend, WriteBuffer * pResult);

    // IDacDbiInterface::DynamicMethodType IsILStubOrLCGMethod(VMPTR_MethodDesc vmMethodDesc)
    void Unpack_IsILStubOrLCGMethod(ReadBuffer * pSend, WriteBuffer * pResult);

    // TargetBuffer GetVarArgSig(CORDB_ADDRESS VASigCookieAddr, CORDB_ADDRESS * pArgBase)
    void Unpack_GetVarArgSig(ReadBuffer * pSend, WriteBuffer * pResult);

    // GENERICS_TYPE_TOKEN ResolveExactGenericArgsToken(DWORD dwExactGenericArgsTokenIndex, GENERICS_TYPE_TOKEN rawToken)
    void Unpack_ResolveExactGenericArgsToken(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetILCodeAndSig(VMPTR_DomainFile vmDomainFile, mdToken functionToken, TargetBuffer * pCodeInfo, mdToken * pLocalSigToken)
    void Unpack_GetILCodeAndSig(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetNativeCodeInfo(VMPTR_DomainFile vmDomainFile, mdToken functionToken, NativeCodeFunctionData * pCodeInfo)
    void Unpack_GetNativeCodeInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetNativeCodeInfoForAddr(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS hotCodeStartAddr, NativeCodeFunctionData * pCodeInfo)
    void Unpack_GetNativeCodeInfoForAddr(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetClassInfo(VMPTR_AppDomain vmAppDomain, VMPTR_Module vmModule, mdTypeDef metadataToken, VMPTR_TypeHandle thExact, VMPTR_TypeHandle thApprox, ClassInfo * pData)
    void Unpack_GetClassInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetInstantiationFieldInfo(VMPTR_DomainFile vmDomainFile, mdTypeDef metadataToken, VMPTR_TypeHandle vmThExact, VMPTR_TypeHandle vmThApprox, DacDbiArrayList<FieldData> * pFieldList, SIZE_T * pObjectSize)
    void Unpack_GetInstantiationFieldInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void TypeHandleToExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, DebuggerIPCE_ExpandedTypeData * pTypeInfo)
    void Unpack_TypeHandleToExpandedTypeInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetObjectExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, CORDB_ADDRESS addr, DebuggerIPCE_ExpandedTypeData * pTypeInfo)
    void Unpack_GetObjectExpandedTypeInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_TypeHandle GetApproxTypeHandle(TypeInfoList * pTypeData)
    void Unpack_GetApproxTypeHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_TypeHandle GetExactTypeHandle(DebuggerIPCE_ExpandedTypeData * pTypeData, ArgInfoList * pArgInfo)
    void Unpack_GetExactTypeHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetMethodDescParams(VMPTR_AppDomain vmAppDomain, VMPTR_MethodDesc vmMethodDesc, GENERICS_TYPE_TOKEN genericsToken, UINT32 * pcGenericClassTypeParams, TypeParamsList * pGenericTypeParams)
    void Unpack_GetMethodDescParams(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetThreadOrContextStaticAddress(VMPTR_FieldDesc vmField, VMPTR_Thread vmRuntimeThread)
    void Unpack_GetThreadOrContextStaticAddress(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetCollectibleTypeStaticAddress(VMPTR_FieldDesc vmField, VMPTR_AppDomain vmAppDomain)
    void Unpack_GetCollectibleTypeStaticAddress(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetEnCHangingFieldInfo(const EnCHangingFieldInfo * pEnCFieldInfo, FieldData * pFieldData, BOOL * pfStatic)
    void Unpack_GetEnCHangingFieldInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetTypeHandleParams(VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, TypeParamsList * pParams)
    void Unpack_GetTypeHandleParams(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetSimpleType(VMPTR_AppDomain vmAppDomain, CorElementType simpleType, mdTypeDef * pMetadataToken, VMPTR_DomainFile * pVmDomainFile)
    void Unpack_GetSimpleType(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetTypedByRefInfo(CORDB_ADDRESS pTypedByRef, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetTypedByRefInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetStringData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetStringData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetArrayData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetArrayData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetBasicObjectInfo(CORDB_ADDRESS objectAddress, CorElementType type, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetBasicObjectInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void TestCrst(VMPTR_Crst vmCrst)
    void Unpack_TestCrst(ReadBuffer * pSend, WriteBuffer * pResult);

    // void TestRWLock(VMPTR_SimpleRWLock vmRWLock)
    void Unpack_TestRWLock(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetDebuggerControlBlockAddress()
    void Unpack_GetDebuggerControlBlockAddress(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_Object GetObjectFromRefPtr(CORDB_ADDRESS ptr)
    void Unpack_GetObjectFromRefPtr(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_Object GetObject(CORDB_ADDRESS ptr)
    void Unpack_GetObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetVmObjectHandle(CORDB_ADDRESS handleAddress)
    void Unpack_GetVmObjectHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsVmObjectHandleValid(VMPTR_OBJECTHANDLE vmHandle)
    void Unpack_IsVmObjectHandleValid(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG GetAppDomainIdFromVmObjectHandle(VMPTR_OBJECTHANDLE vmHandle)
    void Unpack_GetAppDomainIdFromVmObjectHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetHandleAddressFromVmHandle(VMPTR_OBJECTHANDLE vmHandle)
    void Unpack_GetHandleAddressFromVmHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // TargetBuffer GetObjectContents(VMPTR_Object obj)
    void Unpack_GetObjectContents(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateBlockingObjects(VMPTR_Thread vmThread, IDacDbiInterface::FP_BLOCKINGOBJECT_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateBlockingObjects(ReadBuffer * pSend, WriteBuffer * pResult);

    // MonitorLockInfo GetThreadOwningMonitorLock(VMPTR_Object vmObject)
    void Unpack_GetThreadOwningMonitorLock(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateMonitorEventWaitList(VMPTR_Object vmObject, IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateMonitorEventWaitList(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsManagedDebugEventPending()
    void Unpack_IsManagedDebugEventPending(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool GetMetaDataFileInfoFromPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwImageSize, bool & isNGEN, IStringHolder * pStrFilename)
    void Unpack_GetMetaDataFileInfoFromPEFile(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool GetILImageInfoFromNgenPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwSize, IStringHolder * pStrFilename)
    void Unpack_GetILImageInfoFromNgenPEFile(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool IsThreadSuspendedOrHijacked(VMPTR_Thread vmThread)
    void Unpack_IsThreadSuspendedOrHijacked(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool AreGCStructuresValid()
    void Unpack_AreGCStructuresValid(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT CreateHeapWalk(HeapWalkHandle * pHandle)
    void Unpack_CreateHeapWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // void DeleteHeapWalk(HeapWalkHandle handle)
    void Unpack_DeleteHeapWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT WalkHeap(HeapWalkHandle handle, ULONG count, COR_HEAPOBJECT * objects, ULONG * pFetched)
    void Unpack_WalkHeap(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT GetHeapSegments(DacDbiArrayList<COR_SEGMENT> * pSegments)
    void Unpack_GetHeapSegments(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool IsValidObject(CORDB_ADDRESS obj)
    void Unpack_IsValidObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool GetAppDomainForObject(CORDB_ADDRESS obj, VMPTR_AppDomain * pApp, VMPTR_Module * pModule, VMPTR_DomainFile * pDomainFile)
    void Unpack_GetAppDomainForObject(ReadBuffer * pSend, WriteBuffer * pResult);

    };

#endif // _DDUNPACK_H_

#endif //FEATURE_DBGIPC_TRANSPORT_VM

// end of file
