//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information. 
//

// Unpacker
// 
// Lives on EE side of the fence
// 
// Note that this file is generated by ndp\clr\src\Debug\tools\BuildDDMarshal\.  
// Changes should be made to output\DDUnpack_template.cpp in that directory.
// 


#include "stdafx.h"

#if defined(FEATURE_DBGIPC_TRANSPORT_VM)
#include "dacdbiinterface.h"

#include "ddshared.h"

#include "ddmarshalutil.h"

#include "ddunpack.h"

#include "../shared/stringcopyholder.cpp"

// Suppress PREFast warning about overly large function
// These functions are automatically generated.
#if defined(_PREFAST_)
#pragma warning(disable:21000) 
#endif

// general callback for Callback functions.
template <class T>
void GeneralEnumerationCallback(T vmAppDomain, void * pUserData)
{
    WriteBuffer * pResult = (WriteBuffer *) pUserData;

    DWORD dw = 1; // Continue
    WriteToBuffer(pResult, dw);
    WriteToBuffer(pResult, vmAppDomain);
}




// 
// These stubs are called by the handler
// 
//---------------------------------------------------------------------
// Unpacking stub for:
//    HRESULT CheckDbiVersion(const DbiVersion * pVersion)
void DDUnpack::Unpack_CheckDbiVersion(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    DbiVersion _pVersion; // storage
    const DbiVersion * pVersion = &_pVersion;
    ReadFromBuffer(pSend, &_pVersion); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    HRESULT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->CheckDbiVersion(pVersion); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method CheckDbiVersion

//---------------------------------------------------------------------
// Unpacking stub for:
//    HRESULT FlushCache()
void DDUnpack::Unpack_FlushCache(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    HRESULT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->FlushCache(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method FlushCache

//---------------------------------------------------------------------
// Unpacking stub for:
//    void DacSetTargetConsistencyChecks(bool fEnableAsserts)
void DDUnpack::Unpack_DacSetTargetConsistencyChecks(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    bool fEnableAsserts;
    ReadFromBuffer(pSend, fEnableAsserts);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->DacSetTargetConsistencyChecks(fEnableAsserts); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method DacSetTargetConsistencyChecks

//---------------------------------------------------------------------
// Unpacking stub for:
//    void Destroy()
void DDUnpack::Unpack_Destroy(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->Destroy(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method Destroy

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsLeftSideInitialized()
void DDUnpack::Unpack_IsLeftSideInitialized(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsLeftSideInitialized(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsLeftSideInitialized

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_AppDomain GetAppDomainFromId(ULONG appdomainId)
void DDUnpack::Unpack_GetAppDomainFromId(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    ULONG appdomainId;
    ReadFromBuffer(pSend, appdomainId);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_AppDomain _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetAppDomainFromId(appdomainId); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAppDomainFromId

//---------------------------------------------------------------------
// Unpacking stub for:
//    ULONG GetAppDomainId(VMPTR_AppDomain vmAppDomain)
void DDUnpack::Unpack_GetAppDomainId(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    ULONG _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetAppDomainId(vmAppDomain); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAppDomainId

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_OBJECTHANDLE GetAppDomainObject(VMPTR_AppDomain vmAppDomain)
void DDUnpack::Unpack_GetAppDomainObject(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_OBJECTHANDLE _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetAppDomainObject(vmAppDomain); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAppDomainObject

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsDefaultDomain(VMPTR_AppDomain vmAppDomain)
void DDUnpack::Unpack_IsDefaultDomain(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsDefaultDomain(vmAppDomain); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsDefaultDomain

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetAssemblyFromDomainAssembly(VMPTR_DomainAssembly vmDomainAssembly, VMPTR_Assembly * vmAssembly)
void DDUnpack::Unpack_GetAssemblyFromDomainAssembly(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainAssembly vmDomainAssembly;
    ReadFromBuffer(pSend, vmDomainAssembly);
    VMPTR_Assembly _vmAssembly; // storage
    VMPTR_Assembly * vmAssembly = &_vmAssembly;
    // vmAssembly does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetAssemblyFromDomainAssembly(vmDomainAssembly, vmAssembly); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, vmAssembly);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAssemblyFromDomainAssembly

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsAssemblyFullyTrusted(VMPTR_DomainAssembly vmDomainAssembly)
void DDUnpack::Unpack_IsAssemblyFullyTrusted(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainAssembly vmDomainAssembly;
    ReadFromBuffer(pSend, vmDomainAssembly);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsAssemblyFullyTrusted(vmDomainAssembly); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsAssemblyFullyTrusted

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetAppDomainFullName(VMPTR_AppDomain vmAppDomain, IStringHolder * pStrName)
void DDUnpack::Unpack_GetAppDomainFullName(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    StringCopyHolder _pStrName; // storage
    StringCopyHolder* pStrName = &_pStrName;
    // pStrName does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetAppDomainFullName(vmAppDomain, pStrName); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pStrName);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAppDomainFullName

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetModuleSimpleName(VMPTR_Module vmModule, IStringHolder * pStrFilename)
void DDUnpack::Unpack_GetModuleSimpleName(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Module vmModule;
    ReadFromBuffer(pSend, vmModule);
    StringCopyHolder _pStrFilename; // storage
    StringCopyHolder* pStrFilename = &_pStrFilename;
    // pStrFilename does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetModuleSimpleName(vmModule, pStrFilename); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pStrFilename);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetModuleSimpleName

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL GetAssemblyPath(VMPTR_Assembly vmAssembly, IStringHolder * pStrFilename)
void DDUnpack::Unpack_GetAssemblyPath(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Assembly vmAssembly;
    ReadFromBuffer(pSend, vmAssembly);
    StringCopyHolder _pStrFilename; // storage
    StringCopyHolder* pStrFilename = &_pStrFilename;
    // pStrFilename does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetAssemblyPath(vmAssembly, pStrFilename); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pStrFilename);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAssemblyPath

//---------------------------------------------------------------------
// Unpacking stub for:
//    void ResolveTypeReference(const TypeRefData * pTypeRefInfo, TypeRefData * pTargetRefInfo)
void DDUnpack::Unpack_ResolveTypeReference(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    TypeRefData _pTypeRefInfo; // storage
    const TypeRefData * pTypeRefInfo = &_pTypeRefInfo;
    ReadFromBuffer(pSend, &_pTypeRefInfo); // serialize to storage
    TypeRefData _pTargetRefInfo; // storage
    TypeRefData * pTargetRefInfo = &_pTargetRefInfo;
    ReadFromBuffer(pSend, &_pTargetRefInfo); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->ResolveTypeReference(pTypeRefInfo, pTargetRefInfo); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pTargetRefInfo);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method ResolveTypeReference

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL GetModulePath(VMPTR_Module vmModule, IStringHolder * pStrFilename)
void DDUnpack::Unpack_GetModulePath(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Module vmModule;
    ReadFromBuffer(pSend, vmModule);
    StringCopyHolder _pStrFilename; // storage
    StringCopyHolder* pStrFilename = &_pStrFilename;
    // pStrFilename does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetModulePath(vmModule, pStrFilename); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pStrFilename);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetModulePath

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL GetModuleNGenPath(VMPTR_Module vmModule, IStringHolder * pStrFilename)
void DDUnpack::Unpack_GetModuleNGenPath(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Module vmModule;
    ReadFromBuffer(pSend, vmModule);
    StringCopyHolder _pStrFilename; // storage
    StringCopyHolder* pStrFilename = &_pStrFilename;
    // pStrFilename does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetModuleNGenPath(vmModule, pStrFilename); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pStrFilename);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetModuleNGenPath

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetMetadata(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer)
void DDUnpack::Unpack_GetMetadata(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Module vmModule;
    ReadFromBuffer(pSend, vmModule);
    TargetBuffer _pTargetBuffer; // storage
    TargetBuffer * pTargetBuffer = &_pTargetBuffer;
    // pTargetBuffer does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetMetadata(vmModule, pTargetBuffer); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pTargetBuffer);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetMetadata

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetSymbolsBuffer(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer, IDacDbiInterface::SymbolFormat * pSymbolFormat)
void DDUnpack::Unpack_GetSymbolsBuffer(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Module vmModule;
    ReadFromBuffer(pSend, vmModule);
    TargetBuffer _pTargetBuffer; // storage
    TargetBuffer * pTargetBuffer = &_pTargetBuffer;
    // pTargetBuffer does not need to be copied on input
    IDacDbiInterface::SymbolFormat _pSymbolFormat; // storage
    IDacDbiInterface::SymbolFormat * pSymbolFormat = &_pSymbolFormat;
    // pSymbolFormat does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetSymbolsBuffer(vmModule, pTargetBuffer, pSymbolFormat); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pTargetBuffer);
    WriteToBuffer(pResult, pSymbolFormat);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetSymbolsBuffer

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetModuleData(VMPTR_Module vmModule, ModuleInfo * pData)
void DDUnpack::Unpack_GetModuleData(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Module vmModule;
    ReadFromBuffer(pSend, vmModule);
    ModuleInfo _pData; // storage
    ModuleInfo * pData = &_pData;
    // pData does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetModuleData(vmModule, pData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pData);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetModuleData

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetDomainFileData(VMPTR_DomainFile vmDomainFile, DomainFileInfo * pData)
void DDUnpack::Unpack_GetDomainFileData(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmDomainFile;
    ReadFromBuffer(pSend, vmDomainFile);
    DomainFileInfo _pData; // storage
    DomainFileInfo * pData = &_pData;
    // pData does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetDomainFileData(vmDomainFile, pData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pData);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetDomainFileData

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetModuleForDomainFile(VMPTR_DomainFile vmDomainFile, VMPTR_Module * pModule)
void DDUnpack::Unpack_GetModuleForDomainFile(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmDomainFile;
    ReadFromBuffer(pSend, vmDomainFile);
    VMPTR_Module _pModule; // storage
    VMPTR_Module * pModule = &_pModule;
    // pModule does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetModuleForDomainFile(vmDomainFile, pModule); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pModule);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetModuleForDomainFile

//---------------------------------------------------------------------
// Unpacking stub for:
//    IDacDbiInterface::AddressType GetAddressType(CORDB_ADDRESS address)
void DDUnpack::Unpack_GetAddressType(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS address;
    ReadFromBuffer(pSend, address);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    IDacDbiInterface::AddressType _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetAddressType(address); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAddressType

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsTransitionStub(CORDB_ADDRESS address)
void DDUnpack::Unpack_IsTransitionStub(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS address;
    ReadFromBuffer(pSend, address);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsTransitionStub(address); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsTransitionStub

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL * pfAllowJITOpts, BOOL * pfEnableEnC)
void DDUnpack::Unpack_GetCompilerFlags(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmDomainFile;
    ReadFromBuffer(pSend, vmDomainFile);
    BOOL _pfAllowJITOpts; // storage
    BOOL * pfAllowJITOpts = &_pfAllowJITOpts;
    // pfAllowJITOpts does not need to be copied on input
    BOOL _pfEnableEnC; // storage
    BOOL * pfEnableEnC = &_pfEnableEnC;
    // pfEnableEnC does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetCompilerFlags(vmDomainFile, pfAllowJITOpts, pfEnableEnC); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pfAllowJITOpts);
    WriteToBuffer(pResult, pfEnableEnC);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetCompilerFlags

//---------------------------------------------------------------------
// Unpacking stub for:
//    HRESULT SetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL fAllowJitOpts, BOOL fEnableEnC)
void DDUnpack::Unpack_SetCompilerFlags(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmDomainFile;
    ReadFromBuffer(pSend, vmDomainFile);
    BOOL fAllowJitOpts;
    ReadFromBuffer(pSend, fAllowJitOpts);
    BOOL fEnableEnC;
    ReadFromBuffer(pSend, fEnableEnC);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    HRESULT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->SetCompilerFlags(vmDomainFile, fAllowJitOpts, fEnableEnC); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method SetCompilerFlags

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateAppDomains(IDacDbiInterface::FP_APPDOMAIN_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateAppDomains(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        // Extra stuff for callback handlers
        m_pReal->EnumerateAppDomains(GeneralEnumerationCallback, pResult);

    }
    EX_CATCH_HRESULT(hr);

    // Sentinel for callback list
    DWORD dw = 2; // Stop
    WriteToBuffer(pResult, dw); 
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateAppDomains

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateAssembliesInAppDomain(VMPTR_AppDomain vmAppDomain, IDacDbiInterface::FP_ASSEMBLY_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateAssembliesInAppDomain(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        // Extra stuff for callback handlers
        m_pReal->EnumerateAssembliesInAppDomain(vmAppDomain, GeneralEnumerationCallback, pResult);

    }
    EX_CATCH_HRESULT(hr);

    // Sentinel for callback list
    DWORD dw = 2; // Stop
    WriteToBuffer(pResult, dw); 
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateAssembliesInAppDomain

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateModulesInAssembly(VMPTR_DomainAssembly vmAssembly, IDacDbiInterface::FP_MODULE_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateModulesInAssembly(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainAssembly vmAssembly;
    ReadFromBuffer(pSend, vmAssembly);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        // Extra stuff for callback handlers
        m_pReal->EnumerateModulesInAssembly(vmAssembly, GeneralEnumerationCallback, pResult);

    }
    EX_CATCH_HRESULT(hr);

    // Sentinel for callback list
    DWORD dw = 2; // Stop
    WriteToBuffer(pResult, dw); 
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateModulesInAssembly

//---------------------------------------------------------------------
// Unpacking stub for:
//    void RequestSyncAtEvent()
void DDUnpack::Unpack_RequestSyncAtEvent(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->RequestSyncAtEvent(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method RequestSyncAtEvent

//---------------------------------------------------------------------
// Unpacking stub for:
//    void MarkDebuggerAttachPending()
void DDUnpack::Unpack_MarkDebuggerAttachPending(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->MarkDebuggerAttachPending(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method MarkDebuggerAttachPending

//---------------------------------------------------------------------
// Unpacking stub for:
//    void MarkDebuggerAttached(BOOL fAttached)
void DDUnpack::Unpack_MarkDebuggerAttached(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    BOOL fAttached;
    ReadFromBuffer(pSend, fAttached);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->MarkDebuggerAttached(fAttached); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method MarkDebuggerAttached

//---------------------------------------------------------------------
// Unpacking stub for:
//    void Hijack(VMPTR_Thread vmThread, ULONG32 dwThreadId, const EXCEPTION_RECORD * pRecord, T_CONTEXT * pOriginalContext, ULONG32 cbSizeContext, EHijackReason::EHijackReason reason, void * pUserData, CORDB_ADDRESS * pRemoteContextAddr)
void DDUnpack::Unpack_Hijack(ReadBuffer * pSend, WriteBuffer * pResult)
{
 // Callbacks not yet implemented
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method Hijack

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateConnections(IDacDbiInterface::FP_CONNECTION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateConnections(ReadBuffer * pSend, WriteBuffer * pResult)
{
 // Callbacks not yet implemented
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateConnections

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateThreads(IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateThreads(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        // Extra stuff for callback handlers
        m_pReal->EnumerateThreads(GeneralEnumerationCallback, pResult);

    }
    EX_CATCH_HRESULT(hr);

    // Sentinel for callback list
    DWORD dw = 2; // Stop
    WriteToBuffer(pResult, dw); 
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateThreads

//---------------------------------------------------------------------
// Unpacking stub for:
//    bool IsThreadMarkedDead(VMPTR_Thread vmThread)
void DDUnpack::Unpack_IsThreadMarkedDead(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    bool _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsThreadMarkedDead(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsThreadMarkedDead

//---------------------------------------------------------------------
// Unpacking stub for:
//    HANDLE GetThreadHandle(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetThreadHandle(ReadBuffer * pSend, WriteBuffer * pResult)
{
 // Callbacks not yet implemented
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetThreadHandle

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_OBJECTHANDLE GetThreadObject(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetThreadObject(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_OBJECTHANDLE _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetThreadObject(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetThreadObject

//---------------------------------------------------------------------
// Unpacking stub for:
//    void SetDebugState(VMPTR_Thread vmThread, CorDebugThreadState debugState)
void DDUnpack::Unpack_SetDebugState(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    CorDebugThreadState debugState;
    ReadFromBuffer(pSend, debugState);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->SetDebugState(vmThread, debugState); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method SetDebugState

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL HasUnhandledException(VMPTR_Thread vmThread)
void DDUnpack::Unpack_HasUnhandledException(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->HasUnhandledException(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method HasUnhandledException

//---------------------------------------------------------------------
// Unpacking stub for:
//    CorDebugUserState GetUserState(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetUserState(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    CorDebugUserState _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetUserState(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetUserState

//---------------------------------------------------------------------
// Unpacking stub for:
//    CONNID GetConnectionID(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetConnectionID(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    CONNID _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetConnectionID(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetConnectionID

//---------------------------------------------------------------------
// Unpacking stub for:
//    TASKID GetTaskID(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetTaskID(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    TASKID _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetTaskID(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetTaskID

//---------------------------------------------------------------------
// Unpacking stub for:
//    DWORD TryGetVolatileOSThreadID(VMPTR_Thread vmThread)
void DDUnpack::Unpack_TryGetVolatileOSThreadID(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    DWORD _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->TryGetVolatileOSThreadID(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method TryGetVolatileOSThreadID

//---------------------------------------------------------------------
// Unpacking stub for:
//    DWORD GetUniqueThreadID(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetUniqueThreadID(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    DWORD _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetUniqueThreadID(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetUniqueThreadID

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_OBJECTHANDLE GetCurrentException(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetCurrentException(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_OBJECTHANDLE _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetCurrentException(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetCurrentException

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_OBJECTHANDLE GetCurrentCustomDebuggerNotification(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetCurrentCustomDebuggerNotification(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_OBJECTHANDLE _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetCurrentCustomDebuggerNotification(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetCurrentCustomDebuggerNotification

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_AppDomain GetCurrentAppDomain(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetCurrentAppDomain(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_AppDomain _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetCurrentAppDomain(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetCurrentAppDomain

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_DomainAssembly ResolveAssembly(VMPTR_DomainFile vmScope, mdToken tkAssemblyRef)
void DDUnpack::Unpack_ResolveAssembly(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmScope;
    ReadFromBuffer(pSend, vmScope);
    mdToken tkAssemblyRef;
    ReadFromBuffer(pSend, tkAssemblyRef);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_DomainAssembly _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->ResolveAssembly(vmScope, tkAssemblyRef); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method ResolveAssembly

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetNativeCodeSequencePointsAndVarInfo(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS startAddress, BOOL fCodeAvailabe, NativeVarData * pNativeVarData, SequencePoints * pSequencePoints)
void DDUnpack::Unpack_GetNativeCodeSequencePointsAndVarInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_MethodDesc vmMethodDesc;
    ReadFromBuffer(pSend, vmMethodDesc);
    CORDB_ADDRESS startAddress;
    ReadFromBuffer(pSend, startAddress);
    BOOL fCodeAvailabe;
    ReadFromBuffer(pSend, fCodeAvailabe);
    NativeVarData _pNativeVarData; // storage
    NativeVarData * pNativeVarData = &_pNativeVarData;
    // pNativeVarData does not need to be copied on input
    SequencePoints _pSequencePoints; // storage
    SequencePoints * pSequencePoints = &_pSequencePoints;
    // pSequencePoints does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetNativeCodeSequencePointsAndVarInfo(vmMethodDesc, startAddress, fCodeAvailabe, pNativeVarData, pSequencePoints); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pNativeVarData);
    WriteToBuffer(pResult, pSequencePoints);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetNativeCodeSequencePointsAndVarInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_CONTEXT GetManagedStoppedContext(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetManagedStoppedContext(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_CONTEXT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetManagedStoppedContext(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetManagedStoppedContext

//---------------------------------------------------------------------
// Unpacking stub for:
//    void CreateStackWalk(VMPTR_Thread vmThread, DT_CONTEXT * pInternalContextBuffer, StackWalkHandle * ppSFIHandle)
void DDUnpack::Unpack_CreateStackWalk(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    DT_CONTEXT _pInternalContextBuffer; // storage
    DT_CONTEXT * pInternalContextBuffer = &_pInternalContextBuffer;
    ReadFromBuffer(pSend, &_pInternalContextBuffer); // serialize to storage
    StackWalkHandle _ppSFIHandle; // storage
    StackWalkHandle * ppSFIHandle = &_ppSFIHandle;
    // ppSFIHandle does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->CreateStackWalk(vmThread, pInternalContextBuffer, ppSFIHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pInternalContextBuffer);
    WriteToBuffer(pResult, ppSFIHandle);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method CreateStackWalk

//---------------------------------------------------------------------
// Unpacking stub for:
//    void DeleteStackWalk(StackWalkHandle ppSFIHandle)
void DDUnpack::Unpack_DeleteStackWalk(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    StackWalkHandle ppSFIHandle;
    ReadFromBuffer(pSend, ppSFIHandle);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->DeleteStackWalk(ppSFIHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method DeleteStackWalk

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetStackWalkCurrentContext(StackWalkHandle pSFIHandle, DT_CONTEXT * pContext)
void DDUnpack::Unpack_GetStackWalkCurrentContext(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    StackWalkHandle pSFIHandle;
    ReadFromBuffer(pSend, pSFIHandle);
    DT_CONTEXT _pContext; // storage
    DT_CONTEXT * pContext = &_pContext;
    ReadFromBuffer(pSend, &_pContext); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetStackWalkCurrentContext(pSFIHandle, pContext); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pContext);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetStackWalkCurrentContext

//---------------------------------------------------------------------
// Unpacking stub for:
//    void SetStackWalkCurrentContext(VMPTR_Thread vmThread, StackWalkHandle pSFIHandle, CorDebugSetContextFlag flag, DT_CONTEXT * pContext)
void DDUnpack::Unpack_SetStackWalkCurrentContext(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    StackWalkHandle pSFIHandle;
    ReadFromBuffer(pSend, pSFIHandle);
    CorDebugSetContextFlag flag;
    ReadFromBuffer(pSend, flag);
    DT_CONTEXT _pContext; // storage
    DT_CONTEXT * pContext = &_pContext;
    ReadFromBuffer(pSend, &_pContext); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->SetStackWalkCurrentContext(vmThread, pSFIHandle, flag, pContext); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pContext);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method SetStackWalkCurrentContext

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL UnwindStackWalkFrame(StackWalkHandle pSFIHandle)
void DDUnpack::Unpack_UnwindStackWalkFrame(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    StackWalkHandle pSFIHandle;
    ReadFromBuffer(pSend, pSFIHandle);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->UnwindStackWalkFrame(pSFIHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method UnwindStackWalkFrame

//---------------------------------------------------------------------
// Unpacking stub for:
//    HRESULT CheckContext(VMPTR_Thread vmThread, const DT_CONTEXT * pContext)
void DDUnpack::Unpack_CheckContext(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    DT_CONTEXT _pContext; // storage
    const DT_CONTEXT * pContext = &_pContext;
    ReadFromBuffer(pSend, &_pContext); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    HRESULT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->CheckContext(vmThread, pContext); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method CheckContext

//---------------------------------------------------------------------
// Unpacking stub for:
//    IDacDbiInterface::FrameType GetStackWalkCurrentFrameInfo(StackWalkHandle pSFIHandle, DebuggerIPCE_STRData * pFrameData)
void DDUnpack::Unpack_GetStackWalkCurrentFrameInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    StackWalkHandle pSFIHandle;
    ReadFromBuffer(pSend, pSFIHandle);
    DebuggerIPCE_STRData _pFrameData; // storage
    DebuggerIPCE_STRData * pFrameData = &_pFrameData;
    ReadFromBuffer(pSend, &_pFrameData); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    IDacDbiInterface::FrameType _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetStackWalkCurrentFrameInfo(pSFIHandle, pFrameData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pFrameData);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetStackWalkCurrentFrameInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    ULONG32 GetCountOfInternalFrames(VMPTR_Thread vmThread)
void DDUnpack::Unpack_GetCountOfInternalFrames(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    ULONG32 _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetCountOfInternalFrames(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetCountOfInternalFrames

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateInternalFrames(VMPTR_Thread vmThread, IDacDbiInterface::FP_INTERNAL_FRAME_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateInternalFrames(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        // Extra stuff for callback handlers
        m_pReal->EnumerateInternalFrames(vmThread, GeneralEnumerationCallback, pResult);

    }
    EX_CATCH_HRESULT(hr);

    // Sentinel for callback list
    DWORD dw = 2; // Stop
    WriteToBuffer(pResult, dw); 
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateInternalFrames

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsMatchingParentFrame(FramePointer fpToCheck, FramePointer fpParent)
void DDUnpack::Unpack_IsMatchingParentFrame(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    FramePointer fpToCheck;
    ReadFromBuffer(pSend, fpToCheck);
    FramePointer fpParent;
    ReadFromBuffer(pSend, fpParent);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsMatchingParentFrame(fpToCheck, fpParent); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsMatchingParentFrame

//---------------------------------------------------------------------
// Unpacking stub for:
//    ULONG32 GetStackParameterSize(CORDB_ADDRESS controlPC)
void DDUnpack::Unpack_GetStackParameterSize(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS controlPC;
    ReadFromBuffer(pSend, controlPC);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    ULONG32 _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetStackParameterSize(controlPC); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetStackParameterSize

//---------------------------------------------------------------------
// Unpacking stub for:
//    FramePointer GetFramePointer(StackWalkHandle pSFIHandle)
void DDUnpack::Unpack_GetFramePointer(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    StackWalkHandle pSFIHandle;
    ReadFromBuffer(pSend, pSFIHandle);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    FramePointer _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetFramePointer(pSFIHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetFramePointer

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsLeafFrame(VMPTR_Thread vmThread, const DT_CONTEXT * pContext)
void DDUnpack::Unpack_IsLeafFrame(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    DT_CONTEXT _pContext; // storage
    const DT_CONTEXT * pContext = &_pContext;
    ReadFromBuffer(pSend, &_pContext); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsLeafFrame(vmThread, pContext); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsLeafFrame

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetContext(VMPTR_Thread vmThread, DT_CONTEXT * pContextBuffer)
void DDUnpack::Unpack_GetContext(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    DT_CONTEXT _pContextBuffer; // storage
    DT_CONTEXT * pContextBuffer = &_pContextBuffer;
    ReadFromBuffer(pSend, &_pContextBuffer); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetContext(vmThread, pContextBuffer); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pContextBuffer);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetContext

//---------------------------------------------------------------------
// Unpacking stub for:
//    void ConvertContextToDebuggerRegDisplay(const DT_CONTEXT * pInContext, DebuggerREGDISPLAY * pOutDRD, BOOL fActive)
void DDUnpack::Unpack_ConvertContextToDebuggerRegDisplay(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    DT_CONTEXT _pInContext; // storage
    const DT_CONTEXT * pInContext = &_pInContext;
    ReadFromBuffer(pSend, &_pInContext); // serialize to storage
    DebuggerREGDISPLAY _pOutDRD; // storage
    DebuggerREGDISPLAY * pOutDRD = &_pOutDRD;
    ReadFromBuffer(pSend, &_pOutDRD); // serialize to storage
    BOOL fActive;
    ReadFromBuffer(pSend, fActive);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->ConvertContextToDebuggerRegDisplay(pInContext, pOutDRD, fActive); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pOutDRD);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method ConvertContextToDebuggerRegDisplay

//---------------------------------------------------------------------
// Unpacking stub for:
//    IDacDbiInterface::DynamicMethodType IsILStubOrLCGMethod(VMPTR_MethodDesc vmMethodDesc)
void DDUnpack::Unpack_IsILStubOrLCGMethod(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_MethodDesc vmMethodDesc;
    ReadFromBuffer(pSend, vmMethodDesc);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    IDacDbiInterface::DynamicMethodType _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsILStubOrLCGMethod(vmMethodDesc); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsILStubOrLCGMethod

//---------------------------------------------------------------------
// Unpacking stub for:
//    TargetBuffer GetVarArgSig(CORDB_ADDRESS VASigCookieAddr, CORDB_ADDRESS * pArgBase)
void DDUnpack::Unpack_GetVarArgSig(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS VASigCookieAddr;
    ReadFromBuffer(pSend, VASigCookieAddr);
    CORDB_ADDRESS _pArgBase; // storage
    CORDB_ADDRESS * pArgBase = &_pArgBase;
    // pArgBase does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    TargetBuffer _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetVarArgSig(VASigCookieAddr, pArgBase); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pArgBase);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetVarArgSig

//---------------------------------------------------------------------
// Unpacking stub for:
//    GENERICS_TYPE_TOKEN ResolveExactGenericArgsToken(DWORD dwExactGenericArgsTokenIndex, GENERICS_TYPE_TOKEN rawToken)
void DDUnpack::Unpack_ResolveExactGenericArgsToken(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    DWORD dwExactGenericArgsTokenIndex;
    ReadFromBuffer(pSend, dwExactGenericArgsTokenIndex);
    GENERICS_TYPE_TOKEN rawToken;
    ReadFromBuffer(pSend, rawToken);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    GENERICS_TYPE_TOKEN _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->ResolveExactGenericArgsToken(dwExactGenericArgsTokenIndex, rawToken); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method ResolveExactGenericArgsToken

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetILCodeAndSig(VMPTR_DomainFile vmDomainFile, mdToken functionToken, TargetBuffer * pCodeInfo, mdToken * pLocalSigToken)
void DDUnpack::Unpack_GetILCodeAndSig(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmDomainFile;
    ReadFromBuffer(pSend, vmDomainFile);
    mdToken functionToken;
    ReadFromBuffer(pSend, functionToken);
    TargetBuffer _pCodeInfo; // storage
    TargetBuffer * pCodeInfo = &_pCodeInfo;
    // pCodeInfo does not need to be copied on input
    mdToken _pLocalSigToken; // storage
    mdToken * pLocalSigToken = &_pLocalSigToken;
    // pLocalSigToken does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetILCodeAndSig(vmDomainFile, functionToken, pCodeInfo, pLocalSigToken); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pCodeInfo);
    WriteToBuffer(pResult, pLocalSigToken);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetILCodeAndSig

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetNativeCodeInfo(VMPTR_DomainFile vmDomainFile, mdToken functionToken, NativeCodeFunctionData * pCodeInfo)
void DDUnpack::Unpack_GetNativeCodeInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmDomainFile;
    ReadFromBuffer(pSend, vmDomainFile);
    mdToken functionToken;
    ReadFromBuffer(pSend, functionToken);
    NativeCodeFunctionData _pCodeInfo; // storage
    NativeCodeFunctionData * pCodeInfo = &_pCodeInfo;
    // pCodeInfo does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetNativeCodeInfo(vmDomainFile, functionToken, pCodeInfo); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pCodeInfo);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetNativeCodeInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetNativeCodeInfoForAddr(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS hotCodeStartAddr, NativeCodeFunctionData * pCodeInfo)
void DDUnpack::Unpack_GetNativeCodeInfoForAddr(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_MethodDesc vmMethodDesc;
    ReadFromBuffer(pSend, vmMethodDesc);
    CORDB_ADDRESS hotCodeStartAddr;
    ReadFromBuffer(pSend, hotCodeStartAddr);
    NativeCodeFunctionData _pCodeInfo; // storage
    NativeCodeFunctionData * pCodeInfo = &_pCodeInfo;
    ReadFromBuffer(pSend, &_pCodeInfo); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetNativeCodeInfoForAddr(vmMethodDesc, hotCodeStartAddr, pCodeInfo); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pCodeInfo);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetNativeCodeInfoForAddr

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetClassInfo(VMPTR_AppDomain vmAppDomain, VMPTR_Module vmModule, mdTypeDef metadataToken, VMPTR_TypeHandle thExact, VMPTR_TypeHandle thApprox, ClassInfo * pData)
void DDUnpack::Unpack_GetClassInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    VMPTR_Module vmModule;
    ReadFromBuffer(pSend, vmModule);
    mdTypeDef metadataToken;
    ReadFromBuffer(pSend, metadataToken);
    VMPTR_TypeHandle thExact;
    ReadFromBuffer(pSend, thExact);
    VMPTR_TypeHandle thApprox;
    ReadFromBuffer(pSend, thApprox);
    ClassInfo _pData; // storage
    ClassInfo * pData = &_pData;
    ReadFromBuffer(pSend, &_pData); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetClassInfo(vmAppDomain, vmModule, metadataToken, thExact, thApprox, pData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pData);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetClassInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetInstantiationFieldInfo(VMPTR_DomainFile vmDomainFile, mdTypeDef metadataToken, VMPTR_TypeHandle vmThExact, VMPTR_TypeHandle vmThApprox, DacDbiArrayList<FieldData> * pFieldList, SIZE_T * pObjectSize)
void DDUnpack::Unpack_GetInstantiationFieldInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_DomainFile vmDomainFile;
    ReadFromBuffer(pSend, vmDomainFile);
    mdTypeDef metadataToken;
    ReadFromBuffer(pSend, metadataToken);
    VMPTR_TypeHandle vmThExact;
    ReadFromBuffer(pSend, vmThExact);
    VMPTR_TypeHandle vmThApprox;
    ReadFromBuffer(pSend, vmThApprox);
    DacDbiArrayList<FieldData> _pFieldList; // storage
    DacDbiArrayList<FieldData> * pFieldList = &_pFieldList;
    // pFieldList does not need to be copied on input
    SIZE_T _pObjectSize; // storage
    SIZE_T * pObjectSize = &_pObjectSize;
    // pObjectSize does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetInstantiationFieldInfo(vmDomainFile, metadataToken, vmThExact, vmThApprox, pFieldList, pObjectSize); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pFieldList);
    WriteToBuffer(pResult, pObjectSize);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetInstantiationFieldInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    void TypeHandleToExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, DebuggerIPCE_ExpandedTypeData * pTypeInfo)
void DDUnpack::Unpack_TypeHandleToExpandedTypeInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    AreValueTypesBoxed boxed;
    ReadFromBuffer(pSend, boxed);
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    VMPTR_TypeHandle vmTypeHandle;
    ReadFromBuffer(pSend, vmTypeHandle);
    DebuggerIPCE_ExpandedTypeData _pTypeInfo; // storage
    DebuggerIPCE_ExpandedTypeData * pTypeInfo = &_pTypeInfo;
    ReadFromBuffer(pSend, &_pTypeInfo); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->TypeHandleToExpandedTypeInfo(boxed, vmAppDomain, vmTypeHandle, pTypeInfo); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pTypeInfo);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method TypeHandleToExpandedTypeInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetObjectExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, CORDB_ADDRESS addr, DebuggerIPCE_ExpandedTypeData * pTypeInfo)
void DDUnpack::Unpack_GetObjectExpandedTypeInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    AreValueTypesBoxed boxed;
    ReadFromBuffer(pSend, boxed);
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    CORDB_ADDRESS addr;
    ReadFromBuffer(pSend, addr);
    DebuggerIPCE_ExpandedTypeData _pTypeInfo; // storage
    DebuggerIPCE_ExpandedTypeData * pTypeInfo = &_pTypeInfo;
    // pTypeInfo does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetObjectExpandedTypeInfo(boxed, vmAppDomain, addr, pTypeInfo); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pTypeInfo);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetObjectExpandedTypeInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_TypeHandle GetApproxTypeHandle(TypeInfoList * pTypeData)
void DDUnpack::Unpack_GetApproxTypeHandle(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    TypeInfoList _pTypeData; // storage
    TypeInfoList * pTypeData = &_pTypeData;
    ReadFromBuffer(pSend, &_pTypeData); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_TypeHandle _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetApproxTypeHandle(pTypeData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pTypeData);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetApproxTypeHandle

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_TypeHandle GetExactTypeHandle(DebuggerIPCE_ExpandedTypeData * pTypeData, ArgInfoList * pArgInfo)
void DDUnpack::Unpack_GetExactTypeHandle(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    DebuggerIPCE_ExpandedTypeData _pTypeData; // storage
    DebuggerIPCE_ExpandedTypeData * pTypeData = &_pTypeData;
    ReadFromBuffer(pSend, &_pTypeData); // serialize to storage
    ArgInfoList _pArgInfo; // storage
    ArgInfoList * pArgInfo = &_pArgInfo;
    ReadFromBuffer(pSend, &_pArgInfo); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_TypeHandle _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetExactTypeHandle(pTypeData, pArgInfo); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pTypeData);
    WriteToBuffer(pResult, pArgInfo);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetExactTypeHandle

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetMethodDescParams(VMPTR_AppDomain vmAppDomain, VMPTR_MethodDesc vmMethodDesc, GENERICS_TYPE_TOKEN genericsToken, UINT32 * pcGenericClassTypeParams, TypeParamsList * pGenericTypeParams)
void DDUnpack::Unpack_GetMethodDescParams(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    VMPTR_MethodDesc vmMethodDesc;
    ReadFromBuffer(pSend, vmMethodDesc);
    GENERICS_TYPE_TOKEN genericsToken;
    ReadFromBuffer(pSend, genericsToken);
    UINT32 _pcGenericClassTypeParams; // storage
    UINT32 * pcGenericClassTypeParams = &_pcGenericClassTypeParams;
    // pcGenericClassTypeParams does not need to be copied on input
    TypeParamsList _pGenericTypeParams; // storage
    TypeParamsList * pGenericTypeParams = &_pGenericTypeParams;
    // pGenericTypeParams does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetMethodDescParams(vmAppDomain, vmMethodDesc, genericsToken, pcGenericClassTypeParams, pGenericTypeParams); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pcGenericClassTypeParams);
    WriteToBuffer(pResult, pGenericTypeParams);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetMethodDescParams

//---------------------------------------------------------------------
// Unpacking stub for:
//    CORDB_ADDRESS GetThreadOrContextStaticAddress(VMPTR_FieldDesc vmField, VMPTR_Thread vmRuntimeThread)
void DDUnpack::Unpack_GetThreadOrContextStaticAddress(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_FieldDesc vmField;
    ReadFromBuffer(pSend, vmField);
    VMPTR_Thread vmRuntimeThread;
    ReadFromBuffer(pSend, vmRuntimeThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    CORDB_ADDRESS _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetThreadOrContextStaticAddress(vmField, vmRuntimeThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetThreadOrContextStaticAddress

//---------------------------------------------------------------------
// Unpacking stub for:
//    CORDB_ADDRESS GetCollectibleTypeStaticAddress(VMPTR_FieldDesc vmField, VMPTR_AppDomain vmAppDomain)
void DDUnpack::Unpack_GetCollectibleTypeStaticAddress(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_FieldDesc vmField;
    ReadFromBuffer(pSend, vmField);
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    CORDB_ADDRESS _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetCollectibleTypeStaticAddress(vmField, vmAppDomain); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetCollectibleTypeStaticAddress

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetEnCHangingFieldInfo(const EnCHangingFieldInfo * pEnCFieldInfo, FieldData * pFieldData, BOOL * pfStatic)
void DDUnpack::Unpack_GetEnCHangingFieldInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    EnCHangingFieldInfo _pEnCFieldInfo; // storage
    const EnCHangingFieldInfo * pEnCFieldInfo = &_pEnCFieldInfo;
    ReadFromBuffer(pSend, &_pEnCFieldInfo); // serialize to storage
    FieldData _pFieldData; // storage
    FieldData * pFieldData = &_pFieldData;
    // pFieldData does not need to be copied on input
    BOOL _pfStatic; // storage
    BOOL * pfStatic = &_pfStatic;
    // pfStatic does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetEnCHangingFieldInfo(pEnCFieldInfo, pFieldData, pfStatic); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pFieldData);
    WriteToBuffer(pResult, pfStatic);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetEnCHangingFieldInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetTypeHandleParams(VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, TypeParamsList * pParams)
void DDUnpack::Unpack_GetTypeHandleParams(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    VMPTR_TypeHandle vmTypeHandle;
    ReadFromBuffer(pSend, vmTypeHandle);
    TypeParamsList _pParams; // storage
    TypeParamsList * pParams = &_pParams;
    // pParams does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetTypeHandleParams(vmAppDomain, vmTypeHandle, pParams); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pParams);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetTypeHandleParams

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetSimpleType(VMPTR_AppDomain vmAppDomain, CorElementType simpleType, mdTypeDef * pMetadataToken, VMPTR_DomainFile * pVmDomainFile)
void DDUnpack::Unpack_GetSimpleType(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    CorElementType simpleType;
    ReadFromBuffer(pSend, simpleType);
    mdTypeDef _pMetadataToken; // storage
    mdTypeDef * pMetadataToken = &_pMetadataToken;
    // pMetadataToken does not need to be copied on input
    VMPTR_DomainFile _pVmDomainFile; // storage
    VMPTR_DomainFile * pVmDomainFile = &_pVmDomainFile;
    // pVmDomainFile does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetSimpleType(vmAppDomain, simpleType, pMetadataToken, pVmDomainFile); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pMetadataToken);
    WriteToBuffer(pResult, pVmDomainFile);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetSimpleType

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetTypedByRefInfo(CORDB_ADDRESS pTypedByRef, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData)
void DDUnpack::Unpack_GetTypedByRefInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS pTypedByRef;
    ReadFromBuffer(pSend, pTypedByRef);
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    DebuggerIPCE_ObjectData _pObjectData; // storage
    DebuggerIPCE_ObjectData * pObjectData = &_pObjectData;
    ReadFromBuffer(pSend, &_pObjectData); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetTypedByRefInfo(pTypedByRef, vmAppDomain, pObjectData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pObjectData);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetTypedByRefInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetStringData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData)
void DDUnpack::Unpack_GetStringData(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS objectAddress;
    ReadFromBuffer(pSend, objectAddress);
    DebuggerIPCE_ObjectData _pObjectData; // storage
    DebuggerIPCE_ObjectData * pObjectData = &_pObjectData;
    ReadFromBuffer(pSend, &_pObjectData); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetStringData(objectAddress, pObjectData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pObjectData);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetStringData

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetArrayData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData)
void DDUnpack::Unpack_GetArrayData(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS objectAddress;
    ReadFromBuffer(pSend, objectAddress);
    DebuggerIPCE_ObjectData _pObjectData; // storage
    DebuggerIPCE_ObjectData * pObjectData = &_pObjectData;
    ReadFromBuffer(pSend, &_pObjectData); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetArrayData(objectAddress, pObjectData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pObjectData);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetArrayData

//---------------------------------------------------------------------
// Unpacking stub for:
//    void GetBasicObjectInfo(CORDB_ADDRESS objectAddress, CorElementType type, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData)
void DDUnpack::Unpack_GetBasicObjectInfo(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS objectAddress;
    ReadFromBuffer(pSend, objectAddress);
    CorElementType type;
    ReadFromBuffer(pSend, type);
    VMPTR_AppDomain vmAppDomain;
    ReadFromBuffer(pSend, vmAppDomain);
    DebuggerIPCE_ObjectData _pObjectData; // storage
    DebuggerIPCE_ObjectData * pObjectData = &_pObjectData;
    ReadFromBuffer(pSend, &_pObjectData); // serialize to storage
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->GetBasicObjectInfo(objectAddress, type, vmAppDomain, pObjectData); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pObjectData);
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetBasicObjectInfo

//---------------------------------------------------------------------
// Unpacking stub for:
//    void TestCrst(VMPTR_Crst vmCrst)
void DDUnpack::Unpack_TestCrst(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Crst vmCrst;
    ReadFromBuffer(pSend, vmCrst);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->TestCrst(vmCrst); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method TestCrst

//---------------------------------------------------------------------
// Unpacking stub for:
//    void TestRWLock(VMPTR_SimpleRWLock vmRWLock)
void DDUnpack::Unpack_TestRWLock(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_SimpleRWLock vmRWLock;
    ReadFromBuffer(pSend, vmRWLock);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->TestRWLock(vmRWLock); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method TestRWLock

//---------------------------------------------------------------------
// Unpacking stub for:
//    CORDB_ADDRESS GetDebuggerControlBlockAddress()
void DDUnpack::Unpack_GetDebuggerControlBlockAddress(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    CORDB_ADDRESS _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetDebuggerControlBlockAddress(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetDebuggerControlBlockAddress

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_Object GetObjectFromRefPtr(CORDB_ADDRESS ptr)
void DDUnpack::Unpack_GetObjectFromRefPtr(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS ptr;
    ReadFromBuffer(pSend, ptr);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_Object _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetObjectFromRefPtr(ptr); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetObjectFromRefPtr

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_Object GetObject(CORDB_ADDRESS ptr)
void DDUnpack::Unpack_GetObject(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS ptr;
    ReadFromBuffer(pSend, ptr);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_Object _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetObject(ptr); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetObject

//---------------------------------------------------------------------
// Unpacking stub for:
//    VMPTR_OBJECTHANDLE GetVmObjectHandle(CORDB_ADDRESS handleAddress)
void DDUnpack::Unpack_GetVmObjectHandle(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS handleAddress;
    ReadFromBuffer(pSend, handleAddress);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    VMPTR_OBJECTHANDLE _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetVmObjectHandle(handleAddress); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetVmObjectHandle

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsVmObjectHandleValid(VMPTR_OBJECTHANDLE vmHandle)
void DDUnpack::Unpack_IsVmObjectHandleValid(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_OBJECTHANDLE vmHandle;
    ReadFromBuffer(pSend, vmHandle);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsVmObjectHandleValid(vmHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsVmObjectHandleValid

//---------------------------------------------------------------------
// Unpacking stub for:
//    ULONG GetAppDomainIdFromVmObjectHandle(VMPTR_OBJECTHANDLE vmHandle)
void DDUnpack::Unpack_GetAppDomainIdFromVmObjectHandle(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_OBJECTHANDLE vmHandle;
    ReadFromBuffer(pSend, vmHandle);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    ULONG _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetAppDomainIdFromVmObjectHandle(vmHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAppDomainIdFromVmObjectHandle

//---------------------------------------------------------------------
// Unpacking stub for:
//    CORDB_ADDRESS GetHandleAddressFromVmHandle(VMPTR_OBJECTHANDLE vmHandle)
void DDUnpack::Unpack_GetHandleAddressFromVmHandle(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_OBJECTHANDLE vmHandle;
    ReadFromBuffer(pSend, vmHandle);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    CORDB_ADDRESS _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetHandleAddressFromVmHandle(vmHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetHandleAddressFromVmHandle

//---------------------------------------------------------------------
// Unpacking stub for:
//    TargetBuffer GetObjectContents(VMPTR_Object obj)
void DDUnpack::Unpack_GetObjectContents(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Object obj;
    ReadFromBuffer(pSend, obj);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    TargetBuffer _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetObjectContents(obj); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetObjectContents

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateBlockingObjects(VMPTR_Thread vmThread, IDacDbiInterface::FP_BLOCKINGOBJECT_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateBlockingObjects(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        // Extra stuff for callback handlers
        m_pReal->EnumerateBlockingObjects(vmThread, GeneralEnumerationCallback, pResult);

    }
    EX_CATCH_HRESULT(hr);

    // Sentinel for callback list
    DWORD dw = 2; // Stop
    WriteToBuffer(pResult, dw); 
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateBlockingObjects

//---------------------------------------------------------------------
// Unpacking stub for:
//    MonitorLockInfo GetThreadOwningMonitorLock(VMPTR_Object vmObject)
void DDUnpack::Unpack_GetThreadOwningMonitorLock(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Object vmObject;
    ReadFromBuffer(pSend, vmObject);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    MonitorLockInfo _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetThreadOwningMonitorLock(vmObject); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetThreadOwningMonitorLock

//---------------------------------------------------------------------
// Unpacking stub for:
//    void EnumerateMonitorEventWaitList(VMPTR_Object vmObject, IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
void DDUnpack::Unpack_EnumerateMonitorEventWaitList(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Object vmObject;
    ReadFromBuffer(pSend, vmObject);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        // Extra stuff for callback handlers
        m_pReal->EnumerateMonitorEventWaitList(vmObject, GeneralEnumerationCallback, pResult);

    }
    EX_CATCH_HRESULT(hr);

    // Sentinel for callback list
    DWORD dw = 2; // Stop
    WriteToBuffer(pResult, dw); 
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method EnumerateMonitorEventWaitList

//---------------------------------------------------------------------
// Unpacking stub for:
//    BOOL IsManagedDebugEventPending()
void DDUnpack::Unpack_IsManagedDebugEventPending(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    BOOL _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsManagedDebugEventPending(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsManagedDebugEventPending

//---------------------------------------------------------------------
// Unpacking stub for:
//    bool GetMetaDataFileInfoFromPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwImageSize, bool & isNGEN, IStringHolder * pStrFilename)
void DDUnpack::Unpack_GetMetaDataFileInfoFromPEFile(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_PEFile vmPEFile;
    ReadFromBuffer(pSend, vmPEFile);
    DWORD dwTimeStamp;
    ReadFromBuffer(pSend, dwTimeStamp);
    DWORD dwImageSize;
    ReadFromBuffer(pSend, dwImageSize);
    bool isNGEN;
    ReadFromBuffer(pSend, isNGEN);
    StringCopyHolder _pStrFilename; // storage
    StringCopyHolder* pStrFilename = &_pStrFilename;
    // pStrFilename does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    bool _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetMetaDataFileInfoFromPEFile(vmPEFile, dwTimeStamp, dwImageSize, isNGEN, pStrFilename); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, dwTimeStamp);
    WriteToBuffer(pResult, dwImageSize);
    WriteToBuffer(pResult, isNGEN);
    WriteToBuffer(pResult, pStrFilename);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetMetaDataFileInfoFromPEFile

//---------------------------------------------------------------------
// Unpacking stub for:
//    bool GetILImageInfoFromNgenPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwSize, IStringHolder * pStrFilename)
void DDUnpack::Unpack_GetILImageInfoFromNgenPEFile(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_PEFile vmPEFile;
    ReadFromBuffer(pSend, vmPEFile);
    DWORD dwTimeStamp;
    ReadFromBuffer(pSend, dwTimeStamp);
    DWORD dwSize;
    ReadFromBuffer(pSend, dwSize);
    StringCopyHolder _pStrFilename; // storage
    StringCopyHolder* pStrFilename = &_pStrFilename;
    // pStrFilename does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    bool _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetILImageInfoFromNgenPEFile(vmPEFile, dwTimeStamp, dwSize, pStrFilename); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, dwTimeStamp);
    WriteToBuffer(pResult, dwSize);
    WriteToBuffer(pResult, pStrFilename);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetILImageInfoFromNgenPEFile

//---------------------------------------------------------------------
// Unpacking stub for:
//    bool IsThreadSuspendedOrHijacked(VMPTR_Thread vmThread)
void DDUnpack::Unpack_IsThreadSuspendedOrHijacked(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    VMPTR_Thread vmThread;
    ReadFromBuffer(pSend, vmThread);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    bool _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsThreadSuspendedOrHijacked(vmThread); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsThreadSuspendedOrHijacked

//---------------------------------------------------------------------
// Unpacking stub for:
//    bool AreGCStructuresValid()
void DDUnpack::Unpack_AreGCStructuresValid(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    bool _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->AreGCStructuresValid(); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method AreGCStructuresValid

//---------------------------------------------------------------------
// Unpacking stub for:
//    HRESULT CreateHeapWalk(HeapWalkHandle * pHandle)
void DDUnpack::Unpack_CreateHeapWalk(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    HeapWalkHandle _pHandle; // storage
    HeapWalkHandle * pHandle = &_pHandle;
    // pHandle does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    HRESULT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->CreateHeapWalk(pHandle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pHandle);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method CreateHeapWalk

//---------------------------------------------------------------------
// Unpacking stub for:
//    void DeleteHeapWalk(HeapWalkHandle handle)
void DDUnpack::Unpack_DeleteHeapWalk(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    HeapWalkHandle handle;
    ReadFromBuffer(pSend, handle);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        m_pReal->DeleteHeapWalk(handle); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method DeleteHeapWalk

//---------------------------------------------------------------------
// Unpacking stub for:
//    HRESULT WalkHeap(HeapWalkHandle handle, ULONG count, COR_HEAPOBJECT * objects, ULONG * pFetched)
void DDUnpack::Unpack_WalkHeap(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    HeapWalkHandle handle;
    ReadFromBuffer(pSend, handle);
    ULONG count;
    ReadFromBuffer(pSend, count);
    COR_HEAPOBJECT _objects; // storage
    COR_HEAPOBJECT * objects = &_objects;
    // objects does not need to be copied on input
    ULONG _pFetched; // storage
    ULONG * pFetched = &_pFetched;
    // pFetched does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    HRESULT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->WalkHeap(handle, count, objects, pFetched); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, objects);
    WriteToBuffer(pResult, pFetched);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method WalkHeap

//---------------------------------------------------------------------
// Unpacking stub for:
//    HRESULT GetHeapSegments(DacDbiArrayList<COR_SEGMENT> * pSegments)
void DDUnpack::Unpack_GetHeapSegments(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    DacDbiArrayList<COR_SEGMENT> _pSegments; // storage
    DacDbiArrayList<COR_SEGMENT> * pSegments = &_pSegments;
    // pSegments does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    HRESULT _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetHeapSegments(pSegments); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pSegments);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetHeapSegments

//---------------------------------------------------------------------
// Unpacking stub for:
//    bool IsValidObject(CORDB_ADDRESS obj)
void DDUnpack::Unpack_IsValidObject(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS obj;
    ReadFromBuffer(pSend, obj);
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    bool _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->IsValidObject(obj); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method IsValidObject

//---------------------------------------------------------------------
// Unpacking stub for:
//    bool GetAppDomainForObject(CORDB_ADDRESS obj, VMPTR_AppDomain * pApp, VMPTR_Module * pModule, VMPTR_DomainFile * pDomainFile)
void DDUnpack::Unpack_GetAppDomainForObject(ReadBuffer * pSend, WriteBuffer * pResult)
{
    // Initialize a holder to swap in & out the g_pAllocator
    DD_UNPACK_ENTER_MAY_THROW;

    // Parameters
    CORDB_ADDRESS obj;
    ReadFromBuffer(pSend, obj);
    VMPTR_AppDomain _pApp; // storage
    VMPTR_AppDomain * pApp = &_pApp;
    // pApp does not need to be copied on input
    VMPTR_Module _pModule; // storage
    VMPTR_Module * pModule = &_pModule;
    // pModule does not need to be copied on input
    VMPTR_DomainFile _pDomainFile; // storage
    VMPTR_DomainFile * pDomainFile = &_pDomainFile;
    // pDomainFile does not need to be copied on input
    _ASSERTE(pSend->IsAtEnd()); // ensure entire buffer is read
    bool _retValue; // return result

    //
    // Make the actual call
    //
    HRESULT hr = S_OK;
    EX_TRY
    {
        _retValue = m_pReal->GetAppDomainForObject(obj, pApp, pModule, pDomainFile); // actual call

    }
    EX_CATCH_HRESULT(hr);
    // Marshal parameters back
    WriteToBuffer(pResult, pApp);
    WriteToBuffer(pResult, pModule);
    WriteToBuffer(pResult, pDomainFile);
    WriteToBuffer(pResult, hr); // exception result
    WriteToBuffer(pResult, _retValue); // copy back return result
    // Dtors for any DacDbi structures that we marshalled get run here.
} // end method GetAppDomainForObject


//
// Handler 
// 
void DDUnpack::HandleDDMessage(ReadBuffer * pSend, WriteBuffer * pResult)
{
    DD_MessageId id;
    ReadFromBuffer(pSend, id);

    switch(id) 
    {

    case DDID_CheckDbiVersion:
        Unpack_CheckDbiVersion(pSend, pResult);
        break;

    case DDID_FlushCache:
        Unpack_FlushCache(pSend, pResult);
        break;

    case DDID_DacSetTargetConsistencyChecks:
        Unpack_DacSetTargetConsistencyChecks(pSend, pResult);
        break;

    case DDID_Destroy:
        Unpack_Destroy(pSend, pResult);
        break;

    case DDID_IsLeftSideInitialized:
        Unpack_IsLeftSideInitialized(pSend, pResult);
        break;

    case DDID_GetAppDomainFromId:
        Unpack_GetAppDomainFromId(pSend, pResult);
        break;

    case DDID_GetAppDomainId:
        Unpack_GetAppDomainId(pSend, pResult);
        break;

    case DDID_GetAppDomainObject:
        Unpack_GetAppDomainObject(pSend, pResult);
        break;

    case DDID_IsDefaultDomain:
        Unpack_IsDefaultDomain(pSend, pResult);
        break;

    case DDID_GetAssemblyFromDomainAssembly:
        Unpack_GetAssemblyFromDomainAssembly(pSend, pResult);
        break;

    case DDID_IsAssemblyFullyTrusted:
        Unpack_IsAssemblyFullyTrusted(pSend, pResult);
        break;

    case DDID_GetAppDomainFullName:
        Unpack_GetAppDomainFullName(pSend, pResult);
        break;

    case DDID_GetModuleSimpleName:
        Unpack_GetModuleSimpleName(pSend, pResult);
        break;

    case DDID_GetAssemblyPath:
        Unpack_GetAssemblyPath(pSend, pResult);
        break;

    case DDID_ResolveTypeReference:
        Unpack_ResolveTypeReference(pSend, pResult);
        break;

    case DDID_GetModulePath:
        Unpack_GetModulePath(pSend, pResult);
        break;

    case DDID_GetModuleNGenPath:
        Unpack_GetModuleNGenPath(pSend, pResult);
        break;

    case DDID_GetMetadata:
        Unpack_GetMetadata(pSend, pResult);
        break;

    case DDID_GetSymbolsBuffer:
        Unpack_GetSymbolsBuffer(pSend, pResult);
        break;

    case DDID_GetModuleData:
        Unpack_GetModuleData(pSend, pResult);
        break;

    case DDID_GetDomainFileData:
        Unpack_GetDomainFileData(pSend, pResult);
        break;

    case DDID_GetModuleForDomainFile:
        Unpack_GetModuleForDomainFile(pSend, pResult);
        break;

    case DDID_GetAddressType:
        Unpack_GetAddressType(pSend, pResult);
        break;

    case DDID_IsTransitionStub:
        Unpack_IsTransitionStub(pSend, pResult);
        break;

    case DDID_GetCompilerFlags:
        Unpack_GetCompilerFlags(pSend, pResult);
        break;

    case DDID_SetCompilerFlags:
        Unpack_SetCompilerFlags(pSend, pResult);
        break;

    case DDID_EnumerateAppDomains:
        Unpack_EnumerateAppDomains(pSend, pResult);
        break;

    case DDID_EnumerateAssembliesInAppDomain:
        Unpack_EnumerateAssembliesInAppDomain(pSend, pResult);
        break;

    case DDID_EnumerateModulesInAssembly:
        Unpack_EnumerateModulesInAssembly(pSend, pResult);
        break;

    case DDID_RequestSyncAtEvent:
        Unpack_RequestSyncAtEvent(pSend, pResult);
        break;

    case DDID_MarkDebuggerAttachPending:
        Unpack_MarkDebuggerAttachPending(pSend, pResult);
        break;

    case DDID_MarkDebuggerAttached:
        Unpack_MarkDebuggerAttached(pSend, pResult);
        break;

    case DDID_Hijack:
        Unpack_Hijack(pSend, pResult);
        break;

    case DDID_EnumerateConnections:
        Unpack_EnumerateConnections(pSend, pResult);
        break;

    case DDID_EnumerateThreads:
        Unpack_EnumerateThreads(pSend, pResult);
        break;

    case DDID_IsThreadMarkedDead:
        Unpack_IsThreadMarkedDead(pSend, pResult);
        break;

    case DDID_GetThreadHandle:
        Unpack_GetThreadHandle(pSend, pResult);
        break;

    case DDID_GetThreadObject:
        Unpack_GetThreadObject(pSend, pResult);
        break;

    case DDID_SetDebugState:
        Unpack_SetDebugState(pSend, pResult);
        break;

    case DDID_HasUnhandledException:
        Unpack_HasUnhandledException(pSend, pResult);
        break;

    case DDID_GetUserState:
        Unpack_GetUserState(pSend, pResult);
        break;

    case DDID_GetConnectionID:
        Unpack_GetConnectionID(pSend, pResult);
        break;

    case DDID_GetTaskID:
        Unpack_GetTaskID(pSend, pResult);
        break;

    case DDID_TryGetVolatileOSThreadID:
        Unpack_TryGetVolatileOSThreadID(pSend, pResult);
        break;

    case DDID_GetUniqueThreadID:
        Unpack_GetUniqueThreadID(pSend, pResult);
        break;

    case DDID_GetCurrentException:
        Unpack_GetCurrentException(pSend, pResult);
        break;

    case DDID_GetCurrentCustomDebuggerNotification:
        Unpack_GetCurrentCustomDebuggerNotification(pSend, pResult);
        break;

    case DDID_GetCurrentAppDomain:
        Unpack_GetCurrentAppDomain(pSend, pResult);
        break;

    case DDID_ResolveAssembly:
        Unpack_ResolveAssembly(pSend, pResult);
        break;

    case DDID_GetNativeCodeSequencePointsAndVarInfo:
        Unpack_GetNativeCodeSequencePointsAndVarInfo(pSend, pResult);
        break;

    case DDID_GetManagedStoppedContext:
        Unpack_GetManagedStoppedContext(pSend, pResult);
        break;

    case DDID_CreateStackWalk:
        Unpack_CreateStackWalk(pSend, pResult);
        break;

    case DDID_DeleteStackWalk:
        Unpack_DeleteStackWalk(pSend, pResult);
        break;

    case DDID_GetStackWalkCurrentContext:
        Unpack_GetStackWalkCurrentContext(pSend, pResult);
        break;

    case DDID_SetStackWalkCurrentContext:
        Unpack_SetStackWalkCurrentContext(pSend, pResult);
        break;

    case DDID_UnwindStackWalkFrame:
        Unpack_UnwindStackWalkFrame(pSend, pResult);
        break;

    case DDID_CheckContext:
        Unpack_CheckContext(pSend, pResult);
        break;

    case DDID_GetStackWalkCurrentFrameInfo:
        Unpack_GetStackWalkCurrentFrameInfo(pSend, pResult);
        break;

    case DDID_GetCountOfInternalFrames:
        Unpack_GetCountOfInternalFrames(pSend, pResult);
        break;

    case DDID_EnumerateInternalFrames:
        Unpack_EnumerateInternalFrames(pSend, pResult);
        break;

    case DDID_IsMatchingParentFrame:
        Unpack_IsMatchingParentFrame(pSend, pResult);
        break;

    case DDID_GetStackParameterSize:
        Unpack_GetStackParameterSize(pSend, pResult);
        break;

    case DDID_GetFramePointer:
        Unpack_GetFramePointer(pSend, pResult);
        break;

    case DDID_IsLeafFrame:
        Unpack_IsLeafFrame(pSend, pResult);
        break;

    case DDID_GetContext:
        Unpack_GetContext(pSend, pResult);
        break;

    case DDID_ConvertContextToDebuggerRegDisplay:
        Unpack_ConvertContextToDebuggerRegDisplay(pSend, pResult);
        break;

    case DDID_IsILStubOrLCGMethod:
        Unpack_IsILStubOrLCGMethod(pSend, pResult);
        break;

    case DDID_GetVarArgSig:
        Unpack_GetVarArgSig(pSend, pResult);
        break;

    case DDID_ResolveExactGenericArgsToken:
        Unpack_ResolveExactGenericArgsToken(pSend, pResult);
        break;

    case DDID_GetILCodeAndSig:
        Unpack_GetILCodeAndSig(pSend, pResult);
        break;

    case DDID_GetNativeCodeInfo:
        Unpack_GetNativeCodeInfo(pSend, pResult);
        break;

    case DDID_GetNativeCodeInfoForAddr:
        Unpack_GetNativeCodeInfoForAddr(pSend, pResult);
        break;

    case DDID_GetClassInfo:
        Unpack_GetClassInfo(pSend, pResult);
        break;

    case DDID_GetInstantiationFieldInfo:
        Unpack_GetInstantiationFieldInfo(pSend, pResult);
        break;

    case DDID_TypeHandleToExpandedTypeInfo:
        Unpack_TypeHandleToExpandedTypeInfo(pSend, pResult);
        break;

    case DDID_GetObjectExpandedTypeInfo:
        Unpack_GetObjectExpandedTypeInfo(pSend, pResult);
        break;

    case DDID_GetApproxTypeHandle:
        Unpack_GetApproxTypeHandle(pSend, pResult);
        break;

    case DDID_GetExactTypeHandle:
        Unpack_GetExactTypeHandle(pSend, pResult);
        break;

    case DDID_GetMethodDescParams:
        Unpack_GetMethodDescParams(pSend, pResult);
        break;

    case DDID_GetThreadOrContextStaticAddress:
        Unpack_GetThreadOrContextStaticAddress(pSend, pResult);
        break;

    case DDID_GetCollectibleTypeStaticAddress:
        Unpack_GetCollectibleTypeStaticAddress(pSend, pResult);
        break;

    case DDID_GetEnCHangingFieldInfo:
        Unpack_GetEnCHangingFieldInfo(pSend, pResult);
        break;

    case DDID_GetTypeHandleParams:
        Unpack_GetTypeHandleParams(pSend, pResult);
        break;

    case DDID_GetSimpleType:
        Unpack_GetSimpleType(pSend, pResult);
        break;

    case DDID_GetTypedByRefInfo:
        Unpack_GetTypedByRefInfo(pSend, pResult);
        break;

    case DDID_GetStringData:
        Unpack_GetStringData(pSend, pResult);
        break;

    case DDID_GetArrayData:
        Unpack_GetArrayData(pSend, pResult);
        break;

    case DDID_GetBasicObjectInfo:
        Unpack_GetBasicObjectInfo(pSend, pResult);
        break;

    case DDID_TestCrst:
        Unpack_TestCrst(pSend, pResult);
        break;

    case DDID_TestRWLock:
        Unpack_TestRWLock(pSend, pResult);
        break;

    case DDID_GetDebuggerControlBlockAddress:
        Unpack_GetDebuggerControlBlockAddress(pSend, pResult);
        break;

    case DDID_GetObjectFromRefPtr:
        Unpack_GetObjectFromRefPtr(pSend, pResult);
        break;

    case DDID_GetObject:
        Unpack_GetObject(pSend, pResult);
        break;

    case DDID_GetVmObjectHandle:
        Unpack_GetVmObjectHandle(pSend, pResult);
        break;

    case DDID_IsVmObjectHandleValid:
        Unpack_IsVmObjectHandleValid(pSend, pResult);
        break;

    case DDID_GetAppDomainIdFromVmObjectHandle:
        Unpack_GetAppDomainIdFromVmObjectHandle(pSend, pResult);
        break;

    case DDID_GetHandleAddressFromVmHandle:
        Unpack_GetHandleAddressFromVmHandle(pSend, pResult);
        break;

    case DDID_GetObjectContents:
        Unpack_GetObjectContents(pSend, pResult);
        break;

    case DDID_EnumerateBlockingObjects:
        Unpack_EnumerateBlockingObjects(pSend, pResult);
        break;

    case DDID_GetThreadOwningMonitorLock:
        Unpack_GetThreadOwningMonitorLock(pSend, pResult);
        break;

    case DDID_EnumerateMonitorEventWaitList:
        Unpack_EnumerateMonitorEventWaitList(pSend, pResult);
        break;

    case DDID_IsManagedDebugEventPending:
        Unpack_IsManagedDebugEventPending(pSend, pResult);
        break;

    case DDID_GetMetaDataFileInfoFromPEFile:
        Unpack_GetMetaDataFileInfoFromPEFile(pSend, pResult);
        break;

    case DDID_GetILImageInfoFromNgenPEFile:
        Unpack_GetILImageInfoFromNgenPEFile(pSend, pResult);
        break;

    case DDID_IsThreadSuspendedOrHijacked:
        Unpack_IsThreadSuspendedOrHijacked(pSend, pResult);
        break;

    case DDID_AreGCStructuresValid:
        Unpack_AreGCStructuresValid(pSend, pResult);
        break;

    case DDID_CreateHeapWalk:
        Unpack_CreateHeapWalk(pSend, pResult);
        break;

    case DDID_DeleteHeapWalk:
        Unpack_DeleteHeapWalk(pSend, pResult);
        break;

    case DDID_WalkHeap:
        Unpack_WalkHeap(pSend, pResult);
        break;

    case DDID_GetHeapSegments:
        Unpack_GetHeapSegments(pSend, pResult);
        break;

    case DDID_IsValidObject:
        Unpack_IsValidObject(pSend, pResult);
        break;

    case DDID_GetAppDomainForObject:
        Unpack_GetAppDomainForObject(pSend, pResult);
        break;


    } // end switch
} // end HandleDDMessage method

#endif //FEATURE_DBGIPC_TRANSPORT_VM

// end of file
