//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information. 
//

// Unpacker
// 
// Lives on EE side of the fence
//
// Note that this file is generated by ndp\clr\src\Debug\tools\BuildDDMarshal\.  
// Changes should be made to output\DDUnpack_template.h in that directory.
// 


#ifndef _DDUNPACK_H_
#define _DDUNPACK_H_

#if defined(FEATURE_DBGIPC_TRANSPORT_VM)

#include "ddmarshalutil.h"
#include "ddshared.h"


// This technique is now misnamed, but I am still using it to lower code churn.
// When handing memory back and forth between DAC and DBI we use this (forDbi) new variant
// to ensure that everything goes in the correct heap. In DBI it resolves to new, and in DAC
// it resolves to calling into a special allocator that DBI passed over that ultimately also
// calls DBI new. A few types such as DacDbiArrayList get included on both sides of the DLL
// boundary and they assume there will be a (forDbi) new variant available to them.
//
//     Now however we have a new in-proc consumer of DAC and again we need to pass memory blocks
// to it. The most straightforward technique is to consume DAC exactly how DBI does, thus mimicing
// DBI's new variant here so that all the types which straddle the boundary can continue using
// it. At some point we might want to change the naming to something more general... 'forDacCaller'
// perhaps. I don't consider the technique a workaround, just the naming is overly specific.

#define forDbi (*(forDbiWorker *)NULL)

// for dbi we just default to new, but we need to have these defined for both dac and dbi
inline void * operator new(size_t lenBytes, const forDbiWorker &)
{
    void * result = new BYTE[lenBytes];
    if (result == NULL) 
    {
        ThrowOutOfMemory();
    }
    return result;
}

inline void * operator new[](size_t lenBytes, const forDbiWorker &)
{
    void * result = new BYTE[lenBytes];
    if (result == NULL) 
    {
        ThrowOutOfMemory();
    }
    return result;
}

// Helper to delete memory used with the IDacDbiInterface::IAllocator  interface.
template<class T> inline
void DeleteDbiMemory(T *p)
{
    delete p;
}


// Header for unpacking 
// 
class DDUnpack
    {
    protected:
        IDacDbiInterface * m_pReal;
        IDacDbiInterface::IAllocator * m_pAllocator;
    public:
        DDUnpack(IDacDbiInterface * pReal, IDacDbiInterface::IAllocator * pAllocator)
        {
            m_pReal = pReal;
            m_pAllocator = pAllocator;
        }

        // Main entry point
        // This will then delegate to the proper unpacking stubs.
        void HandleDDMessage(ReadBuffer * pSend, WriteBuffer * pResult);


        //
        // Stubs 
        // 

//---------------------------------------------------------------------
// Unpacking stubs
    // HRESULT CheckDbiVersion(const DbiVersion * pVersion)
    void Unpack_CheckDbiVersion(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetLocalInterfaceHashAndTimestamp(DWORD & hash1, DWORD & hash2, DWORD & hash3, DWORD & hash4, DWORD & timestamp1, DWORD & timestamp2)
    void Unpack_GetLocalInterfaceHashAndTimestamp(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetRemoteInterfaceHashAndTimestamp(DWORD & hash1, DWORD & hash2, DWORD & hash3, DWORD & hash4, DWORD & timestamp1, DWORD & timestamp2)
    void Unpack_GetRemoteInterfaceHashAndTimestamp(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT FlushCache()
    void Unpack_FlushCache(ReadBuffer * pSend, WriteBuffer * pResult);

    // void DacSetTargetConsistencyChecks(bool fEnableAsserts)
    void Unpack_DacSetTargetConsistencyChecks(ReadBuffer * pSend, WriteBuffer * pResult);

    // void Destroy()
    void Unpack_Destroy(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsLeftSideInitialized()
    void Unpack_IsLeftSideInitialized(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_AppDomain GetAppDomainFromId(ULONG appdomainId)
    void Unpack_GetAppDomainFromId(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG GetAppDomainId(VMPTR_AppDomain vmAppDomain)
    void Unpack_GetAppDomainId(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetAppDomainObject(VMPTR_AppDomain vmAppDomain)
    void Unpack_GetAppDomainObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsDefaultDomain(VMPTR_AppDomain vmAppDomain)
    void Unpack_IsDefaultDomain(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetAssemblyFromDomainAssembly(VMPTR_DomainAssembly vmDomainAssembly, VMPTR_Assembly * vmAssembly)
    void Unpack_GetAssemblyFromDomainAssembly(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsAssemblyFullyTrusted(VMPTR_DomainAssembly vmDomainAssembly)
    void Unpack_IsAssemblyFullyTrusted(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetAppDomainFullName(VMPTR_AppDomain vmAppDomain, IStringHolder * pStrName)
    void Unpack_GetAppDomainFullName(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetModuleSimpleName(VMPTR_Module vmModule, IStringHolder * pStrFilename)
    void Unpack_GetModuleSimpleName(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL GetAssemblyPath(VMPTR_Assembly vmAssembly, IStringHolder * pStrFilename)
    void Unpack_GetAssemblyPath(ReadBuffer * pSend, WriteBuffer * pResult);

    // void ResolveTypeReference(const TypeRefData * pTypeRefInfo, TypeRefData * pTargetRefInfo)
    void Unpack_ResolveTypeReference(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL GetModulePath(VMPTR_Module vmModule, IStringHolder * pStrFilename)
    void Unpack_GetModulePath(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL GetModuleNGenPath(VMPTR_Module vmModule, IStringHolder * pStrFilename)
    void Unpack_GetModuleNGenPath(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetMetadata(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer)
    void Unpack_GetMetadata(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetSymbolsBuffer(VMPTR_Module vmModule, TargetBuffer * pTargetBuffer, IDacDbiInterface::SymbolFormat * pSymbolFormat)
    void Unpack_GetSymbolsBuffer(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetModuleData(VMPTR_Module vmModule, ModuleInfo * pData)
    void Unpack_GetModuleData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetDomainFileData(VMPTR_DomainFile vmDomainFile, DomainFileInfo * pData)
    void Unpack_GetDomainFileData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetModuleForDomainFile(VMPTR_DomainFile vmDomainFile, VMPTR_Module * pModule)
    void Unpack_GetModuleForDomainFile(ReadBuffer * pSend, WriteBuffer * pResult);

    // IDacDbiInterface::AddressType GetAddressType(CORDB_ADDRESS address)
    void Unpack_GetAddressType(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsTransitionStub(CORDB_ADDRESS address)
    void Unpack_IsTransitionStub(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL * pfAllowJITOpts, BOOL * pfEnableEnC)
    void Unpack_GetCompilerFlags(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT SetCompilerFlags(VMPTR_DomainFile vmDomainFile, BOOL fAllowJitOpts, BOOL fEnableEnC)
    void Unpack_SetCompilerFlags(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateAppDomains(IDacDbiInterface::FP_APPDOMAIN_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateAppDomains(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateAssembliesInAppDomain(VMPTR_AppDomain vmAppDomain, IDacDbiInterface::FP_ASSEMBLY_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateAssembliesInAppDomain(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateModulesInAssembly(VMPTR_DomainAssembly vmAssembly, IDacDbiInterface::FP_MODULE_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateModulesInAssembly(ReadBuffer * pSend, WriteBuffer * pResult);

    // void RequestSyncAtEvent()
    void Unpack_RequestSyncAtEvent(ReadBuffer * pSend, WriteBuffer * pResult);

    // void MarkDebuggerAttachPending()
    void Unpack_MarkDebuggerAttachPending(ReadBuffer * pSend, WriteBuffer * pResult);

    // void MarkDebuggerAttached(BOOL fAttached)
    void Unpack_MarkDebuggerAttached(ReadBuffer * pSend, WriteBuffer * pResult);

    // void Hijack(VMPTR_Thread vmThread, ULONG32 dwThreadId, const EXCEPTION_RECORD * pRecord, T_CONTEXT * pOriginalContext, ULONG32 cbSizeContext, EHijackReason::EHijackReason reason, void * pUserData, CORDB_ADDRESS * pRemoteContextAddr)
    void Unpack_Hijack(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateConnections(IDacDbiInterface::FP_CONNECTION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateConnections(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateThreads(IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateThreads(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool IsThreadMarkedDead(VMPTR_Thread vmThread)
    void Unpack_IsThreadMarkedDead(ReadBuffer * pSend, WriteBuffer * pResult);

    // HANDLE GetThreadHandle(VMPTR_Thread vmThread)
    void Unpack_GetThreadHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetThreadObject(VMPTR_Thread vmThread)
    void Unpack_GetThreadObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // void SetDebugState(VMPTR_Thread vmThread, CorDebugThreadState debugState)
    void Unpack_SetDebugState(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL HasUnhandledException(VMPTR_Thread vmThread)
    void Unpack_HasUnhandledException(ReadBuffer * pSend, WriteBuffer * pResult);

    // CorDebugUserState GetUserState(VMPTR_Thread vmThread)
    void Unpack_GetUserState(ReadBuffer * pSend, WriteBuffer * pResult);

    // CONNID GetConnectionID(VMPTR_Thread vmThread)
    void Unpack_GetConnectionID(ReadBuffer * pSend, WriteBuffer * pResult);

    // TASKID GetTaskID(VMPTR_Thread vmThread)
    void Unpack_GetTaskID(ReadBuffer * pSend, WriteBuffer * pResult);

    // DWORD TryGetVolatileOSThreadID(VMPTR_Thread vmThread)
    void Unpack_TryGetVolatileOSThreadID(ReadBuffer * pSend, WriteBuffer * pResult);

    // DWORD GetUniqueThreadID(VMPTR_Thread vmThread)
    void Unpack_GetUniqueThreadID(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetCurrentException(VMPTR_Thread vmThread)
    void Unpack_GetCurrentException(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetCurrentCustomDebuggerNotification(VMPTR_Thread vmThread)
    void Unpack_GetCurrentCustomDebuggerNotification(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_AppDomain GetCurrentAppDomain(VMPTR_Thread vmThread)
    void Unpack_GetCurrentAppDomain(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_DomainAssembly ResolveAssembly(VMPTR_DomainFile vmScope, mdToken tkAssemblyRef)
    void Unpack_ResolveAssembly(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetNativeCodeSequencePointsAndVarInfo(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS startAddress, BOOL fCodeAvailabe, NativeVarData * pNativeVarData, SequencePoints * pSequencePoints)
    void Unpack_GetNativeCodeSequencePointsAndVarInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_CONTEXT GetManagedStoppedContext(VMPTR_Thread vmThread)
    void Unpack_GetManagedStoppedContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // void CreateStackWalk(VMPTR_Thread vmThread, DT_CONTEXT * pInternalContextBuffer, StackWalkHandle * ppSFIHandle)
    void Unpack_CreateStackWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // void DeleteStackWalk(StackWalkHandle ppSFIHandle)
    void Unpack_DeleteStackWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetStackWalkCurrentContext(StackWalkHandle pSFIHandle, DT_CONTEXT * pContext)
    void Unpack_GetStackWalkCurrentContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // void SetStackWalkCurrentContext(VMPTR_Thread vmThread, StackWalkHandle pSFIHandle, CorDebugSetContextFlag flag, DT_CONTEXT * pContext)
    void Unpack_SetStackWalkCurrentContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL UnwindStackWalkFrame(StackWalkHandle pSFIHandle)
    void Unpack_UnwindStackWalkFrame(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT CheckContext(VMPTR_Thread vmThread, const DT_CONTEXT * pContext)
    void Unpack_CheckContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // IDacDbiInterface::FrameType GetStackWalkCurrentFrameInfo(StackWalkHandle pSFIHandle, DebuggerIPCE_STRData * pFrameData)
    void Unpack_GetStackWalkCurrentFrameInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG32 GetCountOfInternalFrames(VMPTR_Thread vmThread)
    void Unpack_GetCountOfInternalFrames(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateInternalFrames(VMPTR_Thread vmThread, IDacDbiInterface::FP_INTERNAL_FRAME_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateInternalFrames(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsMatchingParentFrame(FramePointer fpToCheck, FramePointer fpParent)
    void Unpack_IsMatchingParentFrame(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG32 GetStackParameterSize(CORDB_ADDRESS controlPC)
    void Unpack_GetStackParameterSize(ReadBuffer * pSend, WriteBuffer * pResult);

    // FramePointer GetFramePointer(StackWalkHandle pSFIHandle)
    void Unpack_GetFramePointer(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsLeafFrame(VMPTR_Thread vmThread, const DT_CONTEXT * pContext)
    void Unpack_IsLeafFrame(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetContext(VMPTR_Thread vmThread, DT_CONTEXT * pContextBuffer)
    void Unpack_GetContext(ReadBuffer * pSend, WriteBuffer * pResult);

    // void ConvertContextToDebuggerRegDisplay(const DT_CONTEXT * pInContext, DebuggerREGDISPLAY * pOutDRD, BOOL fActive)
    void Unpack_ConvertContextToDebuggerRegDisplay(ReadBuffer * pSend, WriteBuffer * pResult);

    // IDacDbiInterface::DynamicMethodType IsILStubOrLCGMethod(VMPTR_MethodDesc vmMethodDesc)
    void Unpack_IsILStubOrLCGMethod(ReadBuffer * pSend, WriteBuffer * pResult);

    // TargetBuffer GetVarArgSig(CORDB_ADDRESS VASigCookieAddr, CORDB_ADDRESS * pArgBase)
    void Unpack_GetVarArgSig(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL RequiresAlign8(VMPTR_TypeHandle thExact)
    void Unpack_RequiresAlign8(ReadBuffer * pSend, WriteBuffer * pResult);

    // GENERICS_TYPE_TOKEN ResolveExactGenericArgsToken(DWORD dwExactGenericArgsTokenIndex, GENERICS_TYPE_TOKEN rawToken)
    void Unpack_ResolveExactGenericArgsToken(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetILCodeAndSig(VMPTR_DomainFile vmDomainFile, mdToken functionToken, TargetBuffer * pCodeInfo, mdToken * pLocalSigToken)
    void Unpack_GetILCodeAndSig(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetNativeCodeInfo(VMPTR_DomainFile vmDomainFile, mdToken functionToken, NativeCodeFunctionData * pCodeInfo)
    void Unpack_GetNativeCodeInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetNativeCodeInfoForAddr(VMPTR_MethodDesc vmMethodDesc, CORDB_ADDRESS hotCodeStartAddr, NativeCodeFunctionData * pCodeInfo)
    void Unpack_GetNativeCodeInfoForAddr(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetClassInfo(VMPTR_AppDomain vmAppDomain, VMPTR_Module vmModule, mdTypeDef metadataToken, VMPTR_TypeHandle thExact, VMPTR_TypeHandle thApprox, ClassInfo * pData)
    void Unpack_GetClassInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetInstantiationFieldInfo(VMPTR_DomainFile vmDomainFile, mdTypeDef metadataToken, VMPTR_TypeHandle vmThExact, VMPTR_TypeHandle vmThApprox, DacDbiArrayList<FieldData> * pFieldList, SIZE_T * pObjectSize)
    void Unpack_GetInstantiationFieldInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void TypeHandleToExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, DebuggerIPCE_ExpandedTypeData * pTypeInfo)
    void Unpack_TypeHandleToExpandedTypeInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetObjectExpandedTypeInfo(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, CORDB_ADDRESS addr, DebuggerIPCE_ExpandedTypeData * pTypeInfo)
    void Unpack_GetObjectExpandedTypeInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetObjectExpandedTypeInfoFromID(AreValueTypesBoxed boxed, VMPTR_AppDomain vmAppDomain, COR_TYPEID id, DebuggerIPCE_ExpandedTypeData * pTypeInfo)
    void Unpack_GetObjectExpandedTypeInfoFromID(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_TypeHandle GetApproxTypeHandle(TypeInfoList * pTypeData)
    void Unpack_GetApproxTypeHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT GetExactTypeHandle(DebuggerIPCE_ExpandedTypeData * pTypeData, ArgInfoList * pArgInfo, VMPTR_TypeHandle & vmTypeHandle)
    void Unpack_GetExactTypeHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetMethodDescParams(VMPTR_AppDomain vmAppDomain, VMPTR_MethodDesc vmMethodDesc, GENERICS_TYPE_TOKEN genericsToken, UINT32 * pcGenericClassTypeParams, TypeParamsList * pGenericTypeParams)
    void Unpack_GetMethodDescParams(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetThreadOrContextStaticAddress(VMPTR_FieldDesc vmField, VMPTR_Thread vmRuntimeThread)
    void Unpack_GetThreadOrContextStaticAddress(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetCollectibleTypeStaticAddress(VMPTR_FieldDesc vmField, VMPTR_AppDomain vmAppDomain)
    void Unpack_GetCollectibleTypeStaticAddress(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetEnCHangingFieldInfo(const EnCHangingFieldInfo * pEnCFieldInfo, FieldData * pFieldData, BOOL * pfStatic)
    void Unpack_GetEnCHangingFieldInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetTypeHandleParams(VMPTR_AppDomain vmAppDomain, VMPTR_TypeHandle vmTypeHandle, TypeParamsList * pParams)
    void Unpack_GetTypeHandleParams(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetSimpleType(VMPTR_AppDomain vmAppDomain, CorElementType simpleType, mdTypeDef * pMetadataToken, VMPTR_Module * pVmModule, VMPTR_DomainFile * pVmDomainFile)
    void Unpack_GetSimpleType(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsExceptionObject(VMPTR_Object vmObject)
    void Unpack_IsExceptionObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetStackFramesFromException(VMPTR_Object vmObject, DacDbiArrayList<DacExceptionCallStackData> & dacStackFrames)
    void Unpack_GetStackFramesFromException(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsRcw(VMPTR_Object vmObject)
    void Unpack_IsRcw(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetRcwCachedInterfaceTypes(VMPTR_Object vmObject, VMPTR_AppDomain vmAppDomain, BOOL bIInspectableOnly, DacDbiArrayList<DebuggerIPCE_ExpandedTypeData> * pDacInterfaces)
    void Unpack_GetRcwCachedInterfaceTypes(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetRcwCachedInterfacePointers(VMPTR_Object vmObject, BOOL bIInspectableOnly, DacDbiArrayList<CORDB_ADDRESS> * pDacItfPtrs)
    void Unpack_GetRcwCachedInterfacePointers(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetCachedWinRTTypesForIIDs(VMPTR_AppDomain vmAppDomain, DacDbiArrayList<GUID> & iids, DacDbiArrayList<DebuggerIPCE_ExpandedTypeData> * pTypes)
    void Unpack_GetCachedWinRTTypesForIIDs(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetCachedWinRTTypes(VMPTR_AppDomain vmAppDomain, DacDbiArrayList<GUID> * piids, DacDbiArrayList<DebuggerIPCE_ExpandedTypeData> * pTypes)
    void Unpack_GetCachedWinRTTypes(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetTypedByRefInfo(CORDB_ADDRESS pTypedByRef, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetTypedByRefInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetStringData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetStringData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetArrayData(CORDB_ADDRESS objectAddress, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetArrayData(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetBasicObjectInfo(CORDB_ADDRESS objectAddress, CorElementType type, VMPTR_AppDomain vmAppDomain, DebuggerIPCE_ObjectData * pObjectData)
    void Unpack_GetBasicObjectInfo(ReadBuffer * pSend, WriteBuffer * pResult);

    // void TestCrst(VMPTR_Crst vmCrst)
    void Unpack_TestCrst(ReadBuffer * pSend, WriteBuffer * pResult);

    // void TestRWLock(VMPTR_SimpleRWLock vmRWLock)
    void Unpack_TestRWLock(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetDebuggerControlBlockAddress()
    void Unpack_GetDebuggerControlBlockAddress(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_Object GetObjectFromRefPtr(CORDB_ADDRESS ptr)
    void Unpack_GetObjectFromRefPtr(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_Object GetObject(CORDB_ADDRESS ptr)
    void Unpack_GetObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT EnableNGENPolicy(CorDebugNGENPolicy ePolicy)
    void Unpack_EnableNGENPolicy(ReadBuffer * pSend, WriteBuffer * pResult);

    // VMPTR_OBJECTHANDLE GetVmObjectHandle(CORDB_ADDRESS handleAddress)
    void Unpack_GetVmObjectHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // BOOL IsVmObjectHandleValid(VMPTR_OBJECTHANDLE vmHandle)
    void Unpack_IsVmObjectHandleValid(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT IsWinRTModule(VMPTR_Module vmModule, BOOL & isWinRT)
    void Unpack_IsWinRTModule(ReadBuffer * pSend, WriteBuffer * pResult);

    // ULONG GetAppDomainIdFromVmObjectHandle(VMPTR_OBJECTHANDLE vmHandle)
    void Unpack_GetAppDomainIdFromVmObjectHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // CORDB_ADDRESS GetHandleAddressFromVmHandle(VMPTR_OBJECTHANDLE vmHandle)
    void Unpack_GetHandleAddressFromVmHandle(ReadBuffer * pSend, WriteBuffer * pResult);

    // TargetBuffer GetObjectContents(VMPTR_Object obj)
    void Unpack_GetObjectContents(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateBlockingObjects(VMPTR_Thread vmThread, IDacDbiInterface::FP_BLOCKINGOBJECT_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateBlockingObjects(ReadBuffer * pSend, WriteBuffer * pResult);

    // MonitorLockInfo GetThreadOwningMonitorLock(VMPTR_Object vmObject)
    void Unpack_GetThreadOwningMonitorLock(ReadBuffer * pSend, WriteBuffer * pResult);

    // void EnumerateMonitorEventWaitList(VMPTR_Object vmObject, IDacDbiInterface::FP_THREAD_ENUMERATION_CALLBACK fpCallback, CALLBACK_DATA pUserData)
    void Unpack_EnumerateMonitorEventWaitList(ReadBuffer * pSend, WriteBuffer * pResult);

    // CLR_DEBUGGING_PROCESS_FLAGS GetAttachStateFlags()
    void Unpack_GetAttachStateFlags(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool GetMetaDataFileInfoFromPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwImageSize, bool & isNGEN, IStringHolder * pStrFilename)
    void Unpack_GetMetaDataFileInfoFromPEFile(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool GetILImageInfoFromNgenPEFile(VMPTR_PEFile vmPEFile, DWORD & dwTimeStamp, DWORD & dwSize, IStringHolder * pStrFilename)
    void Unpack_GetILImageInfoFromNgenPEFile(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool IsThreadSuspendedOrHijacked(VMPTR_Thread vmThread)
    void Unpack_IsThreadSuspendedOrHijacked(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool AreGCStructuresValid()
    void Unpack_AreGCStructuresValid(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT CreateHeapWalk(HeapWalkHandle * pHandle)
    void Unpack_CreateHeapWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // void DeleteHeapWalk(HeapWalkHandle handle)
    void Unpack_DeleteHeapWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT WalkHeap(HeapWalkHandle handle, ULONG count, COR_HEAPOBJECT * objects, ULONG * pFetched)
    void Unpack_WalkHeap(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT GetHeapSegments(DacDbiArrayList<COR_SEGMENT> * pSegments)
    void Unpack_GetHeapSegments(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool IsValidObject(CORDB_ADDRESS obj)
    void Unpack_IsValidObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // bool GetAppDomainForObject(CORDB_ADDRESS obj, VMPTR_AppDomain * pApp, VMPTR_Module * pModule, VMPTR_DomainFile * pDomainFile)
    void Unpack_GetAppDomainForObject(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT CreateRefWalk(RefWalkHandle * pHandle, BOOL walkStacks, BOOL walkFQ, UINT32 handleWalkMask)
    void Unpack_CreateRefWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // void DeleteRefWalk(RefWalkHandle handle)
    void Unpack_DeleteRefWalk(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT WalkRefs(RefWalkHandle handle, ULONG count, DacGcReference * refs, ULONG * pFetched)
    void Unpack_WalkRefs(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT GetTypeID(CORDB_ADDRESS obj, COR_TYPEID * pType)
    void Unpack_GetTypeID(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT GetObjectFields(COR_TYPEID id, ULONG32 celt, COR_FIELD * layout, ULONG32 * pceltFetched)
    void Unpack_GetObjectFields(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT GetTypeLayout(COR_TYPEID id, COR_TYPE_LAYOUT * pLayout)
    void Unpack_GetTypeLayout(ReadBuffer * pSend, WriteBuffer * pResult);

    // HRESULT GetArrayLayout(COR_TYPEID id, COR_ARRAY_LAYOUT * pLayout)
    void Unpack_GetArrayLayout(ReadBuffer * pSend, WriteBuffer * pResult);

    // void GetGCHeapInformation(COR_HEAPINFO * pHeapInfo)
    void Unpack_GetGCHeapInformation(ReadBuffer * pSend, WriteBuffer * pResult);

    };

#endif // _DDUNPACK_H_

#endif //FEATURE_DBGIPC_TRANSPORT_VM

// end of file
