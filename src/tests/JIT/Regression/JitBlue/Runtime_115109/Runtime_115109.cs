// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// Generated by Fuzzlyn v2.8 on 2025-04-27 22:46:08
// Run on X86 Windows
// Seed: 2255917678885586044-vectort,vector128,vector256,x86aes,x86avx,x86avx2,x86avx512bw,x86avx512bwvl,x86avx512cd,x86avx512cdvl,x86avx512dq,x86avx512dqvl,x86avx512f,x86avx512fvl,x86bmi1,x86bmi2,x86fma,x86lzcnt,x86pclmulqdq,x86popcnt,x86sse,x86sse2,x86sse3,x86sse41,x86sse42,x86ssse3,x86x86base
// Reduced from 118.3 KiB to 1.0 KiB in 00:17:25
// Debug: Outputs <0, 0, 0, 0, 0, 0, 0, 0>
// Release: Outputs <1, 0, 0, 0, 0, 0, 0, 0>
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using Xunit;

public class Runtime_115109
{
    static int s_5 = 101;
    static Vector<int>[] s_10;
    static byte s_21;
    
    [Fact]
    public static int TestEntryPoint()
    {
        s_10 = [Vector128.CreateScalar(0).AsVector()];
        bool vr5 = 0 <= M10();
        return s_10[0][0];
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static byte M10()
    {
        byte lvar2 = 3;
        do
        {
            s_5 = 100;
            int lvar4 = 0;
            do
            {
                s_10[0] = Vector128.CreateScalar(s_5).AsVector();
            }
            while (++lvar4 < 2);
        }
        while (--lvar2 > 1);
        return s_21;
    }
}
