<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// Runtime_64125.cs is AUTOGENERATED. DO NOT MODIFY the file manually.
// Instead use the following command to generate the .cs file from .tt file.
//   "%DevEnvDir%\TextTransform.exe" Runtime_64125.tt

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Runtime_64125
{
<#
    int[] byteCounts = new int[] { 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 127, 128 };
    int[] offsets = new int[] { 252, 255, 504, 1008, 4095, 8190, 16380, 32760, 65520 };

    int maximumByteCount = byteCounts.Max();
    int maximumOffset = offsets.Max();

    foreach (int byteCount in byteCounts)
    {
#>
    [StructLayout(LayoutKind.Explicit, Size=<#= byteCount #>)]
    struct Struct<#= byteCount #>Bytes
    {
    }

<#
    }
#>
    [StructLayout(LayoutKind.Explicit, Size=<#= maximumByteCount + maximumOffset #>)]
    struct AnyOffset
    {
<#
    foreach (int fieldOffset in offsets)
    {
#>
        [FieldOffset(<#= fieldOffset #>)]
        public byte fieldAtOffset<#= fieldOffset #>;
<#
    }
#>
    }

    class AnyLocation
    {
<#
    foreach (int byteCount in byteCounts)
    foreach (int srcOffset in offsets)
    foreach (int dstOffset in offsets)
    {
        string structByteCount = $"Struct{byteCount}Bytes";
#>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public unsafe void Copy<#= byteCount #>BytesFromLocationAtOffset<#= srcOffset #>ToLocationAtOffset<#= dstOffset #>(AnyOffset* dst, AnyOffset* src)
        {
            *(<#= structByteCount #>*)&dst->fieldAtOffset<#= dstOffset #> = *(<#= structByteCount #>*)&src->fieldAtOffset<#= srcOffset #>;
        }

<#
    }
#>
    }

    class Program
    {
        static unsafe void Init(byte* bytes, int byteCount)
        {
            for (int i = 0; i < byteCount; i++)
            {
                bytes[i] = TestLibrary.Generator.GetByte();
            }
        }

        static unsafe bool MemoryCompare(byte* left, byte* right, int byteCount)
        {
            for (int i = 0; i < byteCount; i++)
            {
                if (left[i] != right[i]) return false;
            }

            return true;
        }

        static unsafe int Main()
        {
            var anyLocation = new AnyLocation();

            var src = new AnyOffset();
            var dst = new AnyOffset();

            Init((byte*)&src, sizeof(AnyOffset));
<#
    foreach (int byteCount in byteCounts)
    foreach (int srcOffset in offsets)
    foreach (int dstOffset in offsets)
    {
#>
            anyLocation.Copy<#= byteCount #>BytesFromLocationAtOffset<#= srcOffset #>ToLocationAtOffset<#= dstOffset #>(&dst, &src);
            if (!MemoryCompare(&src.fieldAtOffset<#= srcOffset #>, &dst.fieldAtOffset<#= dstOffset #>, <#= byteCount #>)) return 0;
<#
    }
#>

            return 100;
        }
    }
}
