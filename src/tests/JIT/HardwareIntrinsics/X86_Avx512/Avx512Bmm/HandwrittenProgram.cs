// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using Xunit;

namespace JIT.HardwareIntrinsics.X86._Avx512Bmm
{
    public static partial class Program
    {
        static Program()
        {

        }

	    [Fact]
	    public static void CheckSupported()
        {
            (int Eax, int Ebx, int Ecx, int Edx) = X86Base.CpuId(unchecked((int)0x80000021), (int)0x0);
            bool isSupported = (Eax & (1 << 23)) != 0;
            Assert.Equal(isSupported, Avx512Bmm.IsSupported);
        }

	    [Fact]
	    public static void Vbmacor16x16x16_Vector256()
	    {
            if (!Avx512Bmm.IsSupported) return;
		    Vector256<ushort> x = Vector256.Create((ushort)0x1);
		    Vector256<ushort> y = Vector256.Create((ushort)0x1);
		    Vector256<ushort> z = Vector256.Create((ushort)0x1011);
		    Vector256<ushort> result = Avx512Bmm.Vbmacor16x16x16(x, y, z);
		    Assert.Equal(result, Vector256.Create((ushort)0x1011));
	    }

        [Fact]
        public static void Vbmacor16x16x16_Vector512()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector512<ushort> x = Vector512.Create((ushort)0x1);
            Vector512<ushort> y = Vector512.Create((ushort)0x1);
            Vector512<ushort> z = Vector512.Create((ushort)0x1011);
            Vector512<ushort> result = Avx512Bmm.Vbmacor16x16x16(x, y, z);
            Assert.Equal(result, Vector512.Create((ushort)0x1011));
        }

        [Fact]
        public static void Vbmacxor16x16x16_Vector256()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector256<ushort> x = Vector256.Create((ushort)0x1);
            Vector256<ushort> y = Vector256.Create((ushort)0x1);
            Vector256<ushort> z = Vector256.Create((ushort)0x1011);
            Vector256<ushort> result = Avx512Bmm.Vbmacxor16x16x16(x, y, z);
            Assert.Equal(result, Vector256.Create((ushort)0x1010));
        }

        [Fact]
        public static void Vbmacxor16x16x16_Vector512()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector512<ushort> x = Vector512.Create((ushort)0x1);
            Vector512<ushort> y = Vector512.Create((ushort)0x1);
            Vector512<ushort> z = Vector512.Create((ushort)0x1011);
            Vector512<ushort> result = Avx512Bmm.Vbmacxor16x16x16(x, y, z);
            Assert.Equal(result, Vector512.Create((ushort)0x1010));
        }

        [Fact]
        public static void BitReverse_Vector128()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector128<byte> x = Vector128.Create((byte)0xAA);
            Vector128<byte> y = Avx512Bmm.BitReverse(x);
            Assert.Equal(y, Vector128.Create((byte)0x55));
        }

        [Fact]
        public static void BitReverse_Vector128_Mask()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector128<byte> x = Vector128.Create((byte)0xAA);
            Vector128<byte> mask = Vector128.Create(0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
            Vector128<byte> y = Avx512BW.BlendVariable(x, Avx512Bmm.BitReverse(x), mask);
            Assert.Equal(y, Vector128.Create((byte)0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA));
        }

        [Fact]
        public static void BitReverse_Vector128_Maskz()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector128<byte> x = Vector128.Create((byte)0xAA);
            Vector128<byte> mask = Vector128.Create(0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
            Vector128<byte> y = Avx512BW.BlendVariable(Vector128<byte>.Zero, Avx512Bmm.BitReverse(x), mask);
            Assert.Equal(y, Vector128.Create((byte)0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
        }

        [Fact]
        public static void BitReverse_Vector256()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector256<byte> x = Vector256.Create((byte)0xAA);
            Vector256<byte> y = Avx512Bmm.BitReverse(x);
            Assert.Equal(y, Vector256.Create((byte)0x55));
        }

        [Fact]
        public static void BitReverse_Vector256_Mask()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector256<byte> x = Vector256.Create((byte)0xAA);
            Vector256<byte> mask = Vector256.Create(0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
            Vector256<byte> y = Avx512BW.BlendVariable(x, Avx512Bmm.BitReverse(x), mask);
            Assert.Equal(y, Vector256.Create((byte)0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA));
        }

        [Fact]
        public static void BitReverse_Vector256_Maskz()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector256<byte> x = Vector256.Create((byte)0xAA);
            Vector256<byte> mask = Vector256.Create(0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
            Vector256<byte> y = Avx512BW.BlendVariable(Vector256<byte>.Zero, Avx512Bmm.BitReverse(x), mask);
            Assert.Equal(y, Vector256.Create((byte)0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
        }

        [Fact]
        public static void BitReverse_Vector512()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector512<byte> x = Vector512.Create((byte)0xAA);
            Vector512<byte> y = Avx512Bmm.BitReverse(x);
            Assert.Equal(y, Vector512.Create((byte)0x55));
        }

        [Fact]
        public static void BitReverse_Vector512_Mask()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector512<byte> x = Vector512.Create((byte)0xAA);
            Vector512<byte> mask = Vector512.Create(0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
            Vector512<byte> y = Avx512BW.BlendVariable(x, Avx512Bmm.BitReverse(x), mask);
            Assert.Equal(y, Vector512.Create((byte)0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA));
        }

        [Fact]
        public static void BitReverse_Vector512_Maskz()
        {
            if (!Avx512Bmm.IsSupported) return;
            Vector512<byte> x = Vector512.Create((byte)0xAA);
            Vector512<byte> mask = Vector512.Create(0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
            Vector512<byte> y = Avx512BW.BlendVariable(Vector512<byte>.Zero, Avx512Bmm.BitReverse(x), mask);
            Assert.Equal(y, Vector512.Create((byte)0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
        }
    }
}
