// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.Build.Utilities;
using Microsoft.Build.Framework;
using System.Diagnostics.CodeAnalysis;

//
// This class generates the icall_trampoline_dispatch () function used by the interpreter to call native code on WASM.
// It should be kept in sync with mono_wasm_interp_to_native_trampoline () in the runtime.
//

#nullable enable

public class InterpToNativeGenerator
{
    protected TaskLoggingHelper Log { get; set; }

    public InterpToNativeGenerator(TaskLoggingHelper log) => Log = log;

    private static string TypeToSigType(char c)
    {
        switch (c)
        {
            case 'V': return "void";
            case 'I': return "int";
            case 'L': return "int64_t";
            case 'F': return "float";
            case 'D': return "double";
            default:
                throw new Exception("Can't handle " + c);
        }
    }

    public void Generate(IEnumerable<string> cookies, string outputPath)
    {
        string tmpFileName = Path.GetTempFileName();
        using (var w = File.CreateText(tmpFileName))
        {
            Emit(w, cookies);
        }

        if (Utils.CopyIfDifferent(tmpFileName, outputPath, useHash: false))
            Log.LogMessage(MessageImportance.Low, $"Generating managed2native table to '{outputPath}'.");
        else
            Log.LogMessage(MessageImportance.Low, $"Managed2native table in {outputPath} is unchanged.");

        File.Delete(tmpFileName);
    }

    private static void Emit(StreamWriter w, IEnumerable<string> cookies)
    {
        w.WriteLine("/*");
        w.WriteLine("* GENERATED FILE, DON'T EDIT");
        w.WriteLine("* Generated by InterpToNativeGenerator");
        w.WriteLine("*/");
        w.WriteLine("");
        w.WriteLine(@"#include ""pinvoke.h""");
        w.WriteLine(@"#include <stdlib.h>");
        w.WriteLine("");

        var signatures = cookies.Distinct().ToArray();
        foreach (var c in signatures)
        {
            w.WriteLine("static void");
            w.WriteLine($"wasm_invoke_{c.ToLower(CultureInfo.InvariantCulture)} (void *target_func, MonoInterpMethodArguments *margs)");
            w.WriteLine("{");

            w.Write($"\ttypedef {TypeToSigType(c[0])} (*T)(");
            for (int i = 1; i < c.Length; ++i)
            {
                char p = c[i];
                if (i > 1)
                    w.Write(", ");
                w.Write($"{TypeToSigType(p)} arg_{i - 1}");
            }
            if (c.Length == 1)
                w.Write("void");

            w.WriteLine(");\n\tT func = (T)target_func;");

            var ctx = new EmitCtx();

            w.Write("\t");
            if (c[0] != 'V')
                w.Write($"{TypeToSigType(c[0])} res = ");

            w.Write("func (");
            for (int i = 1; i < c.Length; ++i)
            {
                char p = c[i];
                if (i > 1)
                    w.Write(", ");
                w.Write(ctx.Emit(p));
            }
            w.WriteLine(");");

            if (c[0] != 'V')
            {
                w.WriteLine($"\tvoid *retval = mono_wasm_interp_method_args_get_retval (margs);");
                w.WriteLine($"\t*({TypeToSigType(c[0])}*)retval = res;");
            }

            w.WriteLine("}\n");
        }

        Array.Sort(signatures);


        w.WriteLine("static void* interp_to_native_invokes[] = {");
        foreach (var sig in signatures)
        {
            var lsig = sig.ToLower(CultureInfo.InvariantCulture);
            w.WriteLine($"\twasm_invoke_{lsig},");
        }
        w.WriteLine("};");

        w.WriteLine("static const char* interp_to_native_signatures[] = {");
        foreach (var sig in signatures)
            w.WriteLine($"\"{sig}\",");
        w.WriteLine("};");

        w.WriteLine($"unsigned int interp_to_native_signatures_count = {signatures.Length};");

        w.WriteLine("static int compare_icall_tramp (const void *key, const void *elem) { return strcmp (key, *(void**)elem); }");
        w.WriteLine("");
        w.WriteLine("static void* ");
        w.WriteLine("mono_wasm_interp_to_native_callback (char* cookie)");
        w.WriteLine("{");
        w.WriteLine("\tvoid* p = bsearch (cookie, interp_to_native_signatures, interp_to_native_signatures_count, sizeof (void*), compare_icall_tramp);");
        w.WriteLine("\tif (!p)");
        w.WriteLine("\t\treturn NULL;");
        w.WriteLine("\tint idx = (const char**)p - (const char**)interp_to_native_signatures;");
        w.WriteLine("\treturn interp_to_native_invokes [idx];");
        w.WriteLine("};");
    }

    private sealed class EmitCtx
    {
        private int iarg, farg;

        public string Emit(char c)
        {
            switch (c)
            {
                case 'I':
                    iarg += 1;
                    break;
                case 'L':
                    iarg += 2;
                    break;
                case 'F':
                case 'D':
                    farg += 1;
                    break;
                default:
                    throw new Exception("IDK how to handle " + c);
            }

            return $"mono_wasm_interp_method_args_get_{char.ToLower(c)}arg (margs, {iarg - 1})";
        }
    }
}
