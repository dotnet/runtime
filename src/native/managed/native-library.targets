<Project>
    <ItemGroup>
        <PackageReference Include="Microsoft.DotNet.Build.Tasks.Templating" Version="$(MicrosoftDotNetBuildTasksTemplatingVersion)" />
    </ItemGroup>

    <!-- set a default include path, if there wasn't one already in the project -->
    <ItemGroup>
        <NativeLibraryCmakeFragmentIncludePath Condition="'@(NativeLibraryCmakeFragmentIncludePath->Count())' == '0' and Exists($([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)\..\inc')))" Include="$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)\..\inc'))" />
    </ItemGroup>


    <PropertyGroup>
        <!-- template for the cmake config file, used by the find_package(...) cmake function -->
        <NativeLibraryCmakeFindPackageConfigTemplateFile>$(MSBuildThisFileDirectory)Templates/native-lib.find_package-config.cmake.in</NativeLibraryCmakeFindPackageConfigTemplateFile>

        <!-- put the generated cmake config files where the runtime expects to find them -->
        <NativeLibraryCMakeFindPackageConfigOutputPath>$([MSBuild]::NormalizeDirectory('$(ArtifactsObjDir)\cmake\find_package\'))</NativeLibraryCMakeFindPackageConfigOutputPath>

    </PropertyGroup>


    <!-- Write a ProjectName.cmake fragment into the publish artifact folder with that helps with consuming the NativeAOT produced library -->

    <Target Name="WriteNativeLibraryCMakeFragment"
            DependsOnTargets="SetupProperties;WriteNativeLibraryCMakeFragmentSetup"
            AfterTargets="Publish"
            Condition="'$(PublishAot)' == 'true'"
            Outputs="$(NativeLibraryCMakeFindPackageConfigPath)">
        <!-- Note: GenerateFileFromTemplate uses ${replacementVar} syntax for things that it will replace.
             Use a backtick to write a normal cmake variable reference: `${nonReplacedVar}
             Wish: GenerateFileFromTemplate should provide a way to specify the replacement sigil.
        -->

        <Error Text="Generating a cmake fragment is only supported for a shared library" Condition="'$(NativeLib)' != 'shared'" />

        <GenerateFileFromTemplate
            TemplateFile="$(NativeLibraryCmakeFindPackageConfigTemplateFile)"
            OutputPath="$(NativeLibraryCMakeFindPackageConfigPath)"
            Properties="@(NativeLibraryCmakeFragmentProperties->'%(Identity)=%(Value)')" />
    </Target>

    <!-- setup properties for writing the config template -->
    <Target Name="WriteNativeLibraryCMakeFragmentSetup"
            DependsOnTargets="SetupProperties"
            AfterTargets="Publish"
            Condition="'$(PublishAot)' == 'true'">
        <PropertyGroup>
            <NativeLibraryArtifactName>$(TargetName)</NativeLibraryArtifactName>
            <NativeLibraryCMakeFindPackageConfigPath>$(NativeLibraryCMakeFindPackageConfigOutputPath)$(NativeLibraryArtifactName)-config.cmake</NativeLibraryCMakeFindPackageConfigPath>
            <NativeLibraryArtifactExt>$(NativeBinaryExt)</NativeLibraryArtifactExt>
            <NativeLibraryArtifactLibBasePath>$(PublishDir)/</NativeLibraryArtifactLibBasePath>
            <!-- cmake prefers unix-style paths even on windows -->
            <NativeLibraryArtifactLibBasePath Condition="'$(TargetOS)' == 'windows'">$(NativeLibraryArtifactLibBasePath.Replace('\', '/'))</NativeLibraryArtifactLibBasePath>
            <!-- make a semicolon-separted list from the item group, then fixup the backslashes -->
            <NativeLibraryArtifactIncludePath>@(NativeLibraryCmakeFragmentIncludePath, ';')</NativeLibraryArtifactIncludePath>
            <NativeLibraryArtifactIncludePath Condition="'$(TargetOS)' == 'windows'">$(NativeLibraryArtifactIncludePath.Replace('\', '/'))</NativeLibraryArtifactIncludePath>
        </PropertyGroup>

        <ItemGroup>
            <NativeLibraryCmakeFragmentProperties Include="libArtifactName" Value="$(NativeLibraryArtifactName)" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactExt" Value="$(NativeLibraryArtifactExt)" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactLibBasePath" Value="$(NativeLibraryArtifactLibBasePath.TrimEnd('\/'))" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactIncludePath" Value="$(NativeLibraryArtifactIncludePath.TrimEnd('\/'))" />
        </ItemGroup>

        <!-- make the import lib template arg for the shared library -->
        <PropertyGroup Condition="'$(TargetOS)' == 'windows' and '$(NativeLib)' == 'shared'">
            <!-- the import lib is in the native sub-directory, not publish-->
            <NativeLibraryArtifactImpLibFullPath>$([System.IO.Path]::GetFullPath('$(NativeOutputPath)$(TargetName)$(StaticLibSuffix)'))</NativeLibraryArtifactImpLibFullPath>
            <!-- change backslashes to unix-style paths to make cmake happy -->
            <NativeLibraryArtifactImpLibFullPath>$(NativeLibraryArtifactImpLibFullPath.Replace('\', '/'))</NativeLibraryArtifactImpLibFullPath>
        </PropertyGroup>
        <ItemGroup Condition="'$(NativeLib)' == 'shared'">
            <NativeLibraryCmakeFragmentProperties Include="libArtifactImpLibFullPath" Value="$(NativeLibraryArtifactImpLibFullPath.TrimEnd('\/'))" Condition="'$(TargetOS)' == 'windows'" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactImpLibFullPath" Value="" Condition="'$(TargetOS)' != 'windows'" />
        </ItemGroup>
    </Target>

    <!-- strip the library the same way as the cmake build for coreclr does it:
         - on mac, leave a .dylib.dwarf file next to the library.
         - on linux leave a .so.dbg file next to to the library
    -->
    <Target Name="StripLibraryLikeCoreCLRSetupPaths"
            DependsOnTargets="CopyNativeBinary"
            Condition="'$(IsRuntimeComponent)' == 'true' and '$(TargetsWindows)' != 'true'">
        <PropertyGroup>
            <StrippedOutputPath>$(OutputPath)stripped\</StrippedOutputPath>
            <StripSourceFile>$(StrippedOutputPath)$(TargetName)$(NativeBinaryExt)</StripSourceFile>
            <StrippedExt Condition="'$(StrippedExt)' == '' and ('$(TargetsOSX)' == 'true' or '$(TargetsAppleMobile)' == 'true')">.dylib.dwarf</StrippedExt>
            <StrippedExt Condition="'$(TargetsUnix)' == 'true' and '$(StrippedExt)' == ''">.so.dbg</StrippedExt>
            <StripDestinationFile>$(StrippedOutputPath)$(TargetName)$(StrippedExt)</StripDestinationFile>
        </PropertyGroup>
    </Target>

    <!--
	Hack: temporarily turn on StripSymbols whlie SetupOSSpecificProps runs, then turn it off
	again before LinkNative runs.  The problem is that SetupOSSpecificProps only probes for
	$(ObjCopyName) and $(ObjCopyNameAlternative) if symbol stripping is turned on.  But we don't
	want LinkNative to actually do any stripping since we have our own way that we'd like it to
	work.
    -->
    <Target Name="TempStripSymbolsOn"
	    BeforeTargets="SetupOSSpecificProps">
	<PropertyGroup>
	    <StripSymbols>true</StripSymbols>
	</PropertyGroup>
    </Target>

    <Target Name="TempStripSymbolsOff"
	    AfterTargets="SetupOSSpecificProps"
	    BeforeTargets="LinkNative">
	<PropertyGroup>
	    <StripSymbols>false</StripSymbols>
	</PropertyGroup>
    </Target>

    <Target Name="StripLibraryLikeCoreCLRBuild"
            DependsOnTargets="SetupOSSpecificProps;CopyNativeBinary;StripLibraryLikeCoreCLRSetupPaths"
            Condition="'$(IsRuntimeComponent)' == 'true' and '$(TargetsWindows)' != 'true'"
            Inputs="$(PublishDir)$(TargetName)$(NativeBinaryExt)"
            Outputs="$(StripSourceFile);$(StripDestinationFile)">
        <Error Text="Do not set StripSymbols to true - runtime components stripping is controlled by native-library.targets" Condition="'$(StripSymbols)' == 'true'" />

        <Message Importance="Normal" Text="Stripping $(PublishDir)$(TargetName)$(NativeBinaryExt) into $(StripSourceFile) and $(StripDestinationFile)" />

        <!-- copy from the published/ subfolder to the stripped/ subfolder -->
        <Copy SourceFiles="$(PublishDir)$(TargetName)$(NativeBinaryExt)"
              DestinationFolder="$(StrippedOutputPath)"
              SkipUnchangedFiles="true" />

        <PropertyGroup>
            <_StripLike Condition="'$(TargetsOSX)' == 'true' or '$(TargetsAppleMobile)' == 'true'">apple</_StripLike>
            <_StripLike Condition="'$(_StripLike)' == ''">gnu</_StripLike>
        </PropertyGroup>

        <Exec Command="dsymutil --flat $(LikeCoreCLRDSymUtilMinimizeOpt) $(StripSourceFile)" Condition="'$(_StripLike)' == 'apple'"/> <!-- produces the .dylib.dwarf file -->
        <Exec Command="strip -no_code_signature_warning -S $(StripSourceFile)" Condition="'$(_StripLike)' == 'apple'"/>
        <!-- runtime build runs "codesign -f -s - libWhatever.dylib" in release configurations -->
        <Exec Command="codesign -f -s - $(StripSourceFile)" Condition="'$(RuntimeConfiguration)' == 'Release' and '$(_StripLike)' == 'apple'" />

        <Exec Command="$(ObjCopyName) --only-keep-debug $(StripSourceFile) $(StripDestinationFile)" Condition="'$(_StripLike)' == 'gnu'"/>
        <Exec Command="$(ObjCopyName) --strip-debug --strip-unneeded $(StripSourceFile)" Condition="'$(_StripLike)' == 'gnu'"/>
        <Exec Command="$(ObjCopyName) --add-gnu-debuglink=$(StripDestinationFile) $(StripSourceFile)" Condition="'$(_StripLike)' == 'gnu'"/>
    </Target>

    <Target Name="InstallRuntimeComponentToFinalDest"
            AfterTargets="CopyNativeBinary"
            DependsOnTargets="CopyNativeBinary;StripLibraryLikeCoreCLRBuild" Condition="'$(IsRuntimeComponent)' == 'true'">
        <Error Text="Set at least one @InstallRuntimeComponentDest item" Condition="@(InstallRuntimeComponentDest->Count()) == 0" />

        <PropertyGroup>
            <!-- FIXME: this is the same as CoreCLRToolPath - but that doesn't seem like a good name -->
            <FinalRuntimeComponentDestinationBase>$([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', '$(RuntimeFlavor.ToLower())', '$(TargetOS).$(TargetArchitecture).$(RuntimeConfiguration)'))</FinalRuntimeComponentDestinationBase>
        </PropertyGroup>

        <ItemGroup>
            <_NormalizedInstallRuntimeComponentDest Include="$([MSBuild]::NormalizeDirectory('$(FinalRuntimeComponentDestinationBase)', '%(InstallRuntimeComponentDest.Identity)'))" />
        </ItemGroup>

        <ItemGroup Condition="'$(TargetsWindows)' != 'true'">
            <CopyFinalFiles Include="$(StripSourceFile)" />
            <CopyFinalFiles Include="$(StripDestinationFile)" />
        </ItemGroup>

        <ItemGroup Condition="'$(TargetsWindows)' == 'true'">
            <CopyFinalFiles Include="$(PublishDir)$(TargetName)$(NativeBinaryExt)" />
            <CopyFinalFilesPDB Include="$(PublishDir)$(TargetName).pdb" />
        </ItemGroup>

        <Message Importance="Normal" Text="Installing @(CopyFinalFiles) into %(_NormalizedInstallRuntimeComponentDest.Identity)"/>
        <Message Importance="Normal" Text="Installing @(CopyFinalFilesPDB) into %(_NormalizedInstallRuntimeComponentDest.Identity)PDB\" Condition="'$(TargetsWindows)' == 'true'"/>

        <Copy SourceFiles="@(CopyFinalFiles)"
              DestinationFolder="%(_NormalizedInstallRuntimeComponentDest.Identity)"
              SkipUnchangedFiles="true"/>
        <Copy SourceFiles="@(CopyFinalFilesPDB)"
              DestinationFolder="%(_NormalizedInstallRuntimeComponentDest.Identity)PDB\"
              SkipUnchangedFiles="true"
              Condition="'$(TargetsWindows)' == 'true'"/>
    </Target>


</Project>
