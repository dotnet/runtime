<Project>
    <ItemGroup>
            <PackageReference Include="Microsoft.DotNet.Build.Tasks.Templating" Version="$(MicrosoftDotNetBuildTasksTemplatingVersion)" />
    </ItemGroup>

    <!-- set a default include path, if there wasn't one already in the project -->
    <ItemGroup>
        <NativeLibraryCmakeFragmentIncludePath Condition="'@(NativeLibraryCmakeFragmentIncludePath->Count())' == '0' and Exists($([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)\..\inc')))" Include="$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)\..\inc'))" />
    </ItemGroup>


    <PropertyGroup>
        <NativeLibraryCMakeFindPackageConfigOutputPath>$([MSBuild]::NormalizeDirectory('$(ArtifactsObjDir)\cmake\find_package\'))</NativeLibraryCMakeFindPackageConfigOutputPath>
    </PropertyGroup>


    <!-- Write a ProjectName.cmake fragment into the publish artifact folder with that helps with consuming the NativeAOT produced library -->

    <Target Name="WriteNativeLibraryCMakeFragment" DependsOnTargets="SetupProperties;WriteNativeLibraryCMakeFragmentCommon;WriteNativeLibraryCMakeFragmentShared" AfterTargets="Publish" Condition="'$(PublishAot)' == 'true'"
            Outputs="$(NativeLibraryCMakeFragmentPath);$(NativeLibraryCMakeFindPackageConfigPath)">
        <!-- Note: GenerateFileFromTemplate uses ${replacementVar} syntax for things that it will replace.
             Use a backtick to write a normal cmake variable reference: `${nonReplacedVar}
             Wish: GenerateFileFromTemplate should provide a way to specify the replacement sigil.
        -->
        <PropertyGroup>
            <NativeLibraryCmakeFragmentTemplateFile Condition="'$(NativeLib)' == 'shared'">$(MSBuildThisFileDirectory)Templates/native-lib.shared.cmake.in</NativeLibraryCmakeFragmentTemplateFile>
            <NativeLibraryCmakeFindPackageConfigTemplateFile>$(MSBuildThisFileDirectory)Templates/native-lib.find_package-config.cmake.in</NativeLibraryCmakeFindPackageConfigTemplateFile>
        </PropertyGroup>

        <Error Text="Generating a cmake fragment is only supported for a shared library" Condition="'$(NativeLib)' != 'shared'" />

        <GenerateFileFromTemplate
            TemplateFile="$(NativeLibraryCmakeFragmentTemplateFile)"
            OutputPath="$(NativeLibraryCMakeFragmentPath)"
            Properties="@(NativeLibraryCmakeFragmentProperties->'%(Identity)=%(Value)')" />
        <GenerateFileFromTemplate
            TemplateFile="$(NativeLibraryCmakeFindPackageConfigTemplateFile)"
            OutputPath="$(NativeLibraryCMakeFindPackageConfigPath)"
            Properties="@(NativeLibraryCmakeFragmentProperties->'%(Identity)=%(Value)')" />
    </Target>

    <Target Name="WriteNativeLibraryCMakeFragmentCommon" DependsOnTargets="SetupProperties" AfterTargets="Publish" Condition="'$(PublishAot)' == 'true'">
        <PropertyGroup>
            <NativeLibraryCMakeVarPrefix>$(TargetName.ToUpper())</NativeLibraryCMakeVarPrefix>
            <NativeLibraryCMakeFragmentPath Condition="'$(NativeLibraryCMakeFragmentPath)' == ''">$(ArtifactsObjDir)$(TargetName)\$(TargetName).cmake</NativeLibraryCMakeFragmentPath>
            <NativeLibraryArtifactName>$(TargetName)</NativeLibraryArtifactName>
            <NativeLibraryCMakeFindPackageConfigPath>$(NativeLibraryCMakeFindPackageConfigOutputPath)$(NativeLibraryArtifactName)-config.cmake</NativeLibraryCMakeFindPackageConfigPath>
            <NativeLibraryArtifactExt>$(NativeBinaryExt)</NativeLibraryArtifactExt>
            <NativeLibraryArtifactLibPath>$(PublishDir)/</NativeLibraryArtifactLibPath>
            <!-- cmake prefers unix-style paths even on windows -->
            <NativeLibraryArtifactLibPath Condition="'$(TargetOS)' == 'windows'">$(NativeLibraryArtifactLibPath.Replace('\', '/'))</NativeLibraryArtifactLibPath>
            <!-- make a semicolon-separted list from the item group, then fixup the backslashes -->
            <NativeLibraryArtifactIncludePath>@(NativeLibraryCmakeFragmentIncludePath, ';')</NativeLibraryArtifactIncludePath>
            <NativeLibraryArtifactIncludePath Condition="'$(TargetOS)' == 'windows'">$(NativeLibraryArtifactIncludePath.Replace('\', '/'))</NativeLibraryArtifactIncludePath>
            <!-- when writing the location of the cmake fragment file into the config file, use unix-style paths even on Windows -->
            <NativeLibraryCMakeFragmentPath_ Condition="'$(TargetOS)' == 'windows'">$(NativeLibraryCMakeFragmentPath.Replace('\', '/'))</NativeLibraryCMakeFragmentPath_>
            <NativeLibraryCMakeFragmentPath_ Condition="'$(TargetOS)' != 'windows'">$(NativeLibraryCMakeFragmentPath)</NativeLibraryCMakeFragmentPath_>
        </PropertyGroup>
        <ItemGroup>
            <NativeLibraryCmakeFragmentProperties Include="libCmakeName" Value="$(NativeLibraryCMakeVarPrefix)" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactName" Value="$(NativeLibraryArtifactName)" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactExt" Value="$(NativeLibraryArtifactExt)" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactLibPath" Value="$(NativeLibraryArtifactLibPath.TrimEnd('\/'))" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactIncludePath" Value="$(NativeLibraryArtifactIncludePath.TrimEnd('\/'))" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactConfigFragment" Value="$(NativeLibraryCMakeFragmentPath_)" />
        </ItemGroup>
    </Target>

    <Target Name="WriteNativeLibraryCMakeFragmentShared" DependsOnTargets="SetupProperties;WriteNativeLibraryCMakeFragmentCommon" AfterTargets="Publish" Condition="'$(PublishAot)' == 'true' and '$(NativeLib)' == 'shared'">
        <PropertyGroup Condition="'$(TargetOS)' == 'windows'">
            <!-- the import lib is in the native sub-directory, not publish-->
            <NativeLibraryArtifactImpLibFullPath>$([System.IO.Path]::GetFullPath('$(NativeOutputPath)$(TargetName)$(StaticLibSuffix)'))</NativeLibraryArtifactImpLibFullPath>
        </PropertyGroup>
        <!-- change backslashes to unix-style paths to make cmake happy -->
        <PropertyGroup Condition="'$(TargetOS)' == 'windows'">
            <NativeLibraryArtifactImpLibFullPath>$(NativeLibraryArtifactImpLibFullPath.Replace('\', '/'))</NativeLibraryArtifactImpLibFullPath>
        </PropertyGroup>
        <ItemGroup>
            <NativeLibraryCmakeFragmentProperties Include="libArtifactImpLibFullPath" Value="$(NativeLibraryArtifactImpLibFullPath.TrimEnd('\/'))" Condition="'$(TargetOS)' == 'windows'" />
            <NativeLibraryCmakeFragmentProperties Include="libArtifactImpLibFullPath" Value="" Condition="'$(TargetOS)' != 'windows'" />
        </ItemGroup>
    </Target>

    <!-- strip the library the same way as the cmake build for coreclr does it:
         - on mac, leave a .dylib.dwarf file next to the library.
         - on linux leave a .so.dbg file next to to the library
    -->
    <Target Name="StripLibraryLikeCoreCLRBuild" AfterTargets="Publish" Condition="'$(IsRuntimeComponent)' == 'true'"/>

    <Target Name="InstallRuntimeComponentToFinalDest" AfterTargets="Publish" DependsOnTargets="StripLibraryLikeCoreCLRBuild" Condition="'$(IsRuntimeComponent)' == 'true'">
        <Error Text="Set at least one @InstallRuntimeComponentDest item" Condition="@(InstallRuntimeComponentDest->Count()) == 0" />

        <PropertyGroup>
            <!-- FIXME: this is the same as CoreCLRToolPath - but that doesn't seem like a good name -->
            <FinalRuntimeComponentDestinationBase>$([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', '$(RuntimeFlavor.ToLower())', '$(TargetOS).$(TargetArchitecture).$(RuntimeConfiguration)'))</FinalRuntimeComponentDestinationBase>
        </PropertyGroup>
        
        <!-- TODO: on Windows, copy the pdb to PDB/libName.pdb for each InstallRuntimeComponentDest -->
        <!-- TODO: on Linxu/Mac copy the .dylib.dwarf or .so.dbg file into each InstallRuntimeComponentDest -->
        <ItemGroup>
            <_NormalizedInstallRuntimeComponentDest Include="$([MSBuild]::NormalizeDirectory('$(FinalRuntimeComponentDestinationBase)', '%(InstallRuntimeComponentDest.Identity)'))" />
        </ItemGroup>

        <Message Importance="High" Text="Would  install $(TargetName) into %(_NormalizedInstallRuntimeComponentDest.Identity)" />

        <Copy SourceFiles="$(PublishDir)/$(TargetName)$(NativeBinaryExt)"
              DestinationFolder="%(_NormalizedInstallRuntimeComponentDest.Identity)"
              SkipUnchangedFiles="true" />
    </Target>


</Project>
