name: Backport PR to branch
on:
  workflow_call:
    inputs:
      pr_title_template:
        description: 'The template used for the PR title. Special placeholder tokens that will be replaced with a value: %target_branch%, %source_pr_title%, %source_pr_number%, %cc_users%.'
        required: false
        type: string
        default: '[%target_branch%] %source_pr_title%'
      pr_description_template:
        description: 'The template used for the PR description. Special placeholder tokens that will be replaced with a value: %target_branch%, %source_pr_title%, %source_pr_number%, %cc_users%.'
        required: false
        type: string
        default: |
          Backport of #%source_pr_number% to %target_branch%

          /cc %cc_users%
  issue_comment:
    types: [created]
  schedule:
    # once a day at 13:00 UTC
    - cron: '0 13 * * *'

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  cleanup_old_runs:
    if: github.event.schedule == '0 13 * * *'
    runs-on: ubuntu-latest
    permissions:
      actions: write
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
    - name: Delete old workflow runs
      run: |
        _UrlPath="/repos/$GITHUB_REPOSITORY/actions/workflows"
        _CurrentWorkflowID="$(gh api -X GET "$_UrlPath" | jq '.workflows[] | select(.name == '\""$GITHUB_WORKFLOW"\"') | .id')"

        # delete workitems which are 'completed'. (other candidate values of status field are: 'queued' and 'in_progress')

        gh api -X GET "$_UrlPath/$_CurrentWorkflowID/runs" --paginate \
          | jq '.workflow_runs[] | select(.status == "completed") | .id' \
          | xargs -I{} gh api -X DELETE "/repos/$GITHUB_REPOSITORY/actions/runs"/{}

  backport:
    if: github.event.issue.pull_request != '' && contains(github.event.comment.body, '/backport to')
    runs-on: ubuntu-latest
    steps:
    - name: Extract backport target branch
      uses: actions/github-script@v6
      id: target-branch-extractor
      with:
        result-encoding: string
        script: |
          if (context.eventName !== "issue_comment") throw "Error: This action only works on issue_comment events.";

          // extract the target branch name from the trigger phrase containing these characters: a-z, A-Z, digits, forward slash, dot, hyphen, underscore
          const regex = /^\/backport to ([a-zA-Z\d\/\.\-\_]+)/;
          target_branch = regex.exec(context.payload.comment.body);
          if (target_branch == null) throw "Error: No backport branch found in the trigger phrase.";

          return target_branch[1];
    - name: Post backport started comment to pull request
      uses: actions/github-script@v6
      with:
        script: |
          const backport_start_body = `Started backporting to ${{ steps.target-branch-extractor.outputs.result }}: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
          await github.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: backport_start_body
          });
    - name: Checkout repo
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    - name: Run backport
      uses: actions/github-script@v6
      with:
        script: |
          const repo_owner = context.payload.repository.owner.login;
          const repo_name = context.payload.repository.name;
          const pr_number = context.payload.issue.number;
          const comment_user = context.payload.comment.user.login;

          let target_branch = '${{ steps.target-branch-extractor.outputs.result }}';

          try {
            // verify the comment user is a repo collaborator
            try {
              await github.rest.repos.checkCollaborator({
                owner: repo_owner,
                repo: repo_name,
                username: comment_user
              });
              console.log(`Verified ${comment_user} is a repo collaborator.`);
            } catch (error) {
              console.log(error);
              throw new Error(`Error: @${comment_user} is not a repo collaborator, backporting is not allowed. If you're a collaborator please make sure your ${repo_owner} team membership visibility is set to Public on https://github.com/orgs/${repo_owner}/people?query=${comment_user}`);
            }

            try { await exec.exec(`git ls-remote --exit-code --heads origin ${target_branch}`) } catch { throw new Error(`Error: The specified backport target branch ${target_branch} wasn't found in the repo.`); }
            console.log(`Backport target branch: ${target_branch}`);

            console.log("Applying backport patch");

            await exec.exec(`git checkout ${target_branch}`);
            await exec.exec(`git clean -xdff`);

            // configure git
            await exec.exec(`git config user.name "github-actions"`);
            await exec.exec(`git config user.email "github-actions@github.com"`);

            // create temporary backport branch
            const temp_branch = `backport/pr-${pr_number}-to-${target_branch}`;
            await exec.exec(`git checkout -b ${temp_branch}`);

            // skip opening PR if the branch already exists on the origin remote since that means it was opened
            // by an earlier backport and force pushing to the branch updates the existing PR
            let should_open_pull_request = true;
            try {
              await exec.exec(`git ls-remote --exit-code --heads origin ${temp_branch}`);
              should_open_pull_request = false;
            } catch { }

            // download and apply patch
            await exec.exec(`curl -sSL "${github.context.payload.issue.pull_request.patch_url}" --output changes.patch`);

            const git_am_command = "git am --3way --ignore-whitespace --keep-non-patch changes.patch";
            let git_am_output = `$ ${git_am_command}\n\n`;
            let git_am_failed = false;
            try {
              await exec.exec(git_am_command, [], {
                listeners: {
                  stdout: function stdout(data) { git_am_output += data; },
                  stderr: function stderr(data) { git_am_output += data; }
                }
              });
            } catch (error) {
              git_am_output += error;
              git_am_failed = true;
            }

            if (git_am_failed) {
              const git_am_failed_body = `@${github.context.payload.comment.user.login} backporting to ${target_branch} failed, the patch most likely resulted in conflicts:\n\n\`\`\`shell\n${git_am_output}\n\`\`\`\n\nPlease backport manually!`;
              await github.rest.issues.createComment({
                owner: repo_owner,
                repo: repo_name,
                issue_number: pr_number,
                body: git_am_failed_body
              });
              throw new Error("Error: git am failed, most likely due to a merge conflict.", false);
            }
            else {
              // push the temp branch to the repository
              await exec.exec(`git push --force --set-upstream origin HEAD:${temp_branch}`);
            }

            if (!should_open_pull_request) {
              console.log("Backport temp branch already exists, skipping opening a PR.");
              return;
            }

            // prepate the GitHub PR details
            let backport_pr_title = '${{ inputs.pr_title_template }}';
            let backport_pr_description = '${{ inputs.pr_description_template }}';

            // get users to cc (append PR author if different from user who issued the backport command)
            let cc_users = `@${comment_user}`;
            if (comment_user != github.context.payload.issue.user.login) cc_users += ` @${github.context.payload.issue.user.login}`;

            // replace the special placeholder tokens with values
            backport_pr_title = backport_pr_title
              .replace(/%target_branch%/g, target_branch)
              .replace(/%source_pr_title%/g, github.context.payload.issue.title)
              .replace(/%source_pr_number%/g, github.context.payload.issue.number)
              .replace(/%cc_users%/g, cc_users);

            backport_pr_description = backport_pr_description
              .replace(/%target_branch%/g, target_branch)
              .replace(/%source_pr_title%/g, github.context.payload.issue.title)
              .replace(/%source_pr_number%/g, github.context.payload.issue.number)
              .replace(/%cc_users%/g, cc_users);

            // open the GitHub PR
            await github.rest.pulls.create({
              owner: repo_owner,
              repo: repo_name,
              title: backport_pr_title,
              body: backport_pr_description,
              head: temp_branch,
              base: target_branch
            });

            console.log("Successfully opened the GitHub PR.");
          } catch (error) {

            core.setFailed(error);

            // post failure to GitHub comment
            const unknown_error_body = `@${comment_user} an error occurred while backporting to ${target_branch}, please check the run log for details!\n\n${error.message}`;
            await github.rest.issues.createComment({
              owner: repo_owner,
              repo: repo_name,
              issue_number: pr_number,
              body: unknown_error_body
            });
          }
 
