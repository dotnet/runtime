name: Localization Data Error
description: Error in localization data.
labels: []
body:
  - type: markdown
    attributes:
      value: |
        We're sorry you're experiencing issues with localization data.  There's some things you should be aware of when submitting the report that may help resolve your issue immediately, or will help us to troubleshoot the actual cause.
        ## Quick Troubleshooting
        To cover some commonly reported scenarios, there's some simple and quick troubleshooting that should be done.

        Note that by default all localization and culture data comes from the host operating system.  The runtime SDK does not distribute its own set of data, and normally applications should not distribute their own copy either.  While there are occasionally errors when or how we retrieve this data, in most cases this means that any differences between what you expect and what you see are by design.
  - type: checkboxes
    id: some-recommendations
    attributes:
      label: Some recommended best practices.
      description: |
        Due to how localization data is handled, there are some best practices you should keep in mind while designing applications and writing tests;

          - For any server application (and extending to most persistent backend local services), you _SHOULD_ run the process with an invariant-like culture set (eg, `LC_ALL=C.UTF-8` on Linux), and in the UTC timezone.  For resiliency, such applications _SHOULD_ still explicitly provide the [`InvariantCulture`](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture?view=net-8.0) when internally formatting data, and _SHOULD_ also still use UTC-sourced data (such as [`TimeProvider.GetUtcNow()`](https://learn.microsoft.com/en-us/dotnet/api/system.timeprovider.getutcnow?view=net-8.0#system-timeprovider-getutcnow)).
          - For any local user-facing (most often GUI-based) application, you **MUST** respect and use the culture of the user.
          - When practicable, you _SHOULD_ consider using and enabling format overrides.  On Windows this can be achieved just by calling the proper [`CultureInfo()` constructor](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.-ctor?view=net-8.0#system-globalization-cultureinfo-ctor(system-string-system-boolean)).  Other operating systems or web applications may require custom code.
          - For applications that are distributed, allow zero-downtime updates (eg, Azure Function Applications), or similar you **MUST PLAN** for situations where there may be multiple instances of the application with different format or other culture data (including timezone rules).
          - For any element being used for interchange (eg, a field in a JSON document in an API call), you **MUST** use the [`InvariantCulture`](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture?view=net-8.0); additionally, in many cases you _SHOULD_ either use a roundtrip format (such as the [`"O"`, `"o"` date-time format specifier](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#the-round-trip-o-o-format-specifier)), or explicitly specify a format string.  Although the format strings for the invariant culture are stable and unlikely to change, specifying an explicit format string helps to clarify the intent of your code.
          - You **MUST NOT** [consider culture data to be stable](https://learn.microsoft.com/en-us/archive/blogs/shawnste/culture-data-shouldnt-be-considered-stable-except-for-invariant).  This applies to both format strings and other culture data like timezone rules.
          - To make dependencies more explicit and testing potentially easier and more parallelizable, you _SHOULD CONSIDER_ explicitly passing culture-relevant settings, such as `CultureInfo` parameters to methods that perform formatting or `TimeZoneInfo` to methods that work with dates and times.  You **MUST** use [`TimeProvider`](https://learn.microsoft.com/en-us/dotnet/api/system.timeprovider?view=net-8.0) or a similar type when retrieving the time.
          - For most tests, you _SHOULD NOT_ explicitly validate the exact output of a given formatting operation or the exact offset of a timezone.  Formatting and timezone data can change at any time, and may differ between two otherwise identical instances of an operating system (and potentially different processes on the same machine).  Relying on an exact value makes tests brittle.
            - Generally, validating that some output was received will be sufficient (eg, non-empty strings when formatting).
            - For some data elements and formats, validating that the data parses to the input value may be used instead (roundtripping).  Care needs to be taken for cases where fields are dropped (eg, year for some date-related fields) or the value truncated or rounded (such as for floating-point output).
            - If you have explicit requirements to validate all localized format output, you _SHOULD CONSIDER_ creating and using a custom culture.  This can be done by creating a custom `CultureInfo` object, and can be entirely stable.  There are potential additional benefits to this, such as enabling [pseudolocalization](https://learn.microsoft.com/en-us/globalization/methodology/pseudolocalization) via resource files.
            - If you have explicit requirements to validate the results of all date/time operations, you _SHOULD CONSIDER_ creating and using a custom `TimeZoneInfo` instance.  There are potential additional benefits to this, such as enabling stable testing of certain edge cases (eg, changes to DST rules).
      options:
        - label: My issue is not solved by following these recommendations.
          required: true
