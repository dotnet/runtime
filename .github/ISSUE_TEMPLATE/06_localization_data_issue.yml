name: Globalization Data Error
description: Error in globalization data.
labels: []
body:
  - type: markdown
    attributes:
      value: |
        We're sorry you're experiencing issues with globalization data.  There's some things you should be aware of when submitting the report that may help resolve your issue immediately, or will help us to troubleshoot the actual cause.
        ## Quick Troubleshooting
        To cover some commonly reported scenarios, there's some simple and quick troubleshooting that should be done.

        Note that by default all globalization and culture data, including time zone information, comes from the host operating system.  The runtime SDK does not distribute its own set of data, and normally applications should not distribute their own copy either.  While there are occasionally errors when or how we retrieve this data, in most cases this means that any differences between what you expect and what you see are by design.
        #### "Did nothing" (or only updated the computer) and something has changed.
        Culture data [is not stable](https://learn.microsoft.com/en-us/archive/blogs/shawnste/culture-data-shouldnt-be-considered-stable-except-for-invariant).  It is updated several times a year through host OS channels on all supported platforms.  This includes things like [spaces in time formats](https://github.com/dotnet/runtime/issues/95620).
        #### Porting an application from .NET Framework or .NET Core < 5 to .NET Core 5+ on Windows.
        .NET Framework uses Window's built-in [NLS localization services](https://learn.microsoft.com/en-us/windows/win32/intl/national-language-support).  .NET Core on Windows now uses the [ICU (International Components for Unicode) libraries](https://learn.microsoft.com/en-us/dotnet/core/extensions/globalization-icu), which are standard across all supported operating systems.  While it is possible to [revert to the previous NLS datasource](https://learn.microsoft.com/en-us/dotnet/core/extensions/globalization-icu#use-nls-instead-of-icu), this is not recommended, as there are behavior and data differences between the two.
        #### "The data for a culture isn't what it should be!"
        The ICU libraries use the [Unicode Common Locale Data Repository (CLDR)](https://cldr.unicode.org/) as a datasource.  This data is not maintained by the runtime SDK, nor (outside of legacy Windows applications) by the host OS.  If you believe there is an error in the data, please follow [the CLDR directions on submitting a ticket](https://github.com/unicode-org/cldr/blob/main/docs/requesting_changes.md).
        ## Some recommended best practices.
        Due to how globalization data is handled, there are some best practices you should keep in mind while designing applications and writing tests;
        * For any server application (and extending to most persistent backend local services), you _SHOULD_ run the process with an invariant-like culture set (eg, `LC_ALL=C.UTF-8` on Linux), and in the UTC timezone.  For resiliency, such applications _SHOULD_ still explicitly provide the [`InvariantCulture`](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture?view=net-8.0) when internally formatting data, and _SHOULD_ also still use UTC-sourced data (such as [`TimeProvider.GetUtcNow()`](https://learn.microsoft.com/en-us/dotnet/api/system.timeprovider.getutcnow?view=net-8.0#system-timeprovider-getutcnow)).
        * For any local user-facing (most often GUI-based) application, you **MUST** respect and use the culture of the user.
        * When practicable, you _SHOULD_ consider using and enabling format overrides.  On Windows this can be achieved just by calling the proper [`CultureInfo()` constructor](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.-ctor?view=net-8.0#system-globalization-cultureinfo-ctor(system-string-system-boolean)).  Other operating systems or web applications may require custom code.
        * For applications that are distributed, allow zero-downtime updates (eg, Azure Function Applications), or similar you **MUST PLAN** for situations where there may be multiple instances of the application with different format or other culture data (including timezone rules).
        * For any element being used for interchange (eg, a field in a JSON document in an API call) or storage, you **MUST** use the [`InvariantCulture`](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture?view=net-8.0); additionally, in many cases you _SHOULD_ either use a roundtrip format (such as the [`"O"`, `"o"` date-time format specifier](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#the-round-trip-o-o-format-specifier)), or explicitly specify a format string.  Although the format strings for the invariant culture are stable and unlikely to change, specifying an explicit format string helps to clarify the intent of your code.
          * For date/time elements, consider the advice and observations in Jon Skeet's post [_Storing UTC is not a silver bullet_](https://codeblog.jonskeet.uk/2019/03/27/storing-utc-is-not-a-silver-bullet/).
        * You **MUST NOT** [consider culture data to be stable](https://learn.microsoft.com/en-us/archive/blogs/shawnste/culture-data-shouldnt-be-considered-stable-except-for-invariant).  This applies to both format strings and other culture data like timezone rules.
        * To make dependencies more explicit and testing potentially easier and more parallelizable, you _SHOULD CONSIDER_ explicitly passing culture-relevant settings, such as `CultureInfo` parameters, to methods that perform formatting or `TimeZoneInfo` to methods that work with dates and times.  You **MUST** use [`TimeProvider`](https://learn.microsoft.com/en-us/dotnet/api/system.timeprovider?view=net-8.0) or a similar type when retrieving the time.
        * For most tests, you _SHOULD NOT_ explicitly validate the exact output of a given formatting operation or the exact offset of a timezone.  Formatting and timezone data can change at any time, and may differ between two otherwise identical instances of an operating system (and potentially different processes on the same machine).  Relying on an exact value makes tests brittle.
          * Generally, validating that some output was received will be sufficient (eg, non-empty strings when formatting).
          * For some data elements and formats, validating that the data parses to the input value may be used instead (roundtripping).  Care needs to be taken for cases where fields are dropped (eg, year for some date-related fields) or the value truncated or rounded (such as for floating-point output).
          * If you have explicit requirements to validate all localized format output, you _SHOULD CONSIDER_ creating and using a custom culture.  This can be done by creating a custom `CultureInfo` object, and can be entirely stable.  There are potential additional benefits to this, such as enabling [pseudolocalization](https://learn.microsoft.com/en-us/globalization/methodology/pseudolocalization) via resource files.
          * If you have explicit requirements to validate the results of all date/time operations, you _SHOULD CONSIDER_ creating and using a custom `TimeZoneInfo` instance.  There are potential additional benefits to this, such as enabling stable testing of certain edge cases (eg, changes to DST rules).
  - type: textarea
    id: background
    attributes:
      label: Description
      description: Please share a clear and concise description of the problem.
      placeholder: Description
    validations:
      required: true
  - type: textarea
    id: repro-steps
    attributes:
      label: Reproduction Steps
      description: |
        Please include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small project, with steps to run it. If possible include text as text rather than screenshots (so it shows up in searches).
      placeholder: Minimal Reproduction
    validations:
      required: true
  - type: textarea
    id: expected-behavior
    attributes:
      label: Expected behavior
      description: |
        Provide a description of the expected behavior.
      placeholder: Expected behavior
    validations:
      required: true
  - type: textarea
    id: actual-behavior
    attributes:
      label: Actual behavior
      description: |
        Provide a description of the actual behavior observed. If applicable please include any error messages, exception stacktraces or memory dumps.
      placeholder: Actual behavior
    validations:
      required: true
  - type: textarea
    id: regression
    attributes:
      label: Regression?
      description: |
        Did this work in a previous build or release of .NET Core, or from .NET Framework? If you can try a previous release or build to find out, that can help us narrow down the problem. If you don't know, that's OK.
      placeholder: Regression?
    validations:
      required: false
  - type: textarea
    id: known-workarounds
    attributes:
      label: Known Workarounds
      description: |
        Please provide a description of any known workarounds.
      placeholder: Known Workarounds
    validations:
      required: false
  - type: textarea
    id: configuration
    attributes:
      label: Configuration
      description: |
        Please provide more information on your .NET configuration:
          * Which version of .NET is the code running on?
          * What OS and version, and what distro (if applicable)?
            * If on newer versions of Windows, is your application explicitly set to use NLS?
            * On Linux and other platforms, what version of ICU are you using (eg via `uconv --version`)?
          * What is the architecture (x64, x86, ARM, ARM64)?
          * Do you know whether it is specific to that configuration?
          * If you're using Blazor, which web browser(s) do you see this issue in?
            * Are you using [Invariant Globalization](https://learn.microsoft.com/en-us/aspnet/core/blazor/globalization-localization?view=aspnetcore-8.0#invariant-globalization)?
            * If you aren't using Invariant Globalization, what [data file](https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-icu-wasm.md#wasm-globalization-icu) are you using?
      placeholder: Configuration
    validations:
      required: true
